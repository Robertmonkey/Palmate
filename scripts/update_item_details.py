"""Fetch detailed item metadata for Palmate's item cards.

This script scrapes the public Palworld.gg items listing and maps the
content onto Palmate's internal item keys. The resulting dataset is
written to two files:

* data/item_details.json – consumable via fetch() when the app is served
  over HTTP.
* data/item_details_fallback.js – exposes the same object on
  window.__PALMATE_ITEM_DETAILS__ so the app still works when loaded
  directly from the filesystem.

For any Palmate item keys that are not present on Palworld.gg, the script
creates a light-weight placeholder entry so every item still renders a
rich card.
"""
from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import requests
from bs4 import BeautifulSoup, Tag

ROOT = Path(__file__).resolve().parents[1]
DATASET_PATH = ROOT / "data" / "palworld_complete_data_final.json"
JSON_TARGET = ROOT / "data" / "item_details.json"
FALLBACK_TARGET = ROOT / "data" / "item_details_fallback.js"
BANNER = "// Auto-generated by scripts/update_item_details.py. Do not edit manually.\n"
GLOBAL_NAME = "__PALMATE_ITEM_DETAILS__"
BASE_URL = "https://palworld.gg"
LISTING_URL = f"{BASE_URL}/items?perPage=400"


def slugify(text: str) -> str:
    """Create a Palmate-style slug from Palworld item names."""

    lowered = text.lower()
    normalised = re.sub(r"[^a-z0-9]+", "_", lowered)
    return normalised.strip("_")


def humanise_key(key: str) -> str:
    """Convert an item key like `high_quality_pal_oil` into a display name."""

    parts = [part for part in key.replace("-", "_").split("_") if part]
    return " ".join(part.capitalize() for part in parts) or key


def absolute_url(src: Optional[str]) -> Optional[str]:
    if not src:
        return None
    if src.startswith("http://") or src.startswith("https://"):
        return src
    if not src.startswith("/"):
        return src
    return f"{BASE_URL}{src}"


ItemDetail = Dict[str, Any]


def parse_item_block(block: Tag) -> Optional[Tuple[ItemDetail, str]]:
    name_el = block.select_one(".up .text")
    if not name_el:
        return None
    name = name_el.get_text(strip=True)
    slug = slugify(name)

    type_el = block.select_one(".up .type")
    item_type = type_el.get_text(strip=True) if type_el else None

    desc_el = block.select_one(".item-card .description")
    description = [
        segment.strip()
        for segment in desc_el.stripped_strings
        if segment and segment.strip()
    ] if desc_el else []

    stats: Dict[str, str] = {}
    for key_el in block.select(".item-card .keys .key"):
        label_el = key_el.select_one(".text")
        value_el = key_el.select_one(".value")
        if not label_el or not value_el:
            continue
        label = label_el.get_text(strip=True)
        value = value_el.get_text(strip=True)
        if value:
            stats[label] = value

    recipe: List[Dict[str, Any]] = []
    for entry in block.select(".item-card .recipe .item"):
        name_el = entry.select_one(".name")
        if not name_el:
            continue
        name_text = name_el.get_text(strip=True).replace('\xa0', ' ')
        quantity: Optional[int] = None
        ingredient = name_text
        match = re.match(r"^(\d+)\s+(.+)$", name_text)
        if match:
            quantity = int(match.group(1))
            ingredient = match.group(2)
        icon_el = entry.select_one(".image img")
        icon_src = absolute_url(icon_el["src"]) if icon_el and icon_el.get("src") else None
        recipe.append({
            "name": ingredient,
            "quantity": quantity,
            "icon": icon_src,
        })

    image_el = block.select_one(".up .image img")
    image = absolute_url(image_el["src"]) if image_el and image_el.get("src") else None

    return {
        "name": name,
        "type": item_type,
        "description": description,
        "stats": stats,
        "recipe": recipe,
        "image": image,
        "fromPalworld": True,
    }, slug


def fetch_remote_details() -> Dict[str, ItemDetail]:
    response = requests.get(LISTING_URL, timeout=30)
    response.raise_for_status()
    soup = BeautifulSoup(response.text, "html.parser")
    details: Dict[str, ItemDetail] = {}
    for block in soup.select("div.item"):
        parsed = parse_item_block(block)
        if not parsed:
            continue
        data, slug = parsed
        # Only keep the first occurrence for duplicate names.
        details.setdefault(slug, data)
    return details


def build_full_dataset(scraped: Dict[str, ItemDetail]) -> Dict[str, ItemDetail]:
    with DATASET_PATH.open("r", encoding="utf-8") as handle:
        payload = json.load(handle)
    items = payload.get("items", {})
    combined: Dict[str, ItemDetail] = {}

    for key in sorted(items.keys()):
        if key in scraped:
            combined[key] = scraped[key]
            continue
        category = items[key].get("category", "Item")
        combined[key] = {
            "name": humanise_key(key),
            "type": category,
            "description": [
                f"Detailed Palworld.gg stats for {humanise_key(key)} are not yet available.",
                "These values are based on Palmate's internal category data.",
            ],
            "stats": {},
            "recipe": [],
            "image": None,
            "fromPalworld": False,
        }
    return combined


def write_outputs(details: Dict[str, ItemDetail]) -> None:
    json_payload = json.dumps(details, indent=2, ensure_ascii=False)
    JSON_TARGET.write_text(json_payload + "\n", encoding="utf-8")

    js_payload = json.dumps(details, indent=2, ensure_ascii=False)
    fallback_contents = f"{BANNER}window.{GLOBAL_NAME} = {js_payload};\n"
    FALLBACK_TARGET.write_text(fallback_contents, encoding="utf-8")


def main() -> None:
    scraped = fetch_remote_details()
    combined = build_full_dataset(scraped)
    write_outputs(combined)
    remote_count = sum(1 for detail in combined.values() if detail.get("fromPalworld"))
    placeholder_count = len(combined) - remote_count
    print(
        f"Wrote {len(combined)} item detail entries "
        f"({remote_count} from Palworld.gg, {placeholder_count} placeholders)."
    )


if __name__ == "__main__":
    main()
