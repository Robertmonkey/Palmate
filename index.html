    .trait-chip {
      cursor: default;
      padding: 6px 14px;
      font-size: 0.78rem;
      letter-spacing: 0.04em;
    }
    .trait-chip:not(button) {
      pointer-events: none;
    }
    .trait-chip--compact {
      padding: 4px 10px;
      font-size: 0.68rem;
    }
    .breeding-chip__traits {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 4px;
    }
    .breeding-chip--condensed .breeding-chip__traits {
      gap: 4px;
      margin-top: 2px;
    }
    .breeding-chip__traits .trait-chip {
      box-shadow: none;
    }
    .trait-selector__option-header {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 4px;
    }
    .trait-selector__option-chip {
      pointer-events: none;
      box-shadow: none;
    }
    .trait-selector__option[aria-selected="true"] .trait-selector__option-chip {
      box-shadow: 0 0 0 1px rgba(224, 225, 221, 0.45);
    }
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    .trait-selector__summary .trait-chip {
      box-shadow: none;
    }
                <article class="breeding-result-card trait-outcomes">
                  <header>
                    <h3 id="traitOutcomeTitle">Trait relay outcomes</h3>
                    <p id="traitOutcomeCopy">Select your trait carrier to reveal every egg it can produce while sharing that passive.</p>
                  </header>
                  <div id="traitOutcomeList" class="trait-outcome-list"></div>
                </article>
    let PASSIVE_DETAIL_LOOKUP = new Map();
        PASSIVE_DETAIL_LOOKUP = new Map(
          Object.entries(PASSIVE_DETAILS || {}).map(([name, info]) => [
            (name || '').trim().toLowerCase(),
            info
          ])
        );
      const fallback = kidMode ? 'Catch in the wild' : 'Catch in the wild';
      if (!analysis) return fallback;
      if (palId == null) return fallback;
      const numericId = typeof palId === 'number' ? palId : Number(palId);
      if (Number.isNaN(numericId)) return fallback;
      const caughtKey = String(numericId);
      if (caught && (caught[numericId] || caught[caughtKey])) {
        return kidMode ? 'Already in your camp' : 'Already caught';
      }
      const analysisCaught = analysis.caughtIds instanceof Set ? analysis.caughtIds : null;
      if (analysisCaught && analysisCaught.has(numericId)) {
        return kidMode ? 'Already in your camp' : 'Already caught';
      }
      const depths = analysis.depths instanceof Map ? analysis.depths : null;
      if (!depths || !depths.has(numericId)) return fallback;
      const depth = depths.get(numericId);
      if (parentId != null && PALS[parentId]) return PALS[parentId].name;
      return fallbackPal ? fallbackPal.name : 'Unknown';
    }

    function resolveTraitDetail(traitName) {
      const rawName = (traitName || '').trim();
      if (!rawName) return null;
      const direct = PASSIVE_DETAILS && typeof PASSIVE_DETAILS === 'object' ? PASSIVE_DETAILS[rawName] : null;
      const lookupKey = rawName.toLowerCase();
      const fallbackEntry = PASSIVE_DETAIL_LOOKUP instanceof Map ? PASSIVE_DETAIL_LOOKUP.get(lookupKey) : null;
      const info = direct || fallbackEntry || null;
      const canonicalName = info && info.name ? info.name : rawName;
      const description = info?.description
        || (typeof traitsDictionary[canonicalName] === 'string' ? traitsDictionary[canonicalName]
        : (typeof traitsDictionary[rawName] === 'string' ? traitsDictionary[rawName] : ''));
      const meta = info ? classifyPassiveRank(info.rank) : { key: 'unknown', label: '', className: '' };
      return { name: canonicalName, info, description, meta };
    }

    function createTraitChip(traitName, options = {}) {
      const { compact = false, ariaHidden = false } = options;
      const detail = resolveTraitDetail(traitName);
      const chip = document.createElement('span');
      chip.className = 'chip passive trait-chip';
      if (compact) chip.classList.add('trait-chip--compact');
      const label = detail?.name || (traitName || '').trim() || 'Trait';
      chip.textContent = label;
      if (ariaHidden) {
        chip.setAttribute('aria-hidden', 'true');
      if (detail?.meta?.className) {
        chip.classList.add(detail.meta.className);
        chip.dataset.rank = detail.meta.key;
        if (detail.meta.label) chip.dataset.rankLabel = detail.meta.label;
      }
      const hint = detail?.description || detail?.info?.effect || '';
      if (hint) {
        chip.title = hint;
      }
      return chip;
    }

    function getBreedingAvailabilityLabel(pal, { kidMode = false, fallback = null } = {}) {
      if (!pal || pal.id == null) return fallback || '';
      const fallbackLabel = kidMode ? 'Catch in the wild' : 'Catch in the wild';
      const label = formatBreedingDepthLabel(analysis, pal.id, { kidMode });
      if (label && label !== fallbackLabel) {
        return label;
      }
      return fallback || label || fallbackLabel;
    }

    function formatPlanStepMeta(stepIndex, { kidMode = false, context = 'reuse' } = {}) {
      if (typeof stepIndex !== 'number' || stepIndex < 0) return '';
      const stepNumber = stepIndex + 1;
      if (context === 'result') {
        return kidMode ? `Step ${stepNumber} egg` : `Step ${stepNumber} result`;
      }
      return kidMode ? `Use step ${stepNumber} egg` : `From step ${stepNumber}`;
    }
        const { condensed = false, role = null, meta = null, traits = [] } = options;
        const traitNames = Array.isArray(traits)
          ? Array.from(new Set(traits.map(name => (name || '').trim()).filter(Boolean)))
          : [];
        if (traitNames.length) {
          const traitWrap = document.createElement('div');
          traitWrap.className = 'breeding-chip__traits';
          traitNames.forEach(name => {
            traitWrap.appendChild(createTraitChip(name, { compact: condensed }));
          });
          body.appendChild(traitWrap);
        }
      function createComboCard(pal, fallbackName, extraOptions = {}) {
          meta: pal ? formatSteps(pal.id) : '',
          ...extraOptions
          traitSummary.textContent = '';
          const summaryChip = createTraitChip(selectedTrait, { compact: true });
          if (kidMode) {
            traitSummary.append('Selected: ');
            traitSummary.appendChild(summaryChip);
          } else {
            traitSummary.appendChild(summaryChip);
            traitSummary.append(' locked in for relay planning.');
          }
          const header = document.createElement('div');
          header.className = 'trait-selector__option-header';
          const chip = createTraitChip(entry.name, { compact: true, ariaHidden: true });
          chip.classList.add('trait-selector__option-chip');
          header.appendChild(chip);
          header.appendChild(title);
          option.appendChild(header);
        const carrierMeta = kidMode ? 'Already in your camp' : 'Already caught';
        const childMetaLabel = kidMode ? 'Egg keeps the passive' : 'Trait-ready egg';
        const fallbackMeta = kidMode ? 'Catch in the wild' : 'Catch in the wild';
        const traitBadge = selectedTrait ? [selectedTrait] : [];
            meta: childPal ? childMetaLabel : '',
            traits: childPal && traitBadge.length ? traitBadge : []
            const otherParentMeta = otherParent ? getBreedingAvailabilityLabel(otherParent, { kidMode }) : fallbackMeta;
            const leftIsCarrier = entry.parentIndex === 0;
            const rightIsCarrier = !leftIsCarrier;
            row.appendChild(createComboCard(leftPal, leftName, {
              meta: leftPal ? (leftIsCarrier ? carrierMeta : otherParentMeta) : '',
              traits: leftPal && leftIsCarrier && traitBadge.length ? traitBadge : []
            }));
            row.appendChild(createComboCard(rightPal, rightName, {
              meta: rightPal ? (rightIsCarrier ? carrierMeta : otherParentMeta) : '',
              traits: rightPal && rightIsCarrier && traitBadge.length ? traitBadge : []
            }));
              meta: childPal ? childMetaLabel : '',
              traits: childPal && traitBadge.length ? traitBadge : []
        const producedByStep = new Map();
        plan.steps.forEach((step, index) => {
          if (step.childPal && step.childPal.id != null && !producedByStep.has(step.childPal.id)) {
            producedByStep.set(step.childPal.id, index);
          }
        });
        const carrierMetaBase = kidMode ? 'Already in your camp' : 'Already caught';
        const traitPlanBadge = selectedTrait ? [selectedTrait] : [];
          const carrierReuseIndex = traitCarrierPal && producedByStep.has(traitCarrierPal.id)
            ? producedByStep.get(traitCarrierPal.id)
            : null;
          const otherReuseIndex = otherParentPal && producedByStep.has(otherParentPal.id)
            ? producedByStep.get(otherParentPal.id)
            : null;
          const carrierMeta = traitCarrierPal
            ? (carrierReuseIndex != null && carrierReuseIndex < index
              ? formatPlanStepMeta(carrierReuseIndex, { kidMode })
              : (index === 0
                ? carrierMetaBase
                : getBreedingAvailabilityLabel(traitCarrierPal, { kidMode, fallback: carrierMetaBase })))
            : '';
          let otherMeta = '';
          if (otherParentPal) {
            if (otherReuseIndex != null && otherReuseIndex < index) {
              otherMeta = formatPlanStepMeta(otherReuseIndex, { kidMode });
            } else if (step.helperInfo && step.helperInfo.caught) {
              otherMeta = carrierMetaBase;
            } else if (step.helperInfo && typeof step.helperInfo.depth === 'number' && step.helperInfo.depth > 0) {
              const depth = step.helperInfo.depth;
              const suffix = depth === 1 ? '' : 's';
              otherMeta = kidMode
                ? `${depth} breeding step${suffix}`
                : `${depth} breeding step${suffix}`;
            } else {
              otherMeta = getBreedingAvailabilityLabel(otherParentPal, { kidMode });
            }
          }
          const childMeta = formatPlanStepMeta(index, { kidMode, context: 'result' });
          const leftIsCarrier = step.parentIndex === 0;
          const rightIsCarrier = !leftIsCarrier;
            meta: leftPal ? (leftIsCarrier ? carrierMeta : otherMeta) : '',
            traits: leftPal && leftIsCarrier && traitPlanBadge.length ? traitPlanBadge : []
            meta: rightPal ? (rightIsCarrier ? carrierMeta : otherMeta) : '',
            traits: rightPal && rightIsCarrier && traitPlanBadge.length ? traitPlanBadge : []
            meta: childMeta,
            traits: step.childPal && traitPlanBadge.length ? traitPlanBadge : []
