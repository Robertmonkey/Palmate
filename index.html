<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palmate – Palworld Companion</title>
  <!-- Chart.js for radar charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Font Awesome for interface icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="css/styles.css">
  <!-- Core styles: cosmic blue theme with smooth scrollbars -->
  <style>
    /*
      Colour palette for our epic cosmic theme.  We move away from the
      flat blues of the original and embrace rich purples and golds
      inspired by the Palworld universe.  These variables define the
      background, primary and secondary navigation colours, accent
      highlights, light text, card backgrounds and success/danger
      notifications.  Feel free to tweak these values for your own
      flavour.
    */
    :root {
      /*
        Updated colour palette to give the UI a warmer, more inviting
        atmosphere.  The dark navy base contrasts with desaturated
        blues and soft greens, while the accent colour pops against
        the card backgrounds.  Light colours are slightly brighter to
        improve readability for younger players.  Feel free to tweak
        these values to suit your own tastes.
      */
      --bg: #0d1b2a;
      --primary: #1b263b;
      --secondary: #415a77;
      --accent: #778da9;
      --light: #e0e1dd;
      --card-bg: #1e3246;
      --card-hover: #2e4a62;
      --text: #f0f4f8;
      --muted: rgba(224,225,221,0.7);
      --danger: #e76f51;
      --success: #2a9d8f;
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      /* Set a cosmic background image across the entire page.  We use
         background-attachment: fixed so the stars stay put as you
         scroll, lending a sense of depth.  The fallback colour
         ensures readability while the image loads. */
      background: var(--bg) url('assets/images/background.png') center/cover fixed no-repeat;
      color: var(--text);
      font-family: "Trebuchet MS", sans-serif;
      height: 100%;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      overflow-x: hidden;
    }
    /* Remove the old #app layout (previously used for sidebar).  The
       content area now sits below the navbar and fills the remaining
       space. */
    /* Top navigation bar styling */
    #navbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--primary);
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      padding-top: calc(env(safe-area-inset-top, 0px) + 8px);
      min-height: 60px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: none;
    }
    #navbar::-webkit-scrollbar {
      display: none;
    }
    #navbar .logo {
      font-size: 1.4rem;
      font-weight: bold;
      letter-spacing: 1px;
      margin-right: 12px;
      flex-shrink: 0;
    }
    #navbar .nav-item {
      border: none;
      background: none;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: border-color 0.3s, color 0.3s;
      flex: 0 0 auto;
    }
    #navbar .nav-item i {
      font-size: 1.1rem;
    }
    #navbar .nav-item:hover {
      color: var(--accent);
    }
    #navbar .nav-item.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Mode toggle button styling */
    .mode-btn {
      margin-left: auto;
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 10px;
      transition: color 0.3s;
      flex: 0 0 auto;
    }
    .mode-btn:hover {
      color: var(--accent);
    }

    /* Kid mode adjustments: larger targets and font sizes, simplified cards */
    body.kid-mode .pal-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .item-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .pal-card .name,
    body.kid-mode .item-card .name {
      font-size: 1.2rem;
    }
    body.kid-mode .nav-item span {
      font-size: 1rem;
    }
    body.kid-mode .search-bar input {
      font-size: 1rem;
    }
    /* Main content area.  This section fills the page below the
       navbar.  We add a top margin equal to the navbar height to
       ensure the content does not scroll underneath it. */
    #content {
      padding: 20px;
      margin-top: 20px;
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .glossary-nav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 18px;
      margin: 0 0 28px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(13, 27, 42, 0.78), rgba(35, 68, 107, 0.62));
      box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.28);
      backdrop-filter: blur(12px);
    }
    .glossary-nav button {
      background: transparent;
      color: var(--text);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 9px 18px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .glossary-nav button:hover,
    .glossary-nav button:focus-visible {
      background: rgba(119, 141, 169, 0.16);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      outline: none;
    }
    .glossary-section {
      position: relative;
      padding: 24px;
      margin-bottom: 32px;
      border-radius: 22px;
      background: linear-gradient(155deg, rgba(12, 24, 38, 0.92), rgba(20, 42, 66, 0.82));
      box-shadow: 0 28px 48px rgba(2, 12, 24, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.25);
      overflow: hidden;
    }
    .glossary-section::before {
      content: '';
      position: absolute;
      inset: -120px -120px auto auto;
      width: 220px;
      height: 220px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.18), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .glossary-section > * {
      position: relative;
      z-index: 1;
    }
    .glossary-section h3 {
      margin-top: 0;
      font-size: 1.6rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .glossary-search {
      width: 100%;
      padding: 12px 16px;
      margin: 18px 0 20px;
      border-radius: 14px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(9, 19, 33, 0.6);
      color: var(--text);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .glossary-search::placeholder {
      color: rgba(224, 225, 221, 0.55);
      letter-spacing: 0.02em;
    }
    .glossary-chip-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .glossary-skill-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    .glossary-count {
      margin: 0 0 14px;
      color: rgba(224, 225, 221, 0.75);
      font-size: 0.85rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .glossary-empty {
      margin: 10px 0 0;
      font-style: italic;
      color: rgba(224, 225, 221, 0.6);
    }
    .chip.passive,
    .chip.move,
    .glossary-skill {
      transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .chip.passive:hover,
    .chip.passive:focus-visible,
    .chip.move:hover,
    .chip.move:focus-visible,
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      transform: translateY(-2px);
      outline: none;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      text-align: left;
      border: 1px solid rgba(119, 141, 169, 0.26);
      border-radius: 16px;
      padding: 18px 20px;
      background: linear-gradient(160deg, rgba(14, 27, 42, 0.92), rgba(21, 43, 67, 0.78));
      color: inherit;
      cursor: pointer;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      border-color: var(--accent);
      background: linear-gradient(160deg, rgba(18, 36, 56, 0.95), rgba(32, 64, 98, 0.82));
    }
    .glossary-skill__header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      align-items: center;
      margin-bottom: 6px;
    }
    .glossary-skill__name {
      font-weight: 700;
      font-size: 1.05rem;
    }
    .glossary-skill__element {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(119,141,169,0.25);
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.82);
    }
    .glossary-skill__meta {
      font-size: 0.8rem;
      color: rgba(224, 225, 221, 0.7);
      margin-bottom: 8px;
    }
    .glossary-skill__description {
      font-size: 0.92rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.86);
    }
    .glossary-callout {
      border-left: 4px solid var(--accent);
      padding: 16px 20px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(23, 46, 68, 0.85), rgba(42, 78, 108, 0.72));
      margin-bottom: 20px;
      font-size: 0.95rem;
      box-shadow: inset 0 0 0 1px rgba(119, 141, 169, 0.2);
    }
    .glossary-callout strong {
      display: block;
      font-size: 1.05rem;
      margin-bottom: 6px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .work-tier-legend {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px 18px;
      padding: 16px 20px;
      margin: 0 0 24px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(17, 34, 51, 0.82), rgba(31, 58, 88, 0.7));
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .work-tier-legend__label {
      font-size: 0.9rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-tier-legend__items {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }
    .work-tier-legend__item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-tier-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 38px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 0 1px rgba(12, 24, 38, 0.6), 0 6px 16px rgba(0, 0, 0, 0.35);
    }
    .work-tier-badge--ss {
      background: linear-gradient(135deg, #f6d365, #fda085);
      color: #1a1a1a;
    }
    .work-tier-badge--s {
      background: linear-gradient(135deg, #56ccf2, #2f80ed);
      color: #0b1a2a;
    }
    .work-tier-badge--a {
      background: linear-gradient(135deg, #6be67e, #2ecc71);
      color: #0b2214;
    }
    .work-tier-badge--b {
      background: linear-gradient(135deg, #f2c94c, #f2994a);
      color: #301b07;
    }
    .work-tier-badge--c {
      background: linear-gradient(135deg, #ff758f, #a83279);
      color: #fff;
    }
    .work-tier-badge--d {
      background: linear-gradient(135deg, rgba(149, 158, 174, 0.35), rgba(96, 110, 133, 0.3));
      color: rgba(224, 225, 221, 0.8);
    }
    .glossary-work-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }
    .work-role-card {
      display: flex;
      flex-direction: column;
      gap: 18px;
      padding: 22px;
      border-radius: 20px;
      background: linear-gradient(165deg, rgba(10, 22, 37, 0.92), rgba(23, 46, 68, 0.78));
      border: 1px solid rgba(119, 141, 169, 0.24);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.45);
    }
    .work-role-card__header {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }
    .work-role-card__icon {
      width: 56px;
      height: 56px;
      border-radius: 16px;
      display: grid;
      place-items: center;
      font-size: 2rem;
      background: linear-gradient(135deg, rgba(224, 225, 221, 0.12), rgba(119, 141, 169, 0.18));
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.18);
    }
    .work-role-card__titles {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-role-card__name {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .work-role-card__blurb {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.72);
    }
    .work-pal-grid {
      display: grid;
      gap: 14px;
    }
    @media (min-width: 540px) {
      .work-pal-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .work-pal-card {
      position: relative;
      display: flex;
      align-items: center;
      gap: 16px;
      width: 100%;
      padding: 16px 18px;
      border-radius: 18px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      background: linear-gradient(155deg, rgba(15, 32, 50, 0.9), rgba(31, 58, 88, 0.75));
      color: inherit;
      cursor: pointer;
      text-align: left;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.4);
      overflow: hidden;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .work-pal-card:hover,
    .work-pal-card:focus-visible {
      border-color: var(--accent);
      transform: translateY(-3px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.5);
      outline: none;
    }
    .work-pal-card::after {
      content: '';
      position: absolute;
      inset: -60px -60px auto auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.16), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
    }
    .work-pal-card__rank {
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-pal-card__art {
      width: 76px;
      height: 76px;
      border-radius: 18px;
      background: rgba(5, 14, 26, 0.65);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.12);
      display: grid;
      place-items: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .work-pal-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.45));
    }
    .work-pal-card__placeholder {
      font-size: 1.6rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .work-pal-card__info {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-pal-card__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .work-pal-card__name {
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .work-pal-card__skill {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-skill-meter {
      position: relative;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(8, 17, 30, 0.6);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.1);
    }
    .work-skill-meter__fill {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), rgba(119, 141, 169, 0.85));
      transition: width 0.4s ease;
    }
    .work-pal-card__empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.6);
    }
    .work-pal-empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.7);
      font-style: italic;
    }
    body.kid-mode .glossary-nav button {
      font-size: 0.95rem;
      padding: 12px 20px;
    }
    body.kid-mode .glossary-section h3 {
      font-size: 1.8rem;
    }
    body.kid-mode .glossary-search {
      font-size: 1rem;
    }
    body.kid-mode .work-role-card__name {
      font-size: 1.4rem;
    }
    body.kid-mode .work-role-card__blurb {
      font-size: 1.05rem;
    }
    body.kid-mode .work-pal-card__name {
      font-size: 1.15rem;
    }
    body.kid-mode .work-pal-card__skill {
      font-size: 0.95rem;
    }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    @media (max-width: 900px) {
      #navbar .nav-item {
        padding: 10px 12px;
        font-size: 0.85rem;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      }
    }

    @media (max-width: 600px) {
      #navbar {
        gap: 6px;
      }
      #navbar .logo {
        font-size: 1.1rem;
        margin-right: 8px;
      }
      #content {
        padding: 16px 12px 24px;
      }
      .page-header {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .search-bar {
        max-width: none;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 14px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }
    }

    @media (max-width: 480px) {
      #navbar {
        gap: 4px;
      }
      #navbar .nav-item {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      #navbar .nav-item i {
        font-size: 1rem;
      }
      #content {
        padding: 14px 10px 20px;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      .pal-card img,
      .item-card img {
        width: 90px;
        height: 90px;
      }
    }
    .search-bar {
      width: 100%;
      max-width: 400px;
    }
    .search-bar input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
      background: var(--card-bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    /* Grid for cards */
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }

    body.kid-mode .card-grid {
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 20px;
    }

    #homeCards {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .home-hero {
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.6), rgba(119, 141, 169, 0.25));
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 16px;
      padding: 24px;
      display: grid;
      gap: 20px;
    }

    .home-hero__intro h3 {
      margin: 0 0 6px;
      font-size: 1.6rem;
    }

    .home-hero__intro p {
      margin: 0;
      color: var(--muted);
      font-size: 1rem;
    }

    .mode-callouts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }

    .mode-card {
      background: rgba(14, 29, 48, 0.85);
      border: 1px solid rgba(119, 141, 169, 0.25);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
    }

    .mode-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(119, 141, 169, 0.25);
      transform: translateY(-2px);
    }

    .mode-card__status {
      align-self: flex-start;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.18);
      color: var(--text);
      padding: 4px 10px;
      border-radius: 999px;
    }

    .mode-card.active .mode-card__status {
      background: rgba(42, 157, 143, 0.2);
      color: var(--success);
    }

    .mode-card h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .mode-card p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .mode-card__features {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      color: var(--light);
      font-size: 0.9rem;
    }

    .mode-card__button {
      margin-top: auto;
      width: 100%;
    }

    .home-section-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .home-section-header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .home-progress {
      background: var(--primary);
      border-radius: 16px;
      padding: 24px;
      display: grid;
      gap: 20px;
      border: 1px solid rgba(119, 141, 169, 0.2);
    }

    .home-progress-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 18px;
    }

    .home-progress-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    .home-progress-card__header {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .home-progress-card__icon {
      width: 42px;
      height: 42px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      background: rgba(119, 141, 169, 0.18);
      color: var(--accent);
      font-size: 1.4rem;
      flex-shrink: 0;
    }

    .home-progress-card__header h3 {
      margin: 0;
      font-size: 1.15rem;
    }

    .home-progress-card__header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .home-progress-meter {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.25);
      overflow: hidden;
    }

    .home-progress-meter .fill {
      width: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), rgba(42, 157, 143, 0.8));
      transition: width 0.4s ease;
    }

    .home-progress-text {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .home-progress-next {
      font-size: 0.85rem;
      color: var(--muted);
      text-align: left;
    }

    .home-progress-link {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.9rem;
      padding: 0;
      text-align: left;
      cursor: pointer;
      text-decoration: underline;
      align-self: flex-start;
    }

    .home-progress-link:disabled {
      color: var(--muted);
      cursor: default;
      text-decoration: none;
    }

    .home-progress-actions {
      margin-top: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .home-progress-actions .btn {
      flex: 1 1 auto;
      min-width: 160px;
    }

    .home-spotlight {
      background: rgba(14, 29, 48, 0.85);
      border-radius: 16px;
      padding: 24px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      display: grid;
      gap: 18px;
    }

    .home-spotlight-card {
      display: flex;
      align-items: center;
      gap: 18px;
      background: var(--card-bg);
      border-radius: 12px;
      padding: 16px;
      border: none;
      color: inherit;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .home-spotlight-card:hover:not(:disabled) {
      background: var(--card-hover);
      transform: translateY(-2px);
    }

    .home-spotlight-card:disabled {
      cursor: default;
      opacity: 0.85;
    }

    .home-spotlight-card:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .home-spotlight-card img {
      width: 96px;
      height: 96px;
      object-fit: contain;
      border-radius: 12px;
      background: rgba(13, 27, 42, 0.8);
    }

    .home-spotlight-card__text {
      display: grid;
      gap: 6px;
    }

    .home-spotlight-card__title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .home-spotlight-card__meta {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .home-spotlight-card__types {
      font-size: 0.85rem;
      color: var(--light);
    }

    body.kid-mode .home-hero__intro h3 {
      font-size: 1.8rem;
    }

    body.kid-mode .mode-card__features {
      font-size: 1rem;
    }

    body.kid-mode .home-progress-text {
      font-size: 1.05rem;
    }

    body.kid-mode .home-progress-link {
      font-size: 1rem;
    }

    @media (max-width: 768px) {
      .home-progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
      .mode-card {
        min-height: 100%;
      }
    }

    @media (max-width: 540px) {
      #homeCards {
        gap: 20px;
      }
      .home-hero {
        padding: 20px;
      }
      .home-progress {
        padding: 20px;
      }
      .home-spotlight {
        padding: 20px;
      }
      .home-spotlight-card {
        flex-direction: column;
        align-items: flex-start;
      }
      .home-spotlight-card img {
        width: 90px;
        height: 90px;
      }
    }
    /* Pal and item cards */
    .pal-card, .item-card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
      cursor: pointer;
      position: relative;
    }
    .pal-card:hover, .item-card:hover {
      transform: translateY(-4px);
      background: var(--card-hover);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .pal-card img, .item-card img {
      /* Increase the size of the images to make each pal and item
         card more visually striking and easier for younger players
         to recognise. */
      width: 100px;
      height: 100px;
      object-fit: contain;
      margin-bottom: 8px;
    }
    .item-card-art {
      width: 100%;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    .item-card-art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-card-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .pal-card .name, .item-card .name {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .pal-card .badge {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 4px;
      color: var(--text);
      font-size: 0.8rem;
    }
    .pal-card .badge img {
      width: 22px;
      height: 22px;
    }
    .pal-card .rarity {
      font-size: 0.8rem;
      margin-bottom: 6px;
      color: var(--light);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }
    .pal-card .rarity .stars i {
      color: #E4B914;
      font-size: 0.8rem;
      margin-right: 2px;
    }
    .pal-card .rarity .label {
      color: var(--accent);
      font-weight: bold;
      text-transform: capitalize;
    }
    .pal-card .catch-btn {
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: background 0.2s;
    }
    .pal-card .catch-btn.caught {
      background: var(--secondary);
    }
    /* Modal */
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      z-index: 200;
    }
    #modal.active {
      opacity: 1;
      pointer-events: auto;
    }
    #modalContent {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 20px;
      max-width: 900px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--danger);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .external-embed {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .external-embed .embed-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .external-embed .embed-actions h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .external-embed .embed-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: bold;
    }
    .external-embed .embed-link:hover,
    .external-embed .embed-link:focus {
      text-decoration: underline;
    }
    .external-embed .embed-note,
    .external-embed .embed-fallback {
      font-size: 0.9rem;
      color: var(--light);
      margin: 0;
    }
    .external-embed .embed-summary {
      background: rgba(65, 90, 119, 0.35);
      border-radius: 8px;
      padding: 12px;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    body.kid-mode .external-embed .embed-summary {
      font-size: 1rem;
    }
    .external-embed .embed-frame {
      width: 100%;
      min-height: 70vh;
      border: none;
      border-radius: 10px;
      background: #fff;
    }
    .item-detail-card {
      display: grid;
      gap: 18px;
      background: var(--card-bg);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }
    .item-detail-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .item-detail-heading {
      display: flex;
      align-items: center;
      gap: 16px;
      flex: 1 1 auto;
      min-width: 0;
    }
    .item-detail-image {
      width: 96px;
      height: 96px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .item-detail-image img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-detail-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .item-detail-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .item-detail-meta h3 {
      margin: 0;
      font-size: 1.6rem;
      line-height: 1.2;
    }
    .item-detail-meta .type-tag {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }
    .detail-collect-btn {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .detail-collect-btn:hover,
    .detail-collect-btn:focus {
      background: var(--accent);
      transform: translateY(-1px);
    }
    .detail-collect-btn.collected {
      background: var(--success);
      color: #fff;
    }
    .item-detail-description p {
      margin: 0 0 8px;
      line-height: 1.6;
      font-size: 1rem;
    }
    .item-detail-description p:last-child {
      margin-bottom: 0;
    }
    .item-detail-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .item-detail-stats .stat-pill {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 12px;
    }
    .item-detail-stats .stat-pill .label {
      display: block;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 4px;
    }
    .item-detail-stats .stat-pill .value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .item-detail-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      display: grid;
      gap: 8px;
    }
    .item-detail-section h4 {
      margin: 0;
      font-size: 1.1rem;
    }
    .item-detail-section p {
      margin: 0;
      line-height: 1.5;
    }
    .item-detail-summary ul {
      margin: 0;
      padding-left: 20px;
      line-height: 1.5;
    }
    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip-list .chip {
      background: rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
    }
    .chip-list .chip.highlight {
      background: rgba(42, 157, 143, 0.35);
    }
    .ingredient-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .ingredient-card {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .ingredient-card img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.25);
    }
    .ingredient-card .ingredient-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .ingredient-card .name {
      font-weight: 600;
    }
    .item-detail-footer {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.9rem;
    }
    .item-detail-footer a {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }
    .item-detail-footer a:hover,
    .item-detail-footer a:focus {
      text-decoration: underline;
    }
    .item-detail-note {
      color: var(--accent);
      font-size: 0.85rem;
    }
    body.kid-mode .item-detail-card {
      gap: 14px;
      padding: 20px;
    }
    body.kid-mode .item-detail-meta h3 {
      font-size: 1.4rem;
    }
    body.kid-mode .item-detail-description p {
      font-size: 1.05rem;
    }
    body.kid-mode .item-detail-stats {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    body.kid-mode .item-detail-stats .stat-pill {
      padding: 10px;
    }
    body.kid-mode .item-detail-stats .stat-pill .value {
      font-size: 1rem;
    }
    body.kid-mode .detail-collect-btn {
      font-size: 1rem;
      padding: 12px 20px;
    }
    body.kid-mode .chip-list .chip {
      font-size: 0.95rem;
      padding: 8px 16px;
    }
    body.kid-mode .item-detail-section h4 {
      font-size: 1rem;
    }
    .modal-action-btn {
      background: var(--accent);
      border: none;
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .modal-action-btn:hover,
    .modal-action-btn:focus {
      background: var(--secondary);
      transform: translateY(-1px);
    }
    body.kid-mode .modal-action-btn {
      font-size: 1rem;
    }
    /* Environment map */
    #mapContainer {
      position: relative;
      width: 100%;
      margin: 10px 0;
      border-radius: 8px;
      overflow: hidden;
    }
    #mapContainer img {
      width: 100%;
      height: auto;
      display: block;
    }
    #mapOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #mapOverlay .zone {
      position: absolute;
      opacity: 0;
      background: var(--accent);
      border: 2px solid var(--light);
      /* Make the highlight circular/elliptical to better approximate
         natural habitats instead of square boxes */
      border-radius: 50%;
      transition: opacity 0.3s;
    }
    #mapOverlay .zone.active {
      /* Lower opacity for a gentler highlight that doesn’t overpower the map */
      opacity: 0.2;
    }
    .map-modal {
      display: grid;
      gap: 12px;
    }
    .map-modal h3 {
      margin: 0;
    }
    .map-modal-note {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }
    .map-modal-details {
      display: grid;
      gap: 6px;
      font-size: 0.95rem;
    }
    .map-modal-canvas {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      background: var(--primary);
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
    }
    .map-modal-canvas img {
      display: block;
      width: 100%;
      height: auto;
    }
    .map-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      background: var(--danger);
      border: 2px solid var(--light);
      border-radius: 50%;
      --marker-tail-length: 16px;
      --marker-horizontal-adjust: 0px;
      transform: translate(
        calc(-50% + var(--marker-horizontal-adjust)),
        calc(-100% - var(--marker-tail-length))
      );
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    .map-marker::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      width: 2px;
      height: var(--marker-tail-length);
      background: var(--danger);
      transform: translateX(-50%);
    }
    .map-marker-label {
      position: absolute;
      top: calc(100% + 6px);
      left: 50%;
      transform: translate(-50%, 0);
      background: rgba(13,27,42,0.85);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      pointer-events: none;
    }
    body.kid-mode .map-modal-details p {
      font-size: 1rem;
    }
    /* Items */
    .item-card .name {
      font-weight: bold;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .item-card .category {
      font-size: 0.75rem;
      color: var(--light);
      margin-bottom: 6px;
    }
    .item-card .drops {
      font-size: 0.7rem;
      color: var(--text);
    }
    .item-card .ranch {
      font-size: 0.7rem;
      color: var(--light);
      margin-top: 4px;
    }
    .item-card .ranch--empty {
      opacity: 0.75;
      font-style: italic;
    }
    .item-card .collect-btn {
      margin-top: 6px;
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
    }
    .item-card .collect-btn.collected {
      background: var(--secondary);
    }
    /* Route tracking */
    .route-card {
      text-align: left;
      cursor: default;
      border: 1px solid transparent;
    }
    .route-card.completed {
      border-color: var(--success);
      box-shadow: 0 4px 14px rgba(46, 204, 113, 0.25);
      background: rgba(46, 204, 113, 0.08);
    }
    .route-card .name {
      margin-bottom: 6px;
    }
    .route-steps {
      margin-top: 8px;
    }
    .route-step-list {
      list-style-position: inside;
      padding-left: 0;
      margin: 4px 0 0;
      counter-reset: route-step;
    }
    .route-step {
      counter-increment: route-step;
      margin-bottom: 6px;
      padding: 6px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.02);
      transition: background 0.2s, color 0.2s;
    }
    .route-step::marker {
      font-weight: 700;
      color: var(--secondary);
    }
    .route-step.completed {
      background: rgba(46, 204, 113, 0.12);
    }
    .route-step.completed::marker {
      color: var(--success);
    }
    .route-step-label {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      font-size: 0.75rem;
      color: var(--light);
    }
    .route-step input[type="checkbox"] {
      margin-top: 2px;
      transform: scale(1.05);
    }
    .route-step-text {
      flex: 1;
      line-height: 1.35;
    }
    .route-step.completed .route-step-label {
      color: var(--text);
      font-weight: 600;
    }
    .route-step.completed .route-step-text {
      text-decoration: line-through;
    }
    .route-progress-summary {
      font-size: 0.7rem;
      color: var(--light);
      margin-top: 6px;
    }
    .route-card.completed .route-progress-summary {
      color: var(--success);
      font-weight: 600;
    }
    /* Tech tree */
    #techList {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .tech-level-card {
      background: linear-gradient(135deg, rgba(23,40,59,0.92), rgba(18,32,48,0.92));
      border-radius: 18px;
      border: 1px solid rgba(119,141,169,0.25);
      box-shadow: 0 16px 32px rgba(0,0,0,0.35);
      padding: 18px;
      backdrop-filter: blur(6px);
    }
    .tech-level-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .tech-level-number {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(119,141,169,0.4);
    }
    .tech-level-number span {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--light);
    }
    .tech-level-summary {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .tech-columns {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
    }
    .tech-column {
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: rgba(13,27,42,0.55);
      border: 1px solid rgba(119,141,169,0.18);
      border-radius: 14px;
      padding: 14px;
    }
    .tech-column h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .tech-card {
      position: relative;
      display: flex;
      gap: 14px;
      align-items: stretch;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(119,141,169,0.25);
      background: rgba(15,28,45,0.85);
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .tech-card:hover {
      transform: translateY(-2px);
      border-color: var(--accent);
      box-shadow: 0 14px 28px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked {
      border-color: rgba(42,157,143,0.6);
      box-shadow: 0 0 0 2px rgba(42,157,143,0.35), 0 16px 28px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked .tech-card__cost {
      background: rgba(42,157,143,0.25);
      color: var(--success);
    }
    .tech-card__art {
      width: 72px;
      height: 72px;
      border-radius: 12px;
      background: rgba(119,141,169,0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .tech-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.35));
    }
    .tech-card__art--fallback {
      color: var(--light);
      font-size: 1.6rem;
    }
    .tech-card__info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }
    .tech-card__title {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .tech-card__name {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text);
    }
    .tech-card__cost {
      font-size: 0.75rem;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(119,141,169,0.22);
      color: var(--light);
      letter-spacing: 0.08em;
    }
    .tech-card__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .tech-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.35);
      background: rgba(119,141,169,0.15);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card__description {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.4;
    }
    .tech-card__materials {
      margin: 0;
      padding-left: 18px;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .tech-card__materials li {
      margin: 2px 0;
    }
    .tech-card__actions {
      display: flex;
      justify-content: flex-end;
      margin-top: auto;
    }
    .tech-card .unlock-btn {
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.4);
      background: transparent;
      color: var(--text);
      padding: 6px 16px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }
    .tech-card .unlock-btn:hover {
      background: rgba(119,141,169,0.35);
    }
    .tech-card .unlock-btn.unlocked {
      background: var(--success);
      border-color: var(--success);
      color: #0d1b2a;
    }
    .tech-empty {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
      font-style: italic;
    }
    /* Breeding page */
    .breeding-hero {
      position: relative;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 24px;
      padding: 28px;
      margin-bottom: 28px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.92), rgba(13, 27, 42, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.4);
      box-shadow: 0 22px 45px rgba(5, 15, 30, 0.55);
      overflow: hidden;
    }
    .breeding-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(224, 225, 221, 0.18), transparent 55%);
      pointer-events: none;
    }
    .breeding-hero__icon {
      width: 84px;
      height: 84px;
      display: grid;
      place-items: center;
      border-radius: 28px;
      background: linear-gradient(140deg, rgba(224, 225, 221, 0.25), rgba(119, 141, 169, 0.2));
      border: 1px solid rgba(224, 225, 221, 0.3);
      box-shadow: 0 18px 36px rgba(6, 18, 35, 0.4);
      font-size: 2.2rem;
      color: #fff;
    }
    .breeding-hero__content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .breeding-hero__title {
      display: flex;
      align-items: center;
      gap: 18px;
    }
    .breeding-hero__title h2 {
      margin: 0;
      font-size: 2rem;
      letter-spacing: 0.02em;
    }
    .breeding-hero__intro {
      margin: 0;
      font-size: 1.05rem;
      color: var(--light);
      max-width: 42ch;
    }
    .breeding-perks {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }
    .breeding-perks li {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95rem;
      background: rgba(13, 27, 42, 0.32);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 14px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
    }
    .breeding-perks i {
      color: var(--accent);
    }
    .breeding-hero__callout {
      position: relative;
      z-index: 1;
      align-self: stretch;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      padding: 24px;
      border-radius: 20px;
      background: linear-gradient(160deg, rgba(119, 141, 169, 0.32), rgba(13, 27, 42, 0.6));
      border: 1px solid rgba(224, 225, 221, 0.22);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .breeding-hero__callout span {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-hero__callout p {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    .breeding-workspace {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .breeding-tabs {
      position: relative;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.65);
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
      width: fit-content;
    }
    .breeding-tab {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(224, 225, 221, 0.78);
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      transition: background 0.25s ease, color 0.25s ease, border-color 0.25s ease, transform 0.25s ease;
    }
    .breeding-tab i {
      font-size: 1rem;
    }
    .breeding-tab:hover,
    .breeding-tab:focus-visible {
      color: #fff;
      transform: translateY(-1px);
    }
    .breeding-tab.active {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.9), rgba(119, 141, 169, 0.7));
      color: #0d1b2a;
      border-color: rgba(224, 225, 221, 0.65);
      box-shadow: 0 12px 24px rgba(7, 21, 36, 0.45);
    }
    .breeding-mode {
      display: none;
      border-radius: 24px;
      padding: 24px;
      background: linear-gradient(160deg, rgba(18, 34, 49, 0.78), rgba(10, 21, 33, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 18px 32px rgba(5, 15, 30, 0.48);
    }
    .breeding-mode.active {
      display: block;
    }
    .breeding-panels {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      align-items: start;
    }
    .breeding-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px;
      border-radius: 18px;
      background: rgba(13, 27, 42, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
      min-height: 100%;
    }
    .breeding-panel__header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .breeding-panel__header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-panel__description {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-panel .pal-search input {
      width: 100%;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(13, 27, 42, 0.6);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .breeding-panel .pal-search input:focus {
      outline: none;
      border-color: rgba(224, 225, 221, 0.5);
      box-shadow: 0 0 0 3px rgba(119, 141, 169, 0.25);
    }
    .pal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 14px;
      max-height: 420px;
      overflow-y: auto;
      padding: 12px;
      border-radius: 16px;
      background: rgba(9, 19, 30, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.2);
      box-shadow: inset 0 0 18px rgba(5, 15, 30, 0.45);
    }
    .pal-grid::-webkit-scrollbar {
      width: 8px;
    }
    .pal-grid::-webkit-scrollbar-track {
      background: rgba(13, 27, 42, 0.6);
      border-radius: 999px;
    }
    .pal-grid::-webkit-scrollbar-thumb {
      background: rgba(119, 141, 169, 0.45);
      border-radius: 999px;
    }
    body.kid-mode .pal-grid {
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    }
    .pal-card.compact {
      padding: 12px;
      border-radius: 14px;
      backdrop-filter: blur(2px);
    }
    .pal-card.compact img {
      width: 90px;
      height: 90px;
    }
    .pal-card.compact .name {
      font-size: 1rem;
    }
    .pal-card.compact .badge {
      font-size: 0.78rem;
    }
    .pal-card.compact .rarity {
      font-size: 0.72rem;
    }
    .pal-card.static {
      cursor: default;
    }
    .pal-card.static:hover {
      transform: none;
      background: var(--card-bg);
      box-shadow: none;
    }
    .pal-card.selectable {
      cursor: pointer;
    }
    .pal-card.selected {
      outline: 3px solid rgba(224, 225, 221, 0.55);
      box-shadow: 0 0 0 4px rgba(119, 141, 169, 0.35);
    }
    .breeding-result-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(119, 141, 169, 0.35), rgba(13, 27, 42, 0.65));
      border: 1px solid rgba(224, 225, 221, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
    }
    .breeding-result-card header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .breeding-result-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-result-card p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-result {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-flow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }
    .combo-arrow {
      font-size: 1.5rem;
      color: rgba(224, 225, 221, 0.85);
      font-weight: 700;
    }
    .breeding-tip {
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
      line-height: 1.5;
    }
    .breeding-combo-link {
      align-self: flex-start;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.85), rgba(42, 157, 143, 0.65));
      color: #0d1b2a;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      box-shadow: 0 12px 24px rgba(2, 20, 22, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .breeding-combo-link:hover,
    .breeding-combo-link:focus-visible {
      transform: translateY(-2px);
      opacity: 0.95;
      outline: none;
      box-shadow: 0 16px 32px rgba(2, 20, 22, 0.55);
    }
    .breeding-combos {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-combo {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      align-items: center;
      gap: 10px;
      padding: 12px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(13, 27, 42, 0.75), rgba(65, 90, 119, 0.45));
      border: 1px solid rgba(119, 141, 169, 0.25);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .breeding-combo:hover,
    .breeding-combo:focus-visible {
      transform: translateY(-3px);
      box-shadow: 0 16px 28px rgba(5, 15, 30, 0.55);
      border-color: rgba(224, 225, 221, 0.45);
      outline: none;
    }
    .breeding-combo .pal-card {
      width: 100%;
      margin: 0;
    }
    .breeding-combo .pal-card + .combo-arrow {
      justify-self: center;
    }
    .breeding-workspace .pal-card .badge {
      gap: 2px;
    }
    .breeding-workspace .pal-card .badge img {
      width: 14px;
      height: 14px;
    }
    .breeding-workspace .pal-card .caught-status {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      margin-bottom: 4px;
      color: var(--text);
      background: rgba(119, 141, 169, 0.2);
      text-align: center;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="true"] {
      background: rgba(42, 157, 143, 0.25);
      color: #daf5f0;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="false"] {
      background: rgba(231, 111, 81, 0.25);
      color: #ffe0d8;
    }
    .breeding-baby-header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .breeding-baby-header h3 {
      margin: 0;
    }
    .empty-state {
      font-size: 0.92rem;
      color: rgba(224, 225, 221, 0.75);
      padding: 12px 0;
    }
    body.kid-mode .breeding-hero {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.92), rgba(65, 90, 119, 0.88));
    }
    body.kid-mode .breeding-hero__intro {
      font-size: 1rem;
    }
    body.kid-mode .breeding-panel__description,
    body.kid-mode .breeding-hero__callout p {
      font-size: 0.9rem;
    }
    @media (max-width: 1024px) {
      .breeding-hero {
        grid-template-columns: minmax(0, 1fr);
      }
      .breeding-hero__callout {
        order: 3;
      }
    }
    @media (max-width: 768px) {
      .breeding-mode {
        padding: 20px 18px;
      }
      .pal-grid {
        max-height: 320px;
      }
      .breeding-tabs {
        width: 100%;
        justify-content: center;
      }
      .breeding-combo {
        grid-template-columns: repeat(5, minmax(0, 120px));
        overflow-x: auto;
      }
    }
    /* Progress page */
    .progress-grid {
      display: grid;
      gap: 16px;
      margin-top: 16px;
    }
    @media (min-width: 640px) {
      .progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .progress-card {
      position: relative;
      padding: 18px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.85), rgba(119, 141, 169, 0.6));
      box-shadow: 0 12px 24px rgba(13, 27, 42, 0.35);
      overflow: hidden;
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .progress-card::after {
      content: '';
      position: absolute;
      inset: auto -40px -40px auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.35), transparent 70%);
      opacity: 0.8;
      pointer-events: none;
      transform: rotate(15deg);
    }
    .progress-card--hero {
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.9), rgba(119, 141, 169, 0.65));
    }
    @media (min-width: 960px) {
      .progress-card--hero {
        grid-column: span 2;
      }
    }
    .progress-card__header {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
      z-index: 1;
    }
    .progress-card__icon {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      background: rgba(13, 27, 42, 0.35);
      display: grid;
      place-items: center;
      font-size: 1.6rem;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .progress-card p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .progress-meter {
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.4);
      overflow: hidden;
      position: relative;
      z-index: 1;
    }
    .progress-meter .meter-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.6s ease;
    }
    .progress-card__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      position: relative;
      z-index: 1;
    }
    .progress-text {
      color: var(--light);
    }
    .progress-badge {
      background: rgba(13, 27, 42, 0.45);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.2);
    }
    .progress-choice-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(10, 16, 29, 0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 2000;
    }
    .progress-choice-dialog {
      background: var(--card-bg);
      border-radius: 18px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      padding: 24px;
      width: min(420px, 100%);
      display: grid;
      gap: 16px;
    }
    body.kid-mode .progress-choice-dialog {
      border-radius: 22px;
    }
    .progress-choice-dialog h3 {
      margin: 0;
    }
    .progress-choice-dialog p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .progress-choice-options {
      display: grid;
      gap: 8px;
    }
    .progress-choice-option {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 8px 12px;
    }
    .progress-choice-option span {
      font-size: 0.95rem;
    }
    .progress-choice-helpers {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-helpers .btn {
      flex: 1 1 auto;
    }
    .progress-choice-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-actions .btn {
      flex: 1 1 auto;
    }
    /* Custom scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--primary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Top navigation bar.  We move away from the vertical sidebar and instead
       present a horizontal bar across the top of the page.  Each button
       contains an icon and label.  The active tab is highlighted
       via a coloured underline defined in CSS. -->
  <nav id="navbar">
    <div class="logo">Pal Marathon</div>
    <!-- Navigation items.  We add Home, Map, Route and Glossary to
         provide quick access to all major sections of the app.  The
         first item (Home) is active by default.  Icons chosen via
         Font Awesome provide an intuitive visual cue for each tab. -->
    <button class="nav-item active" data-page="home"><i class="fa-solid fa-house"></i><span>Home</span></button>
    <button class="nav-item" data-page="pals"><i class="fa-solid fa-paw"></i><span>Pals</span></button>
    <button class="nav-item" data-page="map"><i class="fa-solid fa-map"></i><span>Map</span></button>
    <button class="nav-item" data-page="route"><i class="fa-solid fa-road"></i><span>Route</span></button>
    <button class="nav-item" data-page="tech"><i class="fa-solid fa-cog"></i><span>Tech</span></button>
    <button class="nav-item" data-page="items"><i class="fa-solid fa-box"></i><span>Items</span></button>
    <button class="nav-item" data-page="glossary"><i class="fa-solid fa-book-open"></i><span>Glossary</span></button>
    <button class="nav-item" data-page="breeding"><i class="fa-solid fa-egg"></i><span>Breeding</span></button>
    <button class="nav-item" data-page="progress"><i class="fa-solid fa-chart-line"></i><span>Progress</span></button>
    <!-- Mode toggle button sits on the far right.  Clicking it
         switches between Kid Mode (simplified UI) and Grown‑up
         Mode (full details).  The icon updates accordingly. -->
    <button id="modeToggle" class="mode-btn" title="Switch to grown-up mode"><i class="fa-solid fa-child"></i></button>
  </nav>
  <div id="content">
      <!-- Home page -->
      <section id="homePage" class="page active">
        <header class="page-header">
          <h2>Tonight’s Plan</h2>
        </header>
        <p>Welcome to Pal Marathon, your companion guide for completing Palworld with your family. Pick the presentation style that fits your crew and use the snapshots below to jump back into the adventure.</p>
        <div id="homeCards"></div>
      </section>
      <!-- Pals page -->
      <section id="palsPage" class="page">
        <header class="page-header">
          <h2>Pals</h2>
          <div class="search-bar"><input id="palSearch" type="text" placeholder="Search pals by name or type..."></div>
        </header>
        <div id="palsList" class="card-grid"></div>
      </section>
      <!-- Items page -->
      <section id="itemsPage" class="page">
        <header class="page-header">
          <h2>Items</h2>
          <div class="search-bar"><input id="itemSearch" type="text" placeholder="Search items..."></div>
        </header>
        <div id="itemsList" class="card-grid"></div>
      </section>
      <!-- Map page -->
      <section id="mapPage" class="page">
        <header class="page-header">
          <h2>Map</h2>
        </header>
        <p>Explore Palpagos! Toggle layers to highlight points of interest. Open the interactive map for detailed navigation.</p>
        <div id="mapLayers" style="margin-bottom:10px;"></div>
        <!-- Interactive map iframe: embed the palworld.gg map directly in the app with a larger viewing window. -->
        <div id="interactiveMapWrapper" style="width:100%; height:75vh; min-height:600px; border-radius:8px; overflow:hidden; margin-bottom:12px;">
          <iframe id="mapIframe" src="https://palworld.gg/map" style="width:100%; height:100%; border:none;" title="Palworld Interactive Map"></iframe>
        </div>
      </section>
      <!-- Route page -->
      <section id="routePage" class="page"></section>
      <!-- Tech page -->
      <section id="techPage" class="page">
        <header class="page-header">
          <h2>Technology Tree</h2>
        </header>
        <p>Browse every Technology and Ancient Technology tier just like the in-game tree. Review costs, materials, and mark blueprints as you unlock them.</p>
        <div id="techList"></div>
      </section>
      <!-- Breeding page -->
      <section id="breedingPage" class="page">
        <div class="breeding-hero">
          <div class="breeding-hero__content">
            <div class="breeding-hero__title">
              <div class="breeding-hero__icon"><i class="fa-solid fa-egg"></i></div>
              <h2>Breeding Workshop</h2>
            </div>
            <p class="breeding-hero__intro">Match the perfect parents, queue up cakes and hatch legendary helpers faster with our polished Pal pairing lab.</p>
            <ul class="breeding-perks">
              <li><i class="fa-solid fa-wand-magic-sparkles"></i><span>See likely babies instantly by matching breeding power.</span></li>
              <li><i class="fa-solid fa-people-arrows"></i><span>Swap between Parent and Target modes without losing your picks.</span></li>
              <li><i class="fa-solid fa-cookie-bite"></i><span>Kid Mode reminders keep the process friendly for junior keepers.</span></li>
            </ul>
          </div>
          <div class="breeding-hero__callout">
            <span>Pro tip</span>
            <p>Keep a stack of Cakes in the farm chest and tap any combo below to auto-fill the parents. You will be incubating dream pals in no time.</p>
          </div>
        </div>
        <div class="breeding-workspace">
          <div class="breeding-tabs" role="tablist" aria-label="Breeding planner modes">
            <button type="button" id="breedingTabPredict" class="breeding-tab active" data-target="breedingPredict" role="tab" aria-controls="breedingPredict" aria-selected="true" aria-pressed="true">
              <i class="fa-solid fa-people-group"></i>
              <span>Pick parents</span>
            </button>
            <button type="button" id="breedingTabDiscover" class="breeding-tab" data-target="breedingDiscover" role="tab" aria-controls="breedingDiscover" aria-selected="false" aria-pressed="false">
              <i class="fa-solid fa-compass"></i>
              <span>Find parents</span>
            </button>
          </div>
          <div id="breedingPredict" class="breeding-mode active" role="tabpanel" aria-labelledby="breedingTabPredict" aria-hidden="false" tabindex="0">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent A</h3>
                  <p class="breeding-panel__description">Choose your first partner. Filter by pal name or elemental type.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent1Search" placeholder="Search pals" aria-label="Search parent A pals">
                </div>
                <div class="pal-grid" id="parent1Grid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent B</h3>
                  <p class="breeding-panel__description">Match a second pal to balance breeding power and passives.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent2Search" placeholder="Search pals" aria-label="Search parent B pals">
                </div>
                <div class="pal-grid" id="parent2Grid"></div>
              </article>
              <article class="breeding-result-card">
                <header>
                  <h3>Predicted egg</h3>
                  <p>We average breeding power and surface the closest baby match.</p>
                </header>
                <div class="breeding-result" id="breedingResult"></div>
              </article>
            </div>
          </div>
          <div id="breedingDiscover" class="breeding-mode" role="tabpanel" aria-labelledby="breedingTabDiscover" aria-hidden="true" tabindex="-1">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Dream pal</h3>
                  <p class="breeding-panel__description">Search for the pal you want to hatch or browse the list below.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="babySearch" placeholder="Search pals" aria-label="Search desired pals">
                </div>
                <div class="pal-grid" id="babyGrid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent recipes</h3>
                  <p class="breeding-panel__description">Tap any combo to auto-fill the parents and jump back to predictions.</p>
                </div>
                <div class="breeding-combos" id="breedingCombos"></div>
              </article>
            </div>
          </div>
        </div>
      </section>
      <!-- Progress page -->
      <section id="progressPage" class="page">
        <header class="page-header">
          <h2>Your Progress</h2>
        </header>
        <p>Keep tabs on your Pal Marathon adventure. Check off guide steps, recruit pals and unlock technology—the meters below grow as you play.</p>
        <div class="progress-grid">
          <article class="progress-card progress-card--hero">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-book-open-reader"></i></div>
              <div>
                <h3>Adventure Guide</h3>
                <p>Follow the family route and topple every tower boss.</p>
              </div>
            </div>
            <div class="progress-meter" id="guideProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="guideProgress"></div>
            </div>
            <div class="progress-card__footer" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <div style="flex:1;display:flex;flex-direction:column;gap:4px">
                <span id="guideProgressText" class="progress-text"></span>
                <span id="towersClearedBadge" class="progress-badge"></span>
              </div>
              <button class="btn" id="resetRouteProgress" type="button">Reset Guide Progress</button>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-paw"></i></div>
              <div>
                <h3>Pal Squad</h3>
                <p>Mark pals as caught when they join your crew.</p>
              </div>
            </div>
            <div class="progress-meter" id="palsProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="palsProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="palsProgressText" class="progress-text"></span>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-screwdriver-wrench"></i></div>
              <div>
                <h3>Workshop Tech</h3>
                <p>Unlock inventions to boost your base and travel.</p>
              </div>
            </div>
            <div class="progress-meter" id="techProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="techProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="techProgressText" class="progress-text"></span>
            </div>
          </article>
        </div>
      </section>
      <!-- Glossary page -->
      <section id="glossaryPage" class="page">
        <header class="page-header">
          <h2>Glossary</h2>
        </header>
        <p>Browse every passive trait, active skill, element matchup and work task in one place. Use the quick links and search boxes below to jump right to what you need.</p>
        <div id="glossaryContent"></div>
      </section>
    </div>
  </div>
  <!-- Modal for pal details -->
  <div id="modal">
    <div id="modalContent">
      <button id="modalClose">Close</button>
      <div id="modalBody"></div>
    </div>
  </div>
  <script>
    // Data variables
    let PALS = {};
    let ITEMS = {};
    let TECH = [];
    let TECH_LOOKUP = {};
    let SKILL_DETAILS = {};
    let PASSIVE_DETAILS = {};
    let ITEM_DETAILS = {};
    // Map of items to pals that drop them.  Populated after data load.
    let DROPS_MAP = {};
    // Map pal names to IDs for quick lookup when clicking breeding
    // combos.  Populated after data load.
    let PAL_NAME_TO_ID = {};
    let PAL_SLUG_TO_ID = {};
    // Persist breeding page selections between rebuilds (e.g. when switching modes)
    const BREEDING_SELECTION = { parent1Id: null, parent2Id: null, babyId: null, mode: 'breedingPredict' };
    // Progress tracking
    let caught = JSON.parse(localStorage.getItem('caught') || '{}');
    let collected = JSON.parse(localStorage.getItem('collected') || '{}');
    let unlocked = JSON.parse(localStorage.getItem('unlocked') || '{}');
    const KID_MODE_STORAGE_KEY = 'palmate:kidMode';
    // Maximum stats for scaling radar chart
    // Maximum stats for scaling radar chart.  Speed is capped lower to avoid
    // overpowering the chart – the fastest pals reach around 1000.
    const maxStats = { hp: 150, attack: 150, defense: 145, speed: 1000, stamina: 350, support: 150, food: 9 };
    // Type to environment mapping
    const environmentMap = {
      'Fire': 'Volcano',
      'Ice': 'Snow',
      'Electric': 'Coast',
      'Water': 'River',
      'Grass': 'Forest',
      'Ground': 'Desert',
      'Dark': 'Swamp',
      'Dragon': 'Mountains',
      'Air': 'Highlands',
      'Neutral': 'Plains'
    };
    // Rarity to recommended sphere
    const raritySphere = {
      1: 'Pal Sphere',
      2: 'Mega Sphere',
      3: 'Giga Sphere',
      4: 'Hyper Sphere',
      5: 'Ultra Sphere',
      6: 'Legendary Sphere'
    };
    // Human-friendly rarity names for better readability on cards and details.
    const rarityNames = {
      1: 'Common',
      2: 'Uncommon',
      3: 'Rare',
      4: 'Epic',
      5: 'Legendary',
      6: 'Mythic'
    };
    // Sphere capture rates and descriptions (approximate for guidance)
    const sphereRates = {
      'Pal Sphere': { rate: 0.3, description: 'Good for beginners and low-level pals (Lv 1-15)' },
      'Mega Sphere': { rate: 0.45, description: 'Better success for mid-level pals (Lv 16-30)' },
      'Giga Sphere': { rate: 0.6, description: 'Ideal for stronger pals (Lv 31-45)' },
      'Hyper Sphere': { rate: 0.75, description: 'Very high success for tough pals (Lv 46-60)' },
      'Ultra Sphere': { rate: 0.85, description: 'Excellent for very tough pals (Lv 61-70)' },
      'Legendary Sphere': { rate: 1.0, description: 'Guaranteed catch for legendary pals (Lv 71+)' }
    };
    // Trait lists for guidance (simplified)
    const goodTraits = ['Diligent', 'Runner', 'Strong', 'Loyal'];
    const badTraits = ['Coward', 'Lazy', 'Gullible'];

    // Whether we’re in Kid Mode.  Kid Mode simplifies the UI by
    // enlarging fonts, hiding advanced stats and using shorter
    // explanations.  Remember the user’s previous choice so the
    // experience stays consistent between visits.
    const savedKidMode = localStorage.getItem(KID_MODE_STORAGE_KEY);
    let kidMode = savedKidMode === null ? true : savedKidMode === 'true';
    document.body.classList.toggle('kid-mode', kidMode);
    persistKidMode();

    // Descriptions for active skills.  Each entry maps the skill key
    // (as it appears in the data) to a human-friendly object with
    // damage, type (AoE, cone, single-target) and a brief description
    // gleaned from community knowledge and official guides.  When
    // unknown, we provide a generic description encouraging players to
    // experiment.  Feel free to extend this dictionary with more
    // abilities as you discover them.
    const defaultSkillsDictionary = {
      'rolly_poly': { name:'Roly Poly', damage:'Low', type:'Charge', description:'Curls into a ball and rolls after foes; be careful as you may become dizzy afterwards' },
      'air_cannon': { name:'Air Cannon', damage:'Moderate', type:'Projectile', description:'Fires compressed air that pushes enemies back in a line' },
      'power_shot': { name:'Power Shot', damage:'Moderate', type:'Projectile', description:'Charges up and fires a strong projectile at a single target' },
      'implode': { name:'Implode', damage:'Massive', type:'Area', description:'Self-destructs in a powerful explosion harming all nearby – the user faints afterwards' },
      'electric_ball': { name:'Electric Ball', damage:'High', type:'Projectile', description:'Launches a ball of lightning that zaps enemies on contact' },
      'dragon_burst': { name:'Dragon Burst', damage:'High', type:'Area', description:'Unleashes draconic energy in a burst around the user' },
      'fire_blast': { name:'Fire Blast', damage:'High', type:'Cone', description:'Breathes fire in a wide cone, burning anything in its path' },
      'leaf_dance': { name:'Leaf Dance', damage:'Moderate', type:'Area', description:'Summons swirling leaves that slice nearby enemies' },
      // Additional skills with descriptions derived from the Palworld Wiki【841863502450800†L124-L156】.  These give
      // players a better sense of each move’s effect.
      'acid_rain': { name:'Acid Rain', damage:'Moderate', type:'Area', description:'Creates acidic clouds that pour down rain on enemies' },
      'air_blade': { name:'Air Blade', damage:'Moderate', type:'Fan', description:'Sends out sharp blades of air in a fan shape' },
      'apocalypse': { name:'Apocalypse', damage:'High', type:'Area', description:'Generates several dark vortexes in the surrounding area' },
      'aqua_burst': { name:'Aqua Burst', damage:'High', type:'Projectile', description:'Creates a giant ball of water and hurls it at an enemy' },
      'aqua_gun': { name:'Aqua Gun', damage:'Low', type:'Projectile', description:'Hurls a ball of water straight at an enemy' },
      'beam_slicer': { name:'Beam Slicer', damage:'Very High', type:'Beam', description:'Mows down the frontal area with a dragon beam; the impacted area explodes shortly after' },
      'blast_cannon': { name:'Blast Cannon', damage:'High', type:'Projectile', description:'Fires an energy bullet imbued with dragon power that explodes on impact' },
      'blizzard_spike': { name:'Blizzard Spike', damage:'Very High', type:'Projectile', description:'Creates a giant lump of ice and hurls it; damages those in the surrounding area upon impact' },
      'bog_blast': { name:'Bog Blast', damage:'Low', type:'Projectile', description:'Hurls sticky mud at an enemy' },
      'bubble_blast': { name:'Bubble Blast', damage:'Moderate', type:'Homing', description:'Fires numerous bubbles that slowly pursue an enemy' },
      'circle_vine': { name:'Circle Vine', damage:'High', type:'Area', description:'Sprouts sharp roots in and around the enemy’s location' },
      'comet_strike': { name:'Comet Strike', damage:'High', type:'Area', description:'Drops a meteorite straight down, generating a shock wave around the impact area' },
      'cryst_breath': { name:'Cryst Breath', damage:'High', type:'Cone', description:'Enshrouds an enemy in a frigid blast of air, dealing continuous damage' },
      'dark_arrow': { name:'Dark Arrow', damage:'Moderate', type:'Homing', description:'Fires off dark energy that homes in on an enemy' },
      'dark_ball': { name:'Dark Ball', damage:'Low', type:'Homing', description:'Unleashes a sphere of darkness that slowly tracks down the enemy' },
      'dark_cannon': { name:'Dark Cannon', damage:'Moderate', type:'Projectile', description:'Fires off dark energy that homes in on an enemy' },
      'dark_laser': { name:'Dark Laser', damage:'Very High', type:'Beam', description:'Charges dark energy before blasting enemies with a powerful beam' },
      'diamond_rain': { name:'Diamond Rain', damage:'Very High', type:'Area', description:'Creates numerous lumps of ice that consecutively drop on a foe’s head' },
      'draconic_breath': { name:'Draconic Breath', damage:'Moderate', type:'Cone', description:'Exhales breath imbued with draconic energy, dealing continuous damage to those in front' },
      'dragon_cannon': { name:'Dragon Cannon', damage:'Low', type:'Projectile', description:'Hurls an energy ball imbued with draconic energy at an enemy' },
      'dragon_meteor': { name:'Dragon Meteor', damage:'Very High', type:'Area', description:'Calls down numerous small meteorites and launches them at an enemy' },
      'fire_ball': { name:'Fire Ball', damage:'Very High', type:'Projectile', description:'Creates a giant ball of flames and hurls it; it explodes over a wide area upon impact' },
      'flame_funnel': { name:'Flame Funnel', damage:'High', type:'Area', description:'Creates multiple spheres of fiery energy, from which countless fireballs shoot towards the enemy' },
      'flame_wall': { name:'Flame Wall', damage:'High', type:'Area', description:'Creates a wall of flames at the enemy’s location; the wall remains and deals damage over time' },
      'flare_arrow': { name:'Flare Arrow', damage:'Moderate', type:'Homing', description:'Fires three flaming arrows in succession that home in on an enemy' },
      'flare_storm': { name:'Flare Storm', damage:'Moderate', type:'Area', description:'Generates two flaming tornadoes on either side before launching them at an enemy' }
    };
    let skillsDictionary = { ...defaultSkillsDictionary };

    // Descriptions for passive traits.  Each entry summarises the
    // benefits or drawbacks of the trait.  We extracted a few from
    // community guides and added our own commentary for others.  Add
    // additional traits here as needed.  Traits not present here
    // will display a generic encouragement to experiment.
    const defaultTraitsDictionary = {
      'Swift': 'Increases movement speed by 30%, letting your pal dash around quickly',
      'Legend': 'Raises Attack and Defense by 20% and Movement Speed by 15%',
      'Lord of the Sea': 'Increases Water attack damage by 20%',
      'Runner': 'Boosts movement speed by 20%',
      'Diligent': 'Raises work efficiency, making jobs go 20% faster',
      'Strong': 'Increases attack damage by 20%',
      'Loyal': 'Improves Attack and Defense slightly (about 10%)',
      'Coward': 'Lowers Attack and Defense by 10%; this pal gets scared easily',
      'Lazy': 'Decreases work speed by 20%, making tasks take longer',
      'Gullible': 'More susceptible to negative status effects; be wary when battling'
    };
    let traitsDictionary = { ...defaultTraitsDictionary };

    // Mapping of environment names to highlight coordinates.  Each
    // environment corresponds to a circular highlight on the map.  The
    // x and y values represent the percentage offsets from the top-left
    // corner of the map image, while w and h represent the diameter
    // percentages of the highlight.  These were chosen manually to
    // approximate the Palworld regions and provide a more natural
    // spotlight compared to boxy overlays.
    const zonePositions = {
      'Volcano': { x: 68, y: 10, w: 30, h: 30 },
      'Snow': { x: 10, y: 10, w: 25, h: 25 },
      'Plains': { x: 40, y: 50, w: 35, h: 35 },
      'Forest': { x: 12, y: 55, w: 25, h: 25 },
      'Coast': { x: 78, y: 60, w: 25, h: 25 },
      'Desert': { x: 50, y: 65, w: 25, h: 25 },
      'Swamp': { x: 85, y: 45, w: 20, h: 20 },
      'Mountains': { x: 50, y: 20, w: 25, h: 25 },
      'Highlands': { x: 40, y: 5, w: 30, h: 20 },
      'River': { x: 5, y: 70, w: 25, h: 20 }
    };

    const DATA_SOURCES = [
      'data/palworld_complete_data_final.json',
      'data/palworld_complete_data_enhanced.json',
      'data/palworld_complete_data.json'
    ];
    const EMBEDDED_DATA_SCRIPT = 'data/palworld_complete_data_fallback.js';
    const ITEM_DETAILS_SOURCES = ['data/item_details.json'];
    const ITEM_DETAILS_FALLBACK_SCRIPT = 'data/item_details_fallback.js';
    const ITEM_DETAILS_GLOBAL = '__PALMATE_ITEM_DETAILS__';
    let embeddedDataPromise = null;
    let itemDetailsEmbeddedPromise = null;

    async function loadEmbeddedDataset() {
      if (window.__PALMATE_EMBEDDED_DATA__) {
        return window.__PALMATE_EMBEDDED_DATA__;
      }
      if (!embeddedDataPromise) {
        embeddedDataPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = EMBEDDED_DATA_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window.__PALMATE_EMBEDDED_DATA__ || null);
          script.onerror = event => {
            console.warn('Unable to load embedded dataset script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await embeddedDataPromise;
      } catch (err) {
        console.warn('Embedded dataset loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsFallback() {
      if (window[ITEM_DETAILS_GLOBAL]) {
        return window[ITEM_DETAILS_GLOBAL];
      }
      if (!itemDetailsEmbeddedPromise) {
        itemDetailsEmbeddedPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = ITEM_DETAILS_FALLBACK_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window[ITEM_DETAILS_GLOBAL] || null);
          script.onerror = event => {
            console.warn('Unable to load item detail fallback script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await itemDetailsEmbeddedPromise;
      } catch (err) {
        console.warn('Item detail fallback loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsDataset() {
      const loadErrors = [];
      for (const source of ITEM_DETAILS_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          return payload;
        } catch (error) {
          loadErrors.push({ source, error });
          console.warn(`Failed to load item details from ${source}`, error);
        }
      }
      return null;
    }
    async function loadItemDetails() {
      const dataset = await loadItemDetailsDataset();
      if (dataset) return dataset;
      const fallback = await loadItemDetailsFallback();
      if (fallback) return fallback;
      console.warn('Item detail dataset unavailable. Item cards will use minimal info.');
      return {};
    }
    // Type icon mapping (relative file paths)
    const iconMap = {
      'Neutral': 'assets/icons/neutral.png',
      'Fire': 'assets/icons/fire.png',
      'Ice': 'assets/icons/ice.png',
      'Electric': 'assets/icons/electric.png',
      'Water': 'assets/icons/water.png',
      'Grass': 'assets/icons/grass.png',
      'Ground': 'assets/icons/ground.png',
      'Dark': 'assets/icons/dark.png',
      'Dragon': 'assets/icons/dragon.png',
      'Air': 'assets/icons/air.png'
    };

    // A handful of recently added pals still lack bundled artwork.  Rather than
    // shipping temporary binary placeholders (which broke our last build), keep
    // a small deny-list of missing files so we can fall back to type icons
    // without triggering console errors.
    const missingPalArt = new Set([
      'assets/pals/098_astegon.png',
      'assets/pals/130_ice_reptyro.png',
      'assets/pals/131_ice_kingpaca.png',
      'assets/pals/138_selyne.png',
      'assets/pals/139_croajiro.png',
      'assets/pals/140_dogen.png'
    ]);

    function getPrimaryType(pal) {
      if (!pal || !Array.isArray(pal.types)) return 'Neutral';
      const type = pal.types.find(entry => typeof entry === 'string' && entry.trim().length);
      return type || 'Neutral';
    }

    function getPalIconSource(pal) {
      const primary = getPrimaryType(pal);
      return iconMap[primary] || iconMap['Neutral'];
    }

    function getPalArtSource(pal) {
      if (!pal) return null;
      const candidate = pal.localImage;
      if (!candidate || missingPalArt.has(candidate)) {
        return null;
      }
      return candidate;
    }

    function getPalOnlineArtSource(pal) {
      if (!pal) return null;
      const remote = typeof pal.image === 'string' ? pal.image.trim() : '';
      if (!remote) return null;
      return remote;
    }

    function applyPalArtwork(img, pal, { alt } = {}) {
      if (!img) return;
      const sources = [];
      const localArt = getPalArtSource(pal);
      if (localArt) sources.push(localArt);
      const onlineArt = getPalOnlineArtSource(pal);
      if (onlineArt && !sources.includes(onlineArt)) {
        sources.push(onlineArt);
      }
      const iconFallback = getPalIconSource(pal);
      if (iconFallback && !sources.includes(iconFallback)) {
        sources.push(iconFallback);
      }
      let attemptIndex = 0;
      function tryNextSource() {
        while (attemptIndex < sources.length) {
          const candidate = sources[attemptIndex++];
          if (!candidate) continue;
          if (/^https?:/i.test(candidate)) {
            img.referrerPolicy = img.referrerPolicy || 'no-referrer';
          } else if (img.referrerPolicy) {
            img.removeAttribute('referrerpolicy');
          }
          img.src = candidate;
          return;
        }
        img.removeEventListener('error', handleError);
      }
      function handleError() {
        if (attemptIndex < sources.length) {
          tryNextSource();
        } else {
          img.removeEventListener('error', handleError);
        }
      }
      img.loading = img.loading || 'lazy';
      img.decoding = img.decoding || 'async';
      if (alt !== undefined) {
        img.alt = alt;
      } else if (!img.alt || img.alt === '') {
        img.alt = pal && pal.name ? `${pal.name} artwork` : 'Pal artwork';
      }
      img.addEventListener('error', handleError);
      tryNextSource();
    }

    // Audio cues for a more immersive UI.  Users can add their own sound files
    // (e.g. click.mp3, modal_open.mp3, modal_close.mp3) inside assets/sounds.
    const clickSound = new Audio('assets/sounds/click.mp3');
    const openSound = new Audio('assets/sounds/modal_open.mp3');
    const closeSound = new Audio('assets/sounds/modal_close.mp3');
    function playSound(sound) {
      // Gracefully handle missing audio files
      if (!sound || typeof sound.play !== 'function') return;
      try {
        sound.currentTime = 0;
        sound.play();
      } catch (err) {
        // Audio play can fail if files are missing or browser policy blocks it
        console.debug('Sound error', err);
      }
    }
    // Navigation handling: top nav bar.  Each .nav-item button
    // switches to its associated page when clicked.  After the
    // switch, we play a click sound.
    document.querySelectorAll('#navbar .nav-item').forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.getAttribute('data-page');
        switchPage(target);
        playSound(clickSound);
      });
    });

    function refreshModeUI() {
      document.body.classList.toggle('kid-mode', kidMode);
      const toggleTitle = document.getElementById('modeToggle');
      const modeIcon = toggleTitle ? toggleTitle.querySelector('i') : null;
      if (toggleTitle && modeIcon) {
        if (kidMode) {
          modeIcon.classList.remove('fa-user-astronaut');
          modeIcon.classList.add('fa-child');
          toggleTitle.title = 'Switch to grown-up mode';
        } else {
          modeIcon.classList.remove('fa-child');
          modeIcon.classList.add('fa-user-astronaut');
          toggleTitle.title = 'Switch to kid mode';
        }
      }
      document.querySelectorAll('[data-mode-card]').forEach(card => {
        const mode = card.getAttribute('data-mode-card');
        const active = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        card.classList.toggle('active', !!active);
        const status = card.querySelector('.mode-card__status');
        if (status) {
          status.textContent = active
            ? (mode === 'kid' ? 'Kid Mode active' : 'Grown-up Mode active')
            : (mode === 'kid' ? 'Switch to Kid Mode' : 'Switch to Grown-up Mode');
        }
      });
      document.querySelectorAll('[data-mode-choice]').forEach(btn => {
        const mode = btn.getAttribute('data-mode-choice');
        const isActive = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        btn.disabled = isActive;
        if (isActive) {
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.removeAttribute('aria-pressed');
        }
      });
    }

    function rebuildModeAwarePages() {
      buildPalPage();
      buildItemPage();
      buildTechPage();
      buildBreedingPage();
      buildGlossaryPage();
      renderRouteGuide();
      buildHomePage();
      buildProgressPage();
      updateProgressUI();
    }

    function persistKidMode() {
      try {
        localStorage.setItem(KID_MODE_STORAGE_KEY, kidMode ? 'true' : 'false');
      } catch (err) {
        console.warn('Failed to save kid mode preference', err);
      }
    }

    function setKidMode(value, { rebuild = true } = {}) {
      const desired = !!value;
      if (kidMode === desired) {
        persistKidMode();
        refreshModeUI();
        if (rebuild) {
          rebuildModeAwarePages();
        }
        return;
      }
      kidMode = desired;
      persistKidMode();
      refreshModeUI();
      if (rebuild) {
        rebuildModeAwarePages();
      }
    }

    // Mode toggle button: switch between kid and grown-up modes.  The
    // icon and tooltip change based on the current mode.  We also
    // rebuild pages so their copy matches the selected experience.
    document.getElementById('modeToggle').addEventListener('click', () => {
      setKidMode(!kidMode);
      playSound(clickSound);
    });
    refreshModeUI();
    function switchPage(page) {
      // Hide all pages and show the selected page.  Our pages are
      // <section> elements with IDs like palsPage, itemsPage, etc.
      document.querySelectorAll('.page').forEach(section => section.classList.remove('active'));
      const activePage = document.getElementById(page + 'Page');
      if (activePage) activePage.classList.add('active');
      // Update navigation item active state
      document.querySelectorAll('#navbar .nav-item').forEach(btn => {
        btn.classList.toggle('active', btn.getAttribute('data-page') === page);
      });
    }
    // Modal controls
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modalBody');
    document.getElementById('modalClose').addEventListener('click', closeModal);
    modal.addEventListener('click', event => {
      if (event.target === modal) {
        closeModal();
      }
    });
    // Track resize handlers registered by the map modal so they can be
    // removed when the dialog closes.  Without this cleanup we would leak
    // listeners as the player opens multiple guide entries.
    let mapResizeCleanup = null;
    function openModal() {
      modal.classList.add('active');
      playSound(openSound);
    }
    function closeModal() {
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      modal.classList.remove('active');
      modalBody.innerHTML = '';
      playSound(closeSound);
    }
    const PALWORLD_BASE_URL = 'https://palworld.gg';
    const PALWORLD_PAL_SLUG_OVERRIDES = {
      // Reserved for pals whose Palworld.gg slug does not match the default slugification.
    };
    const PALWORLD_ITEM_SLUG_OVERRIDES = {
      // Reserved for items whose Palworld.gg slug does not match their key.
    };
    const ROUTE_GLOSSARY_SUMMARIES = {
      'lifmunk-effigy': {
        title: 'Lifmunk Effigy',
        kid: [
          'Tiny glowing statues hidden all over Palworld.',
          'Feed them to the Statue of Power to make catching pals easier.'
        ],
        grown: [
          'Collectible statues that grant Capture Power when offered at a Statue of Power.',
          'Always grab them on sight; the bonus stacks and makes catching high-level pals easier.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Lifmunk Effigy')}`,
        note: 'Peek at Palworld.gg without losing your place in the route.'
      },
      'skill-fruit': {
        title: 'Skill Fruit',
        kid: [
          'Special fruit that lets a pal learn a new move.',
          'Find them in dungeons or treasure chests and save the ones you like.'
        ],
        grown: [
          'Consumable items that instantly teach the move printed on the fruit.',
          'Best sourced from dungeons; stash rare elements until you know which pal will use them.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Skill Fruit')}`,
        note: 'Palmate keeps this move info handy so you can stay on track.'
      }
    };
    // Palworld's in-game coordinates are not symmetrical on the X/Y axes.
    // The static map we render here is cropped to the explorable landmass,
    // which spans roughly X = [-560, 640] and Y = [-662, 340] in world units.
    // Using tighter bounds keeps the marker aligned with tower entrances
    // instead of drifting toward the centre of the image.
    const MAP_WORLD_BOUNDS = { minX: -560, maxX: 640, minY: -662, maxY: 340 };
    function clampToRange(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    function worldCoordsToPercent(coords) {
      if (!Array.isArray(coords) || coords.length < 2) {
        return { left: 50, top: 50 };
      }
      const [rawX, rawY] = coords.map(Number);
      const width = MAP_WORLD_BOUNDS.maxX - MAP_WORLD_BOUNDS.minX;
      const height = MAP_WORLD_BOUNDS.maxY - MAP_WORLD_BOUNDS.minY;
      if (!width || !height) {
        return { left: 50, top: 50 };
      }
      const x = clampToRange(rawX, MAP_WORLD_BOUNDS.minX, MAP_WORLD_BOUNDS.maxX);
      const y = clampToRange(rawY, MAP_WORLD_BOUNDS.minY, MAP_WORLD_BOUNDS.maxY);
      return {
        left: ((x - MAP_WORLD_BOUNDS.minX) / width) * 100,
        top: ((MAP_WORLD_BOUNDS.maxY - y) / height) * 100
      };
    }
    function mapDescriptionLines(info) {
      if (!info) return [];
      if (kidMode && Array.isArray(info.kid) && info.kid.length) {
        return info.kid;
      }
      if (!kidMode && Array.isArray(info.grown) && info.grown.length) {
        return info.grown;
      }
      if (info.note) {
        return [info.note];
      }
      return [];
    }
    function openRouteMapModal(mapInfo = {}, fallbackUrl) {
      const entrance = mapInfo.entrance || null;
      const entranceCoords = Array.isArray(mapInfo.entranceCoords)
        ? mapInfo.entranceCoords
        : (entrance && Array.isArray(entrance.coords) ? entrance.coords : null);
      const coords = entranceCoords || (Array.isArray(mapInfo.coords) ? mapInfo.coords : null);
      if (!coords) {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
        return;
      }
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      const { left, top } = worldCoordsToPercent(coords);
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'map-modal';
      const heading = document.createElement('h3');
      heading.textContent = mapInfo.title || 'Route location';
      wrap.appendChild(heading);
      const meta = document.createElement('p');
      meta.className = 'map-modal-note';
      const metaBits = [];
      if (mapInfo.region) metaBits.push(mapInfo.region);
      const primaryLabel = entrance && entrance.label ? entrance.label : (mapInfo.coordsLabel || 'Entrance');
      metaBits.push(`${primaryLabel}: (${coords[0]}, ${coords[1]})`);
      if (!entranceCoords && Array.isArray(mapInfo.coords) && mapInfo.coords.length >= 2) {
        metaBits.push(`Location: (${mapInfo.coords[0]}, ${mapInfo.coords[1]})`);
      }
      meta.textContent = metaBits.join(' • ');
      wrap.appendChild(meta);
      const details = [
        ...mapDescriptionLines(mapInfo),
        ...mapDescriptionLines(entrance)
      ];
      if (details.length) {
        const detailsWrap = document.createElement('div');
        detailsWrap.className = 'map-modal-details';
        details.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          detailsWrap.appendChild(p);
        });
        wrap.appendChild(detailsWrap);
      }
      const canvas = document.createElement('div');
      canvas.className = 'map-modal-canvas';
      const mapImage = document.createElement('img');
      mapImage.src = 'assets/images/palworld-full-map-2.webp';
      const mapAltTitle = entrance && entrance.label
        ? `${entrance.label} for ${mapInfo.title || 'the selected encounter'}`
        : (mapInfo.title ? `${mapInfo.title} location on the Palworld map` : 'Palworld map showing the selected route location');
      mapImage.alt = mapAltTitle;
      canvas.appendChild(mapImage);
      const marker = document.createElement('div');
      marker.className = 'map-marker';
      marker.style.left = `${left}%`;
      marker.style.top = `${top}%`;
      const markerLabel = (entrance && entrance.label) || mapInfo.label || mapInfo.title;
      if (markerLabel) {
        const label = document.createElement('span');
        label.className = 'map-marker-label';
        label.textContent = markerLabel;
        marker.appendChild(label);
      }
      canvas.appendChild(marker);
      mapResizeCleanup = null;
      wrap.appendChild(canvas);
      const actions = document.createElement('div');
      actions.className = 'badges';
      actions.style.marginTop = '4px';
      const openBtn = document.createElement('button');
      openBtn.type = 'button';
      openBtn.className = 'modal-action-btn';
      openBtn.textContent = 'Open interactive map';
      openBtn.addEventListener('click', () => {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
      });
      actions.appendChild(openBtn);
      wrap.appendChild(actions);
      modalBody.appendChild(wrap);
      openModal();
    }
    function openTowerMap(link) {
      if (!link) return;
      const info = link.map ? { ...link.map } : {};
      if (!info.url && link.url) {
        info.url = link.url;
      }
      if (!info.title) {
        info.title = niceName(link.id || 'Tower');
      }
      openRouteMapModal(info, link.url);
    }
    function slugifyForPalworld(text) {
      if (!text) return '';
      return text
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/&/g, ' and ')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }
    function humaniseItemKey(key) {
      if (!key) return '';
      return key
        .split('_')
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }
    function openPalworldEmbed({ heading, url, fallbackUrl, note, summaryHtml }) {
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'external-embed';
      const actions = document.createElement('div');
      actions.className = 'embed-actions';
      const titleEl = document.createElement('h3');
      titleEl.textContent = heading;
      actions.appendChild(titleEl);
      if (url) {
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.rel = 'noopener';
        link.className = 'embed-link';
        link.textContent = 'Open in new tab';
        actions.appendChild(link);
      }
      wrap.appendChild(actions);
      const noteEl = document.createElement('p');
      noteEl.className = 'embed-note';
      noteEl.textContent = note || 'This view pulls live details from Palworld.gg while keeping your progress tracker close at hand.';
      wrap.appendChild(noteEl);
      if (summaryHtml) {
        const summary = document.createElement('div');
        summary.className = 'embed-summary';
        summary.innerHTML = summaryHtml;
        wrap.appendChild(summary);
      }
      if (url) {
        const frame = document.createElement('iframe');
        frame.src = url;
        frame.title = heading;
        frame.loading = 'lazy';
        frame.referrerPolicy = 'no-referrer-when-downgrade';
        frame.className = 'embed-frame';
        wrap.appendChild(frame);
      }
      const fallback = document.createElement('p');
      fallback.className = 'embed-fallback';
      const fallbackLink = document.createElement('a');
      fallbackLink.href = fallbackUrl || url || PALWORLD_BASE_URL;
      fallbackLink.target = '_blank';
      fallbackLink.rel = 'noopener';
      fallbackLink.textContent = 'Open on Palworld.gg';
      fallback.appendChild(document.createTextNode('If the page does not load, '));
      fallback.appendChild(fallbackLink);
      fallback.appendChild(document.createTextNode('.'));
      wrap.appendChild(fallback);
      modalBody.appendChild(wrap);
      openModal();
      return wrap;
    }
    async function loadDatasetSequentially() {
      const isFileProtocol = window.location.protocol === 'file:';
      if (isFileProtocol) {
        const embeddedPayload = await loadEmbeddedDataset();
        if (embeddedPayload) {
          return { payload: embeddedPayload, source: 'embedded fallback dataset' };
        }
        console.warn('File protocol detected but embedded dataset fallback was unavailable. Continuing with fetch attempts.');
      }
      const loadErrors = [];
      for (const source of DATA_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          if (!payload.pals || !payload.items || !payload.tech) {
            console.warn(`Dataset ${source} missing required keys. Skipping.`);
            continue;
          }
          return { payload, source };
        } catch (err) {
          loadErrors.push({ source, error: err });
          console.warn(`Failed to load dataset ${source}`, err);
        }
      }
      const embeddedFallback = await loadEmbeddedDataset();
      if (embeddedFallback) {
        return { payload: embeddedFallback, source: 'embedded fallback dataset' };
      }
      const errorSummary = loadErrors.length
        ? loadErrors.map(entry => {
            const reason = entry.error && entry.error.message ? entry.error.message : entry.error;
            return `${entry.source} (${reason})`;
          }).join('; ')
        : '';
      const summarySuffix = errorSummary ? ` ${errorSummary}` : '';
      throw new Error(`Unable to load any dataset from the data folder.${summarySuffix}`);
    }

    (async function initialisePalmate() {
      try {
        const { payload, source } = await loadDatasetSequentially();
        console.info(`Palmate data source: ${source}`);
        // Data is namespaced under pals, items and tech plus extra sections
        PALS = payload.pals || {};
        ITEMS = payload.items || {};
        TECH = payload.tech || [];
        rebuildTechLookup();
        SKILL_DETAILS = payload.skillsDetails || {};
        PASSIVE_DETAILS = payload.passiveDetails || {};
        ITEM_DETAILS = await loadItemDetails();
        // Build name‑to‑ID lookup map
        PAL_NAME_TO_ID = {};
        PAL_SLUG_TO_ID = {};
        Object.values(PALS).forEach(p => {
          PAL_NAME_TO_ID[p.name] = p.id;
          const slug = slugifyForPalworld(p.name);
          if(slug) PAL_SLUG_TO_ID[slug] = p.id;
        });
        // Build a global map of item drops for quick lookup
        DROPS_MAP = {};
        Object.values(PALS).forEach(pal => {
          (pal.drops || []).forEach(item => {
            if (!DROPS_MAP[item]) DROPS_MAP[item] = [];
            DROPS_MAP[item].push(pal.name);
          });
        });
        // Build pages
        buildPalPage();
        buildItemPage();
        buildTechPage();
        buildBreedingPage();
        buildHomePage();
        renderRouteGuide();
        // Synchronise skills and traits dictionaries with the loaded data.
        // Override the static dictionaries with entries from the JSON file.
        skillsDictionary = { ...defaultSkillsDictionary };
        if (SKILL_DETAILS && Object.keys(SKILL_DETAILS).length) {
          const normalizedSkills = {};
          Object.entries(SKILL_DETAILS).forEach(([key, info = {}]) => {
            const normalizedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
            normalizedSkills[normalizedKey] = {
              name: (info.name || key).replace(/_/g, ' '),
              damage: info.power ? `Power ${info.power}` : (info.damage || 'Unknown'),
              type: info.element || info.type || 'Unknown',
              description: info.description || 'No description available.'
            };
          });
          skillsDictionary = { ...defaultSkillsDictionary, ...normalizedSkills };
        }
        traitsDictionary = { ...defaultTraitsDictionary };
        if (PASSIVE_DETAILS && Object.keys(PASSIVE_DETAILS).length) {
          traitsDictionary = { ...defaultTraitsDictionary, ...PASSIVE_DETAILS };
        }
        buildGlossaryPage();
        buildMapPage();
        buildProgressPage();
        updateProgressUI();
      } catch (err) {
        console.error(err);
        const reason = err && err.message ? ` (${err.message})` : '';
        const extraHelp = window.location.protocol === 'file:'
          ? ' Launching a local web server or regenerating data/palworld_complete_data_fallback.js usually resolves file:// restrictions.'
          : ' Please confirm that the data folder is deployed with the site.';
        document.body.insertAdjacentHTML('beforeend', `<p style="color:red">Failed to load data${reason}.${extraHelp}</p>`);
      }
    })();
    // Build pal page
    function buildPalPage() {
      const list = document.getElementById('palsList');
      const search = document.getElementById('palSearch');
      function render(filter = '') {
        list.innerHTML = '';
        const term = filter.toLowerCase();
        Object.values(PALS).forEach(pal => {
          const types = Array.isArray(pal.types) ? pal.types : [];
          if (!pal.name.toLowerCase().includes(term) && !types.join(',').toLowerCase().includes(term)) return;
          const card = document.createElement('div');
          card.className = 'pal-card';
          // Build type icon HTML
          const typeIcons = types.map(t => `<img src="${iconMap[t] || iconMap['Neutral']}" alt="${t} icon" style="width:20px;height:20px;margin-right:2px;">`).join('');
          // Render the pal card. Use the local image if available. If the art is missing
          // (for example, when we have not yet added the file to assets/pals),
          // applyPalArtwork() swaps in a matching type icon automatically so the
          // card always has a visual cue without throwing console errors.
          // Build rarity label and star icons.  Rarity names add readability and
          // stars provide a quick visual indicator.  We use Font Awesome stars
          // here to ensure consistent sizing and colour.
          const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
          let rarityLabel = rarityNames[rarity] || '';
          let starIcons = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          // In kid mode we suppress rarity and stars to avoid
          // confusion and clutter.  Kids can still see the card
          // colour and image to gauge rarity implicitly.
          if (kidMode) {
            rarityLabel = '';
            starIcons = '';
          }
          card.innerHTML = `
            <img alt="">
            <div class="name">${pal.name}</div>
            <div class="badge">${typeIcons}</div>
            <div class="rarity"><span class="stars">${starIcons}</span> <span class="label">${rarityLabel}</span></div>
            <button class="catch-btn ${caught[pal.id] ? 'caught' : ''}">${caught[pal.id] ? 'Caught' : 'Catch'}</button>
          `;
          const portrait = card.querySelector('img');
          applyPalArtwork(portrait, pal, { alt: `${pal.name} portrait` });
          card.dataset.palId = pal.id;
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            showPalDetail(pal.id);
          });
          const btn = card.querySelector('button');
          btn.dataset.palId = pal.id;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            caught[pal.id] = !caught[pal.id];
            localStorage.setItem('caught', JSON.stringify(caught));
            btn.classList.toggle('caught', caught[pal.id]);
            btn.textContent = caught[pal.id] ? 'Caught' : 'Catch';
            updateProgressUI();
            autoCompleteRouteStepsForPal(pal.id);
            playSound(clickSound);
          });
          list.appendChild(card);
        });
      }
      search.addEventListener('input', () => render(search.value));
      render();
    }
    function syncPalButtons(palId) {
      if (palId === undefined || palId === null) return;
      document.querySelectorAll(`.catch-btn[data-pal-id="${palId}"]`).forEach(btn => {
        const state = !!caught[palId];
        btn.classList.toggle('caught', state);
        btn.textContent = state ? 'Caught' : 'Catch';
      });
    }
    function syncTechButtons(techKey, techName) {
      if (!techKey) return;
      document.querySelectorAll(`.unlock-btn[data-tech-key="${techKey}"]`).forEach(btn => {
        const lookupName = btn.dataset.techName || techName;
        const state = lookupName ? !!unlocked[lookupName] : false;
        btn.classList.toggle('unlocked', state);
        btn.textContent = state ? 'Unlocked' : 'Unlock';
        const card = btn.closest('.tech-card');
        if (card) {
          card.classList.toggle('tech-card--unlocked', state);
        }
      });
    }
    function updateItemCollectionButtons(itemKey) {
      document.querySelectorAll(`.item-card button.collect-btn[data-item-key="${itemKey}"]`).forEach(btn => {
        const state = !!collected[itemKey];
        btn.classList.toggle('collected', state);
        btn.textContent = state ? 'Collected' : 'Collect';
      });
    }
    // Show pal details in a modal by embedding the Palworld.gg page
    // alongside quick progress hints and a shortcut back to the map.
    function showPalDetail(id) {
      const pal = PALS[id];
      if (!pal) return;
      const slug = PALWORLD_PAL_SLUG_OVERRIDES[pal.name] || slugifyForPalworld(pal.name);
      const palUrl = slug ? `${PALWORLD_BASE_URL}/pal/${slug}` : `${PALWORLD_BASE_URL}/pals`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/pals?search=${encodeURIComponent(pal.name)}`;
      const habitats = pal.spawnAreas && pal.spawnAreas.length
        ? pal.spawnAreas.join(', ')
        : (environmentMap[pal.types && pal.types[0]] || 'Unknown');
      const sphere = raritySphere[pal.rarity] || 'Pal Sphere';
      const sphereInfo = sphereRates[sphere];
      const caughtStatus = caught[pal.id];
      const summaryLines = [];
      if (kidMode) {
        summaryLines.push(`<strong>Status:</strong> ${caughtStatus ? 'We caught this pal!' : 'Still looking for this pal.'}`);
        if (habitats && habitats !== 'Unknown') {
          summaryLines.push(`<strong>Where it lives:</strong> ${habitats}`);
        }
        summaryLines.push(`<strong>Catch tip:</strong> Try a ${sphere}.`);
      } else {
        summaryLines.push(`<strong>Tracking:</strong> ${caughtStatus ? 'Caught' : 'Not caught yet'}`);
        if (habitats) {
          summaryLines.push(`<strong>Habitats:</strong> ${habitats}`);
        }
        if (sphereInfo) {
          summaryLines.push(`<strong>Suggested Sphere:</strong> ${sphere} (${Math.round(sphereInfo.rate * 100)}% base) – ${sphereInfo.description}`);
        }
      }
      summaryLines.push(`<button type="button" class="open-map-button modal-action-btn">Open Map</button>`);
      const summaryHtml = summaryLines.map(line => `<p>${line}</p>`).join('');
      const note = kidMode
        ? 'We show the Palworld.gg page here so you can read about this pal without leaving your guide.'
        : 'Palworld.gg has the most complete breakdowns. Enjoy them in-place while Palmate keeps tracking your progress.';
      const wrap = openPalworldEmbed({
        heading: `${pal.name} – Palworld.gg`,
        url: palUrl,
        fallbackUrl,
        note,
        summaryHtml
      });
      const mapButton = wrap.querySelector('.open-map-button');
      if (mapButton) {
        mapButton.addEventListener('click', (event) => {
          event.preventDefault();
          closeModal();
          switchPage('map');
        });
      }
    }
    window.viewPal = function(identifier){
      if(identifier === undefined || identifier === null) return;
      if(typeof identifier === 'number'){
        showPalDetail(identifier);
        return;
      }
      const normalized = String(identifier).toLowerCase();
      const slugId = PAL_SLUG_TO_ID[normalized];
      if(slugId){
        showPalDetail(slugId);
        return;
      }
      const byName = PAL_NAME_TO_ID[capitalize(normalized)];
      if(byName){
        showPalDetail(byName);
        return;
      }
      focusSearch(identifier);
    };
    // Build items page
    function buildItemPage() {
      const list = document.getElementById('itemsList');
      const search = document.getElementById('itemSearch');
      // Compute which pals drop each item
      const dropsMap = {};
      Object.values(PALS).forEach(pal => {
        (pal.drops || []).forEach(item => {
          if (!dropsMap[item]) dropsMap[item] = [];
          dropsMap[item].push(pal.name);
        });
      });
      const allItemKeys = Array.from(new Set([
        ...Object.keys(ITEMS || {}),
        ...Object.keys(ITEM_DETAILS || {})
      ])).sort((a, b) => niceName(a).localeCompare(niceName(b)));
      function render(filter = '') {
        list.innerHTML = '';
        const term = filter.trim().toLowerCase();
        allItemKeys.forEach(itemKey => {
          const detail = ITEM_DETAILS[itemKey] || {};
          const baseInfo = ITEMS[itemKey] || {};
          const displayName = detail.name || niceName(itemKey);
          const ranchProducers = Array.isArray(detail.ranchProducers)
            ? detail.ranchProducers
            : (Array.isArray(baseInfo.ranchProducers) ? baseInfo.ranchProducers : []);
          const searchable = [
            itemKey,
            displayName,
            detail.type,
            baseInfo.category,
            ...(ranchProducers || [])
          ].filter(Boolean).join(' ').toLowerCase();
          if (term && !searchable.includes(term)) return;

          const card = document.createElement('div');
          card.className = 'item-card';
          card.dataset.itemKey = itemKey;

          const art = document.createElement('div');
          art.className = 'item-card-art';
          const usePlaceholder = () => {
            if (!art.querySelector('.item-card-placeholder')) {
              const placeholder = document.createElement('div');
              placeholder.className = 'item-card-placeholder';
              placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
              art.appendChild(placeholder);
            }
          };
          const imageUrl = detail.image || baseInfo.image || null;
          if (imageUrl) {
            const img = document.createElement('img');
            img.loading = 'lazy';
            img.decoding = 'async';
            img.alt = `${displayName} icon`;
            img.referrerPolicy = 'no-referrer';
            img.src = imageUrl;
            img.onerror = () => {
              img.remove();
              usePlaceholder();
            };
            art.appendChild(img);
          }
          if (!art.hasChildNodes()) {
            usePlaceholder();
          }
          card.appendChild(art);

          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = displayName;
          card.appendChild(nameEl);

          const category = detail.type || baseInfo.category || 'Misc';
          const categoryEl = document.createElement('div');
          categoryEl.className = 'category';
          categoryEl.textContent = category;
          card.appendChild(categoryEl);

          const dropNames = dropsMap[itemKey] || [];
          const dropsEl = document.createElement('div');
          dropsEl.className = 'drops';
          dropsEl.textContent = `Dropped by: ${dropNames.length ? dropNames.join(', ') : 'None recorded'}`;
          card.appendChild(dropsEl);

          const ranchEl = document.createElement('div');
          ranchEl.className = 'ranch';
          if (ranchProducers.length) {
            ranchEl.textContent = `Ranch pals: ${ranchProducers.join(', ')}`;
          } else {
            ranchEl.textContent = 'Ranch pals: None recorded';
            ranchEl.classList.add('ranch--empty');
          }
          card.appendChild(ranchEl);

          const btn = document.createElement('button');
          btn.className = `collect-btn ${collected[itemKey] ? 'collected' : ''}`;
          btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
          btn.dataset.itemKey = itemKey;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            collected[itemKey] = !collected[itemKey];
            localStorage.setItem('collected', JSON.stringify(collected));
            btn.classList.toggle('collected', collected[itemKey]);
            btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
            updateProgressUI();
          });
          card.appendChild(btn);

          // Clicking the card opens the item details modal.  Exclude button clicks.
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            openItemDetail(itemKey);
          });
          list.appendChild(card);
        });
      }
      search.addEventListener('input', () => render(search.value));
      render();
    }
    // Build technology tree page
    function buildTechPage() {
      const list = document.getElementById('techList');
      if (!list) return;
      list.innerHTML = '';
      const levels = Array.isArray(TECH)
        ? TECH.slice().sort((a, b) => (a?.level || 0) - (b?.level || 0))
        : [];
      if (!levels.length) {
        const empty = document.createElement('p');
        empty.className = 'tech-empty';
        empty.textContent = kidMode
          ? 'Technology data is still loading. Check back soon!'
          : 'Technology data is still loading.';
        list.appendChild(empty);
        return;
      }

      const iconFallback = '<i class="fa-solid fa-gears"></i>';

      function createTechCard(item) {
        if (!item || !item.name) {
          return null;
        }
        const card = document.createElement('article');
        card.className = 'tech-card';
        const techKey = item.id || slugifyForPalworld(item.name);
        if (techKey) {
          card.id = `tech-${techKey}`;
        }
        card.dataset.branch = item.branch || 'Technology';
        const isUnlocked = !!unlocked[item.name];
        if (isUnlocked) {
          card.classList.add('tech-card--unlocked');
        }

        const art = document.createElement('div');
        art.className = 'tech-card__art';
        if (item.image) {
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.decoding = 'async';
          img.alt = `${item.name} image`;
          img.referrerPolicy = 'no-referrer';
          img.src = item.image;
          img.onerror = () => {
            img.remove();
            art.classList.add('tech-card__art--fallback');
            art.innerHTML = iconFallback;
          };
          art.appendChild(img);
        } else {
          art.classList.add('tech-card__art--fallback');
          art.innerHTML = iconFallback;
        }

        const info = document.createElement('div');
        info.className = 'tech-card__info';

        const title = document.createElement('div');
        title.className = 'tech-card__title';
        const nameEl = document.createElement('h5');
        nameEl.className = 'tech-card__name';
        nameEl.textContent = item.name;
        title.appendChild(nameEl);
        const cost = document.createElement('span');
        cost.className = 'tech-card__cost';
        const pointLabel = item.isAncient
          ? (kidMode ? 'Ancient Points' : 'AP')
          : (kidMode ? 'Tech Points' : 'TP');
        const points = typeof item.techPoints === 'number' ? item.techPoints : null;
        cost.textContent = points !== null ? `${points} ${pointLabel}` : pointLabel;
        title.appendChild(cost);
        info.appendChild(title);

        const chips = document.createElement('div');
        chips.className = 'tech-card__chips';
        const labels = new Set();
        if (item.category) labels.add(item.category);
        if (item.group) labels.add(item.group);
        labels.forEach(label => {
          const chip = document.createElement('span');
          chip.className = 'tech-chip';
          chip.textContent = label;
          chips.appendChild(chip);
        });
        if (chips.children.length) {
          info.appendChild(chips);
        }

        const description = document.createElement('p');
        description.className = 'tech-card__description';
        description.textContent = item.description
          || (kidMode
            ? `Unlocks ${item.name}.`
            : `Unlocks the ${item.name} blueprint.`);
        info.appendChild(description);

        if (item.materials && Object.keys(item.materials).length) {
          const materials = document.createElement('ul');
          materials.className = 'tech-card__materials';
          Object.entries(item.materials).forEach(([mat, qty]) => {
            const li = document.createElement('li');
            li.textContent = `${qty} × ${mat}`;
            materials.appendChild(li);
          });
          info.appendChild(materials);
        }

        const actions = document.createElement('div');
        actions.className = 'tech-card__actions';
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'unlock-btn';
        if (isUnlocked) {
          button.classList.add('unlocked');
        }
        if (techKey) {
          button.dataset.techKey = techKey;
        }
        button.dataset.techName = item.name;
        button.textContent = isUnlocked ? 'Unlocked' : 'Unlock';
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          unlocked[item.name] = !unlocked[item.name];
          localStorage.setItem('unlocked', JSON.stringify(unlocked));
          button.classList.toggle('unlocked', unlocked[item.name]);
          button.textContent = unlocked[item.name] ? 'Unlocked' : 'Unlock';
          card.classList.toggle('tech-card--unlocked', unlocked[item.name]);
          updateProgressUI();
          autoCompleteRouteStepsForTech(techKey, item.name);
        });
        actions.appendChild(button);
        info.appendChild(actions);

        card.appendChild(art);
        card.appendChild(info);

        if (techKey) {
          card.addEventListener('click', () => {
            showTechDetail(techKey);
          });
        }
        return card;
      }

      levels.forEach(level => {
        if (!level) return;
        const section = document.createElement('article');
        section.className = 'tech-level-card';

        const header = document.createElement('div');
        header.className = 'tech-level-header';
        const number = document.createElement('div');
        number.className = 'tech-level-number';
        const label = document.createElement('span');
        label.textContent = 'Level';
        number.appendChild(label);
        const value = document.createElement('strong');
        value.textContent = level.level != null ? String(level.level) : '?';
        number.appendChild(value);
        header.appendChild(number);

        const techItems = Array.isArray(level.items) ? level.items.filter(item => item && !item.isAncient) : [];
        const ancientItems = Array.isArray(level.items) ? level.items.filter(item => item && item.isAncient) : [];
        const summary = document.createElement('div');
        summary.className = 'tech-level-summary';
        const summaryParts = [];
        if (techItems.length) summaryParts.push(`${techItems.length} Tech`);
        if (ancientItems.length) summaryParts.push(`${ancientItems.length} Ancient`);
        summary.textContent = summaryParts.length
          ? summaryParts.join(' • ')
          : (kidMode ? 'No blueprints at this level yet.' : 'No unlocks available at this level.');
        header.appendChild(summary);
        section.appendChild(header);

        const columns = document.createElement('div');
        columns.className = 'tech-columns';
        const columnData = [
          {
            key: 'tech',
            heading: 'Technology',
            items: techItems,
            emptyText: kidMode ? 'Nothing new here yet.' : 'No new technology unlocks.',
          },
          {
            key: 'ancient',
            heading: 'Ancient Technology',
            items: ancientItems,
            emptyText: kidMode ? 'No ancient relics unlocked now.' : 'No ancient tech at this level.',
          }
        ];

        columnData.forEach(columnInfo => {
          const column = document.createElement('div');
          column.className = `tech-column tech-column--${columnInfo.key}`;
          const heading = document.createElement('h4');
          heading.textContent = columnInfo.heading;
          column.appendChild(heading);
          if (!columnInfo.items.length) {
            const empty = document.createElement('p');
            empty.className = 'tech-empty';
            empty.textContent = columnInfo.emptyText;
            column.appendChild(empty);
          } else {
            const grid = document.createElement('div');
            grid.className = 'tech-card-grid';
            columnInfo.items.forEach(item => {
              const card = createTechCard(item);
              if (card) grid.appendChild(card);
            });
            column.appendChild(grid);
          }
          columns.appendChild(column);
        });

        section.appendChild(columns);
        list.appendChild(section);
      });
      applyQueuedTechFocus();
    }

    function queueTechFocus(key){
      if(!key){
        pendingTechFocus = null;
        return;
      }
      pendingTechFocus = key;
      setTimeout(applyQueuedTechFocus, 0);
    }

    function applyQueuedTechFocus(){
      if(!pendingTechFocus) return;
      const techCard = document.getElementById(`tech-${pendingTechFocus}`);
      if(!techCard) return;
      pendingTechFocus = null;
      requestAnimationFrame(() => {
        techCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        pulse(techCard);
      });
    }
    // Build breeding page
    function buildBreedingPage() {
      const parent1Grid = document.getElementById('parent1Grid');
      const parent2Grid = document.getElementById('parent2Grid');
      const babyGrid = document.getElementById('babyGrid');
      const result = document.getElementById('breedingResult');
      const combosContainer = document.getElementById('breedingCombos');
      const parent1Search = document.getElementById('parent1Search');
      const parent2Search = document.getElementById('parent2Search');
      const babySearch = document.getElementById('babySearch');
      const modeButtons = Array.from(document.querySelectorAll('.breeding-tab'));
      const modes = Array.from(document.querySelectorAll('.breeding-mode'));
      if (!parent1Grid || !parent2Grid || !babyGrid || !result || !combosContainer || !parent1Search || !parent2Search || !babySearch) {
        return;
      }
      const palsSorted = Object.values(PALS || {}).sort((a, b) => a.name.localeCompare(b.name));
      let parentState = {
        parent1: BREEDING_SELECTION.parent1Id ? PALS[BREEDING_SELECTION.parent1Id] : null,
        parent2: BREEDING_SELECTION.parent2Id ? PALS[BREEDING_SELECTION.parent2Id] : null
      };
      let selectedBaby = BREEDING_SELECTION.babyId ? PALS[BREEDING_SELECTION.babyId] : null;
      if (!parentState.parent1) parentState.parent1 = null;
      if (!parentState.parent2) parentState.parent2 = null;
      if (!selectedBaby) selectedBaby = null;

      function updateBreedingSelection() {
        BREEDING_SELECTION.parent1Id = parentState.parent1 ? parentState.parent1.id : null;
        BREEDING_SELECTION.parent2Id = parentState.parent2 ? parentState.parent2.id : null;
        BREEDING_SELECTION.babyId = selectedBaby ? selectedBaby.id : null;
      }

      function makeEmptyMessage(text) {
        const msg = document.createElement('p');
        msg.className = 'empty-state';
        msg.textContent = text;
        return msg;
      }

      function createPalCard(pal, options = {}) {
        const { compact = true, selectable = true, selected = false } = options;
        const card = document.createElement('div');
        card.classList.add('pal-card');
        if (compact) card.classList.add('compact');
        if (selectable) card.classList.add('selectable');
        else card.classList.add('static');
        if (selected) card.classList.add('selected');
        const img = document.createElement('img');
        applyPalArtwork(img, pal);
        card.appendChild(img);
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = pal.name;
        card.appendChild(name);
        const badge = document.createElement('div');
        badge.className = 'badge';
        if (Array.isArray(pal.types) && pal.types.length) {
          pal.types.forEach(type => {
            const icon = document.createElement('img');
            icon.src = iconMap[type] || iconMap['Neutral'];
            icon.alt = `${type} icon`;
            badge.appendChild(icon);
          });
        } else {
          const span = document.createElement('span');
          span.textContent = 'Unknown';
          badge.appendChild(span);
        }
        card.appendChild(badge);
        if (pal && typeof pal.id !== 'undefined') {
          const caughtStatus = document.createElement('div');
          const isCaught = !!caught[pal.id];
          caughtStatus.className = 'caught-status';
          caughtStatus.dataset.caught = isCaught ? 'true' : 'false';
          caughtStatus.textContent = isCaught
            ? (kidMode ? 'We caught it!' : 'Caught')
            : (kidMode ? 'Need this pal' : 'Not caught yet');
          card.appendChild(caughtStatus);
        }
        const rarityEl = document.createElement('div');
        rarityEl.className = 'rarity';
        const starSpan = document.createElement('span');
        starSpan.className = 'stars';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'label';
        const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
        if (!kidMode) {
          starSpan.innerHTML = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          labelSpan.textContent = rarityNames[rarity] || '';
        }
        rarityEl.appendChild(starSpan);
        rarityEl.appendChild(labelSpan);
        card.appendChild(rarityEl);
        return card;
      }

      function createComboCard(pal, fallbackName) {
        if (pal) {
          return createPalCard(pal, { compact: true, selectable: false });
        }
        const wrapper = document.createElement('div');
        wrapper.classList.add('pal-card', 'compact', 'static');
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = fallbackName;
        wrapper.appendChild(name);
        const badge = document.createElement('div');
        badge.className = 'badge';
        badge.textContent = kidMode ? 'Not in list yet' : 'Not in dataset yet';
        wrapper.appendChild(badge);
        const rarity = document.createElement('div');
        rarity.className = 'rarity';
        wrapper.appendChild(rarity);
        return wrapper;
      }

      function filterPals(term) {
        const normalized = (term || '').trim().toLowerCase();
        if (!normalized) return palsSorted.slice();
        return palsSorted.filter(pal => {
          const nameMatch = pal.name.toLowerCase().includes(normalized);
          const typeMatch = Array.isArray(pal.types) && pal.types.some(type => type && type.toLowerCase().includes(normalized));
          return nameMatch || typeMatch;
        });
      }

      function renderParentGrid(slot) {
        const grid = slot === 'parent1' ? parent1Grid : parent2Grid;
        const searchTerm = slot === 'parent1' ? parent1Search.value : parent2Search.value;
        grid.innerHTML = '';
        if (!palsSorted.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        const selected = slot === 'parent1' ? parentState.parent1 : parentState.parent2;
        let matches = filterPals(searchTerm);
        if (selected && !matches.some(p => p.id === selected.id)) {
          matches = [selected, ...matches];
        }
        if (!matches.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'No pals match your search yet.'));
          return;
        }
        matches.forEach(pal => {
          const isSelected = selected && selected.id === pal.id;
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: isSelected
          });
          card.addEventListener('click', () => {
            const alreadySelected = slot === 'parent1'
              ? parentState.parent1 && parentState.parent1.id === pal.id
              : parentState.parent2 && parentState.parent2.id === pal.id;
            if (slot === 'parent1') {
              parentState.parent1 = alreadySelected ? null : pal;
            } else {
              parentState.parent2 = alreadySelected ? null : pal;
            }
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
          });
          grid.appendChild(card);
        });
      }

      function updateParentGrids() {
        renderParentGrid('parent1');
        renderParentGrid('parent2');
      }

      function renderBabyGrid() {
        babyGrid.innerHTML = '';
        if (!palsSorted.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        let matches = filterPals(babySearch.value);
        if (selectedBaby && !matches.some(p => p.id === selectedBaby.id)) {
          matches = [selectedBaby, ...matches];
        }
        if (!matches.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'Try a different pal search.'));
          return;
        }
        matches.forEach(pal => {
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: selectedBaby && selectedBaby.id === pal.id
          });
          card.addEventListener('click', () => {
            if (selectedBaby && selectedBaby.id === pal.id) {
              selectedBaby = null;
            } else {
              selectedBaby = pal;
            }
            updateBreedingSelection();
            renderBabyGrid();
            showCombos();
          });
          babyGrid.appendChild(card);
        });
      }

      function showCombos() {
        combosContainer.innerHTML = '';
        if (!selectedBaby) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'Pick a pal above to see recipes.' : 'Select a pal to see which parents can produce it.'));
          return;
        }
        const header = document.createElement('div');
        header.className = 'breeding-baby-header';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? `Make ${selectedBaby.name}` : `Parent combos for ${selectedBaby.name}`;
        header.appendChild(heading);
        header.appendChild(createPalCard(selectedBaby, { compact: true, selectable: false }));
        combosContainer.appendChild(header);
        const combos = Array.isArray(selectedBaby.breedingCombos) ? selectedBaby.breedingCombos : [];
        if (!combos.length) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'No combos known yet.' : 'We do not have recorded breeding pairs for this pal yet.'));
          return;
        }
        combos.forEach(pair => {
          if (!Array.isArray(pair) || pair.length < 2) return;
          const [leftName, rightName] = pair;
          const leftPalId = PAL_NAME_TO_ID[leftName];
          const rightPalId = PAL_NAME_TO_ID[rightName];
          const leftPal = leftPalId ? PALS[leftPalId] : null;
          const rightPal = rightPalId ? PALS[rightPalId] : null;
          const row = document.createElement('div');
          row.className = 'breeding-combo';
          row.appendChild(createComboCard(leftPal, leftName));
          const plus = document.createElement('div');
          plus.className = 'combo-arrow';
          plus.textContent = '+';
          row.appendChild(plus);
          row.appendChild(createComboCard(rightPal, rightName));
          const arrow = document.createElement('div');
          arrow.className = 'combo-arrow';
          arrow.textContent = '→';
          row.appendChild(arrow);
          row.appendChild(createPalCard(selectedBaby, { compact: true, selectable: false }));
          row.addEventListener('click', () => {
            if (leftPal) parentState.parent1 = leftPal;
            if (rightPal) parentState.parent2 = rightPal;
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
            switchBreedingMode('breedingPredict');
            playSound(clickSound);
          });
          combosContainer.appendChild(row);
        });
      }

      function findPredictedBaby() {
        if (!parentState.parent1 || !parentState.parent2) return null;
        const power1 = parentState.parent1.breeding && typeof parentState.parent1.breeding.power === 'number'
          ? parentState.parent1.breeding.power
          : 0;
        const power2 = parentState.parent2.breeding && typeof parentState.parent2.breeding.power === 'number'
          ? parentState.parent2.breeding.power
          : 0;
        const avgPower = Math.floor((power1 + power2) / 2);
        let closest = null;
        let diff = Infinity;
        Object.values(PALS).forEach(p => {
          const power = p.breeding && typeof p.breeding.power === 'number' ? p.breeding.power : 0;
          const delta = Math.abs(power - avgPower);
          if (delta < diff) {
            diff = delta;
            closest = p;
          }
        });
        return { baby: closest, avgPower };
      }

      function updateResult() {
        result.innerHTML = '';
        if (!parentState.parent1 || !parentState.parent2) {
          result.appendChild(makeEmptyMessage(kidMode ? 'Pick two pals to guess the baby.' : 'Select two parents to see the likely offspring.'));
          return;
        }
        const prediction = findPredictedBaby();
        const baby = prediction ? prediction.baby : null;
        const avgPower = prediction ? prediction.avgPower : 0;
        const flow = document.createElement('div');
        flow.className = 'breeding-flow';
        flow.appendChild(createPalCard(parentState.parent1, { compact: true, selectable: false }));
        const plus = document.createElement('div');
        plus.className = 'combo-arrow';
        plus.textContent = '+';
        flow.appendChild(plus);
        flow.appendChild(createPalCard(parentState.parent2, { compact: true, selectable: false }));
        const arrow = document.createElement('div');
        arrow.className = 'combo-arrow';
        arrow.textContent = '→';
        flow.appendChild(arrow);
        if (baby) {
          flow.appendChild(createPalCard(baby, { compact: true, selectable: false }));
        } else {
          const placeholder = document.createElement('div');
          placeholder.classList.add('empty-state');
          placeholder.textContent = kidMode ? 'Unknown baby' : 'No matching baby yet';
          flow.appendChild(placeholder);
        }
        result.appendChild(flow);
        const tip = document.createElement('p');
        tip.className = 'breeding-tip';
        if (baby) {
          const babyPower = baby && baby.breeding && typeof baby.breeding.power === 'number' ? baby.breeding.power : 'Unknown';
          tip.innerHTML = kidMode
            ? `This pair is most likely to make <strong>${baby.name}</strong>. Pop a Cake into the box before you leave.`
            : `The parents average to breeding power ${avgPower}. That lines up closest with <strong>${baby.name}</strong> (Power ${babyPower}). Drop a Cake in the box to start incubation.`;
          result.appendChild(tip);
          const combosBtn = document.createElement('button');
          combosBtn.type = 'button';
          combosBtn.className = 'breeding-combo-link';
          combosBtn.textContent = kidMode ? 'Show how to make this pal' : 'See breeding combinations';
          combosBtn.addEventListener('click', () => {
            if (!baby) return;
            selectedBaby = baby;
            updateBreedingSelection();
            babySearch.value = '';
            renderBabyGrid();
            showCombos();
            switchBreedingMode('breedingDiscover');
            playSound(clickSound);
          });
          result.appendChild(combosBtn);
        } else {
          tip.textContent = kidMode ? 'We do not know the baby for this pair yet.' : 'We could not find a pal that matches this breeding power. Try another combination!';
          result.appendChild(tip);
        }
      }

      function switchBreedingMode(targetId) {
        modes.forEach(mode => {
          const isActive = mode.id === targetId;
          mode.classList.toggle('active', isActive);
          mode.setAttribute('aria-hidden', isActive ? 'false' : 'true');
          mode.setAttribute('tabindex', isActive ? '0' : '-1');
        });
        modeButtons.forEach(btn => {
          const isActive = btn.dataset.target === targetId;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        BREEDING_SELECTION.mode = targetId;
      }

      const savedMode = BREEDING_SELECTION.mode || 'breedingPredict';
      const availableModes = modes.map(mode => mode.id);
      const initialMode = availableModes.includes(savedMode) ? savedMode : 'breedingPredict';

      modeButtons.forEach(btn => {
        btn.onclick = () => {
          const target = btn.dataset.target;
          switchBreedingMode(target);
          playSound(clickSound);
        };
      });

      parent1Search.oninput = () => renderParentGrid('parent1');
      parent2Search.oninput = () => renderParentGrid('parent2');
      babySearch.oninput = () => renderBabyGrid();

      updateParentGrids();
      renderBabyGrid();
      showCombos();
      updateResult();
      switchBreedingMode(initialMode);
      updateBreedingSelection();
    }

    // Home page builder.  Highlights the two presentation modes,
    // shows quick progress snapshots, and surfaces the next pal to
    // recruit so returning players know where to jump in.
    function buildHomePage() {
      const home = document.getElementById('homeCards');
      if (!home) return;
      home.innerHTML = '';

      function createModeCard(mode) {
        const card = document.createElement('article');
        card.className = 'mode-card';
        card.dataset.modeCard = mode;

        const status = document.createElement('span');
        status.className = 'mode-card__status';
        status.textContent = mode === 'kid' ? 'Kid Mode' : 'Grown-up Mode';
        card.appendChild(status);

        const title = document.createElement('h3');
        title.textContent = mode === 'kid' ? 'Kid Mode' : 'Grown-up Mode';
        card.appendChild(title);

        const desc = document.createElement('p');
        desc.textContent = mode === 'kid'
          ? 'Friendly wording and bigger buttons keep younger Trainers confident.'
          : 'Detailed strategy notes and numbers help planners and older players.';
        card.appendChild(desc);

        const features = document.createElement('ul');
        features.className = 'mode-card__features';
        const featureLines = mode === 'kid'
          ? [
              'Simple step-by-step guide language.',
              'Larger tap targets and softer colours.',
              'Encouraging reminders instead of jargon.'
            ]
          : [
              'Expanded boss tips and resource callouts.',
              'Full material lists for every unlock.',
              'Extra context for breeding and combat choices.'
            ];
        featureLines.forEach(line => {
          const li = document.createElement('li');
          li.textContent = line;
          features.appendChild(li);
        });
        card.appendChild(features);

        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn mode-card__button';
        button.dataset.modeChoice = mode;
        button.textContent = mode === 'kid' ? 'Use Kid Mode' : 'Use Grown-up Mode';
        button.addEventListener('click', () => {
          const desired = mode === 'kid';
          const requiresRebuild = kidMode !== desired;
          setKidMode(desired, { rebuild: requiresRebuild });
          playSound(clickSound);
          switchPage('home');
        });
        card.appendChild(button);

        return card;
      }

      function createProgressCard(type) {
        const card = document.createElement('article');
        card.className = 'home-progress-card';

        const header = document.createElement('div');
        header.className = 'home-progress-card__header';
        const iconWrap = document.createElement('div');
        iconWrap.className = 'home-progress-card__icon';
        const icon = document.createElement('i');
        icon.className = 'fa-solid fa-compass';
        iconWrap.appendChild(icon);
        header.appendChild(iconWrap);

        const headerText = document.createElement('div');
        const title = document.createElement('h3');
        const subtitle = document.createElement('p');

        const meter = document.createElement('div');
        meter.className = 'home-progress-meter';
        meter.setAttribute('role', 'progressbar');
        meter.setAttribute('aria-valuemin', '0');
        meter.setAttribute('aria-valuemax', '100');
        meter.setAttribute('aria-valuenow', '0');
        const fill = document.createElement('div');
        fill.className = 'fill';
        const progressText = document.createElement('div');
        progressText.className = 'home-progress-text';
        progressText.setAttribute('aria-live', 'polite');
        const nextButton = document.createElement('button');
        nextButton.type = 'button';
        nextButton.className = 'home-progress-link home-progress-next';
        nextButton.disabled = true;
        const actions = document.createElement('div');
        actions.className = 'home-progress-actions';
        const actionBtn = document.createElement('button');
        actionBtn.type = 'button';
        actionBtn.className = 'btn';

        if (type === 'route') {
          icon.className = 'fa-solid fa-map-location-dot';
          title.textContent = kidMode ? 'Family Route Guide' : 'Story Route Guide';
          subtitle.textContent = kidMode
            ? 'Track tower goals and chapter steps together.'
            : 'See required steps before tackling the next boss.';
          meter.id = 'homeRouteProgressMeter';
          meter.setAttribute('aria-label', 'Route guide progress');
          fill.id = 'homeRouteProgressBar';
          progressText.id = 'homeRouteProgressText';
          nextButton.id = 'homeRouteNextStep';
          nextButton.textContent = kidMode ? 'Loading next guide step…' : 'Loading next guide step…';
          nextButton.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open the guide' : 'Open route guide';
          actionBtn.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
        } else if (type === 'pals') {
          icon.className = 'fa-solid fa-paw';
          title.textContent = kidMode ? 'Pal Squad Tracker' : 'Pal collection';
          subtitle.textContent = kidMode
            ? 'Mark pals as caught and celebrate new friends.'
            : 'See how many pals you have registered so far.';
          meter.id = 'homePalsProgressMeter';
          meter.setAttribute('aria-label', 'Pal collection progress');
          fill.id = 'homePalsProgressBar';
          progressText.id = 'homePalsProgressText';
          nextButton.id = 'homePalsNext';
          nextButton.textContent = kidMode ? 'Loading pal reminder…' : 'Loading pal reminder…';
          nextButton.addEventListener('click', () => {
            const palId = nextButton.dataset.palId;
            if (palId && PALS[palId]) {
              showPalDetail(palId);
            } else {
              switchPage('pals');
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open pal list' : 'Go to pal tracker';
          actionBtn.addEventListener('click', () => {
            switchPage('pals');
            playSound(clickSound);
          });
        } else {
          icon.className = 'fa-solid fa-screwdriver-wrench';
          title.textContent = kidMode ? 'Workshop Technology' : 'Technology progress';
          subtitle.textContent = kidMode
            ? 'Peek at what inventions are still locked.'
            : 'Review how many blueprints remain.';
          meter.id = 'homeTechProgressMeter';
          meter.setAttribute('aria-label', 'Technology progress');
          fill.id = 'homeTechProgressBar';
          progressText.id = 'homeTechProgressText';
          nextButton.id = 'homeTechNext';
          nextButton.textContent = kidMode ? 'Loading tech reminder…' : 'Loading tech reminder…';
          nextButton.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open tech tree' : 'View tech tree';
          actionBtn.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
        }

        headerText.appendChild(title);
        headerText.appendChild(subtitle);
        header.appendChild(headerText);
        card.appendChild(header);

        meter.appendChild(fill);
        card.appendChild(meter);
        progressText.textContent = kidMode ? 'Loading progress…' : 'Loading progress…';
        card.appendChild(progressText);
        nextButton.disabled = true;
        card.appendChild(nextButton);
        actions.appendChild(actionBtn);
        card.appendChild(actions);
        return card;
      }

      const hero = document.createElement('section');
      hero.className = 'home-hero';
      const intro = document.createElement('div');
      intro.className = 'home-hero__intro';
      intro.innerHTML = kidMode
        ? '<h3>Choose how you play tonight</h3><p>Kid Mode keeps directions bright and simple, while grown-up mode adds the deeper strategy notes adults crave.</p>'
        : '<h3>Two presentation styles for your crew</h3><p>Flip between Kid Mode for gentle guidance or Grown-up Mode for detailed callouts. Change it anytime and the whole guide updates instantly.</p>';
      hero.appendChild(intro);
      const modeGrid = document.createElement('div');
      modeGrid.className = 'mode-callouts';
      modeGrid.appendChild(createModeCard('kid'));
      modeGrid.appendChild(createModeCard('grown'));
      hero.appendChild(modeGrid);
      home.appendChild(hero);

      const progressSection = document.createElement('section');
      progressSection.className = 'home-progress';
      const progressHeader = document.createElement('div');
      progressHeader.className = 'home-section-header';
      progressHeader.innerHTML = kidMode
        ? '<h3>Where you left off</h3><p>Check the guide, your pal roster, and the workshop meter before diving back in.</p>'
        : '<h3>Continue your journey</h3><p>Quick status bars show route progress, pal collection, and technology unlocks at a glance.</p>';
      progressSection.appendChild(progressHeader);
      const progressGrid = document.createElement('div');
      progressGrid.className = 'home-progress-grid';
      progressGrid.appendChild(createProgressCard('route'));
      progressGrid.appendChild(createProgressCard('pals'));
      progressGrid.appendChild(createProgressCard('tech'));
      progressSection.appendChild(progressGrid);
      home.appendChild(progressSection);

      const spotlight = document.createElement('section');
      spotlight.className = 'home-spotlight';
      const spotlightHeader = document.createElement('div');
      spotlightHeader.className = 'home-section-header';
      spotlightHeader.innerHTML = kidMode
        ? '<h3>Pal spotlight</h3><p>Here’s a pal to chase down next based on your progress.</p>'
        : '<h3>Pal spotlight</h3><p>Use this reminder to see who you should recruit or train next.</p>';
      spotlight.appendChild(spotlightHeader);
      const spotlightBtn = document.createElement('button');
      spotlightBtn.type = 'button';
      spotlightBtn.className = 'home-spotlight-card';
      spotlightBtn.id = 'homePalSpotlight';
      spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Loading pal…</span><span class="home-spotlight-card__meta">We’ll suggest a buddy soon.</span></div>';
      spotlightBtn.addEventListener('click', () => {
        const palId = spotlightBtn.dataset.palId;
        if (palId && PALS[palId]) {
          showPalDetail(palId);
        } else {
          switchPage('pals');
        }
        playSound(clickSound);
      });
      spotlight.appendChild(spotlightBtn);
      home.appendChild(spotlight);

      refreshModeUI();
    }

    const ROUTE_STORAGE_KEY = 'palmarathon:route:v1';
    let routeGuideData = null;
    let routeState = loadRouteState();
    let routeHideOptional = false;
    let pendingRouteFocus = null;
    let pendingTechFocus = null;

    function rebuildTechLookup(){
      TECH_LOOKUP = {};
      (Array.isArray(TECH) ? TECH : []).forEach(level => {
        if(!level || !Array.isArray(level.items)) return;
        level.items.forEach(item => {
          if(!item) return;
          const identifiers = [];
          if(item.id) identifiers.push(item.id);
          if(item.name) identifiers.push(item.name);
          identifiers.forEach(identifier => {
            const slug = slugifyForPalworld(String(identifier));
            if(slug){
              TECH_LOOKUP[slug] = { item, level };
            }
          });
        });
      });
    }

    function ensureRouteGuide(){
      if(routeGuideData){
        return Promise.resolve(routeGuideData);
      }
      return fetch('data/route.chapters.json')
        .then(res => {
          if(!res.ok){ throw new Error(`HTTP ${res.status}`); }
          return res.json();
        })
        .then(json => {
          routeGuideData = json;
          return routeGuideData;
        })
        .catch(err => {
          console.error('Failed to load route guide', err);
          routeGuideData = { chapters: [] };
          return routeGuideData;
        });
    }

    function routeChapterTitle(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.titleKid || chapter.title || '') : (chapter.title || chapter.titleKid || '');
    }

    function routeChapterWhy(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.whyKid || chapter.why || '') : (chapter.why || chapter.whyKid || '');
    }

    function routeStepText(step){
      if(!step) return '';
      if(!kidMode && step.textAdult) return step.textAdult;
      return kidMode ? (step.textKid || step.text || '') : (step.text || step.textKid || '');
    }

    function routeOptionalToggleLabel(hidden){
      if(kidMode){
        return hidden ? 'Show bonus steps' : 'Hide bonus steps';
      }
      return hidden ? 'Show Optional' : 'Hide Optional';
    }

    function renderRouteGuide(){
      ensureRouteGuide().then(guide => {
        const node = document.getElementById('routePage');
        if(!node) return;
        const chapters = Array.isArray(guide.chapters) ? guide.chapters : [];
        if(!chapters.length){
          node.innerHTML = '<section class="card"><h2>Boss Route & Progress</h2><p>Route data unavailable.</p></section>';
          return;
        }
        routeState = loadRouteState();
        node.innerHTML = `
          <section class="card">
            <h2>Boss Route & Progress</h2>
            <p>Work through each chapter. Check off steps as you do them. <em>Optional</em> steps don’t block completion.</p>
            <div class="badges" style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px">
              <button class="btn" id="toggleOptional">${routeOptionalToggleLabel(routeHideOptional)}</button>
            </div>
          </section>
          <div id="routeChapters"></div>
        `;
        const wrap = node.querySelector('#routeChapters');
        chapters.forEach((ch, idx) => {
          wrap.appendChild(renderChapterCard(ch, idx === 0));
        });

        wrap.addEventListener('change', handleRouteCheckboxChange);
        wrap.addEventListener('click', handleRouteClick);

        const toggleBtn = node.querySelector('#toggleOptional');
        if(toggleBtn){
          toggleBtn.onclick = () => {
            routeHideOptional = !routeHideOptional;
            toggleBtn.textContent = routeOptionalToggleLabel(routeHideOptional);
            chapters.forEach(ch => rerenderChapter(ch));
          };
        }
        applyQueuedRouteFocus();
        updateProgressUI();
      });
    }

    function queueRouteFocus(stepId){
      if(!stepId){
        pendingRouteFocus = null;
        return;
      }
      pendingRouteFocus = stepId;
      setTimeout(applyQueuedRouteFocus, 0);
    }

    function applyQueuedRouteFocus(){
      if(!pendingRouteFocus) return;
      const routePage = document.getElementById('routePage');
      if(!routePage) return;
      const target = routePage.querySelector(`input[data-step="${pendingRouteFocus}"]`);
      if(!target) return;
      const stepId = pendingRouteFocus;
      pendingRouteFocus = null;
      requestAnimationFrame(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const label = target.closest('.step');
        if(label) pulse(label);
        if(typeof target.focus === 'function'){
          try {
            target.focus({ preventScroll: true });
          } catch (err) {
            target.focus();
          }
        }
      });
    }

    function renderChapterCard(chapter, openByDefault){
      const section = document.createElement('section');
      section.className = 'card';
      section.id = `chapter-${chapter.id}`;
      const progress = chapterProgress(chapter);
      section.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap">
          <div>
            <h3 style="margin:0">${escapeHTML(routeChapterTitle(chapter))}</h3>
            <p style="margin:.25rem 0;color:var(--muted)">${escapeHTML(routeChapterWhy(chapter))}</p>
          </div>
          <div style="min-width:220px">${renderProgress(progress)}</div>
        </div>
        <details ${openByDefault ? 'open' : ''}>
          <summary class="btn" style="margin-top:8px">Open steps</summary>
          ${renderSteps(chapter)}
          <div style="display:flex;gap:8px;margin-top:12px">
            <button class="btn" data-action="markRequired" data-ch="${chapter.id}">Mark Required Complete</button>
            <button class="btn" data-action="resetChapter" data-ch="${chapter.id}">Reset Chapter</button>
            ${progress.requiredDone ? '<span style="margin-left:auto">✅ Chapter Complete</span>' : ''}
          </div>
        </details>
      `;
      return section;
    }

    function rerenderChapter(chapter){
      const node = document.querySelector(`#chapter-${chapter.id}`);
      if(!node) return;
      const wasOpen = node.querySelector('details')?.open;
      const progress = chapterProgress(chapter);
      node.innerHTML = `
        <div style="display:flex;align-items:center;gap:12px;justify-content:space-between;flex-wrap:wrap">
          <div>
            <h3 style="margin:0">${escapeHTML(routeChapterTitle(chapter))}</h3>
            <p style="margin:.25rem 0;color:var(--muted)">${escapeHTML(routeChapterWhy(chapter))}</p>
          </div>
          <div style="min-width:220px">${renderProgress(progress)}</div>
        </div>
        <details ${wasOpen ? 'open' : ''}>
          <summary class="btn" style="margin-top:8px">Open steps</summary>
          ${renderSteps(chapter)}
          <div style="display:flex;gap:8px;margin-top:12px">
            <button class="btn" data-action="markRequired" data-ch="${chapter.id}">Mark Required Complete</button>
            <button class="btn" data-action="resetChapter" data-ch="${chapter.id}">Reset Chapter</button>
            ${progress.requiredDone ? '<span style="margin-left:auto">✅ Chapter Complete</span>' : ''}
          </div>
        </details>
      `;
    }

    async function handleRouteCheckboxChange(event){
      const target = event.target;
      if(!target.matches('input[type="checkbox"][data-step]')) return;
      const stepId = target.dataset.step;
      const isChecked = target.checked;
      const chapterNode = target.closest('section.card');
      let chapter = null;
      let step = null;
      if(chapterNode){
        const chapterId = chapterNode.id.replace('chapter-','');
        chapter = (routeGuideData?.chapters || []).find(ch => ch.id === chapterId) || null;
        if(chapter){
          step = (chapter.steps || []).find(s => s.id === stepId) || null;
        }
      }
      if(isChecked && step){
        const options = buildStepProgressOptions(step);
        if(options.length > 1){
          const selection = await showStepChoiceDialog(step, options);
          if(selection === null){
            target.checked = false;
            return;
          }
          applyStepProgressSelection(options, selection);
        } else if(options.length === 1){
          applyStepProgressSelection(options, [options[0].key]);
        }
      }
      routeState[stepId] = isChecked;
      saveRouteState(routeState);
      if(chapter){
        rerenderChapter(chapter);
      }
      updateProgressUI();
    }

    function handleRouteClick(event){
      const link = event.target.closest('[data-link]');
      if(link){
        const payload = JSON.parse(link.dataset.link);
        navigateLink(payload);
        event.preventDefault();
        return;
      }
      const btn = event.target.closest('button[data-action]');
      if(!btn) return;
      const chapterId = btn.dataset.ch;
      const chapter = (routeGuideData?.chapters || []).find(ch => ch.id === chapterId);
      if(!chapter) return;
      if(btn.dataset.action === 'markRequired'){
        chapter.steps.filter(step => !step.optional).forEach(step => {
          routeState[step.id] = true;
          const options = buildStepProgressOptions(step);
          if(options.length === 1){
            applyStepProgressSelection(options, [options[0].key]);
          }
        });
        saveRouteState(routeState);
        rerenderChapter(chapter);
        updateProgressUI();
      } else if(btn.dataset.action === 'resetChapter'){
        chapter.steps.forEach(step => {
          delete routeState[step.id];
        });
        saveRouteState(routeState);
        rerenderChapter(chapter);
        updateProgressUI();
      }
    }

    function renderSteps(chapter){
      const fragments = [];
      (chapter.steps || []).forEach(step => {
        if(routeHideOptional && step.optional) return;
        const checked = !!routeState[step.id];
        const category = step.category || 'Task';
        const categorySlug = category.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || 'task';
        fragments.push(`
          <label class="step ${step.optional ? 'optional' : ''}">
            <input type="checkbox" data-step="${step.id}" ${checked ? 'checked' : ''} />
            <span class="step-meta">
              <span class="step-category step-category--${categorySlug}">${escapeHTML(category)}</span>
              <span class="step-text">${escapeHTML(routeStepText(step))} ${step.optional ? '<em>(Optional)</em>' : ''}</span>
            </span>
            ${renderLinks(step.links || [])}
          </label>
        `);
      });
      if(!fragments.length) return '';
      return `<div class="step-list">${fragments.join('')}</div>`;
    }

    function buildStepProgressOptions(step){
      if(!step || !Array.isArray(step.links)) return [];
      const options = [];
      const seen = new Set();
      step.links.forEach(link => {
        if(!link || !link.type) return;
        if(link.type === 'pal'){
          const palId = resolvePalIdFromLink(link);
          if(palId !== undefined && palId !== null){
            const key = `pal:${palId}`;
            if(!seen.has(key)){
              seen.add(key);
              const pal = PALS[palId];
              const labelSource = link.name || link.slug || link.id;
              options.push({
                key,
                type: 'pal',
                palId,
                label: pal ? pal.name : (labelSource ? niceName(labelSource) : 'Pal'),
                selected: !!caught[palId]
              });
            }
          }
        } else if(link.type === 'tech'){
          const techInfo = resolveTechFromLink(link);
          if(techInfo && techInfo.item){
            const key = `tech:${techInfo.slug}`;
            if(!seen.has(key)){
              seen.add(key);
              const rawName = techInfo.item.name || link.name || link.id;
              const techName = rawName ? String(rawName) : '';
              const label = rawName ? String(rawName) : 'Tech';
              options.push({
                key,
                type: 'tech',
                slug: techInfo.slug,
                techName,
                label,
                selected: techName ? !!unlocked[techName] : false
              });
            }
          }
        }
      });
      return options;
    }

    function resolvePalIdFromLink(link){
      if(!link) return null;
      if(link.id && PALS[link.id]) return link.id;
      const candidates = [link.slug, link.id, link.name];
      for(const cand of candidates){
        if(!cand) continue;
        const slug = slugifyForPalworld(String(cand));
        if(slug && PAL_SLUG_TO_ID[slug]) return PAL_SLUG_TO_ID[slug];
        const byName = PAL_NAME_TO_ID[capitalize(String(cand))];
        if(byName) return byName;
      }
      return null;
    }

    function resolveTechFromLink(link){
      if(!link) return null;
      const identifiers = [link.id, link.slug, link.name];
      for(const ident of identifiers){
        if(!ident) continue;
        const slug = slugifyForPalworld(String(ident));
        if(slug && TECH_LOOKUP[slug]){
          return { ...TECH_LOOKUP[slug], slug };
        }
      }
      return null;
    }

    function applyStepProgressSelection(options, selectedKeys){
      if(!Array.isArray(options) || !options.length) return false;
      const selected = new Set(selectedKeys || []);
      let caughtChanged = false;
      let techChanged = false;
      options.forEach(option => {
        const isSelected = selected.has(option.key);
        if(option.type === 'pal' && option.palId !== undefined && option.palId !== null){
          if(caught[option.palId] !== isSelected){
            caught[option.palId] = isSelected;
            caughtChanged = true;
            syncPalButtons(option.palId);
          }
        } else if(option.type === 'tech'){
          const techName = option.techName;
          if(techName && unlocked[techName] !== isSelected){
            unlocked[techName] = isSelected;
            techChanged = true;
            if(option.slug) syncTechButtons(option.slug, techName);
          } else if(option.slug){
            syncTechButtons(option.slug, techName);
          }
        }
      });
      if(caughtChanged){
        localStorage.setItem('caught', JSON.stringify(caught));
      }
      if(techChanged){
        localStorage.setItem('unlocked', JSON.stringify(unlocked));
      }
      return caughtChanged || techChanged;
    }

    function autoCompleteRouteStepsForPal(palId){
      if(palId === undefined || palId === null) return;
      autoCompleteRouteSteps({ type: 'pal', palId });
    }

    function autoCompleteRouteStepsForTech(rawKey, techName){
      const slugSource = rawKey || techName;
      if(!slugSource && !techName) return;
      const slug = slugifyForPalworld(slugSource || '');
      const name = typeof techName === 'string' ? techName.toLowerCase() : '';
      autoCompleteRouteSteps({ type: 'tech', slug, name });
    }

    function autoCompleteRouteSteps(change){
      if(!change) return;
      ensureRouteGuide()
        .then(guide => {
          const chapters = Array.isArray(guide?.chapters) ? guide.chapters : [];
          if(!chapters.length) return;
          routeState = loadRouteState();
          const rerenderIds = new Set();
          let stateChanged = false;

          chapters.forEach(chapter => {
            const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
            steps.forEach(step => {
              if(!step || !step.id) return;
              const options = buildStepProgressOptions(step);
              if(!Array.isArray(options) || !options.length) return;
              const matches = options.some(option => {
                if(change.type === 'pal'){
                  return option.type === 'pal' && option.palId === change.palId;
                }
                if(change.type === 'tech'){
                  if(option.type !== 'tech') return false;
                  const slugMatch = change.slug && option.slug === change.slug;
                  const nameMatch = change.name && option.techName && option.techName.toLowerCase() === change.name;
                  return slugMatch || nameMatch;
                }
                return false;
              });
              if(!matches) return;
              if(shouldAutoCompleteStep(step, options) && !routeState[step.id]){
                routeState[step.id] = true;
                stateChanged = true;
                rerenderIds.add(chapter.id);
              }
            });
          });

          if(stateChanged){
            saveRouteState(routeState);
            rerenderIds.forEach(id => {
              const chapter = chapters.find(ch => ch.id === id);
              if(chapter) rerenderChapter(chapter);
            });
            updateProgressUI();
          }
        })
        .catch(err => {
          console.error('Failed to auto-sync route progress', err);
        });
    }

    function shouldAutoCompleteStep(step, options){
      if(!step || !Array.isArray(options) || !options.length) return false;
      const relevant = options.filter(option => option.type === 'pal' || option.type === 'tech');
      if(!relevant.length) return false;
      const satisfiedCount = relevant.filter(optionIsComplete).length;
      if(satisfiedCount === 0) return false;
      if(stepRequiresAllOptions(step, relevant)){
        return satisfiedCount === relevant.length;
      }
      return true;
    }

    function stepRequiresAllOptions(step, options){
      if(!Array.isArray(options) || options.length <= 1) return true;
      const samples = [];
      if(typeof step.text === 'string') samples.push(step.text);
      if(typeof step.textKid === 'string') samples.push(step.textKid);
      if(typeof step.textAdult === 'string') samples.push(step.textAdult);
      const orPattern = /\b(or|either)\b/i;
      return !samples.some(sample => orPattern.test(sample));
    }

    function optionIsComplete(option){
      if(!option) return false;
      if(option.type === 'pal'){
        return option.palId !== undefined && option.palId !== null && !!caught[option.palId];
      }
      if(option.type === 'tech'){
        if(option.techName){
          const direct = unlocked[option.techName];
          if(direct) return true;
          const normalized = option.techName.toLowerCase();
          if(normalized){
            const match = Object.keys(unlocked || {}).some(key => {
              return unlocked[key] && typeof key === 'string' && key.toLowerCase() === normalized;
            });
            if(match) return true;
          }
        }
        if(option.slug){
          const entry = TECH_LOOKUP && TECH_LOOKUP[option.slug];
          const itemName = entry?.item?.name;
          if(itemName && unlocked[itemName]) return true;
        }
      }
      return false;
    }

    function showStepChoiceDialog(step, options){
      return new Promise(resolve => {
        if(!Array.isArray(options) || !options.length){
          resolve([]);
          return;
        }
        const overlay = document.createElement('div');
        overlay.className = 'progress-choice-backdrop';
        const dialog = document.createElement('div');
        dialog.className = 'progress-choice-dialog';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? 'Pick what you finished' : 'Track this step';
        dialog.appendChild(heading);
        if(step && step.text){
          const stepLine = document.createElement('p');
          stepLine.textContent = step.text;
          stepLine.style.fontStyle = 'italic';
          stepLine.style.color = 'var(--light)';
          dialog.appendChild(stepLine);
        }
        const desc = document.createElement('p');
        desc.textContent = kidMode
          ? 'Choose the pals or inventions you just completed. Uncheck anything you skipped.'
          : 'Select which pals or tech you completed. Uncheck anything you skipped.';
        dialog.appendChild(desc);
        const list = document.createElement('div');
        list.className = 'progress-choice-options';
        const checkboxes = [];
        options.forEach(option => {
          const row = document.createElement('label');
          row.className = 'progress-choice-option';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = option.key;
          input.checked = !!option.selected;
          row.appendChild(input);
          const text = document.createElement('span');
          text.textContent = option.label;
          row.appendChild(text);
          list.appendChild(row);
          checkboxes.push(input);
        });
        dialog.appendChild(list);
        if(options.length > 1){
          const helpers = document.createElement('div');
          helpers.className = 'progress-choice-helpers';
          const selectAllBtn = document.createElement('button');
          selectAllBtn.type = 'button';
          selectAllBtn.className = 'btn';
          selectAllBtn.textContent = kidMode ? 'Select everything' : 'Select all';
          selectAllBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = true;
            });
          });
          const clearBtn = document.createElement('button');
          clearBtn.type = 'button';
          clearBtn.className = 'btn';
          clearBtn.textContent = kidMode ? 'Clear choices' : 'Clear';
          clearBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = false;
            });
          });
          helpers.appendChild(selectAllBtn);
          helpers.appendChild(clearBtn);
          dialog.appendChild(helpers);
        }
        const actions = document.createElement('div');
        actions.className = 'progress-choice-actions';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'btn';
        cancelBtn.textContent = kidMode ? 'Go back' : 'Cancel';
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'btn';
        saveBtn.textContent = kidMode ? 'All done!' : 'Save choices';
        actions.appendChild(cancelBtn);
        actions.appendChild(saveBtn);
        dialog.appendChild(actions);
        overlay.appendChild(dialog);
        overlay.addEventListener('click', (ev) => {
          if(ev.target === overlay){
            cleanup(null);
          }
        });
        const cleanup = (result) => {
          overlay.remove();
          document.removeEventListener('keydown', onKeydown);
          resolve(result);
        };
        cancelBtn.addEventListener('click', () => cleanup(null));
        saveBtn.addEventListener('click', () => {
          const selectedValues = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
          cleanup(selectedValues);
        });
        const onKeydown = (ev) => {
          if(ev.key === 'Escape'){
            ev.preventDefault();
            cleanup(null);
          }
          if(ev.key === 'Enter' && ev.target && ev.target.tagName !== 'TEXTAREA'){
            ev.preventDefault();
            saveBtn.click();
          }
        };
        document.addEventListener('keydown', onKeydown);
        document.body.appendChild(overlay);
        setTimeout(() => {
          if(checkboxes.length){
            checkboxes[0].focus();
          } else {
            saveBtn.focus();
          }
        }, 0);
      });
    }

    function chapterProgress(chapter){
      const required = (chapter.steps || []).filter(step => !step.optional);
      const requiredChecked = required.filter(step => routeState[step.id]).length;
      return {
        requiredCount: required.length,
        requiredChecked,
        requiredDone: required.length > 0 && requiredChecked === required.length
      };
    }

    function renderProgress(progress){
      const pct = progress.requiredCount ? Math.round((progress.requiredChecked / progress.requiredCount) * 100) : 0;
      const label = kidMode
        ? `${progress.requiredChecked}/${progress.requiredCount} steps done (${pct}%)`
        : `${progress.requiredChecked}/${progress.requiredCount} required done (${pct}%)`;
      return `
        <div class="progress" aria-label="Chapter progress" style="display:grid;gap:6px">
          <div style="height:10px;border-radius:999px;background:#22314A;overflow:hidden">
            <div style="height:10px;width:${pct}%;background:var(--accent)"></div>
          </div>
          <div style="font-size:.9rem;color:var(--muted)">${label}</div>
        </div>
      `;
    }

    function calculateGuideProgressSummary(){
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      let requiredTotal = 0;
      let requiredComplete = 0;
      let towersTotal = 0;
      let towersComplete = 0;
      chapters.forEach(chapter => {
        const progress = chapterProgress(chapter);
        requiredTotal += progress.requiredCount;
        requiredComplete += progress.requiredChecked;
        (chapter.steps || []).forEach(step => {
          if(step?.category === 'Boss'){
            towersTotal += 1;
            if(routeState[step.id]) towersComplete += 1;
          }
        });
      });
      const percent = requiredTotal ? Math.round((requiredComplete / requiredTotal) * 100) : 0;
      return { requiredTotal, requiredComplete, towersTotal, towersComplete, percent };
    }

    function findNextRouteStep(options = {}){
      const includeOptional = !!options.includeOptional;
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
        for(const step of steps){
          if(step.optional && !includeOptional) continue;
          if(!routeState[step.id]){
            return { chapter, step };
          }
        }
      }
      return null;
    }

    function findNextPalTarget(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const sorted = palsArray.slice().sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      const next = sorted.find(pal => !caught[pal.id]);
      return next || null;
    }

    function findRandomPalCandidate(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const accessible = palsArray.filter(p => (p.rarity || 0) <= 3);
      const pool = accessible.length ? accessible : palsArray;
      return pool[Math.floor(Math.random() * pool.length)] || null;
    }

    function findNextTechUnlock(){
      const levels = Array.isArray(TECH)
        ? TECH.slice().sort((a, b) => (a?.level || 0) - (b?.level || 0))
        : [];
      for(const level of levels){
        const items = Array.isArray(level?.items) ? level.items : [];
        for(const item of items){
          if(!item || !item.name) continue;
          if(!unlocked[item.name]){
            const techKey = item.id || slugifyForPalworld(item.name);
            return { level, item, techKey };
          }
        }
      }
      return null;
    }

    function renderLinks(links){
      if(!links || !links.length) return '';
      return `<span class="badges">${links.map(link => {
        const payload = JSON.stringify(link).replace(/"/g, '&quot;');
        return `<a href="#" class="chip link" data-link="${payload}" role="button">${escapeHTML(linkLabel(link))}</a>`;
      }).join('')}</span>`;
    }

    function linkLabel(link){
      if(link.type === 'pal') return capitalize(link.slug);
      if(link.type === 'item') return niceName(link.id);
      if(link.type === 'passive') return capitalize(link.id);
      if(link.type === 'move') return niceName(link.id);
      if(link.type === 'tech') return niceName(link.id);
      if(link.type === 'glossary') return niceName(link.id);
      if(link.type === 'tower') return niceName(link.id);
      return 'Open';
    }

    function navigateLink(link){
      if(!link) return;
      if(link.type === 'pal'){
        if(window.viewPal){
          window.viewPal(link.slug || link.id);
        } else {
          focusSearch(link.slug || link.id);
        }
      } else if(link.type === 'item'){
        const itemKey = link.id || link.slug;
        if(itemKey && ITEMS[itemKey]){
          openItemDetail(itemKey);
        } else {
          focusSearch(itemKey);
        }
      } else if(link.type === 'tech'){
        showTechDetail(link.id);
      } else if(link.type === 'passive'){
        showTraitDetail(capitalize(link.id));
      } else if(link.type === 'move'){
        showSkillDetail(link.id);
      } else if(link.type === 'glossary'){
        showGlossaryDetail(link.id);
      } else if(link.type === 'tower'){
        openTowerMap(link);
      }
    }

    function showTechDetail(techId){
      if(!techId) return;
      const slug = slugifyForPalworld(String(techId));
      const entry = TECH_LOOKUP[slug];
      const displayName = entry?.item?.name || niceName(techId);
      const safeName = escapeHTML(displayName);
      const techUrl = entry?.item?.url || `${PALWORLD_BASE_URL}/technology-tree?search=${encodeURIComponent(displayName)}`;
      const summaryParts = [];
      if(kidMode){
        summaryParts.push(`<p>Let's get <strong>${safeName}</strong> ready!</p>`);
      } else {
        summaryParts.push(`<p><strong>${safeName}</strong> quick reference.</p>`);
      }
      if(entry?.level?.level){
        summaryParts.push(`<p><strong>Tech Level:</strong> ${escapeHTML(String(entry.level.level))}</p>`);
      }
      if(entry?.item?.branch){
        summaryParts.push(`<p><strong>Branch:</strong> ${escapeHTML(String(entry.item.branch))}</p>`);
      }
      if(typeof entry?.item?.techPoints === 'number'){
        const label = entry.item.isAncient ? 'Ancient Tech Points' : 'Tech Points';
        summaryParts.push(`<p><strong>${label}:</strong> ${escapeHTML(String(entry.item.techPoints))}</p>`);
      }
      if(entry?.item?.materials && Object.keys(entry.item.materials).length){
        const materials = Object.entries(entry.item.materials)
          .map(([material, qty]) => `<li>${escapeHTML(`${qty} × ${material}`)}</li>`)
          .join('');
        if(materials){
          summaryParts.push(`<p>${kidMode ? 'You will need:' : 'Materials required:'}</p><ul>${materials}</ul>`);
        }
      }
      if(entry?.item?.description){
        summaryParts.push(`<p>${escapeHTML(entry.item.description)}</p>`);
      } else if(entry){
        summaryParts.push(`<p>${kidMode
          ? 'Check the Palworld.gg window for a picture and placement tips once you unlock it.'
          : 'Use the Palworld.gg panel for placement notes and unlock requirements.'}</p>`);
      } else {
        summaryParts.push(`<p>${kidMode
          ? 'Palmate will peek at Palworld.gg so you can see what it looks like without leaving this checklist.'
          : 'Palmate opens the Palworld.gg technology tree so you can confirm crafting details without changing pages.'}</p>`);
      }
      const note = entry
        ? 'Palmate keeps this tech guide handy so you can stay on the route checklist.'
        : 'Palmate opens the Palworld.gg technology tree while keeping your route progress on screen.';
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url: techUrl,
        fallbackUrl: techUrl,
        note,
        summaryHtml: summaryParts.join('')
      });
    }

    function showGlossaryDetail(identifier){
      if(!identifier) return;
      const key = String(identifier).toLowerCase();
      const entry = ROUTE_GLOSSARY_SUMMARIES[key];
      const displayName = entry?.title || niceName(identifier);
      const url = entry?.url || `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(displayName)}`;
      const note = entry?.note || 'Palmate keeps this glossary entry in a modal so you never lose your place.';
      const lines = entry
        ? (kidMode ? entry.kid : entry.grown)
        : [kidMode
          ? `Let's learn about ${displayName}. Palworld.gg will open beside your checklist so you can keep exploring.`
          : `Palmate is opening a Palworld.gg search for ${displayName} so you can review it without leaving the route.`];
      const summaryHtml = lines.map(text => `<p>${escapeHTML(text)}</p>`).join('');
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url,
        fallbackUrl: url,
        note,
        summaryHtml
      });
    }

    window.showTechDetail = showTechDetail;
    window.showGlossaryDetail = showGlossaryDetail;

    function pulse(el){
      el.classList.add('pulse');
      setTimeout(() => el.classList.remove('pulse'), 1500);
    }

    function focusSearch(term){
      const input = document.getElementById('palSearch') || document.getElementById('itemSearch');
      if(input){
        input.value = term;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    }

    function loadRouteState(){
      try {
        return JSON.parse(localStorage.getItem(ROUTE_STORAGE_KEY)) || {};
      } catch(err){
        console.warn('Failed to load route progress', err);
        return {};
      }
    }

    function saveRouteState(state){
      localStorage.setItem(ROUTE_STORAGE_KEY, JSON.stringify(state));
    }

    function escapeHTML(str){
      return (str || '').replace(/[&<>"']/g, ch => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch] || ch));
    }

    function capitalize(value){
      return (value || '').replace(/(^|[-_])\w/g, m => m.toUpperCase()).replace(/[-_]/g, ' ');
    }

    function niceName(id){
      return capitalize(String(id).replace(/_/g, ' '));
    }
    // with their descriptions.  Elements and work suitabilities are
    // summarised in organised sections with quick filters for faster lookup.
    function buildGlossaryPage() {
      const container = document.getElementById('glossaryContent');
      if (!container) return;
      container.innerHTML = '';

      const normalizedSkillDetails = {};
      Object.entries(SKILL_DETAILS || {}).forEach(([name, info = {}]) => {
        const normalizedKey = name.toLowerCase().replace(/[\s-]+/g, '_');
        normalizedSkillDetails[normalizedKey] = { name, ...info };
      });

      const nav = document.createElement('div');
      nav.className = 'glossary-nav';
      container.appendChild(nav);

      function createSection(id, title, description) {
        const section = document.createElement('section');
        section.className = 'glossary-section card';
        section.id = id;
        const heading = document.createElement('h3');
        heading.textContent = title;
        section.appendChild(heading);
        if (description) {
          const desc = document.createElement('p');
          desc.textContent = description;
          section.appendChild(desc);
        }
        container.appendChild(section);

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = title;
        btn.dataset.target = id;
        btn.setAttribute('aria-controls', id);
        btn.addEventListener('click', () => {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
        nav.appendChild(btn);

        return section;
      }

      function createSearch(placeholder) {
        const input = document.createElement('input');
        input.type = 'search';
        input.className = 'glossary-search';
        input.placeholder = placeholder;
        input.setAttribute('aria-label', placeholder);
        return input;
      }

      const elementsDescription = kidMode
        ? 'Check which elements pals are strong or weak against.'
        : 'Reference chart for attack advantages and resistances.';
      const elemSection = createSection('glossary-elements', 'Elements & Type Chart', elementsDescription);

      const typeRelations = {
        Neutral: { strong: [], weak: [] },
        Fire: { strong: ['Grass', 'Ice'], weak: ['Water', 'Ground'] },
        Water: { strong: ['Fire', 'Ground'], weak: ['Electric', 'Grass'] },
        Grass: { strong: ['Water', 'Ground'], weak: ['Fire', 'Ice', 'Air'] },
        Electric: { strong: ['Water', 'Air'], weak: ['Ground'] },
        Ice: { strong: ['Dragon', 'Grass'], weak: ['Fire', 'Electric'] },
        Ground: { strong: ['Electric', 'Fire'], weak: ['Water', 'Grass'] },
        Dragon: { strong: ['Dark', 'Dragon'], weak: ['Dragon', 'Ice'] },
        Dark: { strong: ['Neutral'], weak: ['Dragon'] },
        Air: { strong: ['Grass', 'Ground'], weak: ['Electric', 'Ice'] }
      };

      const typeColors = {
        Neutral: '#adb5c7',
        Fire: '#ff7247',
        Water: '#3ac7ff',
        Grass: '#6be67e',
        Electric: '#ffd166',
        Ice: '#8ee7ff',
        Ground: '#e0a15b',
        Dragon: '#c386ff',
        Dark: '#7e6bff',
        Air: '#81d3ff'
      };

      function toRGBString(hex) {
        if (!hex) return '154, 166, 198';
        const cleaned = hex.replace('#', '').trim();
        const normalized = cleaned.length === 3
          ? cleaned.split('').map(ch => ch + ch).join('')
          : (cleaned + '000000').slice(0, 6);
        const r = parseInt(normalized.slice(0, 2), 16);
        const g = parseInt(normalized.slice(2, 4), 16);
        const b = parseInt(normalized.slice(4, 6), 16);
        if ([r, g, b].some(num => Number.isNaN(num))) {
          return '154, 166, 198';
        }
        return `${r}, ${g}, ${b}`;
      }

      const typeColorRGB = {};
      Object.entries(typeColors).forEach(([type, color]) => {
        typeColorRGB[type] = toRGBString(color);
      });

      function getTypeIconSource(type) {
        const source = iconMap[type];
        if (typeof source === 'string' && source.trim().length) {
          return source;
        }
        return iconMap['Neutral'] || 'assets/icons/neutral.png';
      }

      const typeMapLayout = document.createElement('div');
      typeMapLayout.className = 'type-map-layout';
      elemSection.appendChild(typeMapLayout);

      const typeMap = document.createElement('div');
      typeMap.className = 'type-map';
      typeMapLayout.appendChild(typeMap);

      const svgNS = 'http://www.w3.org/2000/svg';
      const connections = document.createElementNS(svgNS, 'svg');
      connections.classList.add('type-map__connections');
      connections.setAttribute('viewBox', '0 0 100 100');
      connections.setAttribute('aria-hidden', 'true');

      const defs = document.createElementNS(svgNS, 'defs');
      const marker = document.createElementNS(svgNS, 'marker');
      marker.id = 'type-map-arrowhead';
      marker.setAttribute('viewBox', '0 0 10 10');
      marker.setAttribute('refX', '10');
      marker.setAttribute('refY', '5');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('orient', 'auto');
      const markerPath = document.createElementNS(svgNS, 'path');
      markerPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
      markerPath.setAttribute('fill', 'currentColor');
      marker.appendChild(markerPath);
      defs.appendChild(marker);
      connections.appendChild(defs);

      const connectionGroup = document.createElementNS(svgNS, 'g');
      connectionGroup.classList.add('type-map__link-group');
      connections.appendChild(connectionGroup);
      typeMap.appendChild(connections);

      const nodesLayer = document.createElement('div');
      nodesLayer.className = 'type-map__nodes';
      typeMap.appendChild(nodesLayer);

      const detailPanel = document.createElement('aside');
      detailPanel.className = 'type-map__detail';
      detailPanel.setAttribute('aria-live', 'polite');
      typeMapLayout.appendChild(detailPanel);

      const legend = document.createElement('p');
      legend.className = 'type-map__legend';
      legend.textContent = kidMode
        ? 'Follow the glowing arrows—each line shows which pals hit super hard!'
        : 'Arrows flow from the attacking element to the element it overwhelms.';
      elemSection.appendChild(legend);

      const orbitElements = Object.keys(typeRelations).filter(type => type !== 'Neutral');
      const nodePositions = {};
      const radius = 38;
      orbitElements.forEach((type, index) => {
        const angle = (index / orbitElements.length) * (Math.PI * 2) - Math.PI / 2;
        const x = 50 + radius * Math.cos(angle);
        const y = 50 + radius * Math.sin(angle);
        nodePositions[type] = { x, y };
      });
      nodePositions.Neutral = { x: 50, y: 50 };

      const links = [];

      function createPath(start, end) {
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const distance = Math.hypot(dx, dy) || 1;
        const offset = Math.min(12, distance / 3);
        const controlX = midX + (-dy / distance) * offset;
        const controlY = midY + (dx / distance) * offset;
        return `M ${start.x} ${start.y} Q ${controlX} ${controlY} ${end.x} ${end.y}`;
      }

      Object.entries(typeRelations).forEach(([source, info]) => {
        const start = nodePositions[source];
        if (!start) return;
        (info.strong || []).forEach(target => {
          if (target === source) return;
          const end = nodePositions[target];
          if (!end) return;
          const path = document.createElementNS(svgNS, 'path');
          path.classList.add('type-map__link');
          path.dataset.source = source;
          path.dataset.target = target;
          path.setAttribute('d', createPath(start, end));
          const color = typeColors[source] || '#f0f4f8';
          const rgb = typeColorRGB[source] || toRGBString(color);
          path.style.setProperty('--type-color', color);
          path.style.setProperty('--type-color-rgb', rgb);
          path.style.color = color;
          path.setAttribute('marker-end', 'url(#type-map-arrowhead)');
          connectionGroup.appendChild(path);
          links.push(path);
        });
      });

      const nodeButtons = [];

      function createNode(type) {
        const pos = nodePositions[type];
        if (!pos) return;
        const strong = (typeRelations[type] && typeRelations[type].strong) || [];
        const weak = (typeRelations[type] && typeRelations[type].weak) || [];
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'type-map__node';
        button.dataset.type = type;
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        button.style.setProperty('--type-color', color);
        button.style.setProperty('--type-color-rgb', rgb);
        button.style.setProperty('--type-x', `${pos.x}%`);
        button.style.setProperty('--type-y', `${pos.y}%`);
        button.setAttribute('aria-label', `${type} element: strong against ${strong.length ? strong.join(', ') : 'no elements'}; weak against ${weak.length ? weak.join(', ') : 'no elements'}`);
        button.setAttribute('aria-pressed', 'false');
        const iconSrc = getTypeIconSource(type);
        button.innerHTML = `
          <span class="type-map__node-ring"></span>
          <span class="type-map__node-visual">
            <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__node-icon" aria-hidden="true">
          </span>
          <span class="type-map__node-name">${escapeHTML(type)}</span>
          <span class="type-map__node-meta">
            <span class="type-map__node-pill type-map__node-pill--strong" title="${kidMode ? 'Number of elements you overpower' : 'Advantage count'}">${strong.length}</span>
            <span class="type-map__node-pill type-map__node-pill--weak" title="${kidMode ? 'Number of elements that overpower you' : 'Weakness count'}">${weak.length}</span>
          </span>
        `;
        button.addEventListener('click', () => selectType(type));
        nodesLayer.appendChild(button);
        nodeButtons.push(button);
      }

      Object.keys(typeRelations).forEach(createNode);

      function renderList(items, empty) {
        if (!items || items.length === 0) {
          return `<p class="type-map__detail-empty">${empty}</p>`;
        }
        return `
          <ul class="type-map__detail-list">
            ${items.map(item => `<li>${escapeHTML(item)}</li>`).join('')}
          </ul>
        `;
      }

      function selectType(type) {
        const info = typeRelations[type] || { strong: [], weak: [] };
        const strongSet = new Set(info.strong);
        const weakSet = new Set(info.weak);
        nodeButtons.forEach(btn => {
          const nodeType = btn.dataset.type;
          const isFocus = nodeType === type;
          btn.classList.toggle('type-map__node--focus', isFocus);
          btn.classList.toggle('type-map__node--ally', strongSet.has(nodeType));
          btn.classList.toggle('type-map__node--danger', weakSet.has(nodeType));
          btn.setAttribute('aria-pressed', isFocus ? 'true' : 'false');
        });
        links.forEach(path => {
          const fromSelected = path.dataset.source === type;
          const toSelected = path.dataset.target === type;
          path.classList.toggle('type-map__link--active', fromSelected);
          path.classList.toggle('type-map__link--incoming', toSelected);
          path.classList.toggle('type-map__link--dim', !fromSelected && !toSelected);
        });

        const strongLabel = kidMode ? 'Super Effective On' : 'Dominates';
        const weakLabel = kidMode ? 'Takes Big Damage From' : 'Vulnerable To';
        const noteText = kidMode
          ? 'Tap another element to see who it blasts or who blasts it.'
          : 'Select different nodes to trace optimal matchups and counters.';
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        const iconSrc = getTypeIconSource(type);
        detailPanel.style.setProperty('--type-color', color);
        detailPanel.style.setProperty('--type-color-rgb', rgb);
        detailPanel.innerHTML = `
          <header class="type-map__detail-header">
            <span class="type-map__detail-chip">
              <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__detail-icon" aria-hidden="true">
              ${escapeHTML(type)}
            </span>
            <span class="type-map__detail-sub">${info.strong.length} advantage${info.strong.length === 1 ? '' : 's'} • ${info.weak.length} weakness${info.weak.length === 1 ? '' : 'es'}</span>
          </header>
          <div class="type-map__detail-columns">
            <div>
              <h4>${strongLabel}</h4>
              ${renderList(info.strong, kidMode ? 'No super strengths.' : 'No direct advantages recorded.')}
            </div>
            <div>
              <h4>${weakLabel}</h4>
              ${renderList(info.weak, kidMode ? 'No big threats.' : 'No notable weaknesses recorded.')}
            </div>
          </div>
          <p class="type-map__detail-note">${noteText}</p>
        `;
      }

      selectType('Fire');

      const workDescription = kidMode
        ? 'These jobs tell you what pals can help with at base.'
        : 'Use these notes to decide which pals to station at each production line.';
      const workSection = createSection('glossary-work', 'Work Suitabilities', workDescription);
      const workLevelLabels = {
        5: kidMode ? 'Mythic helper' : 'Mythic specialist',
        4: kidMode ? 'Master helper' : 'Master specialist',
        3: kidMode ? 'Elite helper' : 'Expert artisan',
        2: kidMode ? 'Trained helper' : 'Skilled worker',
        1: kidMode ? 'Rookie helper' : 'Apprentice',
        0: kidMode ? 'Needs practice' : 'Untrained'
      };

      const tierLookup = {
        5: { badge: 'SS', className: 'work-tier-badge work-tier-badge--ss' },
        4: { badge: 'S', className: 'work-tier-badge work-tier-badge--s' },
        3: { badge: 'A', className: 'work-tier-badge work-tier-badge--a' },
        2: { badge: 'B', className: 'work-tier-badge work-tier-badge--b' },
        1: { badge: 'C', className: 'work-tier-badge work-tier-badge--c' },
        0: { badge: '—', className: 'work-tier-badge work-tier-badge--d' }
      };

      const tierLegend = document.createElement('div');
      tierLegend.className = 'work-tier-legend';
      const tierLegendLabel = document.createElement('span');
      tierLegendLabel.className = 'work-tier-legend__label';
      tierLegendLabel.textContent = kidMode
        ? 'Badges show how strong a pal is at the job:'
        : 'Tier badges convert work levels at a glance:';
      tierLegend.appendChild(tierLegendLabel);
      const tierLegendItems = document.createElement('div');
      tierLegendItems.className = 'work-tier-legend__items';
      [4, 3, 2, 1].forEach(level => {
        const tierInfo = tierLookup[level];
        if (!tierInfo) return;
        const item = document.createElement('span');
        item.className = 'work-tier-legend__item';
        const badge = document.createElement('span');
        badge.className = tierInfo.className;
        badge.textContent = tierInfo.badge;
        const text = document.createElement('span');
        text.textContent = `${kidMode ? 'Level' : 'Level'} ${level} • ${workLevelLabels[level]}`;
        item.appendChild(badge);
        item.appendChild(text);
        tierLegendItems.appendChild(item);
      });
      if (tierLegendItems.childElementCount) {
        tierLegend.appendChild(tierLegendItems);
        workSection.appendChild(tierLegend);
      }

      const allPals = Object.values(PALS || {});
      let highestWorkLevel = 0;
      allPals.forEach(pal => {
        const work = pal?.work || {};
        Object.values(work).forEach(val => {
          if (typeof val === 'number' && val > highestWorkLevel) {
            highestWorkLevel = val;
          }
        });
      });
      if (!highestWorkLevel) {
        highestWorkLevel = 4;
      }

      function getWorkLevel(pal, keys) {
        const work = pal?.work || {};
        return keys.reduce((max, key) => {
          const value = work?.[key] ?? 0;
          return typeof value === 'number' && value > max ? value : max;
        }, 0);
      }

      function findTopPals(keys) {
        return allPals
          .map(pal => ({ pal, level: getWorkLevel(pal, keys) }))
          .filter(item => item.level > 0 && item.pal && item.pal.name)
          .sort((a, b) => {
            if (b.level !== a.level) return b.level - a.level;
            return (a.pal.name || '').localeCompare(b.pal.name || '', undefined, { sensitivity: 'base' });
          })
          .slice(0, 5);
      }

      function getTierInfo(level) {
        if (level >= 5 && tierLookup[5]) return tierLookup[5];
        if (level >= 4) return tierLookup[4];
        if (level >= 3) return tierLookup[3];
        if (level >= 2) return tierLookup[2];
        if (level >= 1) return tierLookup[1];
        return tierLookup[0];
      }

      function getWorkLabel(level) {
        if (level > 0) {
          const descriptor = workLevelLabels[level] != null
            ? workLevelLabels[level]
            : (kidMode ? 'Trusted helper' : 'Seasoned worker');
          return `${kidMode ? 'Level' : 'Level'} ${level} • ${descriptor}`;
        }
        return workLevelLabels[0];
      }

      const workEntries = [
        { id: 'kindling', name: 'Kindling', icon: '🔥', keys: ['kindling'], desc: 'Lights furnaces, cooking pots and heaters so crafting stays on schedule.' },
        { id: 'watering', name: 'Watering', icon: '💧', keys: ['watering'], desc: 'Keeps berry plantations, mill wheels and condensers supplied with water.' },
        { id: 'planting', name: 'Planting', icon: '🌱', keys: ['planting'], desc: 'Sows seeds in your fields and refills ranch plots automatically.' },
        { id: 'electricity', name: 'Electricity', icon: '⚡', keys: ['generating_electricity', 'electricity'], desc: 'Generates power for batteries, assembly lines and refrigerators.' },
        { id: 'handiwork', name: 'Handiwork', icon: '🛠️', keys: ['handiwork'], desc: 'Builds structures, crafts gear and assists with any construction queue.' },
        { id: 'gathering', name: 'Gathering', icon: '🎒', keys: ['gathering'], desc: 'Picks up dropped items around base and hauls them to nearby chests.' },
        { id: 'lumbering', name: 'Lumbering', icon: '🪓', keys: ['lumbering'], desc: 'Cuts logs at the logging site and processes wood for crafting.' },
        { id: 'mining', name: 'Mining', icon: '⛏️', keys: ['mining'], desc: 'Breaks ore nodes and keeps refining stations stocked with stone and ingots.' },
        { id: 'medicine', name: 'Medicine', icon: '💊', keys: ['medicine_production', 'medicine'], desc: 'Brews medical supplies at the workbench and treats sick pals faster.' },
        { id: 'cooling', name: 'Cooling', icon: '❄️', keys: ['cooling'], desc: 'Runs refrigerators, air conditioners and ice workbenches.' },
        { id: 'transporting', name: 'Transporting', icon: '📦', keys: ['transporting'], desc: 'Moves materials between stations and storage so production never stalls.' },
        { id: 'farming', name: 'Farming', icon: '🐑', keys: ['farming'], desc: 'Produces rare drops like milk, wool and eggs while stationed at the ranch.' }
      ];

      const workGrid = document.createElement('div');
      workGrid.className = 'glossary-work-grid';

      workEntries.forEach(entry => {
        const card = document.createElement('article');
        card.className = 'work-role-card';
        card.id = `work-${entry.id}`;

        const header = document.createElement('header');
        header.className = 'work-role-card__header';

        const icon = document.createElement('span');
        icon.className = 'work-role-card__icon';
        icon.textContent = entry.icon || '⭐';
        icon.setAttribute('aria-hidden', 'true');
        header.appendChild(icon);

        const titles = document.createElement('div');
        titles.className = 'work-role-card__titles';

        const title = document.createElement('h4');
        title.className = 'work-role-card__name';
        title.textContent = entry.name;
        titles.appendChild(title);

        const blurb = document.createElement('p');
        blurb.className = 'work-role-card__blurb';
        blurb.textContent = entry.desc;
        titles.appendChild(blurb);

        header.appendChild(titles);
        card.appendChild(header);

        const palGrid = document.createElement('div');
        palGrid.className = 'work-pal-grid';

        const topPals = findTopPals(entry.keys);
        if (!topPals.length) {
          const emptyState = document.createElement('p');
          emptyState.className = 'work-pal-empty';
          emptyState.textContent = kidMode
            ? 'No pals recorded yet.'
            : 'No pals currently specialise in this task.';
          palGrid.appendChild(emptyState);
        } else {
          topPals.forEach((item, index) => {
            const { pal, level } = item;
            const palId = pal.id || pal.key || '';
            const palName = pal.name || 'Unknown Pal';
            const tierInfo = getTierInfo(level);
            const label = getWorkLabel(level);
            const normalizedWidth = Math.min(100, Math.max(0, (level / Math.max(1, highestWorkLevel)) * 100));
            const initial = (palName || '?').trim().charAt(0) || '?';

            const cardBtn = document.createElement('button');
            cardBtn.type = 'button';
            cardBtn.className = 'work-pal-card';
            cardBtn.dataset.palId = palId;
            cardBtn.dataset.workRole = entry.id;
            cardBtn.dataset.workLevel = String(level);
            cardBtn.setAttribute('aria-label', `${palName} ${label}`);
            cardBtn.title = `${palName} — ${label}`;

            const rank = document.createElement('span');
            rank.className = 'work-pal-card__rank';
            rank.textContent = `#${index + 1}`;
            cardBtn.appendChild(rank);

            const artWrap = document.createElement('span');
            artWrap.className = 'work-pal-card__art';
            const placeholder = document.createElement('span');
            placeholder.className = 'work-pal-card__placeholder';
            placeholder.textContent = initial;
            artWrap.appendChild(placeholder);

            const artImg = document.createElement('img');
            artImg.alt = palName;
            artImg.addEventListener('load', () => {
              placeholder.hidden = true;
            });
            applyPalArtwork(artImg, pal, { alt: palName });
            artWrap.appendChild(artImg);
            cardBtn.appendChild(artWrap);

            const infoWrap = document.createElement('span');
            infoWrap.className = 'work-pal-card__info';

            const head = document.createElement('span');
            head.className = 'work-pal-card__head';
            const nameEl = document.createElement('span');
            nameEl.className = 'work-pal-card__name';
            nameEl.textContent = palName;
            head.appendChild(nameEl);

            const badge = document.createElement('span');
            badge.className = tierInfo.className;
            badge.textContent = tierInfo.badge;
            head.appendChild(badge);
            infoWrap.appendChild(head);

            const skill = document.createElement('span');
            skill.className = 'work-pal-card__skill';
            skill.textContent = label;
            infoWrap.appendChild(skill);

            const meter = document.createElement('span');
            meter.className = 'work-skill-meter';
            meter.setAttribute('aria-hidden', 'true');
            const meterFill = document.createElement('span');
            meterFill.className = 'work-skill-meter__fill';
            meterFill.style.width = `${normalizedWidth.toFixed(0)}%`;
            meter.appendChild(meterFill);
            infoWrap.appendChild(meter);

            cardBtn.appendChild(infoWrap);
            palGrid.appendChild(cardBtn);
          });
        }

        card.appendChild(palGrid);
        workGrid.appendChild(card);
      });

      workSection.appendChild(workGrid);

      const passiveDescription = kidMode
        ? 'All partner traits pals can roll. Tap a trait to read what it does.'
        : 'Complete alphabetical list of every passive trait. Select any entry for detailed effects.';
      const passiveSection = createSection('glossary-passives', 'Passive Skills', passiveDescription);
      const passiveSearch = createSearch(kidMode ? 'Search passive traits…' : 'Filter passive traits…');
      passiveSection.appendChild(passiveSearch);
      const passiveCount = document.createElement('p');
      passiveCount.className = 'glossary-count';
      passiveSection.appendChild(passiveCount);
      const passiveWrap = document.createElement('div');
      passiveWrap.className = 'glossary-chip-grid';
      passiveSection.appendChild(passiveWrap);
      const passiveEmpty = document.createElement('p');
      passiveEmpty.className = 'glossary-empty';
      passiveEmpty.textContent = kidMode
        ? 'No passives found. Try a different word.'
        : 'No passive traits match your search.';
      passiveEmpty.hidden = true;
      passiveSection.appendChild(passiveEmpty);

      const passiveEntries = Object.keys(traitsDictionary || {})
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      passiveEntries.forEach(trait => {
        const description = typeof traitsDictionary[trait] === 'string' ? traitsDictionary[trait] : '';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip passive';
        btn.dataset.trait = trait;
        const slug = slugifyForPalworld(trait);
        if (slug) {
          btn.id = `passive-${slug}`;
        }
        btn.title = description || trait;
        btn.textContent = trait;
        btn.dataset.search = `${trait} ${description}`.toLowerCase();
        passiveWrap.appendChild(btn);
      });

      const totalPassives = passiveEntries.length;
      function filterPassives() {
        const term = passiveSearch.value.trim().toLowerCase();
        let visible = 0;
        passiveWrap.querySelectorAll('.chip.passive').forEach(btn => {
          const searchable = btn.dataset.search || '';
          const matches = !term || searchable.includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        passiveCount.textContent = totalPassives
          ? (visible === totalPassives
            ? `${totalPassives} passive traits listed.`
            : `Showing ${visible} of ${totalPassives} passive traits.`)
          : 'No passive traits available.';
        passiveEmpty.hidden = visible !== 0;
      }
      filterPassives();
      passiveSearch.addEventListener('input', filterPassives);

      const activeDescription = kidMode
        ? 'Every move pals can learn. Search by name, element or effect.'
        : 'Complete catalogue of partner and weapon skills. Filter by name, element or effect.';
      const activeSection = createSection('glossary-active', 'Active Skills', activeDescription);
      const rainbowCallout = document.createElement('div');
      rainbowCallout.className = 'glossary-callout';
      rainbowCallout.innerHTML = `<strong>Rainbow skills</strong>Rainbow-fruit moves ignore normal type weaknesses and resistances, so they deal steady damage even when enemies resist your pal’s element. They can be taught to any pal, making them perfect coverage options for favourite partners.`;
      activeSection.appendChild(rainbowCallout);

      const skillSearch = createSearch(kidMode ? 'Search active skills…' : 'Filter active skills by name, element or effect…');
      activeSection.appendChild(skillSearch);
      const skillCount = document.createElement('p');
      skillCount.className = 'glossary-count';
      activeSection.appendChild(skillCount);
      const skillsWrap = document.createElement('div');
      skillsWrap.className = 'glossary-skill-grid';
      activeSection.appendChild(skillsWrap);
      const skillEmpty = document.createElement('p');
      skillEmpty.className = 'glossary-empty';
      skillEmpty.textContent = kidMode
        ? 'No skills found. Try another word or element.'
        : 'No active skills match your filters.';
      skillEmpty.hidden = true;
      activeSection.appendChild(skillEmpty);

      const skillEntriesMap = new Map();
      Object.entries(normalizedSkillDetails).forEach(([key, info]) => {
        skillEntriesMap.set(key, {
          key,
          displayName: info.name || key,
          element: info.element || 'Unknown',
          power: typeof info.power === 'number' ? info.power : null,
          cooldown: typeof info.ct === 'number' ? info.ct : null,
          description: info.description || ''
        });
      });
      Object.entries(skillsDictionary || {}).forEach(([rawKey, info = {}]) => {
        const normalizedKey = rawKey.toLowerCase();
        const existing = skillEntriesMap.get(normalizedKey);
        const baseName = info.name || niceName(rawKey);
        const fallbackPower = typeof info.power === 'number'
          ? info.power
          : (() => {
              const match = (info.damage || '').match(/(\d+)/);
              return match ? Number(match[1]) : null;
            })();
        const description = info.description || existing?.description || '';
        const element = (existing && existing.element && existing.element !== 'Unknown')
          ? existing.element
          : (info.element || info.type || 'Unknown');
        const cooldown = existing?.cooldown != null ? existing.cooldown : null;
        const merged = {
          key: normalizedKey,
          displayName: baseName,
          element,
          power: existing?.power != null ? existing.power : fallbackPower,
          cooldown,
          description
        };
        skillEntriesMap.set(normalizedKey, { ...existing, ...merged });
      });

      const skillEntries = Array.from(skillEntriesMap.values())
        .filter(entry => entry && entry.displayName)
        .sort((a, b) => a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' }));
      skillEntries.forEach(entry => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'glossary-skill';
        btn.dataset.skill = entry.key;
        const slug = slugifyForPalworld(entry.displayName);
        if (slug) {
          btn.id = `move-${slug}`;
        }
        const metaBits = [];
        if (typeof entry.power === 'number' && !Number.isNaN(entry.power)) {
          metaBits.push(`Power ${entry.power}`);
        }
        if (typeof entry.cooldown === 'number' && !Number.isNaN(entry.cooldown)) {
          metaBits.push(`CT ${entry.cooldown}s`);
        }
        const metaText = metaBits.join(' • ');
        btn.innerHTML = `
          <span class="glossary-skill__header">
            <span class="glossary-skill__name">${escapeHTML(entry.displayName)}</span>
            <span class="glossary-skill__element">${escapeHTML(entry.element || 'Unknown')}</span>
          </span>
          ${metaText ? `<span class="glossary-skill__meta">${escapeHTML(metaText)}</span>` : ''}
          <span class="glossary-skill__description">${escapeHTML(entry.description || 'No description available.')}</span>
        `;
        const searchableChunks = [
          entry.displayName,
          entry.element,
          entry.description,
          metaText
        ].filter(Boolean);
        btn.dataset.search = searchableChunks.join(' ').toLowerCase();
        skillsWrap.appendChild(btn);
      });

      const totalSkills = skillEntries.length;
      function filterSkills() {
        const term = skillSearch.value.trim().toLowerCase();
        let visible = 0;
        skillsWrap.querySelectorAll('.glossary-skill').forEach(btn => {
          const matches = !term || (btn.dataset.search || '').includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        skillCount.textContent = totalSkills
          ? (visible === totalSkills
            ? `${totalSkills} active skills listed.`
            : `Showing ${visible} of ${totalSkills} active skills.`)
          : 'No active skills available.';
        skillEmpty.hidden = visible !== 0;
      }
      filterSkills();
      skillSearch.addEventListener('input', filterSkills);

      if (!container.dataset.listenerBound) {
        container.addEventListener('click', (e) => {
          const passiveBtn = e.target.closest('.chip.passive');
          if (passiveBtn) {
            e.preventDefault();
            const trait = passiveBtn.dataset.trait;
            showTraitDetail(trait);
            return;
          }
          const workPalCard = e.target.closest('.work-pal-card');
          if (workPalCard && workPalCard.dataset.palId) {
            e.preventDefault();
            showPalDetail(workPalCard.dataset.palId);
            return;
          }
          const moveBtn = e.target.closest('.glossary-skill');
          if (moveBtn) {
            e.preventDefault();
            const key = moveBtn.dataset.skill;
            showSkillDetail(key);
          }
        });
        container.dataset.listenerBound = 'true';
      }
    }

    // Map page builder.  Creates toggles for different layers and
    // instructions to open the external interactive map.  We do not
    // re‑host community map tiles; instead we encourage opening
    // palworld.gg with the appropriate filters.  A simple overlay is
    // available via environment highlights but hidden by default.
    function buildMapPage() {
      const layers = document.getElementById('mapLayers');
      if (!layers) return;
      layers.innerHTML = '';
      const categories = [
        { name: 'Pals', desc: 'See spawn locations on the external map', url: 'https://palworld.gg/map' },
        { name: 'Alpha Pals', desc: 'Locate strong alpha variants', url: 'https://palworld.gg/map' },
        { name: 'Towers', desc: 'Find tower bosses and fast travel points', url: 'https://palworld.gg/map' },
        { name: 'Dungeons', desc: 'Open map to see dungeon entrances', url: 'https://palworld.gg/map' },
        { name: 'Effigies', desc: 'Locate Lifmunk Effigies for free levels', url: 'https://palworld.gg/map' },
        { name: 'Skill Fruit Trees', desc: 'Find Skill Fruit trees to learn moves', url: 'https://palworld.gg/map' },
        { name: 'Fast Travel', desc: 'Discover fast travel statues', url: 'https://palworld.gg/map' }
      ];
      categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = 'collect-btn';
        btn.style.margin = '4px';
        btn.textContent = cat.name;
        btn.addEventListener('click', () => {
          window.open(cat.url, '_blank');
        });
        layers.appendChild(btn);
      });
    }
    function buildProgressPage() {
      const guideText = document.getElementById('guideProgressText');
      if (guideText) {
        guideText.textContent = kidMode
          ? 'Check off story steps to power up this bar!'
          : 'Check off route steps to track your run.';
      }
      const towersBadge = document.getElementById('towersClearedBadge');
      if (towersBadge) {
        towersBadge.textContent = 'Towers cleared: 0/0';
      }
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = kidMode
          ? 'Catch pals to fill your squad meter.'
          : 'Mark pals as caught to track your crew.';
      }
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = kidMode
          ? 'Unlock new gadgets to light up this meter.'
          : 'Unlock tech to power up your workshop.';
      }
      const resetGuideBtn = document.getElementById('resetRouteProgress');
      if (resetGuideBtn) {
        resetGuideBtn.onclick = () => {
          if (confirm('Reset all guide progress?')) {
            localStorage.removeItem(ROUTE_STORAGE_KEY);
            routeState = {};
            renderRouteGuide();
            updateProgressUI();
          }
        };
      }
    }
    // Update progress bars
    function updateProgressUI() {
      const palsFallback = kidMode
        ? 'Catch pals to fill your squad meter.'
        : 'Mark pals as caught to track your crew.';
      const techFallback = kidMode
        ? 'Unlock new gadgets to light up this meter.'
        : 'Unlock tech to power up your workshop.';
      const guideFallback = kidMode
        ? 'Check off story steps to power up this bar!'
        : 'Check off route steps to track your run.';

      const totalPals = Object.keys(PALS).length;
      const caughtCount = Object.keys(caught).filter(k => caught[k]).length;
      const palsPct = totalPals ? Math.round((caughtCount / totalPals) * 100) : 0;
      const palsBar = document.getElementById('palsProgress');
      if (palsBar) palsBar.style.width = palsPct + '%';
      const palsMeter = document.getElementById('palsProgressMeter');
      if (palsMeter) palsMeter.setAttribute('aria-valuenow', palsPct);
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = totalPals
          ? `${caughtCount} / ${totalPals} pals recruited`
          : palsFallback;
      }
      const homePalsBar = document.getElementById('homePalsProgressBar');
      if (homePalsBar) homePalsBar.style.width = palsPct + '%';
      const homePalsMeter = document.getElementById('homePalsProgressMeter');
      if (homePalsMeter) homePalsMeter.setAttribute('aria-valuenow', palsPct);
      const homePalsText = document.getElementById('homePalsProgressText');
      if (homePalsText) {
        if (totalPals) {
          homePalsText.textContent = kidMode
            ? `${caughtCount} pals recruited so far`
            : `${caughtCount} / ${totalPals} pals recruited`;
        } else {
          homePalsText.textContent = palsFallback;
        }
      }

      const homePalsNext = document.getElementById('homePalsNext');
      if (homePalsNext) {
        const nextPal = findNextPalTarget();
        if (nextPal) {
          const typeLabel = Array.isArray(nextPal.types) && nextPal.types.length
            ? nextPal.types.join(kidMode ? ' & ' : ' / ')
            : (kidMode ? 'Mystery type' : 'Type unknown');
          homePalsNext.textContent = kidMode
            ? `Next recruit: ${nextPal.name}`
            : `Next recruit: ${nextPal.name} — ${typeLabel}`;
          homePalsNext.dataset.palId = nextPal.id || '';
        } else {
          homePalsNext.textContent = caughtCount && totalPals
            ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete! Open the pal list to revisit favourites.')
            : (kidMode ? 'Pal list loading…' : 'Pal data loading…');
          homePalsNext.dataset.palId = '';
        }
        homePalsNext.disabled = false;
      }

      let totalRecipes = 0;
      (Array.isArray(TECH) ? TECH : []).forEach(lvl => {
        if (lvl && Array.isArray(lvl.items)) {
          totalRecipes += lvl.items.length;
        }
      });
      const unlockedCount = Object.keys(unlocked).filter(k => unlocked[k]).length;
      const techPct = totalRecipes ? Math.round((unlockedCount / totalRecipes) * 100) : 0;
      const techBar = document.getElementById('techProgress');
      if (techBar) techBar.style.width = techPct + '%';
      const techMeter = document.getElementById('techProgressMeter');
      if (techMeter) techMeter.setAttribute('aria-valuenow', techPct);
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = totalRecipes
          ? `${unlockedCount} / ${totalRecipes} inventions unlocked`
          : techFallback;
      }
      const homeTechBar = document.getElementById('homeTechProgressBar');
      if (homeTechBar) homeTechBar.style.width = techPct + '%';
      const homeTechMeter = document.getElementById('homeTechProgressMeter');
      if (homeTechMeter) homeTechMeter.setAttribute('aria-valuenow', techPct);
      const homeTechText = document.getElementById('homeTechProgressText');
      if (homeTechText) {
        if (totalRecipes) {
          homeTechText.textContent = kidMode
            ? `${unlockedCount} inventions unlocked`
            : `${unlockedCount} / ${totalRecipes} inventions unlocked`;
        } else {
          homeTechText.textContent = techFallback;
        }
      }

      const nextTech = findNextTechUnlock();
      const homeTechNext = document.getElementById('homeTechNext');
      if (homeTechNext) {
        if (nextTech && nextTech.item) {
          const levelLabel = nextTech.level && nextTech.level.level != null
            ? `Lv ${nextTech.level.level}`
            : (kidMode ? '' : 'Lv ?');
          homeTechNext.textContent = kidMode
            ? `Next unlock: ${nextTech.item.name}${levelLabel ? ` (${levelLabel})` : ''}`
            : `Next unlock: ${levelLabel || 'Level ?'} — ${nextTech.item.name}`;
          homeTechNext.dataset.techKey = nextTech.techKey || '';
        } else {
          homeTechNext.textContent = kidMode
            ? 'Workshop complete! Explore favourites.'
            : 'Workshop complete! Review unlocked blueprints anytime.';
          homeTechNext.dataset.techKey = '';
        }
        homeTechNext.disabled = false;
      }

      const guideSummary = calculateGuideProgressSummary();
      const guideBar = document.getElementById('guideProgress');
      if (guideBar) guideBar.style.width = guideSummary.percent + '%';
      const guideMeter = document.getElementById('guideProgressMeter');
      if (guideMeter) guideMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const guideText = document.getElementById('guideProgressText');
      if (guideText) {
        guideText.textContent = guideSummary.requiredTotal
          ? `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} guide steps complete`
          : guideFallback;
      }
      const homeRouteBar = document.getElementById('homeRouteProgressBar');
      if (homeRouteBar) homeRouteBar.style.width = guideSummary.percent + '%';
      const homeRouteMeter = document.getElementById('homeRouteProgressMeter');
      if (homeRouteMeter) homeRouteMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const homeRouteText = document.getElementById('homeRouteProgressText');
      if (homeRouteText) {
        if (guideSummary.requiredTotal) {
          homeRouteText.textContent = kidMode
            ? `${guideSummary.requiredComplete} of ${guideSummary.requiredTotal} big steps done`
            : `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} required steps complete`;
        } else {
          homeRouteText.textContent = guideFallback;
        }
      }
      const homeRouteNext = document.getElementById('homeRouteNextStep');
      if (homeRouteNext) {
        const nextRequired = findNextRouteStep();
        const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });
        if (nextAny && nextAny.step) {
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopy = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const prefix = nextAny.step.optional && !nextRequired
            ? (kidMode ? 'Bonus step' : 'Optional step')
            : (kidMode ? 'Next step' : 'Next required step');
          const chapterHtml = chapterTitle ? ` — <strong>${escapeHTML(chapterTitle)}</strong>` : '';
          homeRouteNext.innerHTML = `${escapeHTML(prefix)}${chapterHtml}<br>${escapeHTML(stepCopy)}`;
          homeRouteNext.dataset.stepId = nextAny.step.id || '';
        } else {
          homeRouteNext.textContent = kidMode
            ? 'Guide complete! Revisit bonus adventures anytime.'
            : 'Guide complete! Revisit optional chores or rerun towers.';
          homeRouteNext.dataset.stepId = '';
        }
        homeRouteNext.disabled = false;
      }
      const towersBadge = document.getElementById('towersClearedBadge');
      if (towersBadge) {
        towersBadge.textContent = guideSummary.towersTotal
          ? `Towers cleared: ${guideSummary.towersComplete}/${guideSummary.towersTotal}`
          : 'Towers cleared: 0/0';
      }

      const spotlightBtn = document.getElementById('homePalSpotlight');
      if (spotlightBtn) {
        const primaryPal = findNextPalTarget();
        const spotlightPal = primaryPal || findRandomPalCandidate();
        if (spotlightPal) {
          const typeLabel = Array.isArray(spotlightPal.types) && spotlightPal.types.length
            ? spotlightPal.types.join(' • ')
            : '';
          const metaText = primaryPal
            ? (kidMode ? 'Next pal to recruit' : 'Next pal to recruit')
            : (caughtCount === totalPals && totalPals
              ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete — browse pals anytime.')
              : (kidMode ? 'Suggested pal to train next' : 'Suggested pal to train next'));
          const typesHtml = typeLabel
            ? `<span class="home-spotlight-card__types">${escapeHTML(typeLabel)}</span>`
            : '';
          spotlightBtn.innerHTML = `
            <img alt="">
            <div class="home-spotlight-card__text">
              <span class="home-spotlight-card__title">${escapeHTML(spotlightPal.name || 'Pal')}</span>
              <span class="home-spotlight-card__meta">${escapeHTML(metaText)}</span>
              ${typesHtml}
            </div>
          `;
          const spotlightImg = spotlightBtn.querySelector('img');
          applyPalArtwork(spotlightImg, spotlightPal, { alt: `${spotlightPal.name || 'Pal'} portrait` });
          spotlightBtn.dataset.palId = spotlightPal.id || '';
          spotlightBtn.disabled = false;
        } else {
          spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Pal data loading…</span><span class="home-spotlight-card__meta">Keep playing while we fetch pals.</span></div>';
          spotlightBtn.dataset.palId = '';
          spotlightBtn.disabled = true;
        }
      }
    }

    // Display detailed information about an item using a Palworld-inspired card.
    function openItemDetail(itemKey) {
      const item = ITEMS[itemKey] || {};
      const detail = ITEM_DETAILS[itemKey] || {};
      if (!Object.keys(item).length && !Object.keys(detail).length) return;
      const human = detail.name || humaniseItemKey(itemKey);
      const slug = PALWORLD_ITEM_SLUG_OVERRIDES[itemKey] || slugifyForPalworld(human);
      const itemUrl = slug ? `${PALWORLD_BASE_URL}/item/${slug}` : `${PALWORLD_BASE_URL}/items`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(human)}`;
      const drops = (DROPS_MAP[itemKey] || []).slice();
      const collectedStatus = !!collected[itemKey];
      const recipes = [];
      const ranchProducers = Array.isArray(detail.ranchProducers)
        ? detail.ranchProducers
        : (Array.isArray(item.ranchProducers) ? item.ranchProducers : []);
      const categoryLabel = detail.type || item.category || 'Item';
      TECH.forEach(level => {
        level.items.forEach(it => {
          if (it.materials && it.materials[itemKey]) {
            recipes.push({ name: it.name, qty: it.materials[itemKey], level: level.level });
          }
        });
      });
      modalBody.innerHTML = '';
      const card = document.createElement('article');
      card.className = 'item-detail-card';

      const header = document.createElement('div');
      header.className = 'item-detail-header';
      const headingWrap = document.createElement('div');
      headingWrap.className = 'item-detail-heading';
      const art = document.createElement('div');
      art.className = 'item-detail-image';
      const renderPlaceholder = () => {
        if (!art.querySelector('.item-detail-placeholder')) {
          const placeholder = document.createElement('div');
          placeholder.className = 'item-detail-placeholder';
          placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
          art.appendChild(placeholder);
        }
      };
      if (detail.image) {
        const img = document.createElement('img');
        img.src = detail.image;
        img.alt = human;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.referrerPolicy = 'no-referrer';
        img.onerror = () => {
          img.remove();
          renderPlaceholder();
        };
        art.appendChild(img);
      }
      if (!art.hasChildNodes()) {
        renderPlaceholder();
      }
      const meta = document.createElement('div');
      meta.className = 'item-detail-meta';
      const titleEl = document.createElement('h3');
      titleEl.textContent = human;
      const typeEl = document.createElement('span');
      const typeLabel = categoryLabel;
      typeEl.className = 'type-tag';
      typeEl.textContent = typeLabel;
      meta.appendChild(titleEl);
      meta.appendChild(typeEl);
      headingWrap.appendChild(art);
      headingWrap.appendChild(meta);
      header.appendChild(headingWrap);
      const collectBtn = document.createElement('button');
      collectBtn.className = `detail-collect-btn${collectedStatus ? ' collected' : ''}`;
      collectBtn.textContent = collectedStatus ? 'Collected' : 'Mark as collected';
      collectBtn.addEventListener('click', () => {
        collected[itemKey] = !collected[itemKey];
        localStorage.setItem('collected', JSON.stringify(collected));
        const state = !!collected[itemKey];
        collectBtn.classList.toggle('collected', state);
        collectBtn.textContent = state ? 'Collected' : 'Mark as collected';
        updateItemCollectionButtons(itemKey);
        updateProgressUI();
        playSound(clickSound);
      });
      header.appendChild(collectBtn);
      card.appendChild(header);

      const descriptionLines = Array.isArray(detail.description) && detail.description.length
        ? detail.description
        : [`${human} belongs to the ${categoryLabel} family.`];
      const descWrapper = document.createElement('div');
      descWrapper.className = 'item-detail-description';
      const maxParagraphs = kidMode ? Math.min(2, descriptionLines.length) : descriptionLines.length;
      for (let idx = 0; idx < maxParagraphs; idx += 1) {
        const p = document.createElement('p');
        p.textContent = descriptionLines[idx];
        descWrapper.appendChild(p);
      }
      card.appendChild(descWrapper);

      const statsEntries = Object.entries(detail.stats || {});
      if (categoryLabel && !statsEntries.some(entry => entry[0].toLowerCase() === 'category')) {
        statsEntries.push(['Category', categoryLabel]);
      }
      if (statsEntries.length) {
        const statGrid = document.createElement('div');
        statGrid.className = 'item-detail-stats';
        statsEntries.forEach(([label, value]) => {
          const pill = document.createElement('div');
          pill.className = 'stat-pill';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'label';
          labelSpan.textContent = label;
          const valueSpan = document.createElement('span');
          valueSpan.className = 'value';
          valueSpan.textContent = value;
          pill.appendChild(labelSpan);
          pill.appendChild(valueSpan);
          statGrid.appendChild(pill);
        });
        card.appendChild(statGrid);
      }

      const summarySection = document.createElement('section');
      summarySection.className = 'item-detail-section item-detail-summary';
      const summaryHeading = document.createElement('h4');
      summaryHeading.textContent = kidMode ? 'Quick Take' : 'Tracker Notes';
      summarySection.appendChild(summaryHeading);
      if (kidMode) {
        const dropPreview = drops.length ? drops.slice(0, 4).join(', ') + (drops.length > 4 ? '…' : '') : 'Not sure yet';
        const ranchPreview = ranchProducers.length
          ? ranchProducers.slice(0, 4).join(', ') + (ranchProducers.length > 4 ? '…' : '')
          : 'Not recorded yet';
        const summaryLines = [
          `Status: ${collectedStatus ? 'We have this item!' : 'Let’s go find this!'}`,
          `Item type: ${typeLabel}`,
          `Find it from: ${dropPreview}`,
          `Ranch pals: ${ranchPreview}`
        ];
        if (recipes.length) {
          summaryLines.push(`Used for: ${recipes.length} tech unlock${recipes.length === 1 ? '' : 's'}.`);
        }
        summaryLines.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          summarySection.appendChild(p);
        });
      } else {
        const summaryList = document.createElement('ul');
        const lines = [
          `Tracking status: ${collectedStatus ? 'Collected' : 'Not collected yet'}`,
          `Category: ${categoryLabel}`,
          drops.length ? `Drops recorded: ${drops.length}` : 'Drops recorded: none yet',
          ranchProducers.length
            ? `Ranch producers: ${ranchProducers.join(', ')}`
            : 'Ranch producers: none recorded yet',
          recipes.length ? `Tech unlocks: ${recipes.length} recipe${recipes.length === 1 ? '' : 's'} listed below.` : 'Tech unlocks: none recorded yet.'
        ];
        if (detail.fromPalworld === false) {
          lines.push('Data source: Palmate placeholder entry until Palworld.gg publishes more info.');
        } else {
          lines.push('Data source: Palworld.gg item compendium.');
        }
        lines.forEach(text => {
          const li = document.createElement('li');
          li.textContent = text;
          summaryList.appendChild(li);
        });
        summarySection.appendChild(summaryList);
      }
      card.appendChild(summarySection);

      const dropSection = document.createElement('section');
      dropSection.className = 'item-detail-section';
      const dropHeading = document.createElement('h4');
      dropHeading.textContent = 'Dropped by';
      dropSection.appendChild(dropHeading);
      if (drops.length) {
        const dropList = document.createElement('div');
        dropList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, drops.length) : drops.length;
        drops.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          dropList.appendChild(chip);
        });
        if (drops.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${drops.length - limit} more`;
          dropList.appendChild(more);
        }
        dropSection.appendChild(dropList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to drop this item yet.';
        dropSection.appendChild(none);
      }
      card.appendChild(dropSection);

      const ranchSection = document.createElement('section');
      ranchSection.className = 'item-detail-section';
      const ranchHeading = document.createElement('h4');
      ranchHeading.textContent = 'Ranch producers';
      ranchSection.appendChild(ranchHeading);
      if (ranchProducers.length) {
        const ranchList = document.createElement('div');
        ranchList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, ranchProducers.length) : ranchProducers.length;
        ranchProducers.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          ranchList.appendChild(chip);
        });
        if (ranchProducers.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${ranchProducers.length - limit} more`;
          ranchList.appendChild(more);
        }
        ranchSection.appendChild(ranchList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to produce this item at the ranch yet.';
        ranchSection.appendChild(none);
      }
      card.appendChild(ranchSection);

      if (Array.isArray(detail.recipe) && detail.recipe.length) {
        const recipeSection = document.createElement('section');
        recipeSection.className = 'item-detail-section';
        const recipeHeading = document.createElement('h4');
        recipeHeading.textContent = 'Crafting recipe';
        recipeSection.appendChild(recipeHeading);
        const ingredientGrid = document.createElement('div');
        ingredientGrid.className = 'ingredient-grid';
        detail.recipe.forEach(entry => {
          const ingredientCard = document.createElement('div');
          ingredientCard.className = 'ingredient-card';
          if (entry.icon) {
            const img = document.createElement('img');
            img.src = entry.icon;
            img.alt = entry.name;
            img.loading = 'lazy';
            ingredientCard.appendChild(img);
          }
          const textWrap = document.createElement('div');
          textWrap.className = 'ingredient-text';
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = entry.name;
          textWrap.appendChild(nameEl);
          if (entry.quantity) {
            const qty = document.createElement('div');
            qty.textContent = `x${entry.quantity}`;
            textWrap.appendChild(qty);
          }
          ingredientCard.appendChild(textWrap);
          ingredientGrid.appendChild(ingredientCard);
        });
        recipeSection.appendChild(ingredientGrid);
        card.appendChild(recipeSection);
      }

      if (recipes.length) {
        const techSection = document.createElement('section');
        techSection.className = 'item-detail-section';
        const techHeading = document.createElement('h4');
        techHeading.textContent = 'Used in tech';
        techSection.appendChild(techHeading);
        const techList = document.createElement('ul');
        const maxEntries = kidMode ? Math.min(5, recipes.length) : recipes.length;
        recipes.slice(0, maxEntries).forEach(recipe => {
          const li = document.createElement('li');
          li.textContent = `Level ${recipe.level}: ${recipe.name} (x${recipe.qty})`;
          techList.appendChild(li);
        });
        if (recipes.length > maxEntries) {
          const li = document.createElement('li');
          li.textContent = `+${recipes.length - maxEntries} more unlock${recipes.length - maxEntries === 1 ? '' : 's'} in higher tiers.`;
          techList.appendChild(li);
        }
        techSection.appendChild(techList);
        card.appendChild(techSection);
      }

      const footer = document.createElement('div');
      footer.className = 'item-detail-footer';
      const link = document.createElement('a');
      link.href = slug ? itemUrl : fallbackUrl;
      link.target = '_blank';
      link.rel = 'noopener';
      link.textContent = detail.fromPalworld === false ? 'Search on Palworld.gg' : 'View on Palworld.gg';
      footer.appendChild(link);
      const note = document.createElement('p');
      note.className = 'item-detail-note';
      note.textContent = detail.fromPalworld === false
        ? 'Palworld.gg has not published a full entry for this item yet. Details shown use Palmate data.'
        : 'Stats, art, and rarities mirror the Palworld.gg item database.';
      footer.appendChild(note);
      card.appendChild(footer);

      modalBody.appendChild(card);
      openModal();
    }

    // Show details about an active skill.  Looks up the skill in the
    // dictionary; if it’s missing we display a generic placeholder.
    function showSkillDetail(key) {
      const normalisedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
      const info = skillsDictionary[normalisedKey] || skillsDictionary[key] || { name: key.replace(/_/g,' '), damage: 'Unknown', type: 'Unknown', description: 'This skill\'s effects are a mystery! Try it out in battle.' };
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${info.name}</h3><p><strong>Damage:</strong> ${info.damage}</p><p><strong>Type:</strong> ${info.type}</p><p>${info.description}</p>`;
      modalBody.appendChild(div);
      openModal();
    }

    // Show details about a passive trait.  Retrieves the description
    // from the trait dictionary.  Unknown traits yield a default
    // explanation encouraging exploration.
    function showTraitDetail(name) {
      const desc = traitsDictionary[name] || 'This trait has mysterious effects that aren\'t fully documented. See how it behaves in-game!';
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${name}</h3><p>${desc}</p>`;
      modalBody.appendChild(div);
      openModal();
    }
  </script>
</body>
</html>
