<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palmate – Palworld Companion</title>
  <!-- Chart.js for radar charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Font Awesome for interface icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="css/styles.css">
  <!-- Core styles: cosmic blue theme with smooth scrollbars -->
  <style>
    /*
      Colour palette for our epic cosmic theme.  We move away from the
      flat blues of the original and embrace rich purples and golds
      inspired by the Palworld universe.  These variables define the
      background, primary and secondary navigation colours, accent
      highlights, light text, card backgrounds and success/danger
      notifications.  Feel free to tweak these values for your own
      flavour.
    */
    :root {
      /*
        Updated colour palette to give the UI a warmer, more inviting
        atmosphere.  The dark navy base contrasts with desaturated
        blues and soft greens, while the accent colour pops against
        the card backgrounds.  Light colours are slightly brighter to
        improve readability for younger players.  Feel free to tweak
        these values to suit your own tastes.
      */
      --bg: #0d1b2a;
      --primary: #1b263b;
      --secondary: #415a77;
      --accent: #778da9;
      --light: #e0e1dd;
      --card-bg: #1e3246;
      --card-hover: #2e4a62;
      --text: #f0f4f8;
      --muted: rgba(224,225,221,0.7);
      --danger: #e76f51;
      --success: #2a9d8f;
      --layout-max-width: 1200px;
      --layout-page-padding: clamp(16px, 3vw, 32px);
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      /* Set a cosmic background image across the entire page.  We use
         background-attachment: fixed so the stars stay put as you
         scroll, lending a sense of depth.  The fallback colour
         ensures readability while the image loads. */
      background: var(--bg) url('assets/images/background.png') center/cover fixed no-repeat;
      color: var(--text);
      font-family: "Trebuchet MS", sans-serif;
      height: 100%;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100dvh;
      overflow-x: hidden;
      line-height: 1.6;
    }
    /* Remove the old #app layout (previously used for sidebar).  The
       content area now sits below the navbar and fills the remaining
       space. */
    /* Top navigation bar styling */
    #navbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--primary);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      width: 100%;
    }
    #navbar .nav-shell {
      --navbar-padding-block: clamp(10px, 2vw, 18px);
      display: flex;
      align-items: center;
      gap: 12px;
      width: min(100%, var(--layout-max-width));
      margin: 0 auto;
      padding-inline: clamp(12px, 3vw, 28px);
      padding-block: var(--navbar-padding-block);
      padding-block-start: calc(env(safe-area-inset-top, 0px) + var(--navbar-padding-block));
    }
    .nav-brand {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 0 0 auto;
    }
    #navbar .logo {
      font-size: 1.4rem;
      font-weight: bold;
      letter-spacing: 1px;
      flex-shrink: 0;
    }
    .nav-links {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1 1 auto;
      flex-wrap: wrap;
      row-gap: 6px;
      min-width: 0;
    }
    .nav-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      flex: 0 0 auto;
    }
    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: rgba(14, 32, 52, 0.35);
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .nav-toggle:hover,
    .nav-toggle:focus-visible {
      color: var(--accent);
      border-color: rgba(224, 225, 221, 0.25);
      background: rgba(14, 32, 52, 0.5);
      outline: none;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    #navbar .nav-item {
      border: none;
      background: none;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: border-color 0.3s, color 0.3s;
      flex: 0 0 auto;
      min-height: 44px;
    }
    #navbar .nav-item i {
      font-size: 1.1rem;
    }
    #navbar .nav-item:hover {
      color: var(--accent);
    }
    #navbar .nav-item.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Mode toggle button styling */
    .mode-btn {
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 10px;
      transition: color 0.3s;
      flex: 0 0 auto;
    }
    .mode-btn:hover {
      color: var(--accent);
    }

    @media (min-width: 900px) {
      #navbar .nav-shell {
        gap: clamp(8px, 1.5vw, 16px);
      }
      .nav-brand {
        min-width: 0;
      }
      .nav-links {
        flex-wrap: nowrap;
        justify-content: center;
        gap: clamp(4px, 0.7vw, 8px);
        padding-inline: clamp(0px, 0.6vw, 10px);
        overflow-x: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(119, 141, 169, 0.55) transparent;
        scrollbar-gutter: stable both-edges;
      }
      #navbar .nav-item {
        flex: 0 1 auto;
        justify-content: center;
        padding: 6px 10px;
      }
      .nav-links::-webkit-scrollbar {
        height: 6px;
      }
      .nav-links::-webkit-scrollbar-thumb {
        background: rgba(119, 141, 169, 0.55);
        border-radius: 999px;
      }
      .nav-links::-webkit-scrollbar-track {
        background: transparent;
      }
      .nav-actions {
        padding-left: clamp(2px, 0.8vw, 10px);
      }
    }

    @media (max-width: 720px) {
      #navbar .nav-shell {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .nav-brand {
        justify-content: space-between;
      }
      .nav-actions {
        width: 100%;
        justify-content: flex-end;
        margin-left: 0;
      }
      .nav-toggle {
        display: inline-flex;
      }
      .nav-links {
        display: none;
        flex-direction: column;
        gap: 6px;
        width: 100%;
        max-height: 0;
        overflow: hidden;
        padding: 0 12px;
        border-radius: 14px;
        border-top: 1px solid rgba(224, 225, 221, 0.08);
        background: rgba(13, 27, 42, 0.85);
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
      }
      #navbar[data-open="true"] .nav-shell {
        gap: 16px;
      }
      #navbar[data-open="true"] .nav-links {
        display: flex;
        max-height: 600px;
        padding-top: 8px;
        padding-bottom: 12px;
        box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
        border-top-color: rgba(224, 225, 221, 0.2);
      }
      .nav-links .nav-item {
        width: 100%;
        justify-content: flex-start;
      }
    }

    /* Kid mode adjustments: larger targets and font sizes, simplified cards */
    body.kid-mode .pal-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .item-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .pal-card .name,
    body.kid-mode .item-card .name {
      font-size: 1.2rem;
    }
    body.kid-mode .nav-item span {
      font-size: 1rem;
    }
    body.kid-mode .search-bar input {
      font-size: 1rem;
    }
    /* Main content area.  This section fills the page below the
       navbar.  We add a top margin equal to the navbar height to
       ensure the content does not scroll underneath it. */
    #content {
      flex: 1 1 auto;
      width: 100%;
      max-width: var(--layout-max-width);
      margin-inline: auto;
      margin-block: clamp(12px, 2vw, 24px) clamp(36px, 6vw, 72px);
      padding: var(--layout-page-padding);
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .page > p {
      max-width: 68ch;
      margin-bottom: 24px;
    }
    .glossary-nav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 18px;
      margin: 0 0 28px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(13, 27, 42, 0.78), rgba(35, 68, 107, 0.62));
      box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.28);
      backdrop-filter: blur(12px);
    }
    .glossary-nav button {
      background: transparent;
      color: var(--text);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 9px 18px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .glossary-nav button:hover,
    .glossary-nav button:focus-visible {
      background: rgba(119, 141, 169, 0.16);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      outline: none;
    }
    .glossary-section {
      position: relative;
      padding: 24px;
      margin-bottom: 32px;
      border-radius: 22px;
      background: linear-gradient(155deg, rgba(12, 24, 38, 0.92), rgba(20, 42, 66, 0.82));
      box-shadow: 0 28px 48px rgba(2, 12, 24, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.25);
      overflow: hidden;
    }
    .glossary-section::before {
      content: '';
      position: absolute;
      inset: -120px -120px auto auto;
      width: 220px;
      height: 220px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.18), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .glossary-section > * {
      position: relative;
      z-index: 1;
    }
    .glossary-section h3 {
      margin-top: 0;
      font-size: 1.6rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .glossary-search {
      width: 100%;
      padding: 12px 16px;
      margin: 18px 0 20px;
      border-radius: 14px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(9, 19, 33, 0.6);
      color: var(--text);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .glossary-search::placeholder {
      color: rgba(224, 225, 221, 0.55);
      letter-spacing: 0.02em;
    }
    .glossary-chip-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .glossary-skill-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .glossary-count {
      margin: 0 0 14px;
      color: rgba(224, 225, 221, 0.75);
      font-size: 0.85rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .glossary-empty {
      margin: 10px 0 0;
      font-style: italic;
      color: rgba(224, 225, 221, 0.6);
    }
    .chip.passive,
    .chip.move,
    .glossary-skill {
      transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .chip.passive:hover,
    .chip.passive:focus-visible,
    .chip.move:hover,
    .chip.move:focus-visible,
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      transform: translateY(-2px);
      outline: none;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      text-align: left;
      border: 1px solid rgba(119, 141, 169, 0.26);
      border-radius: 16px;
      padding: 18px 20px;
      background: linear-gradient(160deg, rgba(14, 27, 42, 0.92), rgba(21, 43, 67, 0.78));
      color: inherit;
      cursor: pointer;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      border-color: var(--accent);
      background: linear-gradient(160deg, rgba(18, 36, 56, 0.95), rgba(32, 64, 98, 0.82));
    }
    .glossary-skill__header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      align-items: center;
      margin-bottom: 6px;
    }
    .glossary-skill__name {
      font-weight: 700;
      font-size: 1.05rem;
    }
    .glossary-skill__element {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(119,141,169,0.25);
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.82);
    }
    .glossary-skill__meta {
      font-size: 0.8rem;
      color: rgba(224, 225, 221, 0.7);
      margin-bottom: 8px;
    }
    .glossary-skill__description {
      font-size: 0.92rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.86);
    }
    .glossary-callout {
      border-left: 4px solid var(--accent);
      padding: 16px 20px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(23, 46, 68, 0.85), rgba(42, 78, 108, 0.72));
      margin-bottom: 20px;
      font-size: 0.95rem;
      box-shadow: inset 0 0 0 1px rgba(119, 141, 169, 0.2);
    }
    .glossary-callout strong {
      display: block;
      font-size: 1.05rem;
      margin-bottom: 6px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .glossary-callout ul {
      margin: 8px 0 0;
      padding-left: 20px;
      color: rgba(224, 225, 221, 0.78);
      line-height: 1.45;
    }
    .glossary-callout li {
      margin-bottom: 4px;
    }
    .partner-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 0 0 16px;
    }
    .partner-filter {
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.32);
      background: rgba(12, 26, 42, 0.65);
      color: var(--text);
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 7px 16px;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }
    .partner-filter:hover,
    .partner-filter:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }
    .partner-filter[aria-pressed="true"] {
      background: linear-gradient(135deg, rgba(35, 68, 107, 0.78), rgba(57, 102, 147, 0.72));
      border-color: var(--accent);
      box-shadow: 0 10px 24px rgba(7, 19, 38, 0.5);
    }
    .partner-skill-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .partner-skill-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      border-radius: 18px;
      padding: 20px;
      background: linear-gradient(165deg, rgba(14, 28, 44, 0.92), rgba(26, 52, 78, 0.78));
      box-shadow: 0 18px 34px rgba(0, 0, 0, 0.38);
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }
    .partner-skill-card:hover,
    .partner-skill-card:focus-within {
      border-color: var(--accent);
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.42);
      transform: translateY(-2px);
      outline: none;
    }
    .partner-skill-card__header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }
    .partner-skill-card__name {
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      flex: 1 1 auto;
    }
    .partner-skill-card__number {
      font-size: 0.78rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.2);
      border-radius: 999px;
      padding: 4px 10px;
      color: rgba(224, 225, 221, 0.75);
      flex: 0 0 auto;
    }
    .partner-skill-card__tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .partner-skill-card__tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.22);
      color: rgba(224, 225, 221, 0.86);
    }
    .partner-skill-card__tag--mount {
      background: rgba(129, 199, 245, 0.22);
      color: rgba(224, 242, 255, 0.9);
    }
    .partner-skill-card__tag--damage {
      background: rgba(255, 138, 101, 0.22);
      color: rgba(255, 214, 186, 0.92);
    }
    .partner-skill-card__tag--drops {
      background: rgba(144, 238, 144, 0.22);
      color: rgba(226, 255, 226, 0.88);
    }
    .partner-skill-card__description {
      font-size: 0.92rem;
      line-height: 1.55;
      color: rgba(224, 225, 221, 0.88);
    }
    .partner-skill-card__pals {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: auto;
    }
    .partner-skill-card__pal {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 5px 12px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.32);
      background: rgba(12, 24, 38, 0.7);
      color: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, background 0.2s ease;
    }
    .partner-skill-card__pal:hover,
    .partner-skill-card__pal:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.38);
      transform: translateY(-1px);
    }
    .partner-skill-card__pal[aria-disabled="true"] {
      cursor: default;
      opacity: 0.7;
      border-style: dashed;
    }
    .partner-skill-card__pal-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      overflow: hidden;
      background: rgba(119, 141, 169, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
    }
    .partner-skill-card__pal-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .work-tier-legend {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px 18px;
      padding: 16px 20px;
      margin: 0 0 24px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(17, 34, 51, 0.82), rgba(31, 58, 88, 0.7));
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .work-tier-legend__label {
      font-size: 0.9rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-tier-legend__items {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }
    .work-tier-legend__item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-tier-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 38px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 0 1px rgba(12, 24, 38, 0.6), 0 6px 16px rgba(0, 0, 0, 0.35);
    }
    .work-tier-badge--ss {
      background: linear-gradient(135deg, #f6d365, #fda085);
      color: #1a1a1a;
    }
    .work-tier-badge--s {
      background: linear-gradient(135deg, #56ccf2, #2f80ed);
      color: #0b1a2a;
    }
    .work-tier-badge--a {
      background: linear-gradient(135deg, #6be67e, #2ecc71);
      color: #0b2214;
    }
    .work-tier-badge--b {
      background: linear-gradient(135deg, #f2c94c, #f2994a);
      color: #301b07;
    }
    .work-tier-badge--c {
      background: linear-gradient(135deg, #ff758f, #a83279);
      color: #fff;
    }
    .work-tier-badge--d {
      background: linear-gradient(135deg, rgba(149, 158, 174, 0.35), rgba(96, 110, 133, 0.3));
      color: rgba(224, 225, 221, 0.8);
    }
    .glossary-work-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .work-role-card {
      display: flex;
      flex-direction: column;
      gap: 18px;
      padding: 22px;
      border-radius: 20px;
      background: linear-gradient(165deg, rgba(10, 22, 37, 0.92), rgba(23, 46, 68, 0.78));
      border: 1px solid rgba(119, 141, 169, 0.24);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.45);
    }
    .work-role-card__header {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }
    .work-role-card__icon {
      width: 56px;
      height: 56px;
      border-radius: 16px;
      display: grid;
      place-items: center;
      font-size: 2rem;
      background: linear-gradient(135deg, rgba(224, 225, 221, 0.12), rgba(119, 141, 169, 0.18));
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.18);
    }
    .work-role-card__titles {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-role-card__name {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .work-role-card__blurb {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.72);
    }
    .work-pal-grid {
      display: grid;
      gap: 14px;
    }
    @media (min-width: 540px) {
      .work-pal-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .work-pal-card {
      position: relative;
      display: flex;
      align-items: center;
      gap: 16px;
      width: 100%;
      padding: 16px 18px;
      border-radius: 18px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      background: linear-gradient(155deg, rgba(15, 32, 50, 0.9), rgba(31, 58, 88, 0.75));
      color: inherit;
      cursor: pointer;
      text-align: left;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.4);
      overflow: hidden;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .work-pal-card:hover,
    .work-pal-card:focus-visible {
      border-color: var(--accent);
      transform: translateY(-3px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.5);
      outline: none;
    }
    .work-pal-card::after {
      content: '';
      position: absolute;
      inset: -60px -60px auto auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.16), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
    }
    .work-pal-card__rank {
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-pal-card__art {
      width: 76px;
      height: 76px;
      border-radius: 18px;
      background: rgba(5, 14, 26, 0.65);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.12);
      display: grid;
      place-items: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .work-pal-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.45));
    }
    .work-pal-card__placeholder {
      font-size: 1.6rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .work-pal-card__info {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-pal-card__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .work-pal-card__name {
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .work-pal-card__skill {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-skill-meter {
      position: relative;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(8, 17, 30, 0.6);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.1);
    }
    .work-skill-meter__fill {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), rgba(119, 141, 169, 0.85));
      transition: width 0.4s ease;
    }
    .work-pal-card__empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.6);
    }
    .work-pal-empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.7);
      font-style: italic;
    }
    body.kid-mode .glossary-nav button {
      font-size: 0.95rem;
      padding: 12px 20px;
    }
    body.kid-mode .glossary-section h3 {
      font-size: 1.8rem;
    }
    body.kid-mode .glossary-search {
      font-size: 1rem;
    }
    body.kid-mode .work-role-card__name {
      font-size: 1.4rem;
    }
    body.kid-mode .work-role-card__blurb {
      font-size: 1.05rem;
    }
    body.kid-mode .work-pal-card__name {
      font-size: 1.15rem;
    }
    body.kid-mode .work-pal-card__skill {
      font-size: 0.95rem;
    }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
    }

    @media (max-width: 900px) {
      #navbar .nav-item {
        padding: 10px 12px;
        font-size: 0.85rem;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      }
    }

    @media (max-width: 600px) {
      .nav-brand .logo {
        font-size: 1.15rem;
      }
      #content {
        padding: clamp(16px, 6vw, 28px);
        margin-block: clamp(10px, 2vw, 18px) clamp(28px, 7vw, 60px);
      }
      .page-header {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .search-bar {
        max-width: none;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 14px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }
    }

    @media (max-width: 480px) {
      .nav-brand .logo {
        font-size: 1.05rem;
      }
      #navbar .nav-item {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      #navbar .nav-item i {
        font-size: 1rem;
      }
      #content {
        padding: clamp(14px, 7vw, 24px);
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      .pal-card img,
      .item-card img {
        width: 90px;
        height: 90px;
      }
    }
    .search-bar {
      width: 100%;
      max-width: 400px;
    }
    .search-bar input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
      background: var(--card-bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    /* Grid for cards */
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }

    body.kid-mode .card-grid {
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 20px;
    }

    #homeCards {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    .home-hero {
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.6), rgba(119, 141, 169, 0.25));
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 16px;
      padding: 24px;
      display: grid;
      gap: 20px;
    }

    .home-hero__intro h3 {
      margin: 0 0 6px;
      font-size: 1.6rem;
    }

    .home-hero__intro p {
      margin: 0;
      color: var(--muted);
      font-size: 1rem;
    }

    .mode-callouts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }

    .mode-card {
      background: rgba(14, 29, 48, 0.85);
      border: 1px solid rgba(119, 141, 169, 0.25);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: border-color 0.3s ease, box-shadow 0.3s ease, transform 0.2s ease;
    }

    .mode-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(119, 141, 169, 0.25);
      transform: translateY(-2px);
    }

    .mode-card__status {
      align-self: flex-start;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.18);
      color: var(--text);
      padding: 4px 10px;
      border-radius: 999px;
    }

    .mode-card.active .mode-card__status {
      background: rgba(42, 157, 143, 0.2);
      color: var(--success);
    }

    .mode-card h3 {
      margin: 0;
      font-size: 1.25rem;
    }

    .mode-card p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .mode-card__features {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 6px;
      color: var(--light);
      font-size: 0.9rem;
    }

    .mode-card__button {
      margin-top: auto;
      width: 100%;
    }

    .home-section-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .home-section-header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .home-progress {
      background: var(--primary);
      border-radius: 16px;
      padding: 24px;
      display: grid;
      gap: 20px;
      border: 1px solid rgba(119, 141, 169, 0.2);
    }

    .home-progress-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 18px;
    }

    .home-progress-card {
      background: var(--card-bg);
      border-radius: 12px;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    .home-progress-card__header {
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .home-progress-card__icon {
      width: 42px;
      height: 42px;
      border-radius: 12px;
      display: grid;
      place-items: center;
      background: rgba(119, 141, 169, 0.18);
      color: var(--accent);
      font-size: 1.4rem;
      flex-shrink: 0;
    }

    .home-progress-card__header h3 {
      margin: 0;
      font-size: 1.15rem;
    }

    .home-progress-card__header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .home-progress-meter {
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.25);
      overflow: hidden;
    }

    .home-progress-meter .fill {
      width: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), rgba(42, 157, 143, 0.8));
      transition: width 0.4s ease;
    }

    .home-progress-text {
      font-size: 0.95rem;
      font-weight: 600;
    }

    .home-progress-next {
      font-size: 0.85rem;
      color: var(--muted);
      text-align: left;
    }

    .home-progress-link {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.9rem;
      padding: 0;
      text-align: left;
      cursor: pointer;
      text-decoration: underline;
      align-self: flex-start;
    }

    .home-progress-link:disabled {
      color: var(--muted);
      cursor: default;
      text-decoration: none;
    }

    .home-progress-actions {
      margin-top: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .home-progress-actions .btn {
      flex: 1 1 auto;
      min-width: 160px;
    }

    .home-spotlight {
      background: rgba(14, 29, 48, 0.85);
      border-radius: 16px;
      padding: 24px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      display: grid;
      gap: 18px;
    }

    .home-spotlight-card {
      display: flex;
      align-items: center;
      gap: 18px;
      background: var(--card-bg);
      border-radius: 12px;
      padding: 16px;
      border: none;
      color: inherit;
      text-align: left;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .home-spotlight-card:hover:not(:disabled) {
      background: var(--card-hover);
      transform: translateY(-2px);
    }

    .home-spotlight-card:disabled {
      cursor: default;
      opacity: 0.85;
    }

    .home-spotlight-card:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .home-spotlight-card img {
      width: 96px;
      height: 96px;
      object-fit: contain;
      border-radius: 12px;
      background: rgba(13, 27, 42, 0.8);
    }

    .home-spotlight-card__text {
      display: grid;
      gap: 6px;
    }

    .home-spotlight-card__title {
      font-size: 1.15rem;
      font-weight: 600;
    }

    .home-spotlight-card__meta {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .home-spotlight-card__types {
      font-size: 0.85rem;
      color: var(--light);
    }

    body.kid-mode .home-hero__intro h3 {
      font-size: 1.8rem;
    }

    body.kid-mode .mode-card__features {
      font-size: 1rem;
    }

    body.kid-mode .home-progress-text {
      font-size: 1.05rem;
    }

    body.kid-mode .home-progress-link {
      font-size: 1rem;
    }

    @media (max-width: 768px) {
      .home-progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      }
      .mode-card {
        min-height: 100%;
      }
    }

    @media (max-width: 540px) {
      #homeCards {
        gap: 20px;
      }
      .home-hero {
        padding: 20px;
      }
      .home-progress {
        padding: 20px;
      }
      .home-spotlight {
        padding: 20px;
      }
      .home-spotlight-card {
        flex-direction: column;
        align-items: flex-start;
      }
      .home-spotlight-card img {
        width: 90px;
        height: 90px;
      }
    }
    /* Pal and item cards */
    .pal-card, .item-card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
      cursor: pointer;
      position: relative;
    }
    .pal-card:hover, .item-card:hover {
      transform: translateY(-4px);
      background: var(--card-hover);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .pal-card img, .item-card img {
      /* Increase the size of the images to make each pal and item
         card more visually striking and easier for younger players
         to recognise. */
      width: 100px;
      height: 100px;
      object-fit: contain;
      margin-bottom: 8px;
    }
    .item-card-art {
      width: 100%;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    .item-card-art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-card-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .pal-card .name, .item-card .name {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .pal-card .badge {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 4px;
      color: var(--text);
      font-size: 0.8rem;
    }
    .pal-card .badge img {
      width: 22px;
      height: 22px;
    }
    .pal-card .rarity {
      font-size: 0.8rem;
      margin-bottom: 6px;
      color: var(--light);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }
    .pal-card .rarity .stars i {
      color: #E4B914;
      font-size: 0.8rem;
      margin-right: 2px;
    }
    .pal-card .rarity .label {
      color: var(--accent);
      font-weight: bold;
      text-transform: capitalize;
    }
    .pal-card .catch-btn {
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: background 0.2s;
    }
    .pal-card .catch-btn.caught {
      background: var(--secondary);
    }
    /* Modal */
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      z-index: 200;
    }
    #modal.active {
      opacity: 1;
      pointer-events: auto;
    }
    #modalContent {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 20px;
      max-width: 900px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--danger);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .external-embed {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .external-embed .embed-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .external-embed .embed-actions h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .external-embed .embed-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: bold;
    }
    .external-embed .embed-link:hover,
    .external-embed .embed-link:focus {
      text-decoration: underline;
    }
    .external-embed .embed-note,
    .external-embed .embed-fallback {
      font-size: 0.9rem;
      color: var(--light);
      margin: 0;
    }
    .external-embed .embed-summary {
      background: rgba(65, 90, 119, 0.35);
      border-radius: 8px;
      padding: 12px;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    body.kid-mode .external-embed .embed-summary {
      font-size: 1rem;
    }
    .map-iframe-wrapper {
      width: 100%;
      height: clamp(320px, 70vh, 720px);
      border-radius: 18px;
      overflow: hidden;
      margin-bottom: 16px;
      border: 1px solid rgba(119, 141, 169, 0.3);
      box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
      background: #000;
    }
    .map-iframe-wrapper iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }
    #mapLayers {
      margin-bottom: 12px;
    }
    @media (max-width: 600px) {
      .map-iframe-wrapper {
        height: clamp(260px, 60vh, 480px);
        border-radius: 14px;
      }
    }
    .external-embed .embed-frame {
      width: 100%;
      min-height: clamp(320px, 65vh, 640px);
      border: none;
      border-radius: 10px;
      background: #fff;
    }
    .item-detail-card {
      display: grid;
      gap: 18px;
      background: var(--card-bg);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }
    .item-detail-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .item-detail-heading {
      display: flex;
      align-items: center;
      gap: 16px;
      flex: 1 1 auto;
      min-width: 0;
    }
    .item-detail-image {
      width: 96px;
      height: 96px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .item-detail-image img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-detail-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .item-detail-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .item-detail-meta h3 {
      margin: 0;
      font-size: 1.6rem;
      line-height: 1.2;
    }
    .item-detail-meta .type-tag {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }
    .detail-collect-btn {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .detail-collect-btn:hover,
    .detail-collect-btn:focus {
      background: var(--accent);
      transform: translateY(-1px);
    }
    .detail-collect-btn.collected {
      background: var(--success);
      color: #fff;
    }
    .item-detail-description p {
      margin: 0 0 8px;
      line-height: 1.6;
      font-size: 1rem;
    }
    .item-detail-description p:last-child {
      margin-bottom: 0;
    }
    .item-detail-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .item-detail-stats .stat-pill {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 12px;
    }
    .item-detail-stats .stat-pill .label {
      display: block;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 4px;
    }
    .item-detail-stats .stat-pill .value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .item-detail-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      display: grid;
      gap: 8px;
    }
    .item-detail-section h4 {
      margin: 0;
      font-size: 1.1rem;
    }
    .item-detail-section p {
      margin: 0;
      line-height: 1.5;
    }
    .item-detail-summary ul {
      margin: 0;
      padding-left: 20px;
      line-height: 1.5;
    }
    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip-list .chip {
      background: rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
    }
    .chip-list .chip.highlight {
      background: rgba(42, 157, 143, 0.35);
    }
    .ingredient-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .ingredient-card {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .ingredient-card img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.25);
    }
    .ingredient-card .ingredient-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .ingredient-card .name {
      font-weight: 600;
    }
    .item-detail-footer {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.9rem;
    }
    .item-detail-footer a {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }
    .item-detail-footer a:hover,
    .item-detail-footer a:focus {
      text-decoration: underline;
    }
    .item-detail-note {
      color: var(--accent);
      font-size: 0.85rem;
    }
    body.kid-mode .item-detail-card {
      gap: 14px;
      padding: 20px;
    }
    body.kid-mode .item-detail-meta h3 {
      font-size: 1.4rem;
    }
    body.kid-mode .item-detail-description p {
      font-size: 1.05rem;
    }
    body.kid-mode .item-detail-stats {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    body.kid-mode .item-detail-stats .stat-pill {
      padding: 10px;
    }
    body.kid-mode .item-detail-stats .stat-pill .value {
      font-size: 1rem;
    }
    body.kid-mode .detail-collect-btn {
      font-size: 1rem;
      padding: 12px 20px;
    }
    body.kid-mode .chip-list .chip {
      font-size: 0.95rem;
      padding: 8px 16px;
    }
    body.kid-mode .item-detail-section h4 {
      font-size: 1rem;
    }
    .modal-action-btn {
      background: var(--accent);
      border: none;
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .modal-action-btn:hover,
    .modal-action-btn:focus {
      background: var(--secondary);
      transform: translateY(-1px);
    }
    body.kid-mode .modal-action-btn {
      font-size: 1rem;
    }
    /* Environment map */
    #mapContainer {
      position: relative;
      width: 100%;
      margin: 10px 0;
      border-radius: 8px;
      overflow: hidden;
    }
    #mapContainer img {
      width: 100%;
      height: auto;
      display: block;
    }
    #mapOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #mapOverlay .zone {
      position: absolute;
      opacity: 0;
      background: var(--accent);
      border: 2px solid var(--light);
      /* Make the highlight circular/elliptical to better approximate
         natural habitats instead of square boxes */
      border-radius: 50%;
      transition: opacity 0.3s;
    }
    #mapOverlay .zone.active {
      /* Lower opacity for a gentler highlight that doesn’t overpower the map */
      opacity: 0.2;
    }
    .map-modal {
      display: grid;
      gap: 12px;
    }
    .map-modal h3 {
      margin: 0;
    }
    .map-modal-note {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }
    .map-modal-details {
      display: grid;
      gap: 6px;
      font-size: 0.95rem;
    }
    .map-modal-canvas {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      background: var(--primary);
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
    }
    .map-modal-canvas img {
      display: block;
      width: 100%;
      height: auto;
    }
    .map-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      background: var(--danger);
      border: 2px solid var(--light);
      border-radius: 50%;
      --marker-tail-length: 16px;
      --marker-horizontal-adjust: 0px;
      transform: translate(
        calc(-50% + var(--marker-horizontal-adjust)),
        calc(-100% - var(--marker-tail-length))
      );
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    .map-marker::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      width: 2px;
      height: var(--marker-tail-length);
      background: var(--danger);
      transform: translateX(-50%);
    }
    .map-marker-label {
      position: absolute;
      top: calc(100% + 6px);
      left: 50%;
      transform: translate(-50%, 0);
      background: rgba(13,27,42,0.85);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      pointer-events: none;
    }
    body.kid-mode .map-modal-details p {
      font-size: 1rem;
    }
    /* Items */
    .item-card .name {
      font-weight: bold;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .item-card .category {
      font-size: 0.75rem;
      color: var(--light);
      margin-bottom: 6px;
    }
    .item-card .drops {
      font-size: 0.7rem;
      color: var(--text);
    }
    .item-card .ranch {
      font-size: 0.7rem;
      color: var(--light);
      margin-top: 4px;
    }
    .item-card .ranch--empty {
      opacity: 0.75;
      font-style: italic;
    }
    .item-card .collect-btn {
      margin-top: 6px;
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
    }
    .item-card .collect-btn.collected {
      background: var(--secondary);
    }
    /* Route tracking */
    .route-card {
      text-align: left;
      cursor: default;
      border: 1px solid transparent;
    }
    .route-card.completed {
      border-color: var(--success);
      box-shadow: 0 4px 14px rgba(46, 204, 113, 0.25);
      background: rgba(46, 204, 113, 0.08);
    }
    .route-card .name {
      margin-bottom: 6px;
    }
    .route-steps {
      margin-top: 8px;
    }
    .route-step-list {
      list-style-position: inside;
      padding-left: 0;
      margin: 4px 0 0;
      counter-reset: route-step;
    }
    .route-step {
      counter-increment: route-step;
      margin-bottom: 6px;
      padding: 6px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.02);
      transition: background 0.2s, color 0.2s;
    }
    .route-step::marker {
      font-weight: 700;
      color: var(--secondary);
    }
    .route-step.completed {
      background: rgba(46, 204, 113, 0.12);
    }
    .route-step.completed::marker {
      color: var(--success);
    }
    .route-step-label {
      display: flex;
      gap: 8px;
      align-items: flex-start;
      font-size: 0.75rem;
      color: var(--light);
    }
    .route-step input[type="checkbox"] {
      margin-top: 2px;
      transform: scale(1.05);
    }
    .route-step-text {
      flex: 1;
      line-height: 1.35;
    }
    .route-step.completed .route-step-label {
      color: var(--text);
      font-weight: 600;
    }
    .route-step.completed .route-step-text {
      text-decoration: line-through;
    }
    .route-progress-summary {
      font-size: 0.7rem;
      color: var(--light);
      margin-top: 6px;
    }
    .route-card.completed .route-progress-summary {
      color: var(--success);
      font-weight: 600;
    }
    /* Tech tree */
    #techList {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .tech-level-card {
      background: linear-gradient(135deg, rgba(23,40,59,0.92), rgba(18,32,48,0.92));
      border-radius: 18px;
      border: 1px solid rgba(119,141,169,0.25);
      box-shadow: 0 16px 32px rgba(0,0,0,0.35);
      padding: 18px;
      backdrop-filter: blur(6px);
    }
    .tech-level-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .tech-level-number {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(119,141,169,0.4);
    }
    .tech-level-number span {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--light);
    }
    .tech-level-summary {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .tech-columns {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .tech-column {
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: rgba(13,27,42,0.55);
      border: 1px solid rgba(119,141,169,0.18);
      border-radius: 14px;
      padding: 14px;
    }
    .tech-column h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
    }
    .tech-card {
      position: relative;
      display: flex;
      gap: 14px;
      align-items: stretch;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid rgba(119,141,169,0.25);
      background: rgba(15,28,45,0.85);
      box-shadow: 0 8px 20px rgba(0,0,0,0.35);
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .tech-card:hover {
      transform: translateY(-2px);
      border-color: var(--accent);
      box-shadow: 0 14px 28px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked {
      border-color: rgba(42,157,143,0.6);
      box-shadow: 0 0 0 2px rgba(42,157,143,0.35), 0 16px 28px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked .tech-card__cost {
      background: rgba(42,157,143,0.25);
      color: var(--success);
    }
    .tech-card__art {
      width: 72px;
      height: 72px;
      border-radius: 12px;
      background: rgba(119,141,169,0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .tech-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.35));
    }
    .tech-card__art--fallback {
      color: var(--light);
      font-size: 1.6rem;
    }
    .tech-card__info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }
    .tech-card__title {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
    }
    .tech-card__name {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      color: var(--text);
    }
    .tech-card__cost {
      font-size: 0.75rem;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(119,141,169,0.22);
      color: var(--light);
      letter-spacing: 0.08em;
    }
    .tech-card__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .tech-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.35);
      background: rgba(119,141,169,0.15);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card__description {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
      line-height: 1.4;
    }
    .tech-card__materials {
      margin: 0;
      padding-left: 18px;
      font-size: 0.8rem;
      color: var(--muted);
    }
    .tech-card__materials li {
      margin: 2px 0;
    }
    .tech-card__actions {
      display: flex;
      justify-content: flex-end;
      margin-top: auto;
    }
    .tech-card .unlock-btn {
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.4);
      background: transparent;
      color: var(--text);
      padding: 6px 16px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }
    .tech-card .unlock-btn:hover {
      background: rgba(119,141,169,0.35);
    }
    .tech-card .unlock-btn.unlocked {
      background: var(--success);
      border-color: var(--success);
      color: #0d1b2a;
    }
    .tech-empty {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
      font-style: italic;
    }
    /* Breeding page */
    .breeding-hero {
      position: relative;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 24px;
      padding: 28px;
      margin-bottom: 28px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.92), rgba(13, 27, 42, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.4);
      box-shadow: 0 22px 45px rgba(5, 15, 30, 0.55);
      overflow: hidden;
    }
    .breeding-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(224, 225, 221, 0.18), transparent 55%);
      pointer-events: none;
    }
    .breeding-hero__icon {
      width: 84px;
      height: 84px;
      display: grid;
      place-items: center;
      border-radius: 28px;
      background: linear-gradient(140deg, rgba(224, 225, 221, 0.25), rgba(119, 141, 169, 0.2));
      border: 1px solid rgba(224, 225, 221, 0.3);
      box-shadow: 0 18px 36px rgba(6, 18, 35, 0.4);
      font-size: 2.2rem;
      color: #fff;
    }
    .breeding-hero__content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .breeding-hero__title {
      display: flex;
      align-items: center;
      gap: 18px;
    }
    .breeding-hero__title h2 {
      margin: 0;
      font-size: 2rem;
      letter-spacing: 0.02em;
    }
    .breeding-hero__intro {
      margin: 0;
      font-size: 1.05rem;
      color: var(--light);
      max-width: 42ch;
    }
    .breeding-perks {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }
    .breeding-perks li {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95rem;
      background: rgba(13, 27, 42, 0.32);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 14px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
    }
    .breeding-perks i {
      color: var(--accent);
    }
    .breeding-hero__callout {
      position: relative;
      z-index: 1;
      align-self: stretch;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      padding: 24px;
      border-radius: 20px;
      background: linear-gradient(160deg, rgba(119, 141, 169, 0.32), rgba(13, 27, 42, 0.6));
      border: 1px solid rgba(224, 225, 221, 0.22);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .breeding-hero__callout span {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-hero__callout p {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    .breeding-workspace {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .breeding-tabs {
      position: relative;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.65);
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
      width: fit-content;
    }
    .breeding-tab {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(224, 225, 221, 0.78);
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      transition: background 0.25s ease, color 0.25s ease, border-color 0.25s ease, transform 0.25s ease;
    }
    .breeding-tab i {
      font-size: 1rem;
    }
    .breeding-tab:hover,
    .breeding-tab:focus-visible {
      color: #fff;
      transform: translateY(-1px);
    }
    .breeding-tab.active {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.9), rgba(119, 141, 169, 0.7));
      color: #0d1b2a;
      border-color: rgba(224, 225, 221, 0.65);
      box-shadow: 0 12px 24px rgba(7, 21, 36, 0.45);
    }
    .breeding-mode {
      display: none;
      border-radius: 24px;
      padding: 24px;
      background: linear-gradient(160deg, rgba(18, 34, 49, 0.78), rgba(10, 21, 33, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 18px 32px rgba(5, 15, 30, 0.48);
    }
    .breeding-mode.active {
      display: block;
    }
    .breeding-panels {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      align-items: start;
    }
    .breeding-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px;
      border-radius: 18px;
      background: rgba(13, 27, 42, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
      min-height: 100%;
    }
    .breeding-panel__header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .breeding-panel__header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-panel__description {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-panel .pal-search input {
      width: 100%;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(13, 27, 42, 0.6);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .breeding-panel .pal-search input:focus {
      outline: none;
      border-color: rgba(224, 225, 221, 0.5);
      box-shadow: 0 0 0 3px rgba(119, 141, 169, 0.25);
    }
    .pal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 14px;
      max-height: clamp(280px, 60vh, 420px);
      overflow-y: auto;
      padding: 12px;
      border-radius: 16px;
      background: rgba(9, 19, 30, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.2);
      box-shadow: inset 0 0 18px rgba(5, 15, 30, 0.45);
    }
    .pal-grid::-webkit-scrollbar {
      width: 8px;
    }
    .pal-grid::-webkit-scrollbar-track {
      background: rgba(13, 27, 42, 0.6);
      border-radius: 999px;
    }
    .pal-grid::-webkit-scrollbar-thumb {
      background: rgba(119, 141, 169, 0.45);
      border-radius: 999px;
    }
    body.kid-mode .pal-grid {
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    }
    .pal-card.compact {
      padding: 12px;
      border-radius: 14px;
      backdrop-filter: blur(2px);
    }
    .pal-card.compact img {
      width: 90px;
      height: 90px;
    }
    .pal-card.compact .name {
      font-size: 1rem;
    }
    .pal-card.compact .badge {
      font-size: 0.78rem;
    }
    .pal-card.compact .rarity {
      font-size: 0.72rem;
    }
    .pal-card.static {
      cursor: default;
    }
    .pal-card.static:hover {
      transform: none;
      background: var(--card-bg);
      box-shadow: none;
    }
    .pal-card.selectable {
      cursor: pointer;
    }
    .pal-card.selected {
      outline: 3px solid rgba(224, 225, 221, 0.55);
      box-shadow: 0 0 0 4px rgba(119, 141, 169, 0.35);
    }
    .breeding-result-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(119, 141, 169, 0.35), rgba(13, 27, 42, 0.65));
      border: 1px solid rgba(224, 225, 221, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
    }
    .breeding-result-card header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .breeding-result-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-result-card p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-result {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-flow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }
    .combo-arrow {
      font-size: 1.5rem;
      color: rgba(224, 225, 221, 0.85);
      font-weight: 700;
    }
    .breeding-tip {
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
      line-height: 1.5;
    }
    .breeding-combo-link {
      align-self: flex-start;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.85), rgba(42, 157, 143, 0.65));
      color: #0d1b2a;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      box-shadow: 0 12px 24px rgba(2, 20, 22, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .breeding-combo-link:hover,
    .breeding-combo-link:focus-visible {
      transform: translateY(-2px);
      opacity: 0.95;
      outline: none;
      box-shadow: 0 16px 32px rgba(2, 20, 22, 0.55);
    }
    .breeding-combos {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-combo {
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      align-items: center;
      gap: 10px;
      padding: 12px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(13, 27, 42, 0.75), rgba(65, 90, 119, 0.45));
      border: 1px solid rgba(119, 141, 169, 0.25);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .breeding-combo:hover,
    .breeding-combo:focus-visible {
      transform: translateY(-3px);
      box-shadow: 0 16px 28px rgba(5, 15, 30, 0.55);
      border-color: rgba(224, 225, 221, 0.45);
      outline: none;
    }
    .breeding-combo .pal-card {
      width: 100%;
      margin: 0;
    }
    .breeding-combo .pal-card + .combo-arrow {
      justify-self: center;
    }
    .breeding-workspace .pal-card .badge {
      gap: 2px;
    }
    .breeding-workspace .pal-card .badge img {
      width: 14px;
      height: 14px;
    }
    .breeding-workspace .pal-card .caught-status {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      margin-bottom: 4px;
      color: var(--text);
      background: rgba(119, 141, 169, 0.2);
      text-align: center;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="true"] {
      background: rgba(42, 157, 143, 0.25);
      color: #daf5f0;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="false"] {
      background: rgba(231, 111, 81, 0.25);
      color: #ffe0d8;
    }
    .breeding-baby-header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .breeding-baby-header h3 {
      margin: 0;
    }
    .empty-state {
      font-size: 0.92rem;
      color: rgba(224, 225, 221, 0.75);
      padding: 12px 0;
    }
    body.kid-mode .breeding-hero {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.92), rgba(65, 90, 119, 0.88));
    }
    body.kid-mode .breeding-hero__intro {
      font-size: 1rem;
    }
    body.kid-mode .breeding-panel__description,
    body.kid-mode .breeding-hero__callout p {
      font-size: 0.9rem;
    }
    @media (max-width: 1024px) {
      .breeding-hero {
        grid-template-columns: minmax(0, 1fr);
      }
      .breeding-hero__callout {
        order: 3;
      }
    }
    @media (max-width: 768px) {
      .breeding-mode {
        padding: 20px 18px;
      }
      .pal-grid {
        max-height: clamp(240px, 55vh, 360px);
      }
      .breeding-tabs {
        width: 100%;
        justify-content: center;
      }
      .breeding-combo {
        grid-template-columns: repeat(5, minmax(0, 120px));
        overflow-x: auto;
      }
    }
    /* Progress page */
    .progress-grid {
      display: grid;
      gap: 16px;
      margin-top: 16px;
    }
    @media (min-width: 640px) {
      .progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .progress-card {
      position: relative;
      padding: 18px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.85), rgba(119, 141, 169, 0.6));
      box-shadow: 0 12px 24px rgba(13, 27, 42, 0.35);
      overflow: hidden;
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .progress-card::after {
      content: '';
      position: absolute;
      inset: auto -40px -40px auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.35), transparent 70%);
      opacity: 0.8;
      pointer-events: none;
      transform: rotate(15deg);
    }
    .progress-card--hero {
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.9), rgba(119, 141, 169, 0.65));
    }
    @media (min-width: 960px) {
      .progress-card--hero {
        grid-column: span 2;
      }
    }
    .progress-card__header {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
      z-index: 1;
    }
    .progress-card__icon {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      background: rgba(13, 27, 42, 0.35);
      display: grid;
      place-items: center;
      font-size: 1.6rem;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .progress-card p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .progress-meter {
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.4);
      overflow: hidden;
      position: relative;
      z-index: 1;
    }
    .progress-meter .meter-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.6s ease;
    }
    .progress-card__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      position: relative;
      z-index: 1;
    }
    .progress-text {
      color: var(--light);
    }
    .progress-badge {
      background: rgba(13, 27, 42, 0.45);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.2);
    }
    .progress-route {
      position: relative;
      margin-top: clamp(16px, 4vw, 28px);
      padding: clamp(20px, 3vw, 32px);
      background: linear-gradient(135deg, rgba(35, 55, 88, 0.92), rgba(119, 141, 169, 0.55));
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 28px 48px rgba(8, 16, 32, 0.45);
      overflow: hidden;
      display: grid;
      gap: clamp(16px, 3vw, 28px);
    }
    .progress-route::after {
      content: '';
      position: absolute;
      inset: auto -60px -80px auto;
      width: 240px;
      height: 240px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.35), transparent 70%);
      opacity: 0.65;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .progress-route__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }
    .progress-route__intro {
      display: grid;
      gap: 10px;
      max-width: 520px;
    }
    .progress-route__intro h3 {
      margin: 0;
      font-size: clamp(1.35rem, 2.2vw, 1.65rem);
    }
    .progress-route__intro p {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
    }
    .progress-route__eyebrow {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      background: rgba(13, 27, 42, 0.45);
      padding: 6px 14px;
      border-radius: 999px;
      color: rgba(224, 225, 221, 0.85);
      font-weight: 700;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-route__eyebrow i {
      font-size: 0.85rem;
    }
    .progress-route__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .progress-route__stats {
      position: relative;
      z-index: 1;
    }
    .progress-route__next {
      margin: 0;
      font-size: 0.95rem;
      color: var(--light);
      position: relative;
      z-index: 1;
    }
    .progress-route__next strong {
      color: var(--text);
    }
    .progress-route__filters {
      position: relative;
      z-index: 1;
    }
    .progress-route__timeline {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 14px;
      padding-left: 42px;
    }
    .progress-route__timeline::before {
      content: '';
      position: absolute;
      left: 18px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: linear-gradient(180deg, rgba(224, 225, 221, 0.35), rgba(224, 225, 221, 0.05));
    }
    .progress-route__boss {
      position: relative;
      background: rgba(13, 27, 42, 0.55);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
      padding: 18px 20px 18px 22px;
      display: grid;
      gap: 10px;
      overflow: hidden;
    }
    .progress-route__boss::before {
      content: '';
      position: absolute;
      left: -30px;
      top: 22px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(119, 141, 169, 0.35);
    }
    .progress-route__boss::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), transparent 65%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .progress-route__boss:hover::after,
    .progress-route__boss:focus-within::after {
      opacity: 0.35;
    }
    .progress-route__boss-head {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .progress-route__boss-index {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(224, 225, 221, 0.14);
      color: rgba(224, 225, 221, 0.9);
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.2);
    }
    .progress-route__boss-body {
      flex: 1 1 auto;
      display: grid;
      gap: 4px;
      min-width: 0;
    }
    .progress-route__boss-body h4 {
      margin: 0;
      font-size: 1.05rem;
    }
    .progress-route__boss-body p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .progress-route__boss-status {
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      color: rgba(224, 225, 221, 0.9);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-route__boss-copy {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.82);
    }
    .progress-route__boss--complete::before {
      background: var(--success);
      box-shadow: 0 0 0 4px rgba(42, 157, 143, 0.35);
    }
    .progress-route__boss--complete .progress-route__boss-status {
      background: rgba(42, 157, 143, 0.28);
      color: #bff7ec;
      box-shadow: inset 0 0 0 1px rgba(42, 157, 143, 0.45);
    }
    .progress-route__boss--next::before {
      background: #ffd166;
      box-shadow: 0 0 0 4px rgba(255, 209, 102, 0.35);
    }
    .progress-route__boss--next .progress-route__boss-status {
      background: rgba(255, 209, 102, 0.25);
      color: #fff2c6;
      box-shadow: inset 0 0 0 1px rgba(255, 209, 102, 0.45);
    }
    .progress-route__boss--upcoming::before {
      background: rgba(119, 141, 169, 0.6);
    }
    .progress-route__boss--upcoming .progress-route__boss-status {
      background: rgba(119, 141, 169, 0.22);
      color: rgba(224, 225, 221, 0.7);
    }
    .progress-route__empty {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .route-controls {
      display: grid;
      gap: 14px;
      margin-bottom: clamp(12px, 3vw, 24px);
    }
    .route-controls__lead {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.82);
    }
    .route-controls__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .route-controls__filters {
      margin-top: 4px;
    }
    .progress-choice-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(10, 16, 29, 0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 2000;
    }
    .progress-choice-dialog {
      background: var(--card-bg);
      border-radius: 18px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      padding: 24px;
      width: min(420px, 100%);
      display: grid;
      gap: 16px;
    }
    body.kid-mode .progress-choice-dialog {
      border-radius: 22px;
    }
    .progress-choice-dialog h3 {
      margin: 0;
    }
    .progress-choice-dialog p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .progress-choice-options {
      display: grid;
      gap: 8px;
    }
    .progress-choice-option {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 8px 12px;
    }
    .progress-choice-option span {
      font-size: 0.95rem;
    }
    .progress-choice-helpers {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-helpers .btn {
      flex: 1 1 auto;
    }
    .progress-choice-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-actions .btn {
      flex: 1 1 auto;
    }
    /* Base planner styles */
    .base-planner-layout {
      display: grid;
      gap: 24px;
      align-items: stretch;
      grid-template-columns: minmax(280px, 360px) minmax(0, 1fr);
      grid-template-areas:
        "intel intel"
        "level crew";
    }
    @media (max-width: 1024px) {
      .base-planner-layout {
        grid-template-columns: 1fr;
        grid-template-areas:
          "intel"
          "level"
          "crew";
      }
    }
    .base-card {
      background: linear-gradient(145deg, rgba(30, 50, 70, 0.92), rgba(21, 36, 53, 0.92));
      border-radius: 20px;
      padding: 20px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 18px 36px rgba(8, 16, 32, 0.4);
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .base-card--intel {
      grid-area: intel;
      position: relative;
      overflow: hidden;
      padding: 28px;
    }
    .base-card--intel::before {
      content: "";
      position: absolute;
      inset: -40% -10% auto -10%;
      height: 320px;
      background: radial-gradient(circle at 50% 50%, rgba(119, 141, 169, 0.3), transparent 60%);
      opacity: 0.75;
      pointer-events: none;
      transform: rotate(2deg);
    }
    .base-card--intel > * {
      position: relative;
      z-index: 1;
    }
    .base-card--level {
      grid-area: level;
      align-self: start;
    }
    .base-card--crew {
      grid-area: crew;
    }
    .base-intel__shuffle {
      background: rgba(119, 141, 169, 0.18);
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.45);
      color: var(--light);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      padding: 6px 14px;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .base-card__header--intel {
      align-items: center;
      gap: 18px;
      flex-wrap: wrap;
    }
    .base-card__header--intel .base-card__title {
      font-size: 1.4rem;
    }
    .base-card__header--intel .base-card__meta {
      font-size: 0.95rem;
    }
    .base-intel__shuffle:hover,
    .base-intel__shuffle:focus-visible {
      background: rgba(224, 225, 221, 0.2);
      transform: translateY(-1px);
      outline: none;
    }
    .base-intel__context {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: flex-start;
      justify-content: flex-start;
      overflow-wrap: anywhere;
    }
    .base-intel-stage {
      flex: 1 1 260px;
    }
    .base-intel__controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-end;
      justify-content: flex-start;
    }
    .base-intel__hint {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.65);
      text-align: right;
    }
    @media (max-width: 640px) {
      .base-card--intel {
        padding: 22px;
      }
      .base-intel__controls {
        width: 100%;
        align-items: stretch;
      }
      .base-intel__controls .base-intel__shuffle {
        width: 100%;
        text-align: center;
      }
      .base-intel__controls .base-intel__hint {
        text-align: center;
      }
    }
    .base-intel-stage {
      font-size: 0.82rem;
      color: rgba(224, 225, 221, 0.72);
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      background: rgba(10, 21, 34, 0.6);
      border-radius: 16px;
      padding: 12px 18px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
    }
    .base-intel-stage__badge {
      background: rgba(42, 157, 143, 0.2);
      border: 1px solid rgba(42, 157, 143, 0.4);
      color: #9be8d8;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .base-intel-stage span:first-child {
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--text);
    }
    .base-intel-notes {
      position: relative;
      display: grid;
      min-height: 180px;
      padding-top: 6px;
      overflow-wrap: anywhere;
    }
    .base-note {
      position: relative;
      grid-area: 1 / 1;
      border-radius: 18px;
      padding: 16px;
      background: rgba(10, 21, 34, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.3);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
      display: flex;
      flex-direction: column;
      overflow-wrap: anywhere;
      gap: 10px;
      opacity: 0;
      transform: translateY(8px) scale(0.98);
      transition: opacity 0.45s ease, transform 0.45s ease;
      pointer-events: none;
    }
    .base-note--active {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }
    .base-note__header {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .base-note__icon {
      width: 42px;
      height: 42px;
      border-radius: 14px;
      background: rgba(119, 141, 169, 0.2);
      display: grid;
      place-items: center;
      font-size: 1.4rem;
    }
    .base-note__title {
      margin: 0;
      font-size: 1rem;
    }
    .base-note__body {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.85);
      line-height: 1.45;
      overflow-wrap: anywhere;
    }
    .base-note__title {
      overflow-wrap: anywhere;
    }
    .base-note__body + .base-note__body {
      margin-top: -4px;
    }
    .base-note__badge {
      align-self: flex-start;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(148, 210, 189, 0.18);
      color: #e0f2f1;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 210, 189, 0.35);
    }
    .base-note__footer {
      margin-top: auto;
      font-size: 0.78rem;
      color: rgba(224, 225, 221, 0.65);
    }
    body.kid-mode .base-note__body {
      font-size: 0.95rem;
    }
    .base-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }
    .base-card__title {
      margin: 0;
      font-size: 1.2rem;
    }
    .base-card__meta {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 2px;
    }
    .base-card__badge {
      align-self: flex-start;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.2);
      color: var(--light);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.3);
    }
    .base-level-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .base-level-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .base-level-summary__item {
      background: rgba(10, 22, 36, 0.55);
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .base-level-summary__label {
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .base-level-summary__value {
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--text);
    }
    .base-level-slider {
      width: 100%;
      accent-color: var(--accent);
      margin: 6px 0 4px;
    }
    .base-toggle {
      background: rgba(119, 141, 169, 0.2);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      color: var(--light);
      padding: 6px 14px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .base-toggle[aria-pressed="true"] {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .base-toggle:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .base-priority-list {
      display: grid;
      gap: 10px;
      margin: 0;
      padding: 0;
      list-style: none;
    }
    .base-priority-item {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      background: rgba(13, 27, 42, 0.65);
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-priority-item__icon {
      font-size: 1.1rem;
      line-height: 1;
    }
    .base-priority-item__content {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .base-priority-item__label {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .base-priority-item__note {
      font-size: 0.8rem;
      color: var(--muted);
      margin: 0;
    }
    .base-slot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .base-slot-card {
      position: relative;
      background: linear-gradient(155deg, rgba(25, 45, 65, 0.88), rgba(15, 28, 46, 0.92));
      border-radius: 18px;
      border: 1px solid rgba(119, 141, 169, 0.3);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .base-slot-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 18px 32px rgba(6, 14, 28, 0.45);
    }
    .base-slot-card__header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .base-slot-card__slot {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .base-slot-card__status {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(119, 141, 169, 0.18);
      color: var(--light);
    }
    .base-slot-card__status--caught {
      border-color: rgba(42, 157, 143, 0.6);
      background: rgba(42, 157, 143, 0.2);
      color: var(--success);
    }
    .base-slot-card__status--missing {
      border-color: rgba(231, 111, 81, 0.55);
      background: rgba(231, 111, 81, 0.18);
      color: var(--danger);
    }
    .base-slot-card__pal {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .base-slot-card__portrait {
      width: 72px;
      height: 72px;
      border-radius: 16px;
      background: rgba(9, 20, 34, 0.9);
      object-fit: contain;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-slot-card__info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .base-slot-card__name {
      margin: 0;
      font-size: 1rem;
    }
    .base-slot-card__types {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .base-slot-card__types img {
      width: 18px;
      height: 18px;
    }
    .base-slot-card__work {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .base-slot-card__work li {
      background: rgba(119, 141, 169, 0.18);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
      display: flex;
      gap: 6px;
      align-items: center;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-slot-card__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .base-slot-card__action {
      background: rgba(119, 141, 169, 0.15);
      border: 1px solid rgba(119, 141, 169, 0.3);
      border-radius: 999px;
      color: var(--light);
      font-size: 0.75rem;
      padding: 6px 14px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .base-slot-card__action:hover {
      background: rgba(119, 141, 169, 0.25);
      color: var(--text);
    }
    .base-slot-card__action--primary {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .base-slot-card__empty {
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 0.9rem;
      color: var(--muted);
      border: 1px dashed rgba(119, 141, 169, 0.3);
      border-radius: 18px;
      padding: 24px;
    }
    .base-coverage-grid {
      display: grid;
      gap: 10px;
    }
    .base-coverage-item {
      display: grid;
      gap: 6px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(13, 27, 42, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.2);
    }
    .base-coverage-item__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      gap: 10px;
    }
    .base-coverage-item__title {
      font-weight: 600;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .base-coverage-item__status {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .base-coverage-meter {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.18);
      overflow: hidden;
    }
    .base-coverage-meter__fill {
      height: 100%;
      background: linear-gradient(90deg, rgba(119, 141, 169, 0.8), rgba(224, 225, 221, 0.9));
      border-radius: 999px;
      transition: width 0.3s ease;
    }
    .ranch-suggestion-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 8px;
    }
    .ranch-suggestion {
      padding: 12px;
      border-radius: 12px;
      background: rgba(15, 40, 64, 0.55);
      border: 1px solid rgba(119, 141, 169, 0.2);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .ranch-suggestion__header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .ranch-suggestion__item {
      border: none;
      background: rgba(119, 141, 169, 0.15);
      color: inherit;
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-suggestion__item:hover,
    .ranch-suggestion__item:focus-visible {
      background: rgba(119, 141, 169, 0.3);
      color: var(--light);
      outline: none;
    }
    .ranch-suggestion__item[disabled] {
      cursor: not-allowed;
      opacity: 0.7;
    }
    .ranch-suggestion__reason {
      font-size: 0.9rem;
      color: var(--muted);
      flex: 1 1 160px;
    }
    .ranch-suggestion__action {
      margin: 0;
      font-size: 0.95rem;
    }
    .ranch-suggestion__producers {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .ranch-suggestion__producers--missing {
      color: var(--danger);
    }
    .ranch-suggestion__status {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.78);
    }
    .ranch-suggestion__controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .ranch-suggestion__assign {
      border: 1px solid rgba(148, 210, 189, 0.4);
      background: rgba(148, 210, 189, 0.18);
      color: #d3f5eb;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }
    .ranch-suggestion__assign:hover,
    .ranch-suggestion__assign:focus-visible {
      background: rgba(148, 210, 189, 0.35);
      color: #0b1f2f;
      outline: none;
      transform: translateY(-1px);
    }
    .ranch-suggestion__assign[aria-pressed="true"] {
      background: rgba(148, 210, 189, 0.5);
      color: #0b1f2f;
      border-color: rgba(148, 210, 189, 0.65);
    }
    .ranch-suggestion__producer-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .ranch-suggestion__producer-label {
      font-size: 0.75rem;
      color: rgba(224, 225, 221, 0.65);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .ranch-suggestion__producer {
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(13, 27, 42, 0.6);
      color: var(--light);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-suggestion__producer:hover,
    .ranch-suggestion__producer:focus-visible {
      background: rgba(119, 141, 169, 0.35);
      outline: none;
    }
    .ranch-suggestion__producer.is-selected {
      background: rgba(148, 210, 189, 0.4);
      border-color: rgba(148, 210, 189, 0.7);
      color: #0b1f2f;
    }
    .ranch-suggestion--active {
      border-color: rgba(148, 210, 189, 0.6);
      box-shadow: 0 0 0 1px rgba(148, 210, 189, 0.2);
    }
    .base-coverage-item--ranch {
      border-color: rgba(148, 210, 189, 0.45);
      background: rgba(13, 40, 52, 0.7);
    }
    .ranch-assignment-summary {
      display: grid;
      gap: 6px;
      font-size: 0.85rem;
    }
    .ranch-assignment-summary p {
      margin: 0;
    }
    .ranch-assignment-summary__action {
      margin: 0;
      color: rgba(224, 225, 221, 0.85);
    }
    .ranch-assignment-summary__clear {
      justify-self: flex-start;
      border: 1px solid rgba(231, 111, 81, 0.5);
      background: rgba(231, 111, 81, 0.15);
      color: rgba(231, 188, 172, 0.95);
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-assignment-summary__clear:hover,
    .ranch-assignment-summary__clear:focus-visible {
      background: rgba(231, 111, 81, 0.35);
      color: #fff5ef;
      outline: none;
    }
    .base-slot-card--ranch {
      border-color: rgba(148, 210, 189, 0.65);
      box-shadow: 0 0 0 1px rgba(148, 210, 189, 0.18);
    }
    .base-slot-card__assignment {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 210, 189, 0.6);
      background: rgba(148, 210, 189, 0.25);
      color: #d4f7eb;
    }
    .base-slot-card__note {
      font-size: 0.8rem;
      color: var(--muted);
      margin: 0;
    }
    .base-card__hint {
      font-size: 0.85rem;
      color: var(--muted);
      margin: 0;
    }
    /* Custom scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--primary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Top navigation bar.  We move away from the vertical sidebar and instead
       present a horizontal bar across the top of the page.  Each button
       contains an icon and label.  The active tab is highlighted
       via a coloured underline defined in CSS. -->
  <nav id="navbar" data-open="false" aria-label="Primary navigation">
    <div class="nav-shell">
      <div class="nav-brand">
        <button type="button" id="navToggle" class="nav-toggle" aria-expanded="false" aria-controls="navbarLinks" aria-label="Open navigation menu">
          <span class="sr-only">Toggle navigation</span>
          <i class="fa-solid fa-bars"></i>
        </button>
        <div class="logo">Pal Marathon</div>
      </div>
      <!-- Navigation items.  We add Home, Map, Route and Glossary to
           provide quick access to all major sections of the app.  The
           first item (Home) is active by default.  Icons chosen via
           Font Awesome provide an intuitive visual cue for each tab. -->
      <div id="navbarLinks" class="nav-links">
        <button type="button" class="nav-item active" data-page="home"><i class="fa-solid fa-house"></i><span>Home</span></button>
        <button type="button" class="nav-item" data-page="pals"><i class="fa-solid fa-paw"></i><span>Pals</span></button>
        <button type="button" class="nav-item" data-page="map"><i class="fa-solid fa-map"></i><span>Map</span></button>
        <button type="button" class="nav-item" data-page="route"><i class="fa-solid fa-road"></i><span>Route</span></button>
        <button type="button" class="nav-item" data-page="tech"><i class="fa-solid fa-cog"></i><span>Tech</span></button>
        <button type="button" class="nav-item" data-page="base"><i class="fa-solid fa-helmet-safety"></i><span>Base</span></button>
        <button type="button" class="nav-item" data-page="items"><i class="fa-solid fa-box"></i><span>Items</span></button>
        <button type="button" class="nav-item" data-page="glossary"><i class="fa-solid fa-book-open"></i><span>Glossary</span></button>
        <button type="button" class="nav-item" data-page="breeding"><i class="fa-solid fa-egg"></i><span>Breeding</span></button>
        <button type="button" class="nav-item" data-page="progress"><i class="fa-solid fa-chart-line"></i><span>Progress</span></button>
      </div>
      <!-- Mode toggle button sits on the far right.  Clicking it
           switches between Kid Mode (simplified UI) and Grown‑up
           Mode (full details).  The icon updates accordingly. -->
      <div class="nav-actions">
        <button type="button" id="modeToggle" class="mode-btn" title="Switch to grown-up mode"><i class="fa-solid fa-child"></i></button>
      </div>
    </div>
  </nav>
  <main id="content" role="main">
      <!-- Home page -->
      <section id="homePage" class="page active">
        <header class="page-header">
          <h2>Tonight’s Plan</h2>
        </header>
        <p>Welcome to Pal Marathon, your companion guide for completing Palworld with your family. Pick the presentation style that fits your crew and use the snapshots below to jump back into the adventure.</p>
        <div id="homeCards"></div>
      </section>
      <!-- Pals page -->
      <section id="palsPage" class="page">
        <header class="page-header">
          <h2>Pals</h2>
          <div class="search-bar"><input id="palSearch" type="text" placeholder="Search pals by name, type, work or drops..."></div>
        </header>
        <div id="palFilters" class="pal-filters" aria-label="Filter pals">
          <div class="pal-filters__groups">
            <div class="pal-filter-group">
              <span class="pal-filter-label" id="palFilterStatusLabel">Collection status</span>
              <div class="pal-filter-chips" role="group" aria-labelledby="palFilterStatusLabel" data-filter-group="status"></div>
            </div>
            <div class="pal-filter-group">
              <span class="pal-filter-label" id="palFilterWorkLabel">Work roles</span>
              <div class="pal-filter-chips" role="group" aria-labelledby="palFilterWorkLabel" data-filter-group="work"></div>
            </div>
          </div>
          <div class="pal-filter-tools">
            <p id="palFilterSummary" class="pal-filter-summary" aria-live="polite"></p>
            <button type="button" id="palFilterReset" class="pal-filters__reset">Reset filters</button>
          </div>
        </div>
        <div id="palsList" class="card-grid"></div>
      </section>
      <!-- Items page -->
      <section id="itemsPage" class="page">
        <header class="page-header">
          <h2>Items</h2>
          <div class="search-bar"><input id="itemSearch" type="text" placeholder="Search items..."></div>
        </header>
        <div id="itemsList" class="card-grid"></div>
      </section>
      <!-- Map page -->
      <section id="mapPage" class="page">
        <header class="page-header">
          <h2>Map</h2>
        </header>
        <p>Explore Palpagos! Toggle layers to highlight points of interest. Open the interactive map for detailed navigation.</p>
        <div id="mapLayers"></div>
        <!-- Interactive map iframe: embed the palworld.gg map directly in the app with a larger viewing window. -->
        <div id="interactiveMapWrapper" class="map-iframe-wrapper">
          <iframe id="mapIframe" src="https://palworld.gg/map" title="Palworld Interactive Map" loading="lazy"></iframe>
        </div>
      </section>
      <!-- Route page -->
      <section id="routePage" class="page"></section>
      <!-- Tech page -->
      <section id="techPage" class="page">
        <header class="page-header">
          <h2>Technology Tree</h2>
        </header>
        <p>Browse every Technology and Ancient Technology tier just like the in-game tree. Review costs, materials, and mark blueprints as you unlock them.</p>
        <div id="techList"></div>
      </section>
      <!-- Base page -->
      <section id="basePage" class="page"></section>
      <!-- Breeding page -->
      <section id="breedingPage" class="page">
        <div class="breeding-hero">
          <div class="breeding-hero__content">
            <div class="breeding-hero__title">
              <div class="breeding-hero__icon"><i class="fa-solid fa-egg"></i></div>
              <h2>Breeding Workshop</h2>
            </div>
            <p class="breeding-hero__intro">Match the perfect parents, queue up cakes and hatch legendary helpers faster with our polished Pal pairing lab.</p>
            <ul class="breeding-perks">
              <li><i class="fa-solid fa-wand-magic-sparkles"></i><span>See likely babies instantly by matching breeding power.</span></li>
              <li><i class="fa-solid fa-people-arrows"></i><span>Swap between Parent and Target modes without losing your picks.</span></li>
              <li><i class="fa-solid fa-cookie-bite"></i><span>Kid Mode reminders keep the process friendly for junior keepers.</span></li>
            </ul>
          </div>
          <div class="breeding-hero__callout">
            <span>Pro tip</span>
            <p>Keep a stack of Cakes in the farm chest and tap any combo below to auto-fill the parents. You will be incubating dream pals in no time.</p>
          </div>
        </div>
        <div class="breeding-workspace">
          <div class="breeding-tabs" role="tablist" aria-label="Breeding planner modes">
            <button type="button" id="breedingTabPredict" class="breeding-tab active" data-target="breedingPredict" role="tab" aria-controls="breedingPredict" aria-selected="true" aria-pressed="true">
              <i class="fa-solid fa-people-group"></i>
              <span>Pick parents</span>
            </button>
            <button type="button" id="breedingTabDiscover" class="breeding-tab" data-target="breedingDiscover" role="tab" aria-controls="breedingDiscover" aria-selected="false" aria-pressed="false">
              <i class="fa-solid fa-compass"></i>
              <span>Find parents</span>
            </button>
          </div>
          <div id="breedingPredict" class="breeding-mode active" role="tabpanel" aria-labelledby="breedingTabPredict" aria-hidden="false" tabindex="0">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent A</h3>
                  <p class="breeding-panel__description">Choose your first partner. Filter by pal name or elemental type.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent1Search" placeholder="Search pals" aria-label="Search parent A pals">
                </div>
                <div class="pal-grid" id="parent1Grid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent B</h3>
                  <p class="breeding-panel__description">Match a second pal to balance breeding power and passives.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent2Search" placeholder="Search pals" aria-label="Search parent B pals">
                </div>
                <div class="pal-grid" id="parent2Grid"></div>
              </article>
              <article class="breeding-result-card">
                <header>
                  <h3>Predicted egg</h3>
                  <p>We average breeding power and surface the closest baby match.</p>
                </header>
                <div class="breeding-result" id="breedingResult"></div>
              </article>
            </div>
          </div>
          <div id="breedingDiscover" class="breeding-mode" role="tabpanel" aria-labelledby="breedingTabDiscover" aria-hidden="true" tabindex="-1">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Dream pal</h3>
                  <p class="breeding-panel__description">Search for the pal you want to hatch or browse the list below.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="babySearch" placeholder="Search pals" aria-label="Search desired pals">
                </div>
                <div class="pal-grid" id="babyGrid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent recipes</h3>
                  <p class="breeding-panel__description">Tap any combo to auto-fill the parents and jump back to predictions.</p>
                </div>
                <div class="breeding-combos" id="breedingCombos"></div>
              </article>
            </div>
          </div>
        </div>
      </section>
      <!-- Progress page -->
      <section id="progressPage" class="page">
        <header class="page-header">
          <h2>Your Progress</h2>
        </header>
        <p>Keep tabs on your Pal Marathon adventure. Check off guide steps, recruit pals and unlock technology—the meters below grow as you play.</p>
        <div class="progress-grid">
          <article class="progress-card progress-card--hero">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-book-open-reader"></i></div>
              <div>
                <h3>Adventure Guide</h3>
                <p>Follow the family route and topple every tower boss.</p>
              </div>
            </div>
            <div class="progress-meter" id="guideProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="guideProgress"></div>
            </div>
            <div class="progress-card__footer" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <div style="flex:1;display:flex;flex-direction:column;gap:4px">
                <span id="guideProgressText" class="progress-text"></span>
                <span id="towersClearedBadge" class="progress-badge"></span>
              </div>
              <button class="btn" id="resetRouteProgress" type="button">Reset Guide Progress</button>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-paw"></i></div>
              <div>
                <h3>Pal Squad</h3>
                <p>Mark pals as caught when they join your crew.</p>
              </div>
            </div>
            <div class="progress-meter" id="palsProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="palsProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="palsProgressText" class="progress-text"></span>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-screwdriver-wrench"></i></div>
              <div>
                <h3>Workshop Tech</h3>
                <p>Unlock inventions to boost your base and travel.</p>
              </div>
            </div>
            <div class="progress-meter" id="techProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="techProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="techProgressText" class="progress-text"></span>
            </div>
          </article>
        </div>
        <section id="progressRouteSection" class="progress-route card">
          <div class="progress-route__header">
            <div class="progress-route__intro">
              <span class="progress-route__eyebrow"><i class="fa-solid fa-tower-broadcast"></i> Boss Route</span>
              <h3>Boss Route &amp; Progress</h3>
              <p id="progressRouteLead">Track tower victories, see what’s next, and fine-tune the route filters without leaving this page.</p>
            </div>
            <div class="progress-route__actions">
              <button type="button" class="btn" data-route-action="toggle-optional">Hide Optional</button>
              <button type="button" class="btn" data-route-action="jump-next" data-step-id="">Jump to next required</button>
            </div>
          </div>
          <div class="progress-route__stats route-overview__stats">
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-list-check"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="required-title">Required steps</p>
                  <p class="route-overview__stat-value" data-route-role="required-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="required-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="required-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="required-note">Main path objectives</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="optional-title">Optional tasks</p>
                  <p class="route-overview__stat-value" data-route-role="optional-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="optional-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="optional-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="optional-note">Bonus cleanup and prep</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-tower-broadcast"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="tower-title">Towers cleared</p>
                  <p class="route-overview__stat-value" data-route-role="tower-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="tower-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="tower-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="tower-note">Tower bosses defeated so far</p>
            </article>
          </div>
          <p class="progress-route__next" data-route-role="next-callout"></p>
          <div class="progress-route__filters" data-route-role="filters"></div>
          <div class="progress-route__timeline" id="progressBossTimeline"></div>
        </section>
      </section>
      <!-- Glossary page -->
      <section id="glossaryPage" class="page">
        <header class="page-header">
          <h2>Glossary</h2>
        </header>
        <p>Browse every passive trait, active skill, element matchup and work task in one place. Use the quick links and search boxes below to jump right to what you need.</p>
        <div id="glossaryContent"></div>
      </section>
  </main>
  <!-- Modal for pal details -->
  <div id="modal">
    <div id="modalContent">
      <button id="modalClose">Close</button>
      <div id="modalBody"></div>
    </div>
  </div>
  <script>
    // Data variables
    let PALS = {};
    let ITEMS = {};
    let TECH = [];
    let TECH_LOOKUP = {};
    let SKILL_DETAILS = {};
    let PASSIVE_DETAILS = {};
    let ITEM_DETAILS = {};
    let PARTNER_SKILLS = [];
    // Map of items to pals that drop them.  Populated after data load.
    let DROPS_MAP = {};
    // Map pal names to IDs for quick lookup when clicking breeding
    // combos.  Populated after data load.
    let PAL_NAME_TO_ID = {};
    let PAL_SLUG_TO_ID = {};
    // Persist breeding page selections between rebuilds (e.g. when switching modes)
    const BREEDING_SELECTION = { parent1Id: null, parent2Id: null, babyId: null, mode: 'breedingPredict' };
    // Progress tracking
    let caught = JSON.parse(localStorage.getItem('caught') || '{}');
    let collected = JSON.parse(localStorage.getItem('collected') || '{}');
    let unlocked = JSON.parse(localStorage.getItem('unlocked') || '{}');
    let refreshPalList = null;
    const KID_MODE_STORAGE_KEY = 'palmate:kidMode';
    // Maximum stats for scaling radar chart
    // Maximum stats for scaling radar chart.  Speed is capped lower to avoid
    // overpowering the chart – the fastest pals reach around 1000.
    const maxStats = { hp: 150, attack: 150, defense: 145, speed: 1000, stamina: 350, support: 150, food: 9 };
    // Type to environment mapping
    const environmentMap = {
      'Fire': 'Volcano',
      'Ice': 'Snow',
      'Electric': 'Coast',
      'Water': 'River',
      'Grass': 'Forest',
      'Ground': 'Desert',
      'Dark': 'Swamp',
      'Dragon': 'Mountains',
      'Air': 'Highlands',
      'Neutral': 'Plains'
    };
    // Rarity to recommended sphere
    const raritySphere = {
      1: 'Pal Sphere',
      2: 'Mega Sphere',
      3: 'Giga Sphere',
      4: 'Hyper Sphere',
      5: 'Ultra Sphere',
      6: 'Legendary Sphere'
    };
    // Human-friendly rarity names for better readability on cards and details.
    const rarityNames = {
      1: 'Common',
      2: 'Uncommon',
      3: 'Rare',
      4: 'Epic',
      5: 'Legendary',
      6: 'Mythic'
    };
    // Sphere capture rates and descriptions (approximate for guidance)
    const sphereRates = {
      'Pal Sphere': { rate: 0.3, description: 'Good for beginners and low-level pals (Lv 1-15)' },
      'Mega Sphere': { rate: 0.45, description: 'Better success for mid-level pals (Lv 16-30)' },
      'Giga Sphere': { rate: 0.6, description: 'Ideal for stronger pals (Lv 31-45)' },
      'Hyper Sphere': { rate: 0.75, description: 'Very high success for tough pals (Lv 46-60)' },
      'Ultra Sphere': { rate: 0.85, description: 'Excellent for very tough pals (Lv 61-70)' },
      'Legendary Sphere': { rate: 1.0, description: 'Guaranteed catch for legendary pals (Lv 71+)' }
    };
    // Trait lists for guidance (simplified)
    const goodTraits = ['Diligent', 'Runner', 'Strong', 'Loyal'];
    const badTraits = ['Coward', 'Lazy', 'Gullible'];

    const PALWORLD_BASE_URL = 'https://palworld.gg';
    const WORK_TYPE_DETAILS = {
      handiwork: { label: 'Handiwork', kidLabel: 'Building crew', icon: '🛠️' },
      transporting: { label: 'Transporting', kidLabel: 'Hauling crew', icon: '📦' },
      gathering: { label: 'Gathering', kidLabel: 'Picker', icon: '🎒' },
      lumbering: { label: 'Lumbering', kidLabel: 'Woodcutter', icon: '🪓' },
      mining: { label: 'Mining', kidLabel: 'Ore team', icon: '⛏️' },
      watering: { label: 'Watering', kidLabel: 'Water team', icon: '💧' },
      planting: { label: 'Planting', kidLabel: 'Seed planter', icon: '🌱' },
      kindling: { label: 'Kindling', kidLabel: 'Fire starter', icon: '🔥' },
      generating_electricity: { label: 'Electricity', kidLabel: 'Power pals', icon: '⚡' },
      cooling: { label: 'Cooling', kidLabel: 'Chillers', icon: '❄️' },
      medicine: { label: 'Medicine', kidLabel: 'Healers', icon: '💊' },
      farming: { label: 'Ranching', kidLabel: 'Ranch pals', icon: '🐑' }
    };
    const RANCH_ITEM_LIBRARY = {
      pal_sphere: {
        key: 'pal_sphere',
        name: 'Pal Sphere',
        tags: ['sphere', 'early', 'universal'],
        priority: 120,
        producers: ['Vixy'],
        openUrl: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Sphere')}`,
        reasons: {
          sphere: {
            kid: 'Pal Spheres help you catch lots of pals without shopping trips.',
            grown: 'Passive Pal Sphere income keeps capture sprees rolling between tech pushes.'
          },
          default: {
            kid: 'Pal Spheres keep your catching tools stocked up.',
            grown: 'Keep Pal Spheres flowing so every recruitment sprint stays smooth.'
          }
        }
      },
      egg: {
        key: 'egg',
        name: 'Eggs',
        tags: ['cake', 'early'],
        priority: 100,
        reasons: {
          cake: {
            kid: 'Cake batter needs lots of eggs soon.',
            grown: 'Breeding Cakes demand dozens of Eggs—build the surplus early.'
          },
          default: {
            kid: 'Eggs cook into tasty stamina snacks.',
            grown: 'Eggs keep the cooking pot productive before wheat farms scale.'
          }
        }
      },
      milk: {
        key: 'milk',
        name: 'Milk',
        tags: ['cake'],
        priority: 95,
        reasons: {
          cake: {
            kid: 'Cake cream needs lots of milk.',
            grown: 'Cake and high-tier meals burn through Milk nonstop once breeding starts.'
          },
          default: {
            kid: 'Milk keeps the cooking pot stocked.',
            grown: 'Milk covers cooking buffs while you chase late-game recipes.'
          }
        }
      },
      honey: {
        key: 'honey',
        name: 'Honey',
        tags: ['cake'],
        priority: 98,
        reasons: {
          cake: {
            kid: 'Honey is the sticky part of Cake—make sure it never runs out.',
            grown: 'Honey is the classic Cake bottleneck; automate it before the breeding rush.'
          },
          default: {
            kid: 'Honey sweetens lots of late meals.',
            grown: 'Honey supports Cake plus medicine buffs later on.'
          }
        }
      },
      wool: {
        key: 'wool',
        name: 'Wool',
        tags: ['cloth', 'cold', 'early'],
        priority: 90,
        reasons: {
          cloth: {
            kid: 'Wool spins into cloth for armor and story quests.',
            grown: 'Cloth stockpiles gate Chapter 1 prep and early armor upgrades.'
          },
          cold: {
            kid: 'Warm outfits need wool when you hike into the snow.',
            grown: 'Cold-resist armor and late gear both lean on a deep Wool reserve.'
          },
          default: {
            kid: 'Wool keeps the tailor busy.',
            grown: 'Wool converts to Cloth, blankets, and winter gear.'
          }
        }
      },
      high_quality_pal_oil: {
        key: 'high_quality_pal_oil',
        name: 'High Quality Pal Oil',
        tags: ['oil', 'advanced'],
        priority: 70,
        reasons: {
          oil: {
            kid: 'Factory parts and Polymer eat lots of shiny oil.',
            grown: 'Polymer, firearms, and Production Lines guzzle High Quality Pal Oil.'
          },
          default: {
            kid: 'Oil helps late-game machines work.',
            grown: 'HQ Pal Oil keeps late factories and weapon benches humming.'
          }
        }
      },
      pal_fluids: {
        key: 'pal_fluids',
        name: 'Pal Fluids',
        tags: ['medicine', 'advanced'],
        priority: 60,
        reasons: {
          medicine: {
            kid: 'Medicine benches and hot springs sip Pal Fluids.',
            grown: 'Electric and advanced medicine benches plus Hot Springs consume Pal Fluids constantly.'
          },
          default: {
            kid: 'Pal Fluids help heal pals.',
            grown: 'Pal Fluids feed medicine production and luxury baths.'
          }
        }
      }
    };
    const WORK_KEY_ALIASES = {
      medicine_production: 'medicine',
      electricity: 'generating_electricity'
    };
    const BASE_TECH_KEYWORDS = ['base', 'ranch', 'plantation', 'farm', 'logging', 'pit', 'furnace', 'generator', 'mill', 'feed', 'palbox', 'cooler', 'monitoring', 'breeding', 'workbench', 'assembly', 'refinery', 'hot spring'];
    const BASE_TECH_THRESHOLDS = [
      { techLevel: 1, level: 1 },
      { techLevel: 4, level: 2 },
      { techLevel: 7, level: 3 },
      { techLevel: 10, level: 4 },
      { techLevel: 15, level: 5 },
      { techLevel: 20, level: 6 },
      { techLevel: 28, level: 7 },
      { techLevel: 36, level: 8 },
      { techLevel: 45, level: 9 },
      { techLevel: 55, level: 10 }
    ];
    const BASE_INTEL_ROTATION_INTERVAL = 12000;
    const MEDICINE_TECH_NAMES = [
      'Medieval Medicine Workbench',
      'Electric Medicine Workbench',
      'Advanced Medicine Workbench'
    ];
    const FURNACE_TECH_NAMES = ['Primitive Furnace', 'Improved Furnace', 'Electric Furnace', 'Gigantic Furnace'];
    const POWER_TECH_NAMES = ['Human-Powered Generator', 'Power Generator', 'Production Assembly Line'];
    const BASE_STAGE_OVERVIEWS = {
      ch0: {
        icon: '🛖',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kid: {
          title: 'Build the starter camp',
          lines: [
            'Place the Palbox and Primitive Workbench so helpers know where to work.',
            'Add a Feed Box early so Lamballs and Cattiva stay happy while you learn jobs.'
          ]
        },
        grown: {
          title: 'Anchor Base #1',
          lines: [
            'Palbox + Primitive Workbench unlock automation toggles and your first crafting loop.',
            'A Feed Box right away keeps stamina downtime low as you juggle early chores.'
          ]
        }
      },
      ch1: {
        icon: '🎯',
        kid: {
          title: 'Make Pal Spheres nonstop',
          lines: [
            'Catch a Vixy and let it live on the Ranch—it digs up Pal Spheres for free.',
            'Logging Sites and Stone Pits keep wood and rocks ready for sphere crafting.'
          ]
        },
        grown: {
          title: 'Sphere supply & early automation',
          lines: [
            'Ranch a Vixy early; its unique ranch output is Pal Spheres, perfect for the capture spike.',
            'Automate wood and stone so Crusher + workbenches never stall while you push Tech Lv 8.'
          ]
        }
      },
      ch2: {
        icon: '🍰',
        kid: {
          title: 'Bake Cake ingredients',
          lines: [
            'Build a Wheat Plantation, Mill, and Cooking Pot so batter is always ready.',
            'Catch Mozzarina for milk, Chikipi for eggs, and Beegarde for honey.'
          ]
        },
        grown: {
          title: 'Farm lines for Cake & ingots',
          lines: [
            'Primitive Furnace plus Wheat → Mill → Cooking Pot is the midgame backbone.',
            'Secure Mozzarina, Chikipi, and Beegarde so milk, eggs, and honey flow into Cakes.'
          ]
        }
      },
      ch3: {
        icon: '❄️',
        kid: {
          title: 'Keep food cold',
          lines: [
            'A Cooler Box keeps snacks fresh while you travel through the snow.',
            'Leave strong fire pals on the furnace so metal keeps cooking.'
          ]
        },
        grown: {
          title: 'Snow prep & smelting uptime',
          lines: [
            'Cooler Box coverage protects food during long northern expeditions.',
            'Stack high-level Kindling on furnaces so refined ingots stay ahead of tech unlocks.'
          ]
        }
      },
      ch4: {
        icon: '🗺️',
        kid: {
          title: 'Plan Base Three',
          lines: [
            'Pick a desert or ice cliff for coal and shiny quartz.',
            'Bring pals that can mine, haul, and cool things down.'
          ]
        },
        grown: {
          title: 'Chart the resource campus',
          lines: [
            'Scout a coal/quartz plateau for Base #3 once base level 15 unlocks.',
            'Reserve strong Mining, Transporting, and Cooling pals for the expansion site.'
          ]
        }
      },
      ch5: {
        icon: '🌋',
        kid: {
          title: 'Heat-proof the factory',
          lines: [
            'Fire pals handle furnaces while Water pals cool food in the volcano zone.',
            'Pack extra feed so workers recover fast after hot jobs.'
          ]
        },
        grown: {
          title: 'Volcano logistics',
          lines: [
            'Keep Heat-resistant pals on furnaces and move spare Water/Cooling pals onto fridges.',
            'Stockpile coal and refine ore nonstop so weapon upgrades stay on schedule.'
          ]
        }
      },
      ch6: {
        icon: '⚡',
        kid: {
          title: 'Power every station',
          lines: [
            'Strong Electric pals should live on generators so machines keep running.',
            'Have one healer ready for surprise damage.'
          ]
        },
        grown: {
          title: 'Generator & support focus',
          lines: [
            'Marcus & Faleris prep demands continuous power—assign resilient Electricity pals to every generator.',
            'Begin rotating a medicine specialist so revives and first aid are covered.'
          ]
        }
      },
      ch7: {
        icon: '🩺',
        kid: {
          title: 'Keep everyone healed',
          lines: [
            'Unlock the fancy medicine tables and let a gentle pal run them.',
            'Double-check that fridges stay cold for late-game cooking.'
          ]
        },
        grown: {
          title: 'Late-game clinic & cooling',
          lines: [
            'Shadowbeak runs demand medkits—rotate high Medicine pals onto the bench when you unlock it.',
            'Cooling + Electricity coverage keeps the endgame assembly lines from stalling.'
          ]
        }
      },
      ch8: {
        icon: '🌸',
        kid: {
          title: 'Sakurajima supplies',
          lines: [
            'Bring extra gardeners so new crops grow fast in the pink isles.',
            'Swap pals between bases so power and cooling stay strong.'
          ]
        },
        grown: {
          title: 'Selyne support loop',
          lines: [
            'Balance Electricity, Cooling, and Medicine so Sakurajima recipes finish while you raid the island.',
            'Stage extra honey and flour so Cake breeding chains never pause.'
          ]
        }
      },
      ch9: {
        icon: '🛡️',
        kid: {
          title: 'Feybreak finale prep',
          lines: [
            'Make sure generators, coolers, and ranch pals are all full so battles stay easy.',
            'Keep your strongest pals rested before big fights.'
          ]
        },
        grown: {
          title: 'Feybreak sustain',
          lines: [
            'Max out power, cooling, and medicine coverage so Bastigor attempts always start with fresh stocks.',
            'Rotate Artisan handiwork pals so endgame ammo and armor finish quickly.'
          ]
        }
      },
      default: {
        icon: '🛠️',
        kid: {
          title: 'Keep the base happy',
          lines: [
            'Make sure someone builds, someone cooks, and someone carries goodies.',
            'Swap pals between jobs if a meter drops low.'
          ]
        },
        grown: {
          title: 'Balance the roster',
          lines: [
            'Watch your coverage meters—shift pals toward weak jobs to keep automation humming.',
            'Rotate captures based on upcoming tech unlocks so nothing bottlenecks the route.'
          ]
        }
      }
    };
    const BASE_STEP_NOTE_OVERRIDES = {
      'ch0-base-foundation': {
        icon: '🪵',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Place the Palbox',
        grownTitle: 'Anchor your first base',
        kidLines: [
          'Drop the Palbox and Primitive Workbench so pals know where to work.',
          'This lets Palmate track jobs for the Base planner.'
        ],
        grownLines: [
          'Palbox + Primitive Workbench unlocks automation toggles and fast access to build menus.',
          'Log the unlock in Palmate so route detection stays accurate.'
        ]
      },
      'ch0-base-feedbox': {
        icon: '🥕',
        badge: { kid: 'Bonus', grown: 'Optional' },
        kidTitle: 'Set up the Feed Box',
        grownTitle: 'Automate feeding',
        kidLines: [
          'A Feed Box keeps Lamball and Cattiva fed while you adventure.',
          'It stops work breaks from hunger.'
        ],
        grownLines: [
          'Early Feed Box placement keeps stamina downtime low as you expand Base #1.',
          'Even though optional, it speeds every other job immediately.'
        ]
      },
      'ch1-base-alarm-monitor': {
        icon: '🔔',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Build the alert bell',
        grownTitle: 'Set up alert network',
        kidLines: [
          'An Alarm Bell and Monitoring Stand warn you if pals get sleepy or hungry.',
          'Check in when it rings so work keeps going.'
        ],
        grownLines: [
          'Alarm Bell now, Monitoring Stand at Tech Lv 15 keeps downtime visible even when you roam.',
          'Pair it with rested Transporting pals so deliveries keep moving.'
        ]
      },
      'ch1-base-resource-sites': {
        icon: '🏭',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Build wood & rock helpers',
        grownTitle: 'Automate logs and stone',
        kidLines: [
          'Logging Sites and Stone Pits mean pals haul wood and rocks all day.',
          'Put a Crusher nearby so ore turns into Paldium for Pal Spheres.'
        ],
        grownLines: [
          'Drop Logging Site + Stone Pit at Tech Lv 7, then add a Crusher at Lv 8.',
          'This fuels sphere crafting and furnace inputs while you chase Zoe.'
        ]
      },
      'ch1-base-hot-spring': {
        icon: '🛁',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Hot Spring break',
        grownTitle: 'Install the Hot Spring',
        kidLines: [
          'A Hot Spring helps pals rest fast when they get tired.',
          'Keep it near the work sites so breaks are quick.'
        ],
        grownLines: [
          'Hot Springs dramatically shorten rest cycles—place one between crafting and furnace rows.',
          'It offsets the workload spike once Crusher and furnaces come online.'
        ]
      },
      'ch2-base-furnace': {
        icon: '🔥',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Light the furnace',
        grownTitle: 'Staff the Primitive Furnace',
        kidLines: [
          'Build the Primitive Furnace and leave two fire pals to keep it hot.',
          'Ingots are needed for saddles and better tools.'
        ],
        grownLines: [
          'Primitive Furnace unlocks at Tech Lv 10—assign high Kindling pals immediately.',
          'Parallel furnaces prevent metal bottlenecks during the cake/flyer rush.'
        ]
      },
      'ch2-base-farm-line': {
        icon: '🌾',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Start the wheat line',
        grownTitle: 'Build the Cake chain',
        kidLines: [
          'Plant wheat, grind flour, and cook it so Cake batter is ready.',
          'Let Water pals splash plantations so crops grow fast.'
        ],
        grownLines: [
          'Wheat Plantation + Mill + Cooking Pot should sit in one loop with Watering pals on call.',
          'Keep flour ahead of honey to avoid the Cake bottleneck once breeding opens.'
        ]
      },
      'ch2-base-ranch': {
        icon: '🍯',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Ranch sweet treats',
        grownTitle: 'Assign ranch producers',
        kidLines: [
          'Give Chikipi, Mozzarina, and Beegarde ranch jobs for eggs, milk, and honey.',
          'Those goodies turn into Cake for baby pals.'
        ],
        grownLines: [
          'Chikipi (eggs), Mozzarina (milk), and Beegarde/Elizabee (honey) cover the Cake recipe.',
          'Stage storage near the Cooking Pot so ingredients stay topped off.'
        ]
      },
      'ch2-base-new-site': {
        icon: '🏞️',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Place Base Two',
        grownTitle: 'Establish the ore campus',
        kidLines: [
          'Hit base level 10 then drop Base Two near a cliff packed with ore.',
          'Fly back often to empty the boxes.'
        ],
        grownLines: [
          'Base Lv 10 unlock lets you settle the Desolate Church ridge or similar ore shelf.',
          'Anchor furnaces and storage there to supercharge metal throughput.'
        ]
      },
      'roster-mining': {
        icon: '⛏️',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Keep miners ready',
        grownTitle: 'Mining lineup',
        kidLines: [
          'Have two or three mining pals like Digtoise or Rushoar working ore.',
          'Swap in stronger pals later like Anubis.'
        ],
        grownLines: [
          'Maintain at least two Mining specialists (Digtoise, Rushoar, Anubis) at every base.',
          'Their ore feed powers furnaces, Crusher, and sphere crafting simultaneously.'
        ]
      },
      'roster-lumber': {
        icon: '🪓',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Wood team',
        grownTitle: 'Lumber coverage',
        kidLines: [
          'Two lumber pals like Tanzee or Eikthyrdeer keep planks coming.',
          'Wood fuels Pal Spheres and building upgrades.'
        ],
        grownLines: [
          'Assign two Lumbering pals (Tanzee, Eikthyrdeer, or Dinossom) so planks and beams never stall builds.',
          'Combine with Transporters to keep Logging Site outputs moving.'
        ]
      },
      'roster-transport': {
        icon: '🚚',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Hauling pals',
        grownTitle: 'Transport loop',
        kidLines: [
          'Use fliers like Vixy or Pengullet to move items fast.',
          'Vixy on the Ranch can also dig up bonus Pal Spheres.'
        ],
        grownLines: [
          'Keep two dedicated Transporting pals—Pengullet, Vixy, or Fenglope—to prevent crafting clogs.',
          'Bonus: Vixy ranch duty produces Pal Spheres while it isn’t hauling.'
        ]
      },
      'roster-kindling': {
        icon: '🔥',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Fire pals',
        grownTitle: 'Kindling core',
        kidLines: [
          'Foxparks and later Ragnahawk should stay on furnaces and ovens.',
          'They make metal bars super fast.'
        ],
        grownLines: [
          'Maintain two high-level Kindling pals—Foxparks, Arsox, Ragnahawk—to keep furnaces blazing.',
          'Metal throughput is the gate on weapons, armor, and Cake cookware.'
        ]
      },
      'roster-watering': {
        icon: '💧',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Water team',
        grownTitle: 'Water & cooling',
        kidLines: [
          'Pengullet or Fuack can water crops and chill fridges.',
          'Cold pals keep food from spoiling.'
        ],
        grownLines: [
          'At least two Watering/Cooling pals (Pengullet, Surfent, Jormuntide) keep plantations and fridges online.',
          'Balance them between Cake production and exploration prep.'
        ]
      },
      'roster-handiwork': {
        icon: '🛠️',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Crafting pals',
        grownTitle: 'Handiwork trio',
        kidLines: [
          'Have three builders with Handywork so stations finish quick.',
          'Traits like Artisan make them even faster.'
        ],
        grownLines: [
          'Run three Handiwork specialists (Artisan trait preferred) so benches, ammo, and armor queue smoothly.',
          'Rotate extras into training to chase perfect passives.'
        ]
      },
      'roster-ranch': {
        icon: '🐝',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Ranch crew',
        grownTitle: 'Ranch rotation',
        kidLines: [
          'Keep ranch pals like Chikipi, Mozzarina, and Beegarde working the pens.',
          'They make eggs, milk, and honey while you explore.'
        ],
        grownLines: [
          'Reserve one or two ranch slots for Cake staples plus specialty drops (Vixy for Pal Spheres, Wool pals for cloth).',
          'Swap outputs based on the tech you are chasing next.'
        ]
      },
      'ch3-base-cooler': {
        icon: '❄️',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Cool the snacks',
        grownTitle: 'Install Cooler Box',
        kidLines: [
          'Build a Cooler Box so meat and berries stay fresh in the snow.',
          'Keep a Water or Ice pal nearby to power it.'
        ],
        grownLines: [
          'Cooler Box prevents spoilage during long Lily expeditions—staff it with Cooling pals before you leave.',
          'Pair it with Wheat + Honey stores so Cake baking continues while you travel.'
        ]
      },
      'ch4-base-plan': {
        icon: '🧭',
        badge: { kid: 'Optional', grown: 'Optional' },
        kidTitle: 'Plan the next base',
        grownTitle: 'Sketch Base #3',
        kidLines: [
          'Draw where Base Three will go—desert coal or icy quartz spots are best.',
          'List which pals you need to move there.'
        ],
        grownLines: [
          'Scout a plateau with dense coal/quartz for Base #3 and note which pals will migrate.',
          'Queue transporters and miners to follow once the slot unlocks.'
        ]
      }
    };
    let baseIntelState = { notes: [], activeIndex: 0, rotationTimer: null };
    const BASE_LEVEL_CONFIG = [
      {
        level: 1,
        label: 'Starter Camp',
        slots: 5,
        preferredRarity: 2,
        defaultWeight: 0.25,
        focus: ['Handiwork', 'Lumbering', 'Transporting'],
        copy: {
          kid: 'Keep the first camp busy with helpers who build, haul and chop wood.',
          grown: 'Lean on quick builders, haulers and lumber crews to finish early structures.'
        },
        workWeights: {
          handiwork: 1.2,
          transporting: 1.0,
          gathering: 0.85,
          lumbering: 1.1,
          mining: 0.9,
          watering: 0.55,
          planting: 0.45,
          kindling: 0.65,
          generating_electricity: 0.25,
          cooling: 0.2,
          medicine: 0.15,
          farming: 0.5
        }
      },
      {
        level: 2,
        label: 'Settled Outpost',
        slots: 7,
        preferredRarity: 2,
        defaultWeight: 0.25,
        focus: ['Handiwork', 'Mining', 'Watering'],
        copy: {
          kid: 'Add pals who can mine rock and carry water so crafting never pauses.',
          grown: 'Expand stone, water and handiwork coverage to unlock stronger buildings.'
        },
        workWeights: {
          handiwork: 1.15,
          transporting: 0.95,
          gathering: 0.7,
          lumbering: 1.05,
          mining: 1.0,
          watering: 0.7,
          planting: 0.55,
          kindling: 0.7,
          generating_electricity: 0.3,
          cooling: 0.2,
          medicine: 0.15,
          farming: 0.55
        }
      },
      {
        level: 3,
        label: 'Growing Workshop',
        slots: 9,
        preferredRarity: 3,
        defaultWeight: 0.25,
        focus: ['Mining', 'Kindling', 'Watering'],
        copy: {
          kid: 'Fire pals and miners keep furnaces roaring while water pals feed farms.',
          grown: 'Balance ore, furnaces and early crops so metal tools arrive on schedule.'
        },
        workWeights: {
          handiwork: 1.1,
          transporting: 0.9,
          gathering: 0.65,
          lumbering: 1.0,
          mining: 1.1,
          watering: 0.75,
          planting: 0.6,
          kindling: 0.75,
          generating_electricity: 0.35,
          cooling: 0.25,
          medicine: 0.2,
          farming: 0.6
        }
      },
      {
        level: 4,
        label: 'Elemental Shift',
        slots: 11,
        preferredRarity: 3,
        defaultWeight: 0.25,
        focus: ['Kindling', 'Watering', 'Planting'],
        copy: {
          kid: 'Fire pals light furnaces while garden pals grow berries for food.',
          grown: 'Kindling and irrigation ramp up production for cooking pots and plantations.'
        },
        workWeights: {
          handiwork: 1.0,
          transporting: 0.85,
          gathering: 0.6,
          lumbering: 0.95,
          mining: 1.1,
          watering: 0.8,
          planting: 0.7,
          kindling: 0.85,
          generating_electricity: 0.45,
          cooling: 0.3,
          medicine: 0.25,
          farming: 0.65
        }
      },
      {
        level: 5,
        label: 'Production Hub',
        slots: 13,
        preferredRarity: 4,
        defaultWeight: 0.25,
        focus: ['Planting', 'Watering', 'Kindling'],
        copy: {
          kid: 'Big farms need pals to plant, water and cook lots of food.',
          grown: 'Stabilise plantations, ranching and furnaces to support long craft queues.'
        },
        workWeights: {
          handiwork: 0.95,
          transporting: 0.8,
          gathering: 0.55,
          lumbering: 0.9,
          mining: 1.0,
          watering: 0.95,
          planting: 0.85,
          kindling: 0.9,
          generating_electricity: 0.55,
          cooling: 0.35,
          medicine: 0.3,
          farming: 0.75
        }
      },
      {
        level: 6,
        label: 'Powered Base',
        slots: 15,
        preferredRarity: 4,
        defaultWeight: 0.25,
        focus: ['Kindling', 'Planting', 'Electricity'],
        copy: {
          kid: 'Electric pals join the team so machines and fridges can stay on.',
          grown: 'Introduce generators without losing momentum on crops, cooking and smelting.'
        },
        workWeights: {
          handiwork: 0.9,
          transporting: 0.8,
          gathering: 0.5,
          lumbering: 0.85,
          mining: 0.95,
          watering: 1.0,
          planting: 0.9,
          kindling: 1.0,
          generating_electricity: 0.7,
          cooling: 0.45,
          medicine: 0.35,
          farming: 0.8
        }
      },
      {
        level: 7,
        label: 'Industrial Yard',
        slots: 17,
        preferredRarity: 5,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Watering', 'Planting'],
        copy: {
          kid: 'Power pals, gardeners and farmers keep every station buzzing.',
          grown: 'Push automation with strong generators while maintaining crop uptime.'
        },
        workWeights: {
          handiwork: 0.85,
          transporting: 0.75,
          gathering: 0.45,
          lumbering: 0.8,
          mining: 0.95,
          watering: 1.0,
          planting: 0.95,
          kindling: 1.05,
          generating_electricity: 0.85,
          cooling: 0.55,
          medicine: 0.4,
          farming: 0.85
        }
      },
      {
        level: 8,
        label: 'Balanced Campus',
        slots: 19,
        preferredRarity: 5,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Planting', 'Cooling'],
        copy: {
          kid: 'Keep the farm happy and the fridges cold while power stays green.',
          grown: 'Manage cooling, generators and plantations to prep for late-game crafting.'
        },
        workWeights: {
          handiwork: 0.8,
          transporting: 0.75,
          gathering: 0.45,
          lumbering: 0.75,
          mining: 0.9,
          watering: 1.0,
          planting: 1.0,
          kindling: 1.05,
          generating_electricity: 0.95,
          cooling: 0.7,
          medicine: 0.55,
          farming: 0.9
        }
      },
      {
        level: 9,
        label: 'Advanced Facility',
        slots: 22,
        preferredRarity: 6,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Cooling', 'Medicine'],
        copy: {
          kid: 'Science pals join to heal friends and power fancy machines.',
          grown: 'Late-game tech leans on reliable energy, refrigeration and medical coverage.'
        },
        workWeights: {
          handiwork: 0.75,
          transporting: 0.7,
          gathering: 0.4,
          lumbering: 0.7,
          mining: 0.85,
          watering: 1.05,
          planting: 1.05,
          kindling: 1.1,
          generating_electricity: 1.05,
          cooling: 0.85,
          medicine: 0.7,
          farming: 0.95
        }
      },
      {
        level: 10,
        label: 'Prime Headquarters',
        slots: 25,
        preferredRarity: 6,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Medicine', 'Ranching'],
        copy: {
          kid: 'Your dream base runs on power pals, healers and ranch hands.',
          grown: 'Cover every specialty—power grids, cooling, medicine and ranch outputs stay maxed.'
        },
        workWeights: {
          handiwork: 0.7,
          transporting: 0.7,
          gathering: 0.4,
          lumbering: 0.65,
          mining: 0.8,
          watering: 1.05,
          planting: 1.05,
          kindling: 1.1,
          generating_electricity: 1.15,
          cooling: 0.95,
          medicine: 0.85,
          farming: 1.0
        }
      }
    ];
    const BASE_PLANNER_STORAGE_KEY = 'palmate:basePlanner';
    let basePlannerState = loadBasePlannerState();
    let basePlannerElements = {};
    let MAX_WORK_LEVEL = 4;

    // Whether we’re in Kid Mode.  Kid Mode simplifies the UI by
    // enlarging fonts, hiding advanced stats and using shorter
    // explanations.  Remember the user’s previous choice so the
    // experience stays consistent between visits.
    const savedKidMode = localStorage.getItem(KID_MODE_STORAGE_KEY);
    let kidMode = savedKidMode === null ? true : savedKidMode === 'true';
    document.body.classList.toggle('kid-mode', kidMode);
    persistKidMode();

    const WORK_ROLE_COPY = {
      kindling: { kid: 'Fire helper', grown: 'Kindling' },
      watering: { kid: 'Watering', grown: 'Watering' },
      planting: { kid: 'Plant seeds', grown: 'Planting' },
      generating_electricity: { kid: 'Make power', grown: 'Generating Electricity' },
      transporting: { kid: 'Carry items', grown: 'Transporting' },
      handiwork: { kid: 'Crafting', grown: 'Handiwork' },
      gathering: { kid: 'Gathering', grown: 'Gathering' },
      lumbering: { kid: 'Chop wood', grown: 'Lumbering' },
      mining: { kid: 'Mining', grown: 'Mining' },
      medicine: { kid: 'Healing', grown: 'Medicine' },
      medicine_production: { kid: 'Brew medicine', grown: 'Medicine Production' },
      cooling: { kid: 'Cooling', grown: 'Cooling' },
      farming: { kid: 'Ranch helper', grown: 'Farming' }
    };

    function getWorkRoleLabel(role){
      const entry = WORK_ROLE_COPY[role];
      const fallback = niceName(role);
      if(entry){
        const label = kidMode ? entry.kid : entry.grown;
        return label || fallback;
      }
      return fallback;
    }

    // Descriptions for active skills.  Each entry maps the skill key
    // (as it appears in the data) to a human-friendly object with
    // damage, type (AoE, cone, single-target) and a brief description
    // gleaned from community knowledge and official guides.  When
    // unknown, we provide a generic description encouraging players to
    // experiment.  Feel free to extend this dictionary with more
    // abilities as you discover them.
    const defaultSkillsDictionary = {
      'rolly_poly': { name:'Roly Poly', damage:'Low', type:'Charge', description:'Curls into a ball and rolls after foes; be careful as you may become dizzy afterwards' },
      'air_cannon': { name:'Air Cannon', damage:'Moderate', type:'Projectile', description:'Fires compressed air that pushes enemies back in a line' },
      'power_shot': { name:'Power Shot', damage:'Moderate', type:'Projectile', description:'Charges up and fires a strong projectile at a single target' },
      'implode': { name:'Implode', damage:'Massive', type:'Area', description:'Self-destructs in a powerful explosion harming all nearby – the user faints afterwards' },
      'electric_ball': { name:'Electric Ball', damage:'High', type:'Projectile', description:'Launches a ball of lightning that zaps enemies on contact' },
      'dragon_burst': { name:'Dragon Burst', damage:'High', type:'Area', description:'Unleashes draconic energy in a burst around the user' },
      'fire_blast': { name:'Fire Blast', damage:'High', type:'Cone', description:'Breathes fire in a wide cone, burning anything in its path' },
      'leaf_dance': { name:'Leaf Dance', damage:'Moderate', type:'Area', description:'Summons swirling leaves that slice nearby enemies' },
      // Additional skills with descriptions derived from the Palworld Wiki【841863502450800†L124-L156】.  These give
      // players a better sense of each move’s effect.
      'acid_rain': { name:'Acid Rain', damage:'Moderate', type:'Area', description:'Creates acidic clouds that pour down rain on enemies' },
      'air_blade': { name:'Air Blade', damage:'Moderate', type:'Fan', description:'Sends out sharp blades of air in a fan shape' },
      'apocalypse': { name:'Apocalypse', damage:'High', type:'Area', description:'Generates several dark vortexes in the surrounding area' },
      'aqua_burst': { name:'Aqua Burst', damage:'High', type:'Projectile', description:'Creates a giant ball of water and hurls it at an enemy' },
      'aqua_gun': { name:'Aqua Gun', damage:'Low', type:'Projectile', description:'Hurls a ball of water straight at an enemy' },
      'beam_slicer': { name:'Beam Slicer', damage:'Very High', type:'Beam', description:'Mows down the frontal area with a dragon beam; the impacted area explodes shortly after' },
      'blast_cannon': { name:'Blast Cannon', damage:'High', type:'Projectile', description:'Fires an energy bullet imbued with dragon power that explodes on impact' },
      'blizzard_spike': { name:'Blizzard Spike', damage:'Very High', type:'Projectile', description:'Creates a giant lump of ice and hurls it; damages those in the surrounding area upon impact' },
      'bog_blast': { name:'Bog Blast', damage:'Low', type:'Projectile', description:'Hurls sticky mud at an enemy' },
      'bubble_blast': { name:'Bubble Blast', damage:'Moderate', type:'Homing', description:'Fires numerous bubbles that slowly pursue an enemy' },
      'circle_vine': { name:'Circle Vine', damage:'High', type:'Area', description:'Sprouts sharp roots in and around the enemy’s location' },
      'comet_strike': { name:'Comet Strike', damage:'High', type:'Area', description:'Drops a meteorite straight down, generating a shock wave around the impact area' },
      'cryst_breath': { name:'Cryst Breath', damage:'High', type:'Cone', description:'Enshrouds an enemy in a frigid blast of air, dealing continuous damage' },
      'dark_arrow': { name:'Dark Arrow', damage:'Moderate', type:'Homing', description:'Fires off dark energy that homes in on an enemy' },
      'dark_ball': { name:'Dark Ball', damage:'Low', type:'Homing', description:'Unleashes a sphere of darkness that slowly tracks down the enemy' },
      'dark_cannon': { name:'Dark Cannon', damage:'Moderate', type:'Projectile', description:'Fires off dark energy that homes in on an enemy' },
      'dark_laser': { name:'Dark Laser', damage:'Very High', type:'Beam', description:'Charges dark energy before blasting enemies with a powerful beam' },
      'diamond_rain': { name:'Diamond Rain', damage:'Very High', type:'Area', description:'Creates numerous lumps of ice that consecutively drop on a foe’s head' },
      'draconic_breath': { name:'Draconic Breath', damage:'Moderate', type:'Cone', description:'Exhales breath imbued with draconic energy, dealing continuous damage to those in front' },
      'dragon_cannon': { name:'Dragon Cannon', damage:'Low', type:'Projectile', description:'Hurls an energy ball imbued with draconic energy at an enemy' },
      'dragon_meteor': { name:'Dragon Meteor', damage:'Very High', type:'Area', description:'Calls down numerous small meteorites and launches them at an enemy' },
      'fire_ball': { name:'Fire Ball', damage:'Very High', type:'Projectile', description:'Creates a giant ball of flames and hurls it; it explodes over a wide area upon impact' },
      'flame_funnel': { name:'Flame Funnel', damage:'High', type:'Area', description:'Creates multiple spheres of fiery energy, from which countless fireballs shoot towards the enemy' },
      'flame_wall': { name:'Flame Wall', damage:'High', type:'Area', description:'Creates a wall of flames at the enemy’s location; the wall remains and deals damage over time' },
      'flare_arrow': { name:'Flare Arrow', damage:'Moderate', type:'Homing', description:'Fires three flaming arrows in succession that home in on an enemy' },
      'flare_storm': { name:'Flare Storm', damage:'Moderate', type:'Area', description:'Generates two flaming tornadoes on either side before launching them at an enemy' }
    };
    let skillsDictionary = { ...defaultSkillsDictionary };

    // Descriptions for passive traits.  Each entry summarises the
    // benefits or drawbacks of the trait.  We extracted a few from
    // community guides and added our own commentary for others.  Add
    // additional traits here as needed.  Traits not present here
    // will display a generic encouragement to experiment.
    const defaultTraitsDictionary = {
      'Swift': 'Increases movement speed by 30%, letting your pal dash around quickly',
      'Legend': 'Raises Attack and Defense by 20% and Movement Speed by 15%',
      'Lord of the Sea': 'Increases Water attack damage by 20%',
      'Runner': 'Boosts movement speed by 20%',
      'Diligent': 'Raises work efficiency, making jobs go 20% faster',
      'Strong': 'Increases attack damage by 20%',
      'Loyal': 'Improves Attack and Defense slightly (about 10%)',
      'Coward': 'Lowers Attack and Defense by 10%; this pal gets scared easily',
      'Lazy': 'Decreases work speed by 20%, making tasks take longer',
      'Gullible': 'More susceptible to negative status effects; be wary when battling'
    };
    let traitsDictionary = { ...defaultTraitsDictionary };

    // Mapping of environment names to highlight coordinates.  Each
    // environment corresponds to a circular highlight on the map.  The
    // x and y values represent the percentage offsets from the top-left
    // corner of the map image, while w and h represent the diameter
    // percentages of the highlight.  These were chosen manually to
    // approximate the Palworld regions and provide a more natural
    // spotlight compared to boxy overlays.
    const zonePositions = {
      'Volcano': { x: 68, y: 10, w: 30, h: 30 },
      'Snow': { x: 10, y: 10, w: 25, h: 25 },
      'Plains': { x: 40, y: 50, w: 35, h: 35 },
      'Forest': { x: 12, y: 55, w: 25, h: 25 },
      'Coast': { x: 78, y: 60, w: 25, h: 25 },
      'Desert': { x: 50, y: 65, w: 25, h: 25 },
      'Swamp': { x: 85, y: 45, w: 20, h: 20 },
      'Mountains': { x: 50, y: 20, w: 25, h: 25 },
      'Highlands': { x: 40, y: 5, w: 30, h: 20 },
      'River': { x: 5, y: 70, w: 25, h: 20 }
    };

    const DATA_SOURCES = [
      'data/palworld_complete_data_final.json',
      'data/palworld_complete_data_enhanced.json',
      'data/palworld_complete_data.json'
    ];
    const EMBEDDED_DATA_SCRIPT = 'data/palworld_complete_data_fallback.js';
    const ITEM_DETAILS_SOURCES = ['data/item_details.json'];
    const ITEM_DETAILS_FALLBACK_SCRIPT = 'data/item_details_fallback.js';
    const ITEM_DETAILS_GLOBAL = '__PALMATE_ITEM_DETAILS__';
    const PARTNER_SKILL_SOURCES = ['data/partner_skills.json'];
    let embeddedDataPromise = null;
    let itemDetailsEmbeddedPromise = null;

    async function loadEmbeddedDataset() {
      if (window.__PALMATE_EMBEDDED_DATA__) {
        return window.__PALMATE_EMBEDDED_DATA__;
      }
      if (!embeddedDataPromise) {
        embeddedDataPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = EMBEDDED_DATA_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window.__PALMATE_EMBEDDED_DATA__ || null);
          script.onerror = event => {
            console.warn('Unable to load embedded dataset script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await embeddedDataPromise;
      } catch (err) {
        console.warn('Embedded dataset loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsFallback() {
      if (window[ITEM_DETAILS_GLOBAL]) {
        return window[ITEM_DETAILS_GLOBAL];
      }
      if (!itemDetailsEmbeddedPromise) {
        itemDetailsEmbeddedPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = ITEM_DETAILS_FALLBACK_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window[ITEM_DETAILS_GLOBAL] || null);
          script.onerror = event => {
            console.warn('Unable to load item detail fallback script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await itemDetailsEmbeddedPromise;
      } catch (err) {
        console.warn('Item detail fallback loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsDataset() {
      const loadErrors = [];
      for (const source of ITEM_DETAILS_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          return payload;
        } catch (error) {
          loadErrors.push({ source, error });
          console.warn(`Failed to load item details from ${source}`, error);
        }
      }
      return null;
    }
    async function loadItemDetails() {
      const dataset = await loadItemDetailsDataset();
      if (dataset) return dataset;
      const fallback = await loadItemDetailsFallback();
      if (fallback) return fallback;
      console.warn('Item detail dataset unavailable. Item cards will use minimal info.');
      return {};
    }
    async function loadPartnerSkillDataset() {
      for (const source of PARTNER_SKILL_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (Array.isArray(payload)) {
            return payload;
          }
          console.warn(`Partner skill payload from ${source} was not an array.`);
        } catch (err) {
          console.warn(`Failed to load partner skills from ${source}`, err);
        }
      }
      return [];
    }
    // Type icon mapping (relative file paths)
    const iconMap = {
      'Neutral': 'assets/icons/neutral.png',
      'Fire': 'assets/icons/fire.png',
      'Ice': 'assets/icons/ice.png',
      'Electric': 'assets/icons/electric.png',
      'Water': 'assets/icons/water.png',
      'Grass': 'assets/icons/grass.png',
      'Ground': 'assets/icons/ground.png',
      'Dark': 'assets/icons/dark.png',
      'Dragon': 'assets/icons/dragon.png',
      'Air': 'assets/icons/air.png'
    };

    // A handful of recently added pals still lack bundled artwork.  Rather than
    // shipping temporary binary placeholders (which broke our last build), keep
    // a small deny-list of missing files so we can fall back to type icons
    // without triggering console errors.
    const missingPalArt = new Set([
      'assets/pals/098_astegon.png',
      'assets/pals/130_ice_reptyro.png',
      'assets/pals/131_ice_kingpaca.png',
      'assets/pals/138_selyne.png',
      'assets/pals/139_croajiro.png',
      'assets/pals/140_dogen.png'
    ]);

    function getPrimaryType(pal) {
      if (!pal || !Array.isArray(pal.types)) return 'Neutral';
      const type = pal.types.find(entry => typeof entry === 'string' && entry.trim().length);
      return type || 'Neutral';
    }

    function getPalIconSource(pal) {
      const primary = getPrimaryType(pal);
      return iconMap[primary] || iconMap['Neutral'];
    }

    function getPalArtSource(pal) {
      if (!pal) return null;
      const candidate = pal.localImage;
      if (!candidate || missingPalArt.has(candidate)) {
        return null;
      }
      return candidate;
    }

    function getPalOnlineArtSource(pal) {
      if (!pal) return null;
      const remote = typeof pal.image === 'string' ? pal.image.trim() : '';
      if (!remote) return null;
      return remote;
    }

    function applyPalArtwork(img, pal, { alt } = {}) {
      if (!img) return;
      const sources = [];
      const localArt = getPalArtSource(pal);
      if (localArt) sources.push(localArt);
      const onlineArt = getPalOnlineArtSource(pal);
      if (onlineArt && !sources.includes(onlineArt)) {
        sources.push(onlineArt);
      }
      const iconFallback = getPalIconSource(pal);
      if (iconFallback && !sources.includes(iconFallback)) {
        sources.push(iconFallback);
      }
      let attemptIndex = 0;
      function tryNextSource() {
        while (attemptIndex < sources.length) {
          const candidate = sources[attemptIndex++];
          if (!candidate) continue;
          if (/^https?:/i.test(candidate)) {
            img.referrerPolicy = img.referrerPolicy || 'no-referrer';
          } else if (img.referrerPolicy) {
            img.removeAttribute('referrerpolicy');
          }
          img.src = candidate;
          return;
        }
        img.removeEventListener('error', handleError);
      }
      function handleError() {
        if (attemptIndex < sources.length) {
          tryNextSource();
        } else {
          img.removeEventListener('error', handleError);
        }
      }
      img.loading = img.loading || 'lazy';
      img.decoding = img.decoding || 'async';
      if (alt !== undefined) {
        img.alt = alt;
      } else if (!img.alt || img.alt === '') {
        img.alt = pal && pal.name ? `${pal.name} artwork` : 'Pal artwork';
      }
      img.addEventListener('error', handleError);
      tryNextSource();
    }

    // Audio cues for a more immersive UI.  Users can add their own sound files
    // (e.g. click.mp3, modal_open.mp3, modal_close.mp3) inside assets/sounds.
    const clickSound = new Audio('assets/sounds/click.mp3');
    const openSound = new Audio('assets/sounds/modal_open.mp3');
    const closeSound = new Audio('assets/sounds/modal_close.mp3');
    function playSound(sound) {
      // Gracefully handle missing audio files
      if (!sound || typeof sound.play !== 'function') return;
      try {
        sound.currentTime = 0;
        const result = sound.play();
        if (result && typeof result.catch === 'function') {
          result.catch(err => console.debug('Sound error', err));
        }
      } catch (err) {
        // Audio play can fail if files are missing or browser policy blocks it
        console.debug('Sound error', err);
      }
    }
    // Navigation handling: top nav bar.  Each .nav-item button
    // switches to its associated page when clicked.  After the
    // switch, we play a click sound.  On small screens the nav
    // collapses into a menu controlled by #navToggle.
    const navElement = document.getElementById('navbar');
    const navToggle = document.getElementById('navToggle');
    const navItems = Array.from(document.querySelectorAll('#navbar .nav-item'));
    const navMobileQuery = window.matchMedia ? window.matchMedia('(max-width: 720px)') : { matches: false };
    const navToggleIcon = navToggle ? navToggle.querySelector('i') : null;

    function setNavOpen(desired) {
      if (!navElement || !navToggle) return;
      const open = !!desired;
      navElement.dataset.open = open ? 'true' : 'false';
      navToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      navToggle.setAttribute('aria-label', open ? 'Close navigation menu' : 'Open navigation menu');
      if (navToggleIcon) {
        navToggleIcon.classList.toggle('fa-bars', !open);
        navToggleIcon.classList.toggle('fa-xmark', open);
      }
    }

    function collapseNavIfMobile() {
      if (navToggle && navMobileQuery.matches) {
        setNavOpen(false);
      }
    }

    setNavOpen(false);

    if (navToggle) {
      navToggle.addEventListener('click', () => {
        const isOpen = navElement?.dataset.open === 'true';
        setNavOpen(!isOpen);
      });
      document.addEventListener('click', event => {
        if (!navElement || navElement.dataset.open !== 'true' || !navMobileQuery.matches) return;
        if (!navElement.contains(event.target)) {
          setNavOpen(false);
        }
      });
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape' && navElement?.dataset.open === 'true') {
          setNavOpen(false);
          navToggle.focus();
        }
      });
      const navBreakpointHandler = event => {
        if (!event.matches) {
          setNavOpen(false);
        }
      };
      if (typeof navMobileQuery.addEventListener === 'function') {
        navMobileQuery.addEventListener('change', navBreakpointHandler);
      } else if (typeof navMobileQuery.addListener === 'function') {
        navMobileQuery.addListener(navBreakpointHandler);
      }
    }

    navItems.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.getAttribute('data-page');
        switchPage(target);
        playSound(clickSound);
        collapseNavIfMobile();
      });
    });

    navItems.forEach(btn => {
      if (btn.classList.contains('active')) {
        btn.setAttribute('aria-current', 'page');
      }
    });

    function refreshModeUI() {
      document.body.classList.toggle('kid-mode', kidMode);
      const toggleTitle = document.getElementById('modeToggle');
      const modeIcon = toggleTitle ? toggleTitle.querySelector('i') : null;
      if (toggleTitle && modeIcon) {
        if (kidMode) {
          modeIcon.classList.remove('fa-user-astronaut');
          modeIcon.classList.add('fa-child');
          toggleTitle.title = 'Switch to grown-up mode';
        } else {
          modeIcon.classList.remove('fa-child');
          modeIcon.classList.add('fa-user-astronaut');
          toggleTitle.title = 'Switch to kid mode';
        }
      }
      document.querySelectorAll('[data-mode-card]').forEach(card => {
        const mode = card.getAttribute('data-mode-card');
        const active = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        card.classList.toggle('active', !!active);
        const status = card.querySelector('.mode-card__status');
        if (status) {
          status.textContent = active
            ? (mode === 'kid' ? 'Kid Mode active' : 'Grown-up Mode active')
            : (mode === 'kid' ? 'Switch to Kid Mode' : 'Switch to Grown-up Mode');
        }
      });
      document.querySelectorAll('[data-mode-choice]').forEach(btn => {
        const mode = btn.getAttribute('data-mode-choice');
        const isActive = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        btn.disabled = isActive;
        if (isActive) {
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.removeAttribute('aria-pressed');
        }
      });
      if(typeof renderRouteSuggestionFiltersUI === 'function' && typeof reapplyRouteSuggestionFilters === 'function'){
        setTimeout(() => {
          try {
            renderRouteSuggestionFiltersUI();
            reapplyRouteSuggestionFilters();
          } catch(err){
            console.warn('Route filter refresh failed', err);
          }
        }, 0);
      }
    }

    function bindRouteActionButtons(){
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        if(btn.dataset.boundToggle) return;
        btn.dataset.boundToggle = 'true';
        btn.addEventListener('click', () => {
          routeHideOptional = !routeHideOptional;
          persistRoutePreferences();
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          updateRouteOverviewUI();
          renderBossRouteTimeline();
          playSound(clickSound);
        });
      });
      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        if(btn.dataset.boundJump) return;
        btn.dataset.boundJump = 'true';
        btn.addEventListener('click', () => {
          const queued = btn.dataset.stepId;
          const next = queued
            || (findNextRouteStep() || findNextRouteStep({ includeOptional: true }))?.step?.id
            || '';
          if(next){
            queueRouteFocus(next);
          }
          playSound(clickSound);
        });
      });
    }

    function updateRouteToggleButtons(){
      const label = routeOptionalToggleLabel(routeHideOptional);
      const pressed = routeHideOptional ? 'true' : 'false';
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        btn.textContent = label;
        btn.setAttribute('aria-pressed', pressed);
      });
    }

    function rebuildModeAwarePages() {
      buildPalPage();
      buildItemPage();
      buildTechPage();
      buildBasePage();
      buildBreedingPage();
      buildGlossaryPage();
      renderRouteGuide();
      buildHomePage();
      buildProgressPage();
      updateProgressUI();
    }

    function persistKidMode() {
      try {
        localStorage.setItem(KID_MODE_STORAGE_KEY, kidMode ? 'true' : 'false');
      } catch (err) {
        console.warn('Failed to save kid mode preference', err);
      }
    }

    function setKidMode(value, { rebuild = true } = {}) {
      const desired = !!value;
      if (kidMode === desired) {
        persistKidMode();
        refreshModeUI();
        if (rebuild) {
          rebuildModeAwarePages();
        }
        return;
      }
      kidMode = desired;
      persistKidMode();
      refreshModeUI();
      if (rebuild) {
        rebuildModeAwarePages();
      }
    }

    // Mode toggle button: switch between kid and grown-up modes.  The
    // icon and tooltip change based on the current mode.  We also
    // rebuild pages so their copy matches the selected experience.
    document.getElementById('modeToggle').addEventListener('click', () => {
      setKidMode(!kidMode);
      playSound(clickSound);
    });
    refreshModeUI();
    function switchPage(page) {
      // Hide all pages and show the selected page.  Our pages are
      // <section> elements with IDs like palsPage, itemsPage, etc.
      document.querySelectorAll('.page').forEach(section => section.classList.remove('active'));
      const activePage = document.getElementById(page + 'Page');
      if (activePage) activePage.classList.add('active');
      // Update navigation item active state
      navItems.forEach(btn => {
        const isActive = btn.getAttribute('data-page') === page;
        btn.classList.toggle('active', isActive);
        if (isActive) {
          btn.setAttribute('aria-current', 'page');
        } else {
          btn.removeAttribute('aria-current');
        }
      });
      collapseNavIfMobile();
    }
    // Modal controls
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modalBody');
    document.getElementById('modalClose').addEventListener('click', closeModal);
    modal.addEventListener('click', event => {
      if (event.target === modal) {
        closeModal();
      }
    });
    // Track resize handlers registered by the map modal so they can be
    // removed when the dialog closes.  Without this cleanup we would leak
    // listeners as the player opens multiple guide entries.
    let mapResizeCleanup = null;
    function openModal() {
      modal.classList.add('active');
      playSound(openSound);
    }
    function closeModal() {
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      modal.classList.remove('active');
      modalBody.innerHTML = '';
      playSound(closeSound);
    }
    const PALWORLD_PAL_SLUG_OVERRIDES = {
      // Reserved for pals whose Palworld.gg slug does not match the default slugification.
    };
    const PALWORLD_ITEM_SLUG_OVERRIDES = {
      // Reserved for items whose Palworld.gg slug does not match their key.
    };
    const ROUTE_GLOSSARY_SUMMARIES = {
      'lifmunk-effigy': {
        title: 'Lifmunk Effigy',
        kid: [
          'Tiny glowing statues hidden all over Palworld.',
          'Feed them to the Statue of Power to make catching pals easier.'
        ],
        grown: [
          'Collectible statues that grant Capture Power when offered at a Statue of Power.',
          'Always grab them on sight; the bonus stacks and makes catching high-level pals easier.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Lifmunk Effigy')}`,
        note: 'Peek at Palworld.gg without losing your place in the route.'
      },
      'skill-fruit': {
        title: 'Skill Fruit',
        kid: [
          'Special fruit that lets a pal learn a new move.',
          'Find them in dungeons or treasure chests and save the ones you like.'
        ],
        grown: [
          'Consumable items that instantly teach the move printed on the fruit.',
          'Best sourced from dungeons; stash rare elements until you know which pal will use them.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Skill Fruit')}`,
        note: 'Palmate keeps this move info handy so you can stay on track.'
      },
      'pal-essence-condenser': {
        title: 'Pal Essence Condenser',
        kid: [
          'A special machine that eats extra pals to give your favorite buddy shiny stars.',
          'Those stars make their partner skill stronger and can even help with base jobs.'
        ],
        grown: [
          'Consumes 4, 16, 32 and 64 duplicates (116 total) to raise a partner skill to level 5.',
          'Each star boosts base stats and the 4★ upgrade grants +1 to every work suitability.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Essence Condenser')}`,
        note: 'Palmate keeps condensation tips nearby so you never lose the route context.'
      },
      'pal-condensation': {
        title: 'Pal Condensation',
        kid: [
          'Feeding the condenser pals makes partner moves power up one star at a time.',
          'Four stars also give that buddy better job levels back at base.'
        ],
        grown: [
          'Every condenser star increases partner skill level by one (to Lv.5) while adding base stat boosts.',
          'Damage-focused mounts scale hard with these ranks—watch for mount tags that boost player and pal damage.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Essence Condenser')}`,
        note: 'Review condensation effects without leaving your tower or route notes.'
      }
    };
    // Palworld's in-game coordinates are not symmetrical on the X/Y axes.
    // The static map we render here is cropped to the explorable landmass,
    // which spans roughly X = [-560, 640] and Y = [-662, 340] in world units.
    // Using tighter bounds keeps the marker aligned with tower entrances
    // instead of drifting toward the centre of the image.
    const MAP_WORLD_BOUNDS = { minX: -560, maxX: 640, minY: -662, maxY: 340 };
    function clampToRange(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    function worldCoordsToPercent(coords) {
      if (!Array.isArray(coords) || coords.length < 2) {
        return { left: 50, top: 50 };
      }
      const [rawX, rawY] = coords.map(Number);
      const width = MAP_WORLD_BOUNDS.maxX - MAP_WORLD_BOUNDS.minX;
      const height = MAP_WORLD_BOUNDS.maxY - MAP_WORLD_BOUNDS.minY;
      if (!width || !height) {
        return { left: 50, top: 50 };
      }
      const x = clampToRange(rawX, MAP_WORLD_BOUNDS.minX, MAP_WORLD_BOUNDS.maxX);
      const y = clampToRange(rawY, MAP_WORLD_BOUNDS.minY, MAP_WORLD_BOUNDS.maxY);
      return {
        left: ((x - MAP_WORLD_BOUNDS.minX) / width) * 100,
        top: ((MAP_WORLD_BOUNDS.maxY - y) / height) * 100
      };
    }
    function mapDescriptionLines(info) {
      if (!info) return [];
      if (kidMode && Array.isArray(info.kid) && info.kid.length) {
        return info.kid;
      }
      if (!kidMode && Array.isArray(info.grown) && info.grown.length) {
        return info.grown;
      }
      if (info.note) {
        return [info.note];
      }
      return [];
    }
    function openRouteMapModal(mapInfo = {}, fallbackUrl) {
      const entrance = mapInfo.entrance || null;
      const entranceCoords = Array.isArray(mapInfo.entranceCoords)
        ? mapInfo.entranceCoords
        : (entrance && Array.isArray(entrance.coords) ? entrance.coords : null);
      const coords = entranceCoords || (Array.isArray(mapInfo.coords) ? mapInfo.coords : null);
      if (!coords) {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
        return;
      }
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      const { left, top } = worldCoordsToPercent(coords);
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'map-modal';
      const heading = document.createElement('h3');
      heading.textContent = mapInfo.title || 'Route location';
      wrap.appendChild(heading);
      const meta = document.createElement('p');
      meta.className = 'map-modal-note';
      const metaBits = [];
      if (mapInfo.region) metaBits.push(mapInfo.region);
      const primaryLabel = entrance && entrance.label ? entrance.label : (mapInfo.coordsLabel || 'Entrance');
      metaBits.push(`${primaryLabel}: (${coords[0]}, ${coords[1]})`);
      if (!entranceCoords && Array.isArray(mapInfo.coords) && mapInfo.coords.length >= 2) {
        metaBits.push(`Location: (${mapInfo.coords[0]}, ${mapInfo.coords[1]})`);
      }
      meta.textContent = metaBits.join(' • ');
      wrap.appendChild(meta);
      const details = [
        ...mapDescriptionLines(mapInfo),
        ...mapDescriptionLines(entrance)
      ];
      if (details.length) {
        const detailsWrap = document.createElement('div');
        detailsWrap.className = 'map-modal-details';
        details.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          detailsWrap.appendChild(p);
        });
        wrap.appendChild(detailsWrap);
      }
      const canvas = document.createElement('div');
      canvas.className = 'map-modal-canvas';
      const mapImage = document.createElement('img');
      mapImage.src = 'assets/images/palworld-full-map-2.webp';
      const mapAltTitle = entrance && entrance.label
        ? `${entrance.label} for ${mapInfo.title || 'the selected encounter'}`
        : (mapInfo.title ? `${mapInfo.title} location on the Palworld map` : 'Palworld map showing the selected route location');
      mapImage.alt = mapAltTitle;
      canvas.appendChild(mapImage);
      const marker = document.createElement('div');
      marker.className = 'map-marker';
      marker.style.left = `${left}%`;
      marker.style.top = `${top}%`;
      const markerLabel = (entrance && entrance.label) || mapInfo.label || mapInfo.title;
      if (markerLabel) {
        const label = document.createElement('span');
        label.className = 'map-marker-label';
        label.textContent = markerLabel;
        marker.appendChild(label);
      }
      canvas.appendChild(marker);
      mapResizeCleanup = null;
      wrap.appendChild(canvas);
      const actions = document.createElement('div');
      actions.className = 'badges';
      actions.style.marginTop = '4px';
      const openBtn = document.createElement('button');
      openBtn.type = 'button';
      openBtn.className = 'modal-action-btn';
      openBtn.textContent = 'Open interactive map';
      openBtn.addEventListener('click', () => {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
      });
      actions.appendChild(openBtn);
      wrap.appendChild(actions);
      modalBody.appendChild(wrap);
      openModal();
    }
    function openTowerMap(link) {
      if (!link) return;
      const info = link.map ? { ...link.map } : {};
      if (!info.url && link.url) {
        info.url = link.url;
      }
      if (!info.title) {
        info.title = niceName(link.id || 'Tower');
      }
      openRouteMapModal(info, link.url);
    }
    function slugifyForPalworld(text) {
      if (!text) return '';
      return text
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/&/g, ' and ')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }
    function humaniseItemKey(key) {
      if (!key) return '';
      return key
        .split('_')
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }
    function normalizeRanchAssignment(raw) {
      if (!raw || typeof raw !== 'object') return null;
      const itemKey = raw.itemKey ? String(raw.itemKey) : null;
      const itemName = raw.itemName ? String(raw.itemName) : '';
      const palName = raw.palName ? String(raw.palName) : '';
      const palId = raw.palId != null && raw.palId !== '' && Number.isFinite(Number(raw.palId))
        ? Number(raw.palId)
        : null;
      return {
        itemKey,
        itemName,
        palId,
        palName,
        reasonKid: raw.reasonKid ? String(raw.reasonKid) : '',
        reasonGrown: raw.reasonGrown ? String(raw.reasonGrown) : '',
        actionKid: raw.actionKid ? String(raw.actionKid) : '',
        actionGrown: raw.actionGrown ? String(raw.actionGrown) : '',
        noteKid: raw.noteKid ? String(raw.noteKid) : '',
        noteGrown: raw.noteGrown ? String(raw.noteGrown) : '',
        timestamp: Number.isFinite(Number(raw.timestamp)) ? Number(raw.timestamp) : Date.now()
      };
    }
    function loadBasePlannerState() {
      const defaults = { mode: 'auto', manualLevel: 1, ranchAssignment: null };
      try {
        const stored = localStorage.getItem(BASE_PLANNER_STORAGE_KEY);
        if (!stored) {
          return { ...defaults };
        }
        const parsed = JSON.parse(stored);
        if (!parsed || typeof parsed !== 'object') {
          return { ...defaults };
        }
        const mode = parsed.mode === 'manual' ? 'manual' : 'auto';
        const levelRaw = Number(parsed.manualLevel);
        const manualLevel = clampToRange(Number.isFinite(levelRaw) ? Math.round(levelRaw) : 1, 1, BASE_LEVEL_CONFIG.length || 1);
        const ranchAssignment = normalizeRanchAssignment(parsed.ranchAssignment);
        return { mode, manualLevel, ranchAssignment };
      } catch (err) {
        console.warn('Failed to load base planner state', err);
        return { ...defaults };
      }
    }
    function persistBasePlannerState() {
      try {
        localStorage.setItem(BASE_PLANNER_STORAGE_KEY, JSON.stringify(basePlannerState));
      } catch (err) {
        console.warn('Failed to persist base planner state', err);
      }
    }
    function canonicalWorkKey(key) {
      if (!key) return null;
      const normalized = String(key).toLowerCase();
      return WORK_KEY_ALIASES[normalized] || normalized;
    }
    function getWorkTypeDetail(key) {
      const canonical = canonicalWorkKey(key);
      return WORK_TYPE_DETAILS[canonical] || { label: humaniseItemKey(canonical || key || 'Work'), kidLabel: humaniseItemKey(canonical || key || 'Work'), icon: '⭐' };
    }
    function priorityDescriptor(weight) {
      if (weight >= 1.1) {
        return { kid: 'Mega important job', grown: 'Critical priority' };
      }
      if (weight >= 0.95) {
        return { kid: 'Very important job', grown: 'High priority' };
      }
      if (weight >= 0.75) {
        return { kid: 'Helpful job', grown: 'Support priority' };
      }
      if (weight >= 0.5) {
        return { kid: 'Nice to have', grown: 'Supplemental focus' };
      }
      return { kid: 'Bonus coverage', grown: 'Low priority' };
    }
    function coverageDescriptor(weight, totalLevel, config, highestWeight) {
      const slots = Math.max(1, config?.slots || 1);
      const maxWork = Math.max(1, MAX_WORK_LEVEL);
      const normalized = totalLevel > 0 ? totalLevel / (slots * maxWork) : 0;
      const priorityFactor = highestWeight > 0 ? weight / highestWeight : 1;
      const effective = normalized * (0.6 + 0.4 * priorityFactor);
      if (totalLevel <= 0) {
        return { kid: 'Add a pal here', grown: 'No coverage yet', percent: 0 };
      }
      if (effective >= 0.75) {
        return { kid: 'Crew ready', grown: 'Excellent coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      if (effective >= 0.5) {
        return { kid: 'Strong', grown: 'Strong coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      if (effective >= 0.3) {
        return { kid: 'Okay', grown: 'Light coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      return { kid: 'Needs helpers', grown: 'Needs attention', percent: Math.min(100, Math.round(normalized * 100)) };
    }
    function gatherUpcomingRouteSteps(limit = 8, { includeOptional = true } = {}) {
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const upcoming = [];
      for (const chapter of chapters) {
        if (!chapter) continue;
        const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
        for (const step of steps) {
          if (!step) continue;
          if (!includeOptional && step.optional) continue;
          if (routeState && routeState[step.id]) continue;
          upcoming.push({ chapter, step });
          if (upcoming.length >= limit) {
            return upcoming;
          }
        }
      }
      return upcoming;
    }
    function computeRanchPlan({ stageSnapshot, limit = 5 } = {}) {
      const plan = {
        recommendations: [],
        summaryKid: '',
        summaryGrown: '',
        hasRanch: isTechUnlocked('Ranch'),
        stageTags: new Set()
      };
      const stageId = stageSnapshot?.stageId || null;
      const stageIndex = typeof stageSnapshot?.stageIndex === 'number' ? stageSnapshot.stageIndex : -1;
      const tags = plan.stageTags;
      if (stageIndex <= 1) tags.add('early');
      if (stageIndex <= 4) tags.add('sphere');
      if (stageIndex >= 2) tags.add('mid');
      if (stageIndex >= 3) tags.add('cold');
      if (stageIndex >= 4) tags.add('advanced');
      if (stageId === 'ch1') tags.add('cloth');
      if (stageId === 'ch2') tags.add('cake');
      if (stageId === 'ch3') tags.add('cold');
      if (stageId && /^ch\d+/i.test(stageId)) {
        const numeric = Number(stageId.replace(/[^0-9]/g, ''));
        if (Number.isFinite(numeric) && numeric >= 4) tags.add('oil');
      }
      const upcomingSteps = gatherUpcomingRouteSteps(12);
      const addTagsFromText = raw => {
        if (!raw) return;
        const text = String(raw).toLowerCase();
        if (text.includes('cake') || text.includes('breeding farm') || text.includes('bake')) tags.add('cake');
        if (text.includes('cloth') || text.includes('wool') || text.includes('tailor')) tags.add('cloth');
        if (text.includes('snow') || text.includes('cold') || text.includes('freez') || text.includes('tundra')) tags.add('cold');
        if (text.includes('polymer') || text.includes('assembly line') || text.includes('factory') || text.includes('assault rifle')) tags.add('oil');
        if (text.includes('medicine') || text.includes('medical') || text.includes('hot spring')) tags.add('medicine');
        if (text.includes('ranch')) tags.add('cake');
      };
      upcomingSteps.forEach(entry => addTagsFromText(entry?.step?.text));
      (stageSnapshot?.pendingBaseSteps || []).forEach(entry => addTagsFromText(entry?.step?.text));
      if (stageSnapshot?.nextStep) addTagsFromText(stageSnapshot.nextStep.text);
      tags.add('sphere');
      const pickReason = (entry) => {
        const reasons = entry?.reasons || {};
        const entryTags = Array.isArray(entry?.tags) ? entry.tags : [];
        for (const tag of entryTags) {
          if (tags.has(tag) && reasons[tag]) {
            return reasons[tag];
          }
        }
        return reasons.default || { kid: '', grown: '' };
      };
      const unique = arr => Array.from(new Set((arr || []).map(item => String(item || '').trim()).filter(Boolean)));
      const candidates = Object.values(RANCH_ITEM_LIBRARY || {})
        .filter(entry => {
          const entryTags = Array.isArray(entry.tags) ? entry.tags : [];
          if (!entryTags.length && !entry.always) return false;
          return entryTags.some(tag => tags.has(tag)) || entry.always;
        })
        .sort((a, b) => (b.priority || 0) - (a.priority || 0));
      const maxItems = Math.max(1, Number.isFinite(limit) ? Math.round(limit) : 5);
      candidates.slice(0, maxItems).forEach(entry => {
        const detail = (ITEM_DETAILS && ITEM_DETAILS[entry.key]) || (ITEMS && ITEMS[entry.key]) || {};
        const name = entry.name || detail.name || humaniseItemKey(entry.key || 'Item');
        const producers = unique(entry.producers || detail.ranchProducers || (ITEMS && ITEMS[entry.key]?.ranchProducers));
        if (!producers.length) return;
        const caughtProducers = producers.filter(name => isPalCaughtByName(name));
        const missingProducers = producers.filter(name => !isPalCaughtByName(name));
        const reason = pickReason(entry);
        const targetName = name.toLowerCase();
        const caughtLabelKid = caughtProducers.slice(0, 2).join(' and ');
        const caughtLabelGrown = caughtProducers.join(', ');
        const prospectKid = missingProducers.slice(0, 2).join(' or ') || producers.slice(0, 2).join(' or ');
        const prospectGrown = missingProducers.join(', ') || producers.join(', ');
        const actionKid = caughtProducers.length
          ? `Let ${caughtLabelKid} stay on the Ranch so ${targetName} piles up.`
          : `Catch ${prospectKid || 'new pals'} so the Ranch makes ${targetName}.`;
        const actionGrown = caughtProducers.length
          ? `Assign ${caughtProducers[0]} to the Ranch to keep ${targetName} flowing.`
          : `Recruit ${prospectGrown || 'ranch producers'} to automate ${targetName}.`;
        const hasDetail = !!((ITEM_DETAILS && ITEM_DETAILS[entry.key]) || (ITEMS && ITEMS[entry.key]));
        plan.recommendations.push({
          key: entry.key,
          itemKey: entry.key,
          name,
          reasonKid: reason.kid || '',
          reasonGrown: reason.grown || '',
          actionKid,
          actionGrown,
          producers,
          caughtProducers,
          missingProducers,
          hasDetail,
          openUrl: entry.openUrl || null
        });
      });
      const names = plan.recommendations.map(rec => rec.name).slice(0, 4);
      if (names.length) {
        const kidJoin = names.slice(0, 3).join(' & ');
        const grownJoin = names.join(' • ');
        if (plan.hasRanch) {
          plan.summaryKid = `Focus: ${kidJoin}`;
          plan.summaryGrown = `Focus outputs: ${grownJoin}`;
        } else {
          plan.summaryKid = `Plan ahead: ${kidJoin}`;
          plan.summaryGrown = `Plan ahead: ${grownJoin}`;
        }
      } else {
        plan.summaryKid = plan.hasRanch
          ? 'Choose a ranch item to chase next.'
          : 'Unlock the Ranch to start planning outputs.';
        plan.summaryGrown = plan.hasRanch
          ? 'Choose the next ranch output to pursue.'
          : 'Unlock the Ranch to start planning outputs.';
      }
      return plan;
    }
    function pickPreferredRanchProducer(rec, { palName } = {}) {
      if (!rec) return { name: '', pal: null, isCaught: false };
      const names = Array.isArray(rec.producers) ? rec.producers : [];
      if (palName) {
        const match = names.find(name => String(name).toLowerCase() === String(palName).toLowerCase());
        if (match) {
          const pal = findPalByName(match);
          return { name: match, pal, isCaught: pal ? !!caught[pal.id] : isPalCaughtByName(match) };
        }
      }
      const candidates = names.map(name => {
        const pal = findPalByName(name);
        return { name, pal, isCaught: pal ? !!caught[pal.id] : isPalCaughtByName(name) };
      });
      const caughtCandidate = candidates.find(entry => entry.pal && entry.isCaught);
      if (caughtCandidate) return caughtCandidate;
      const withData = candidates.find(entry => entry.pal);
      if (withData) return withData;
      if (names.length) {
        return { name: names[0], pal: findPalByName(names[0]) || null, isCaught: isPalCaughtByName(names[0]) };
      }
      return { name: '', pal: null, isCaught: false };
    }
    function resolveRanchAssignment({ plan } = {}) {
      const stored = basePlannerState?.ranchAssignment;
      if (!stored) return null;
      const normalized = normalizeRanchAssignment(stored);
      if (!normalized) return null;
      let pal = null;
      if (normalized.palId != null && PALS && PALS[normalized.palId]) {
        pal = PALS[normalized.palId];
      }
      if (!pal && normalized.palName) {
        pal = findPalByName(normalized.palName);
      }
      const recommendation = plan && Array.isArray(plan.recommendations)
        ? plan.recommendations.find(rec => rec.itemKey === normalized.itemKey)
        : null;
      const reasonKid = recommendation?.reasonKid || normalized.reasonKid;
      const reasonGrown = recommendation?.reasonGrown || normalized.reasonGrown;
      const actionKid = recommendation?.actionKid || normalized.actionKid;
      const actionGrown = recommendation?.actionGrown || normalized.actionGrown;
      const noteKid = normalized.noteKid || (normalized.palName
        ? `${normalized.palName} works the Ranch for ${normalized.itemName || 'your focus item'}.`
        : `Ranch focus: ${normalized.itemName || 'planned output'}.`);
      const noteGrown = normalized.noteGrown || (normalized.palName
        ? `${normalized.palName} assigned to the Ranch for ${normalized.itemName || 'the planned output'}.`
        : `Ranch focus: ${normalized.itemName || 'planned output'}.`);
      return {
        ...normalized,
        pal,
        recommendation: recommendation || null,
        reasonKid,
        reasonGrown,
        actionKid,
        actionGrown,
        noteKid,
        noteGrown,
        isCaught: pal ? !!caught[pal.id] : (normalized.palName ? isPalCaughtByName(normalized.palName) : false)
      };
    }
    function clearRanchAssignment() {
      if (basePlannerState.ranchAssignment) {
        basePlannerState.ranchAssignment = null;
        persistBasePlannerState();
      }
      updateBasePlanner();
    }
    function setRanchAssignmentFromRecommendation(rec, { palName } = {}) {
      if (!rec) return;
      const preferred = pickPreferredRanchProducer(rec, { palName });
      const pal = preferred.pal;
      const palDisplay = preferred.name || (pal ? pal.name : '');
      if (!palDisplay) return;
      const itemName = rec.name || humaniseItemKey(rec.itemKey || rec.key || 'Ranch Output');
      const lowerOutput = itemName ? itemName.toLowerCase() : 'your ranch output';
      const noteKid = `${palDisplay} works the Ranch so ${lowerOutput} stacks up.`;
      const noteGrown = `${palDisplay} is reserved on the Ranch for ${lowerOutput}.`;
      const nextAssignment = normalizeRanchAssignment({
        itemKey: rec.itemKey || rec.key || null,
        itemName,
        palId: pal ? pal.id : null,
        palName: palDisplay,
        reasonKid: rec.reasonKid || '',
        reasonGrown: rec.reasonGrown || '',
        actionKid: rec.actionKid || '',
        actionGrown: rec.actionGrown || '',
        noteKid,
        noteGrown,
        timestamp: Date.now()
      });
      const current = basePlannerState?.ranchAssignment;
      if (current && current.itemKey === nextAssignment.itemKey && current.palName === nextAssignment.palName) {
        clearRanchAssignment();
        return;
      }
      basePlannerState.ranchAssignment = nextAssignment;
      persistBasePlannerState();
      updateBasePlanner();
    }
    function isBaseRelatedTech(item) {
      if (!item) return false;
      const fields = [item.category, item.group, item.name];
      return fields.some(field => {
        if (!field) return false;
        const value = String(field).toLowerCase();
        return BASE_TECH_KEYWORDS.some(keyword => value.includes(keyword));
      });
    }
    function deriveBaseLevelFromTech(techLevel) {
      if (!Array.isArray(BASE_TECH_THRESHOLDS) || !BASE_TECH_THRESHOLDS.length) {
        return 1;
      }
      let derived = 1;
      BASE_TECH_THRESHOLDS.forEach(threshold => {
        if (techLevel >= threshold.techLevel) {
          derived = threshold.level;
        }
      });
      return clampToRange(derived, 1, BASE_LEVEL_CONFIG.length || 1);
    }
    function calculateAutoBaseLevelDetail() {
      let highestTechLevel = 0;
      let highestItem = null;
      let unlockCount = 0;
      (Array.isArray(TECH) ? TECH : []).forEach(levelEntry => {
        const tierLevel = Number(levelEntry?.level) || 0;
        (levelEntry?.items || []).forEach(item => {
          if (!item || !item.name) return;
          if (!isBaseRelatedTech(item)) return;
          if (unlocked[item.name]) {
            unlockCount += 1;
            if (tierLevel > highestTechLevel) {
              highestTechLevel = tierLevel;
              highestItem = { name: item.name, techLevel: tierLevel };
            }
          }
        });
      });
      const level = deriveBaseLevelFromTech(highestTechLevel);
      return { level, highestTechLevel, highestItem, unlockCount };
    }
    function isTechUnlocked(name) {
      if (!name) return false;
      if (unlocked && unlocked[name]) return true;
      const normalized = String(name).toLowerCase();
      return Object.keys(unlocked || {}).some(key => {
        return unlocked[key] && typeof key === 'string' && key.toLowerCase() === normalized;
      });
    }
    function hasAnyTechUnlocked(names) {
      if (!Array.isArray(names)) return false;
      return names.some(name => isTechUnlocked(name));
    }
    function findPalByName(name) {
      if (!name) return null;
      const id = PAL_NAME_TO_ID && Object.prototype.hasOwnProperty.call(PAL_NAME_TO_ID, name)
        ? PAL_NAME_TO_ID[name]
        : null;
      if (id != null && PALS && PALS[id]) {
        return PALS[id];
      }
      return Object.values(PALS || {}).find(pal => pal && pal.name === name) || null;
    }
    function isPalCaughtByName(name) {
      const pal = findPalByName(name);
      if (!pal) return false;
      return !!caught[pal.id];
    }
    function palsThatDropItem(itemKey) {
      if (!itemKey) return [];
      const needle = String(itemKey).toLowerCase();
      return Object.values(PALS || {}).filter(pal => {
        return Array.isArray(pal?.drops) && pal.drops.some(drop => String(drop || '').toLowerCase() === needle);
      });
    }
    function collectPendingBaseSteps({ includeOptional = true } = {}) {
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const pending = [];
      chapters.forEach((chapter, chapterIndex) => {
        (chapter?.steps || []).forEach(step => {
          if (!step || step.category !== 'Base') return;
          if (!includeOptional && step.optional) return;
          if (routeState && routeState[step.id]) return;
          pending.push({ chapter, step, chapterIndex });
        });
      });
      pending.sort((a, b) => {
        if (a.chapterIndex !== b.chapterIndex) {
          return a.chapterIndex - b.chapterIndex;
        }
        const optionalA = !!a.step?.optional;
        const optionalB = !!b.step?.optional;
        if (optionalA !== optionalB) {
          return optionalA ? 1 : -1;
        }
        return 0;
      });
      return pending;
    }
    function determineGuideStageSnapshot() {
      const pendingBaseSteps = collectPendingBaseSteps();
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      if (!chapters.length) {
        return {
          stageId: null,
          stageIndex: -1,
          stageTitleKid: '',
          stageTitleGrown: '',
          progressPercent: null,
          pendingBaseSteps,
          nextStep: null
        };
      }
      const nextRoute = findNextRouteStep ? findNextRouteStep({ includeOptional: false }) : null;
      let activeChapter = nextRoute?.chapter || null;
      if (!activeChapter) {
        activeChapter = chapters[chapters.length - 1];
      }
      const stageId = activeChapter?.id || null;
      const stageIndex = chapters.findIndex(chapter => chapter && (chapter === activeChapter || chapter.id === stageId));
      const stageTitleKid = activeChapter ? (activeChapter.titleKid || activeChapter.title || '') : '';
      const stageTitleGrown = activeChapter ? (activeChapter.title || activeChapter.titleKid || '') : '';
      const progress = typeof calculateGuideProgressSummary === 'function' ? calculateGuideProgressSummary() : null;
      const progressPercent = progress ? progress.percent : null;
      return {
        stageId,
        stageIndex,
        stageTitleKid,
        stageTitleGrown,
        progressPercent,
        pendingBaseSteps,
        nextStep: nextRoute?.step || null
      };
    }
    function createStageOverviewNote(stageSnapshot) {
      const stageId = stageSnapshot?.stageId;
      const overview = (stageId && BASE_STAGE_OVERVIEWS[stageId]) || BASE_STAGE_OVERVIEWS.default;
      if (!overview) return null;
      const badgeConfig = overview.badge || null;
      const kidLines = Array.isArray(overview.kid?.lines) && overview.kid.lines.length
        ? overview.kid.lines.slice()
        : [stageSnapshot?.stageTitleKid || 'Keep your base balanced.'];
      const grownLines = Array.isArray(overview.grown?.lines) && overview.grown.lines.length
        ? overview.grown.lines.slice()
        : [stageSnapshot?.stageTitleGrown || 'Keep your base balanced.'];
      if (stageId === 'ch1') {
        if (isPalCaughtByName('Vixy')) {
          if (kidLines.length) kidLines[0] = 'Let Vixy live on the Ranch so it digs Pal Spheres while you explore.';
          kidLines.push('Keep wood and stone pals busy so the Crusher never stops.');
          if (grownLines.length) grownLines[0] = 'Park Vixy on the Ranch for passive Pal Sphere income and keep Crusher fed.';
          grownLines.push('Balance Transporting coverage so logging and stone outputs stay clear.');
        }
      }
      if (stageId === 'ch2') {
        const honeyReady = palsThatDropItem('honey').some(pal => caught && caught[pal.id]);
        if (honeyReady) {
          kidLines.push('Check the honey chest often so Cakes never pause.');
          grownLines.push('With honey secured, ensure flour and milk stay ahead of egg demand.');
        }
      }
      return {
        id: `base-stage-${stageId || 'default'}`,
        icon: overview.icon || '🛠️',
        badge: badgeConfig
          ? { kid: badgeConfig.kid || badgeConfig.grown || '', grown: badgeConfig.grown || badgeConfig.kid || '' }
          : null,
        kid: {
          title: overview.kid?.title || stageSnapshot?.stageTitleKid || 'Base focus',
          lines: kidLines
        },
        grown: {
          title: overview.grown?.title || stageSnapshot?.stageTitleGrown || 'Base focus',
          lines: grownLines
        }
      };
    }
    function createBaseStepNote(entry) {
      if (!entry || !entry.step) return null;
      const { step } = entry;
      const override = BASE_STEP_NOTE_OVERRIDES[step.id] || {};
      const badgeConfig = override.badge || (step.optional ? { kid: 'Bonus', grown: 'Optional' } : { kid: 'Guide step', grown: 'Guide step' });
      const kidLines = Array.isArray(override.kidLines) && override.kidLines.length
        ? override.kidLines.slice()
        : [(step.textKid || step.text || '').trim()].filter(Boolean);
      const grownLines = Array.isArray(override.grownLines) && override.grownLines.length
        ? override.grownLines.slice()
        : [(step.textAdult || step.text || step.textKid || '').trim()].filter(Boolean);
      const note = {
        id: `base-step-${step.id}`,
        icon: override.icon || '📋',
        badge: badgeConfig
          ? { kid: badgeConfig.kid || badgeConfig.grown || '', grown: badgeConfig.grown || badgeConfig.kid || '' }
          : null,
        kid: {
          title: override.kidTitle || step.textKid || step.text || 'Base reminder',
          lines: kidLines
        },
        grown: {
          title: override.grownTitle || step.textAdult || step.text || 'Base reminder',
          lines: grownLines
        }
      };
      if (step.optional) {
        note.kid.footer = 'Optional step';
        note.grown.footer = 'Optional checklist item';
      }
      return note;
    }
    function suggestPalsForWork(key, { crew, baseConfig, stageSnapshot } = {}) {
      const result = { kid: [], grown: [] };
      const seen = new Set();
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      const stageIndex = typeof snapshot?.stageIndex === 'number' && snapshot.stageIndex >= 0 ? snapshot.stageIndex : 0;
      let config = baseConfig;
      if (!config) {
        const autoInfo = calculateAutoBaseLevelDetail();
        const manualLevel = clampToRange(
          Number.isFinite(basePlannerState?.manualLevel) ? Math.round(basePlannerState.manualLevel) : autoInfo.level,
          1,
          BASE_LEVEL_CONFIG.length || 1
        );
        const activeLevel = basePlannerState?.mode === 'manual' ? manualLevel : autoInfo.level;
        config = getBaseLevelConfig(activeLevel);
      }
      const preferredRarity = Number(config?.preferredRarity);
      const rarityBaseline = Number.isFinite(preferredRarity) ? preferredRarity : 2;
      const rarityCap = Math.max(1, rarityBaseline + Math.max(0, Math.floor(stageIndex / 2)));
      const priceCap = 1800 + stageIndex * 1400;
      const STARTER_SPAWN_KEYWORDS = ['plains', 'forest', 'coast', 'plateau', 'grass', 'field', 'hill', 'valley', 'beach', 'lake'];
      const MID_SPAWN_KEYWORDS = ['desert', 'marsh', 'swamp', 'canyon', 'highland', 'mountain'];
      const LATE_SPAWN_KEYWORDS = ['volcano', 'tundra', 'snow', 'ice', 'ruins', 'abyss', 'sanctuary', 'dungeon', 'frost'];
      const evaluateAccessibility = pal => {
        const rarity = Number(pal?.rarity) || 0;
        const price = Number(pal?.price) || 0;
        const areas = Array.isArray(pal?.spawnAreas) ? pal.spawnAreas : [];
        const normalizedAreas = areas.map(area => String(area || '').toLowerCase());
        const hasStarterArea = normalizedAreas.some(area => STARTER_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        const hasMidArea = normalizedAreas.some(area => MID_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        const hasLateArea = normalizedAreas.some(area => LATE_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        let spawnPenalty = 1.5;
        if (!normalizedAreas.length) {
          spawnPenalty = 2;
        } else if (hasStarterArea) {
          spawnPenalty = 0;
        } else if (hasLateArea) {
          spawnPenalty = stageIndex >= 4 ? 1.5 : 4;
        } else if (hasMidArea) {
          spawnPenalty = stageIndex >= 2 ? 1.2 : 2.6;
        } else {
          spawnPenalty = 1.2;
        }
        const rarityPenalty = Math.max(0, rarity - rarityCap);
        const pricePenalty = priceCap > 0 ? Math.max(0, price - priceCap) / priceCap : 0;
        const accessible =
          rarity <= rarityCap &&
          (price === 0 || price <= priceCap) &&
          (spawnPenalty <= 2 || stageIndex >= 3);
        const accessibilityScore = rarityPenalty * 6 + pricePenalty * 4 + spawnPenalty + (accessible ? 0 : 15);
        return { accessible, accessibilityScore };
      };
      if (crew && Array.isArray(crew.selections)) {
        crew.selections.forEach(entry => {
          if (!entry || !entry.pal) return;
          if (!Array.isArray(entry.contributions)) return;
          if (!entry.contributions.some(contribution => contribution.key === key)) return;
          const name = entry.pal.name;
          if (!name || seen.has(name)) return;
          if (!entry.isCaught && result.kid.length < 2) {
            result.kid.push(name);
            seen.add(name);
            return;
          }
          if (entry.isCaught && result.grown.length < 2) {
            result.grown.push(name);
            seen.add(name);
          }
        });
      }
      if (result.kid.length < 2 || result.grown.length < 2) {
        const dataset = Object.values(PALS || {})
          .filter(pal => pal?.work && Number(pal.work[key]) > 0)
          .map(pal => {
            const { accessible, accessibilityScore } = evaluateAccessibility(pal);
            return {
              pal,
              accessible,
              accessibilityScore,
              workLevel: Number(pal.work[key]) || 0
            };
          })
          .sort((a, b) => {
            if (b.workLevel !== a.workLevel) return b.workLevel - a.workLevel;
            if (a.accessible !== b.accessible) return a.accessible ? -1 : 1;
            if (a.accessibilityScore !== b.accessibilityScore) return a.accessibilityScore - b.accessibilityScore;
            const rarityDiff = (a.pal.rarity || 0) - (b.pal.rarity || 0);
            if (rarityDiff !== 0) return rarityDiff;
            const priceDiff = (a.pal.price || 0) - (b.pal.price || 0);
            if (priceDiff !== 0) return priceDiff;
            return a.pal.name.localeCompare(b.pal.name);
          });
        dataset.forEach(entry => {
          const pal = entry.pal;
          if (!pal?.name || seen.has(pal.name)) return;
          if (result.kid.length < 2) {
            result.kid.push(pal.name);
          }
          if (result.grown.length < 2) {
            result.grown.push(pal.name);
          }
          seen.add(pal.name);
        });
      }
      if (!result.grown.length) {
        result.grown = result.kid.slice();
      }
      if (!result.kid.length) {
        result.kid = result.grown.slice();
      }
      return result;
    }
    function calculateEffectiveWorkWeights(config, context = {}) {
      const baseWeights = config?.workWeights || {};
      const weights = {};
      Object.keys(baseWeights).forEach(key => {
        weights[key] = baseWeights[key];
      });
      const defaultWeight = config?.defaultWeight != null ? config.defaultWeight : 0.2;
      const stageSnapshot = context.stageSnapshot || determineGuideStageSnapshot();
      const stageIndex = typeof stageSnapshot?.stageIndex === 'number' ? stageSnapshot.stageIndex : null;
      if (!hasAnyTechUnlocked(MEDICINE_TECH_NAMES)) {
        if (weights.medicine != null) {
          weights.medicine = Math.min(weights.medicine, defaultWeight * 0.6);
        } else {
          weights.medicine = defaultWeight * 0.5;
        }
      }
      if (hasAnyTechUnlocked(FURNACE_TECH_NAMES)) {
        const baseKindling = weights.kindling != null ? weights.kindling : defaultWeight;
        weights.kindling = Math.max(baseKindling, baseKindling + 0.15);
        const baseMining = weights.mining != null ? weights.mining : defaultWeight;
        weights.mining = Math.max(baseMining, baseMining + 0.05);
        const baseTransport = weights.transporting != null ? weights.transporting : defaultWeight;
        weights.transporting = Math.max(baseTransport, baseTransport + 0.05);
      }
      if (stageIndex != null && stageIndex >= 2) {
        const baseFarming = weights.farming != null ? weights.farming : defaultWeight;
        weights.farming = Math.max(baseFarming, baseFarming + 0.1);
        const basePlanting = weights.planting != null ? weights.planting : defaultWeight;
        weights.planting = Math.max(basePlanting, basePlanting + 0.05);
        const baseWatering = weights.watering != null ? weights.watering : defaultWeight;
        weights.watering = Math.max(baseWatering, baseWatering + 0.05);
      }
      if (hasAnyTechUnlocked(POWER_TECH_NAMES)) {
        const basePower = weights.generating_electricity != null ? weights.generating_electricity : defaultWeight;
        weights.generating_electricity = Math.max(basePower, basePower + 0.08);
      }
      return weights;
    }
    function generateCoverageNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      if (!crew || !crew.coverage) return notes;
      const entries = Object.entries(weights || config?.workWeights || {})
        .filter(([, weight]) => weight && weight > 0)
        .sort((a, b) => b[1] - a[1]);
      if (!entries.length) return notes;
      const highestWeight = entries[0][1];
      const threshold = (config?.defaultWeight != null ? config.defaultWeight : 0.2) * 1.5;
      const gaps = entries
        .map(([key, weight]) => {
          const total = crew.coverage[key] || 0;
          const descriptor = coverageDescriptor(weight, total, config, highestWeight);
          return { key, weight, descriptor };
        })
        .filter(entry => entry.descriptor.percent < 55 && entry.weight >= threshold);
      gaps.sort((a, b) => {
        if (a.descriptor.percent !== b.descriptor.percent) {
          return a.descriptor.percent - b.descriptor.percent;
        }
        return b.weight - a.weight;
      });
      const ranchPlan = computeRanchPlan({ stageSnapshot, limit: kidMode ? 3 : 4 });
      let ranchNoteAdded = false;
      gaps.slice(0, 2).forEach(entry => {
        const canonical = canonicalWorkKey(entry.key);
        if (canonical === 'farming') {
          if (ranchNoteAdded) return;
          ranchNoteAdded = true;
          const focusKid = ranchPlan.recommendations.map(rec => rec.name).slice(0, kidMode ? 2 : 3).join(' & ');
          const focusGrown = ranchPlan.recommendations.map(rec => rec.name).slice(0, 3).join(' • ');
          const primary = ranchPlan.recommendations[0] || null;
          const secondary = ranchPlan.recommendations[1] || null;
          const kidLines = [];
          if (focusKid) {
            kidLines.push(ranchPlan.hasRanch
              ? `Ranch focus: ${focusKid}.`
              : `Plan for ${focusKid} when the Ranch is ready.`);
          } else if (!ranchPlan.hasRanch) {
            kidLines.push('Unlock the Ranch to start making special items.');
          }
          if (primary?.reasonKid) kidLines.push(primary.reasonKid);
          if (primary?.actionKid) kidLines.push(primary.actionKid);
          if (secondary && !secondary.caughtProducers.length) {
            kidLines.push(secondary.actionKid);
          }
          if (!kidLines.length) {
            kidLines.push('Assign a pal to the Ranch to begin passive production.');
          }
          const grownLines = [];
          if (focusGrown) {
            grownLines.push(ranchPlan.hasRanch
              ? `Target outputs: ${focusGrown}.`
              : `Queue these outputs post-Ranch: ${focusGrown}.`);
          } else if (!ranchPlan.hasRanch) {
            grownLines.push('Unlock the Ranch to add passive item production.');
          }
          if (primary?.reasonGrown) grownLines.push(primary.reasonGrown);
          if (primary?.actionGrown) grownLines.push(primary.actionGrown);
          if (secondary && secondary.missingProducers.length) {
            grownLines.push(`Recruit ${secondary.missingProducers.join(', ')} to unlock ${secondary.name.toLowerCase()}.`);
          }
          if (!grownLines.length) {
            grownLines.push('Review ranch slots and assign producers for upcoming recipes.');
          }
          notes.push({
            id: 'coverage-ranch-plan',
            icon: '🐑',
            badge: { kid: 'Ranch', grown: 'Ranch' },
            kid: {
              title: 'Ranch plan',
              lines: kidLines
            },
            grown: {
              title: 'Ranch focus',
              lines: grownLines
            }
          });
          return;
        }
        const detail = getWorkTypeDetail(entry.key);
        const helperNames = suggestPalsForWork(entry.key, { crew, baseConfig: config, stageSnapshot });
        const kidTargets = helperNames.kid.slice(0, 2);
        const grownTargets = helperNames.grown.slice(0, 2);
        const kidLines = [
          `We need more ${detail.kidLabel || detail.label.toLowerCase()} helpers (${Math.round(entry.descriptor.percent)}% filled).`
        ];
        if (kidTargets.length) {
          kidLines.push(`Try ${kidTargets.join(' or ')}.`);
        } else {
          kidLines.push('Open the pal list to find workers with this job.');
        }
        kidLines.push('Switch pals around until this meter turns green.');
        const grownLines = [
          `${detail.label} coverage is ${Math.round(entry.descriptor.percent)}%.`,
          grownTargets.length
            ? `Recruit or reassign ${grownTargets.join(' or ')}.`
            : 'Review your pal list for strong specialists to cover this role.',
          'Balancing this job keeps automation from stalling.'
        ];
        notes.push({
          id: `coverage-${entry.key}`,
          icon: detail.icon || '⭐',
          badge: { kid: 'Coverage', grown: 'Coverage' },
          kid: {
            title: `${detail.kidLabel || detail.label} boost`,
            lines: kidLines
          },
          grown: {
            title: `${detail.label} priority`,
            lines: grownLines
          }
        });
      });
      return notes;
    }
    function generateCatchNotes(crew) {
      const notes = [];
      if (!crew || !Array.isArray(crew.selections)) return notes;
      const missing = crew.selections.filter(entry => entry && entry.pal && !entry.isCaught);
      missing.sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        return b.rawScore - a.rawScore;
      });
      missing.slice(0, 3).forEach(entry => {
        const pal = entry.pal;
        const contributions = Array.isArray(entry.contributions) ? entry.contributions : [];
        const top = contributions.slice(0, 2);
        const kidHighlights = top.map(contribution => {
          const detail = getWorkTypeDetail(contribution.key);
          return `${detail.kidLabel || detail.label} ${workLevelLabel(contribution.level)}`;
        });
        const grownHighlights = top.map(contribution => {
          const detail = getWorkTypeDetail(contribution.key);
          return `${detail.label} Lv ${contribution.level}`;
        });
        const habitats = Array.isArray(pal.spawnAreas) && pal.spawnAreas.length
          ? pal.spawnAreas.slice(0, 2).join(', ')
          : '';
        const rarityLabel = rarityNames[pal.rarity] || '';
        const sphere = raritySphere[pal.rarity] || 'Pal Sphere';
        const kidLines = [
          kidHighlights.length ? `${pal.name} brings ${kidHighlights.join(' & ')}.` : `${pal.name} helps with lots of jobs.`,
          habitats ? `Look in ${habitats}.` : 'Check the map page to see where it lives.',
          `Try a ${sphere}.`
        ];
        const grownLines = [
          `${pal.name} covers ${grownHighlights.join(', ') || 'important roles'}${rarityLabel ? ` (${rarityLabel})` : ''}.`,
          habitats ? `Spawns: ${habitats}.` : 'Use the map tab or modal to confirm spawn points.',
          `Suggested sphere: ${sphere}.`
        ];
        notes.push({
          id: `target-${pal.id}`,
          icon: '🎯',
          badge: { kid: 'Next catch', grown: 'Next catch' },
          kid: {
            title: `Catch ${pal.name}`,
            lines: kidLines
          },
          grown: {
            title: `Recruit ${pal.name}`,
            lines: grownLines
          }
        });
      });
      return notes;
    }
    function generateTechPriorityNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      const medicineUnlocked = hasAnyTechUnlocked(MEDICINE_TECH_NAMES);
      if (!medicineUnlocked && (weights?.medicine || 0) > (config?.defaultWeight || 0.2) * 0.5) {
        notes.push({
          id: 'tech-medicine',
          icon: '💊',
          badge: { kid: 'Heads-up', grown: 'Heads-up' },
          kid: {
            title: 'Medicine comes later',
            lines: [
              'No doctor table is unlocked yet, so it is okay if healer pals rest for now.',
              'Focus on builders, haulers, and fire pals until the medicine bench is ready.'
            ]
          },
          grown: {
            title: 'Delay medicine coverage',
            lines: [
              'Medicine benches are not unlocked, so Palmate deprioritises specialist healers.',
              'Revisit once the Medieval Medicine Workbench (or better) is marked unlocked.'
            ]
          }
        });
      }
      const honeyCandidates = palsThatDropItem('honey');
      const hasHoneyPal = honeyCandidates.some(pal => caught && caught[pal.id]);
      const hasRanch = isTechUnlocked('Ranch');
      if (hasRanch && !hasHoneyPal && (stageSnapshot?.stageIndex ?? 0) >= 1) {
        const honeyNames = honeyCandidates.map(pal => pal.name).filter(Boolean);
        const preview = honeyNames.slice(0, 2).join(' or ') || 'Beegarde';
        notes.push({
          id: 'tech-honey',
          icon: '🍯',
          badge: { kid: 'Cake prep', grown: 'Cake prep' },
          kid: {
            title: 'Catch a honey pal',
            lines: [
              `We still need honey for Cakes. Try to catch ${preview} soon.`,
              'Give them a Ranch slot so honey flows while you explore.'
            ]
          },
          grown: {
            title: 'Secure honey production',
            lines: [
              `Cakes hinge on honey—target ${preview} and park them on the Ranch.`,
              'Pair with Mozzarina (milk) and Chikipi (eggs) to complete the recipe pipeline.'
            ]
          }
        });
      }
      const furnaceUnlocked = hasAnyTechUnlocked(FURNACE_TECH_NAMES);
      if (furnaceUnlocked) {
        const kindlingCoverage = crew?.coverage?.kindling || 0;
        const expected = Math.max(1, crew?.slotCount || 1) * Math.max(1, MAX_WORK_LEVEL);
        if (kindlingCoverage < expected * 0.6) {
          const helpers = suggestPalsForWork('kindling', { crew, baseConfig: config, stageSnapshot });
          const kidTargets = helpers.kid.slice(0, 2).join(' or ') || 'strong fire pals';
          const grownTargets = helpers.grown.slice(0, 2).join(' or ') || 'dedicated Kindling specialists';
          notes.push({
            id: 'tech-kindling',
            icon: '🔥',
            badge: { kid: 'Smelting', grown: 'Smelting' },
            kid: {
              title: 'More fire pals',
              lines: [
                `Furnaces love fire pals. Add ${kidTargets} to keep metal bars cooking.`,
                'More flames mean faster saddles, weapons, and Cake cookware.'
              ]
            },
            grown: {
              title: 'Boost kindling uptime',
              lines: [
                `Kindling coverage is light—recruit ${grownTargets} so furnaces never idle.`,
                'Parallel smelters prevent bottlenecks during the midgame tech rush.'
              ]
            }
          });
        }
      }
      return notes;
    }
    function generateBaseIntelNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      const queue = new Set();
      const addNote = note => {
        if (!note || !note.id || queue.has(note.id)) return;
        queue.add(note.id);
        notes.push(note);
      };
      const pending = snapshot.pendingBaseSteps || [];
      const prioritizedStep = pending.find(entry => {
        if (snapshot.stageIndex != null && entry.chapterIndex > snapshot.stageIndex + 1) return false;
        return true;
      }) || pending[0];
      if (prioritizedStep) {
        addNote(createBaseStepNote(prioritizedStep));
      } else {
        addNote(createStageOverviewNote(snapshot));
      }
      generateCoverageNotes({ config, crew, weights, stageSnapshot: snapshot }).forEach(addNote);
      generateCatchNotes(crew).forEach(addNote);
      generateTechPriorityNotes({ config, crew, weights, stageSnapshot: snapshot }).forEach(addNote);
      const ranchAssignment = crew?.ranchAssignment;
      if (ranchAssignment && (ranchAssignment.itemName || ranchAssignment.palName)) {
        const kidLines = [
          ranchAssignment.palName && ranchAssignment.itemName
            ? `${ranchAssignment.palName} stays on the Ranch making ${ranchAssignment.itemName}.`
            : null,
          ranchAssignment.reasonKid || null,
          ranchAssignment.actionKid || null
        ].filter(Boolean);
        const grownLines = [
          ranchAssignment.palName && ranchAssignment.itemName
            ? `${ranchAssignment.palName} reserved on the Ranch for ${ranchAssignment.itemName}.`
            : null,
          ranchAssignment.reasonGrown || null,
          ranchAssignment.actionGrown || null
        ].filter(Boolean);
        addNote({
          id: `ranch-assignment-${ranchAssignment.itemKey || 'active'}`,
          icon: '🐑',
          badge: { kid: 'Ranch', grown: 'Ranch' },
          kid: {
            title: 'Ranch helper locked in',
            lines: kidLines.length ? kidLines : ['Keep a pal on the Ranch so items pile up.']
          },
          grown: {
            title: 'Ranch plan active',
            lines: grownLines.length ? grownLines : ['Reserve one worker on the Ranch and rebalance the crew.']
          }
        });
      }
      if (!notes.length) {
        addNote(createStageOverviewNote(snapshot));
      }
      return notes.slice(0, 6);
    }
    function renderBaseIntelNotes(notes, activeIndex, { stageSnapshot } = {}) {
      const elements = basePlannerElements || {};
      if (elements.intelStage) {
        const label = kidMode
          ? (stageSnapshot?.stageTitleKid || 'Follow the guide')
          : (stageSnapshot?.stageTitleGrown || 'Follow the route guide');
        const badgeText = typeof stageSnapshot?.progressPercent === 'number'
          ? `${stageSnapshot.progressPercent}% ${kidMode ? 'done' : 'complete'}`
          : '';
        const parts = [];
        parts.push(`<span>${escapeHTML(label)}</span>`);
        if (badgeText) {
          parts.push(`<span class="base-intel-stage__badge">${escapeHTML(badgeText)}</span>`);
        }
        elements.intelStage.innerHTML = parts.join(' ');
      }
      if (elements.intelMeta) {
        const total = notes.length;
        if (total > 1) {
          elements.intelMeta.textContent = kidMode
            ? `Palmate shows ${total} tips. They swap every ${Math.round(BASE_INTEL_ROTATION_INTERVAL / 1000)} seconds.`
            : `${total} rotating notes — auto-advance every ${Math.round(BASE_INTEL_ROTATION_INTERVAL / 1000)}s.`;
        } else if (total === 1) {
          elements.intelMeta.textContent = kidMode
            ? 'Palmate found one big tip for your base.'
            : 'Palmate found a key insight for your base.';
        } else {
          elements.intelMeta.textContent = kidMode
            ? 'Mark guide steps and unlock tech so Palmate can share base tips.'
            : 'Track guide progress and unlocked tech to unlock tailored base insights.';
        }
      }
      const container = elements.intelNotes;
      if (!container) return;
      container.innerHTML = '';
      if (!notes.length) {
        const empty = document.createElement('div');
        empty.className = 'base-note base-note--active';
        const body = document.createElement('p');
        body.className = 'base-note__body';
        body.textContent = kidMode
          ? 'Palmate needs more info. Check off guide steps and mark pals as caught to unlock tips!'
          : 'Palmate needs more data. Update your guide steps and captured pals to unlock insights.';
        empty.appendChild(body);
        container.appendChild(empty);
        return;
      }
      notes.forEach((note, index) => {
        const card = document.createElement('article');
        card.className = `base-note${index === activeIndex ? ' base-note--active' : ''}`;
        const header = document.createElement('div');
        header.className = 'base-note__header';
        const icon = document.createElement('div');
        icon.className = 'base-note__icon';
        icon.textContent = note.icon || '⭐';
        header.appendChild(icon);
        const title = document.createElement('h4');
        title.className = 'base-note__title';
        const variant = kidMode ? note.kid : note.grown;
        title.textContent = variant?.title || (kidMode ? 'Base tip' : 'Base insight');
        header.appendChild(title);
        card.appendChild(header);
        const badge = note.badge && (kidMode ? note.badge.kid : note.badge.grown);
        if (badge) {
          const badgeEl = document.createElement('span');
          badgeEl.className = 'base-note__badge';
          badgeEl.textContent = badge;
          card.appendChild(badgeEl);
        }
        (variant?.lines || []).forEach(line => {
          if (!line) return;
          const body = document.createElement('p');
          body.className = 'base-note__body';
          body.textContent = line;
          card.appendChild(body);
        });
        if (variant?.footer) {
          const footer = document.createElement('div');
          footer.className = 'base-note__footer';
          footer.textContent = variant.footer;
          card.appendChild(footer);
        }
        container.appendChild(card);
      });
    }
    function restartBaseIntelTimer() {
      if (baseIntelState.rotationTimer) {
        clearInterval(baseIntelState.rotationTimer);
        baseIntelState.rotationTimer = null;
      }
      if (!baseIntelState.notes || baseIntelState.notes.length <= 1) {
        return;
      }
      baseIntelState.rotationTimer = setInterval(() => {
        rotateBaseIntel(1);
      }, BASE_INTEL_ROTATION_INTERVAL);
    }
    function rotateBaseIntel(step = 1, { userInitiated = false } = {}) {
      const notes = baseIntelState.notes || [];
      if (!notes.length) return;
      const total = notes.length;
      baseIntelState.activeIndex = (baseIntelState.activeIndex + step + total) % total;
      renderBaseIntelNotes(notes, baseIntelState.activeIndex, { stageSnapshot: baseIntelState.stageSnapshot });
      if (userInitiated) {
        restartBaseIntelTimer();
      }
    }
    function updateBaseIntel(config, crew, { weights, stageSnapshot } = {}) {
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      baseIntelState.stageSnapshot = snapshot;
      const previous = baseIntelState.notes && baseIntelState.notes[baseIntelState.activeIndex];
      const previousId = previous?.id || null;
      const notes = generateBaseIntelNotes({ config, crew, weights, stageSnapshot: snapshot });
      baseIntelState.notes = notes;
      if (previousId) {
        const idx = notes.findIndex(note => note.id === previousId);
        baseIntelState.activeIndex = idx >= 0 ? idx : 0;
      } else {
        baseIntelState.activeIndex = 0;
      }
      renderBaseIntelNotes(notes, baseIntelState.activeIndex, { stageSnapshot: snapshot });
      restartBaseIntelTimer();
    }
    function getBaseLevelConfig(level) {
      if (!Array.isArray(BASE_LEVEL_CONFIG) || !BASE_LEVEL_CONFIG.length) return null;
      return BASE_LEVEL_CONFIG.find(cfg => cfg.level === level) || BASE_LEVEL_CONFIG[BASE_LEVEL_CONFIG.length - 1];
    }
    function computeMaxWorkLevel() {
      let max = 0;
      Object.values(PALS || {}).forEach(pal => {
        const work = pal?.work || {};
        Object.values(work).forEach(value => {
          if (typeof value === 'number' && value > max) {
            max = value;
          }
        });
      });
      return max || 4;
    }
    function workLevelLabel(level) {
      const numeric = Number(level) || 0;
      return `Lv ${numeric}`;
    }
    function buildBasePage() {
      const page = document.getElementById('basePage');
      if (!page) return;
      const introText = kidMode
        ? 'Palmate watches your tech unlocks and pals to build a dream crew for your base.'
        : 'Palmate analyses unlocked tech, captured pals, and work priorities to recommend an optimal base roster.';
      page.innerHTML = `
        <header class="page-header">
          <h2>${kidMode ? 'Base Crew' : 'Base Planner'}</h2>
        </header>
        <p class="page-intro">${introText}</p>
        <div class="base-planner-layout">
          <article class="base-card base-card--intel">
            <div class="base-card__header base-card__header--intel">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Base intel' : 'Base intel'}</h3>
                <p class="base-card__meta" id="baseIntelMeta"></p>
              </div>
              <div class="base-intel__controls">
                <button type="button" class="base-intel__shuffle" id="baseIntelShuffle">${kidMode ? 'Next tip' : 'Shuffle tips'}</button>
                <span class="base-intel__hint">${kidMode ? 'Palmate swaps tips every 20 seconds.' : 'Tips auto-rotate every 20 seconds.'}</span>
              </div>
            </div>
            <div class="base-intel__context">
              <div class="base-intel-stage" id="baseIntelStage"></div>
            </div>
            <div class="base-intel-notes" id="baseIntelNotes"></div>
          </article>
          <article class="base-card base-card--level">
            <div class="base-card__header">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Track your base level' : 'Track your base level'}</h3>
                <p class="base-card__meta" id="baseLevelCopy"></p>
              </div>
              <span class="base-card__badge" id="baseModeBadge"></span>
            </div>
            <div class="base-level-summary">
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Auto level' : 'Detected level'}</span>
                <span class="base-level-summary__value" id="baseDetectedLevel">1</span>
              </div>
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Manual level' : 'Manual level'}</span>
                <span class="base-level-summary__value" id="baseManualValue">1</span>
              </div>
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Crew slots' : 'Slots available'}</span>
                <span class="base-level-summary__value" id="baseSlotCount">5</span>
              </div>
            </div>
            <label for="baseLevelInput">${kidMode ? 'Slide to match your base level.' : 'Use the slider when you want to override the detected level.'}</label>
            <input type="range" min="1" max="${BASE_LEVEL_CONFIG.length}" value="${basePlannerState.manualLevel}" id="baseLevelInput" class="base-level-slider">
            <div class="base-level-controls">
              <button type="button" class="base-toggle" id="baseManualToggle" aria-pressed="${basePlannerState.mode === 'manual'}">${kidMode ? 'Manual level' : 'Manual control'}: ${basePlannerState.mode === 'manual' ? (kidMode ? 'On' : 'On') : (kidMode ? 'Off' : 'Off')}</button>
              <button type="button" class="base-toggle" id="baseUseDetected">${kidMode ? 'Use detected level' : 'Use detected level'}</button>
            </div>
            <p class="base-card__hint" id="baseLevelHint"></p>
            <p class="base-card__meta" id="baseFocusText"></p>
            <ul class="base-priority-list" id="basePriorityList"></ul>
          </article>
          <article class="base-card base-card--crew">
            <div class="base-card__header">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Suggested pals' : 'Suggested crew'}</h3>
                <p class="base-card__meta" id="baseCrewMeta"></p>
              </div>
              <span class="base-card__badge" id="baseActiveBadge"></span>
            </div>
            <div class="base-slot-grid" id="baseSlotsGrid"></div>
            <div>
              <h4 class="base-card__title" style="font-size:1rem;">${kidMode ? 'Coverage check' : 'Work coverage check'}</h4>
            </div>
            <div class="base-coverage-grid" id="baseCoverageGrid"></div>
          </article>
        </div>
      `;
      basePlannerElements = {
        page,
        slider: page.querySelector('#baseLevelInput'),
        manualToggle: page.querySelector('#baseManualToggle'),
        useDetected: page.querySelector('#baseUseDetected'),
        detectedValue: page.querySelector('#baseDetectedLevel'),
        manualValue: page.querySelector('#baseManualValue'),
        slotCount: page.querySelector('#baseSlotCount'),
        levelHint: page.querySelector('#baseLevelHint'),
        priorityList: page.querySelector('#basePriorityList'),
        slotsGrid: page.querySelector('#baseSlotsGrid'),
        coverageGrid: page.querySelector('#baseCoverageGrid'),
        focusText: page.querySelector('#baseFocusText'),
        levelCopy: page.querySelector('#baseLevelCopy'),
        crewMeta: page.querySelector('#baseCrewMeta'),
        modeBadge: page.querySelector('#baseModeBadge'),
        activeBadge: page.querySelector('#baseActiveBadge'),
        intelNotes: page.querySelector('#baseIntelNotes'),
        intelMeta: page.querySelector('#baseIntelMeta'),
        intelStage: page.querySelector('#baseIntelStage'),
        intelShuffle: page.querySelector('#baseIntelShuffle')
      };
      if (baseIntelState.rotationTimer) {
        clearInterval(baseIntelState.rotationTimer);
        baseIntelState.rotationTimer = null;
      }
      if (basePlannerElements.slider) {
        basePlannerElements.slider.max = String(BASE_LEVEL_CONFIG.length);
        basePlannerElements.slider.addEventListener('input', event => {
          const raw = Number(event.target.value);
          const value = clampToRange(Number.isFinite(raw) ? Math.round(raw) : 1, 1, BASE_LEVEL_CONFIG.length || 1);
          basePlannerState.manualLevel = value;
          basePlannerState.mode = 'manual';
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.manualToggle) {
        basePlannerElements.manualToggle.addEventListener('click', () => {
          if (basePlannerState.mode === 'manual') {
            basePlannerState.mode = 'auto';
          } else {
            const sliderValue = basePlannerElements.slider ? Number(basePlannerElements.slider.value) : NaN;
            const fallback = calculateAutoBaseLevelDetail().level;
            basePlannerState.manualLevel = clampToRange(Number.isFinite(sliderValue) ? Math.round(sliderValue) : fallback, 1, BASE_LEVEL_CONFIG.length || 1);
            basePlannerState.mode = 'manual';
          }
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.useDetected) {
        basePlannerElements.useDetected.addEventListener('click', () => {
          const autoInfo = calculateAutoBaseLevelDetail();
          basePlannerState.manualLevel = autoInfo.level;
          basePlannerState.mode = 'auto';
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.intelShuffle) {
        basePlannerElements.intelShuffle.addEventListener('click', () => {
          rotateBaseIntel(1, { userInitiated: true });
        });
      }
      updateBasePlanner();
    }
    function updateBasePlanner() {
      const elements = basePlannerElements || {};
      if (!elements.slider || !BASE_LEVEL_CONFIG.length) return;
      const autoInfo = calculateAutoBaseLevelDetail();
      const clampedManual = clampToRange(basePlannerState.manualLevel || autoInfo.level || 1, 1, BASE_LEVEL_CONFIG.length || 1);
      if (basePlannerState.manualLevel !== clampedManual) {
        basePlannerState.manualLevel = clampedManual;
        persistBasePlannerState();
      }
      const useManual = basePlannerState.mode === 'manual';
      const activeLevel = useManual ? basePlannerState.manualLevel : autoInfo.level;
      const config = getBaseLevelConfig(activeLevel);
      if (!config) return;
      const stageSnapshot = determineGuideStageSnapshot();
      const weights = calculateEffectiveWorkWeights(config, { stageSnapshot, activeLevel, autoInfo });
      const ranchPlan = computeRanchPlan({ stageSnapshot, limit: kidMode ? 3 : 4 });
      const resolvedRanchAssignment = resolveRanchAssignment({ plan: ranchPlan });
      const sliderValue = useManual ? basePlannerState.manualLevel : autoInfo.level;
      elements.slider.value = String(sliderValue);
      elements.slider.disabled = !useManual;
      if (elements.slider.disabled) {
        elements.slider.setAttribute('aria-disabled', 'true');
      } else {
        elements.slider.removeAttribute('aria-disabled');
      }
      if (elements.manualValue) {
        elements.manualValue.textContent = String(sliderValue);
      }
      if (elements.detectedValue) {
        elements.detectedValue.textContent = String(autoInfo.level || 1);
      }
      if (elements.slotCount) {
        elements.slotCount.textContent = String(config.slots);
      }
      if (elements.modeBadge) {
        elements.modeBadge.textContent = useManual
          ? (kidMode ? 'Manual' : 'Manual override')
          : (kidMode ? 'Auto detect' : 'Auto detect');
      }
      if (elements.activeBadge) {
        elements.activeBadge.textContent = `Lv ${activeLevel}`;
      }
      if (elements.levelCopy) {
        elements.levelCopy.textContent = kidMode ? (config.copy?.kid || '') : (config.copy?.grown || '');
      }
      if (elements.focusText) {
        const focusNames = Array.isArray(config.focus)
          ? config.focus.map(key => {
              const detail = getWorkTypeDetail(key);
              return kidMode ? (detail.kidLabel || detail.label) : detail.label;
            }).filter(Boolean)
          : [];
        elements.focusText.textContent = focusNames.length
          ? `${kidMode ? 'Focus:' : 'Priority focus:'} ${focusNames.join(kidMode ? ', ' : ' • ')}`
          : '';
      }
      if (elements.manualToggle) {
        elements.manualToggle.setAttribute('aria-pressed', useManual ? 'true' : 'false');
        elements.manualToggle.textContent = `${kidMode ? 'Manual level' : 'Manual control'}: ${useManual ? (kidMode ? 'On' : 'On') : (kidMode ? 'Off' : 'Off')}`;
      }
      if (elements.useDetected) {
        elements.useDetected.disabled = !useManual && autoInfo.level === basePlannerState.manualLevel;
      }
      if (elements.levelHint) {
        const hints = [];
        if (useManual) {
          hints.push(kidMode ? 'Manual mode is on. Match the slider to your real base level.' : 'Manual override active. Use the slider to match your in-game base level.');
        } else if (autoInfo.highestItem) {
          hints.push(kidMode
            ? `Detected level from ${autoInfo.highestItem.name} (Tech Lv ${autoInfo.highestItem.techLevel}).`
            : `Detected from ${autoInfo.highestItem.name} at Tech Lv ${autoInfo.highestItem.techLevel}.`);
        } else {
          hints.push(kidMode ? 'No base unlocks marked yet, so we start at Level 1.' : 'No base-focused tech marked unlocked yet. Defaulting to Level 1.');
        }
        if (!useManual && autoInfo.highestItem) {
          hints.push(kidMode ? 'Switch to manual if your camp is ahead.' : 'Toggle manual control if your base has progressed further.');
        }
        elements.levelHint.textContent = hints.join(' ');
      }
      if (elements.priorityList) {
        elements.priorityList.innerHTML = '';
        const entries = Object.entries(weights || {})
          .filter(([, weight]) => weight && weight > 0)
          .sort((a, b) => b[1] - a[1]);
        const limit = kidMode ? Math.min(entries.length, 5) : entries.length;
        entries.slice(0, limit).forEach(([key, weight]) => {
          const detail = getWorkTypeDetail(key);
          const item = document.createElement('li');
          item.className = 'base-priority-item';
          const icon = document.createElement('span');
          icon.className = 'base-priority-item__icon';
          icon.textContent = detail.icon || '⭐';
          item.appendChild(icon);
          const content = document.createElement('div');
          content.className = 'base-priority-item__content';
          const label = document.createElement('span');
          label.className = 'base-priority-item__label';
          label.textContent = kidMode ? (detail.kidLabel || detail.label) : detail.label;
          content.appendChild(label);
          const note = document.createElement('p');
          note.className = 'base-priority-item__note';
          const descriptor = priorityDescriptor(weight);
          note.textContent = kidMode ? descriptor.kid : descriptor.grown;
          content.appendChild(note);
          item.appendChild(content);
          elements.priorityList.appendChild(item);
        });
      }
      const crew = recommendBaseCrew(config, { stageSnapshot, weightsOverride: weights, ranchAssignment: resolvedRanchAssignment });
      updateBaseIntel(config, crew, { weights, stageSnapshot });
      if (elements.slotsGrid) {
        elements.slotsGrid.innerHTML = '';
        for (let slotIndex = 0; slotIndex < config.slots; slotIndex += 1) {
          const entry = crew.selections[slotIndex];
          if (entry && entry.pal) {
            const card = document.createElement('article');
            card.className = 'base-slot-card';
            card.dataset.palId = entry.pal.id || '';
            if (entry.assignmentType === 'ranch' || (entry.assignment && entry.assignment.type === 'ranch')) {
              card.classList.add('base-slot-card--ranch');
            }
            const header = document.createElement('div');
            header.className = 'base-slot-card__header';
            const slotLabel = document.createElement('span');
            slotLabel.className = 'base-slot-card__slot';
            slotLabel.textContent = `${kidMode ? 'Slot' : 'Slot'} ${slotIndex + 1}`;
            header.appendChild(slotLabel);
            const status = document.createElement('span');
            status.className = `base-slot-card__status ${entry.isCaught ? 'base-slot-card__status--caught' : 'base-slot-card__status--missing'}`;
            status.textContent = entry.isCaught ? (kidMode ? 'Caught' : 'Caught') : (kidMode ? 'Catch next' : 'Not caught');
            header.appendChild(status);
            if (entry.assignment && entry.assignment.type === 'ranch') {
              const badge = document.createElement('span');
              badge.className = 'base-slot-card__assignment';
              badge.textContent = kidMode ? 'Ranch pal' : 'Ranch pal';
              header.appendChild(badge);
            }
            card.appendChild(header);
            const palInfo = document.createElement('div');
            palInfo.className = 'base-slot-card__pal';
            const portrait = document.createElement('img');
            portrait.className = 'base-slot-card__portrait';
            applyPalArtwork(portrait, entry.pal, { alt: `${entry.pal.name || 'Pal'} portrait` });
            palInfo.appendChild(portrait);
            const infoWrap = document.createElement('div');
            infoWrap.className = 'base-slot-card__info';
            const nameEl = document.createElement('h4');
            nameEl.className = 'base-slot-card__name';
            nameEl.textContent = entry.pal.name || 'Pal';
            infoWrap.appendChild(nameEl);
            const types = Array.isArray(entry.pal.types) ? entry.pal.types : [];
            if (types.length) {
              const typesWrap = document.createElement('div');
              typesWrap.className = 'base-slot-card__types';
              types.forEach(type => {
                const icon = document.createElement('img');
                icon.src = iconMap[type] || iconMap['Neutral'];
                icon.alt = `${type} icon`;
                typesWrap.appendChild(icon);
              });
              infoWrap.appendChild(typesWrap);
            }
            palInfo.appendChild(infoWrap);
            card.appendChild(palInfo);
            const workList = document.createElement('ul');
            workList.className = 'base-slot-card__work';
            entry.contributions.slice(0, kidMode ? 2 : 3).forEach(contribution => {
              const detail = getWorkTypeDetail(contribution.key);
              const item = document.createElement('li');
              item.innerHTML = `<span>${detail.icon || '⭐'}</span><span>${kidMode ? (detail.kidLabel || detail.label) : detail.label} ${workLevelLabel(contribution.level)}</span>`;
              workList.appendChild(item);
            });
            card.appendChild(workList);
            const note = document.createElement('p');
            note.className = 'base-slot-card__note';
            if (entry.assignment && entry.assignment.type === 'ranch') {
              const noteTextKid = entry.assignment.noteKid || entry.assignment.actionKid || `Keep ${entry.pal.name} on the Ranch.`;
              const noteTextGrown = entry.assignment.noteGrown || entry.assignment.actionGrown || `Reserve ${entry.pal.name} for ranch output.`;
              note.textContent = kidMode ? noteTextKid : noteTextGrown;
            } else if (entry.note) {
              note.textContent = entry.note;
            } else {
              const highlights = entry.contributions.slice(0, 2).map(contribution => {
                const detail = getWorkTypeDetail(contribution.key);
                const label = kidMode ? (detail.kidLabel || detail.label) : detail.label;
                return `${label} ${workLevelLabel(contribution.level)}`;
              });
              note.textContent = highlights.length
                ? (kidMode ? `Great at ${highlights.join(' & ')}` : `Highlights: ${highlights.join(' • ')}`)
                : (kidMode ? 'Flexible helper' : 'General support');
            }
            card.appendChild(note);
            const actions = document.createElement('div');
            actions.className = 'base-slot-card__actions';
            const viewButton = document.createElement('button');
            viewButton.type = 'button';
            viewButton.className = 'base-slot-card__action base-slot-card__action--primary';
            viewButton.textContent = kidMode ? 'View pal' : 'Open details';
            viewButton.addEventListener('click', event => {
              event.stopPropagation();
              showPalDetail(entry.pal.id);
            });
            actions.appendChild(viewButton);
            const toggleButton = document.createElement('button');
            toggleButton.type = 'button';
            toggleButton.className = 'base-slot-card__action';
            toggleButton.textContent = entry.isCaught
              ? (kidMode ? 'Mark not caught' : 'Mark as not caught')
              : (kidMode ? 'Mark caught' : 'Mark as caught');
            toggleButton.addEventListener('click', event => {
              event.stopPropagation();
              setPalCaught(entry.pal.id, !entry.isCaught);
            });
            actions.appendChild(toggleButton);
            card.appendChild(actions);
            elements.slotsGrid.appendChild(card);
          } else {
            const placeholder = document.createElement('article');
            placeholder.className = 'base-slot-card';
            const header = document.createElement('div');
            header.className = 'base-slot-card__header';
            const slotLabel = document.createElement('span');
            slotLabel.className = 'base-slot-card__slot';
            slotLabel.textContent = `${kidMode ? 'Slot' : 'Slot'} ${slotIndex + 1}`;
            header.appendChild(slotLabel);
            const status = document.createElement('span');
            status.className = 'base-slot-card__status';
            status.textContent = kidMode ? 'Open slot' : 'Open slot';
            header.appendChild(status);
            placeholder.appendChild(header);
            const empty = document.createElement('div');
            empty.className = 'base-slot-card__empty';
            empty.textContent = kidMode
              ? 'Catch another helper to fill this job.'
              : 'Catch or recruit another worker to fill this assignment.';
            placeholder.appendChild(empty);
            elements.slotsGrid.appendChild(placeholder);
          }
        }
      }
      if (elements.crewMeta) {
        const filled = Math.min(crew.selections.length, config.slots);
        const capturedCount = crew.capturedCount || 0;
        const suggestionCount = Math.max(0, filled - capturedCount);
        if (config.slots) {
          const baseSummary = kidMode
            ? `Palmate filled ${filled} of ${config.slots} slots.`
            : `Recommended crew covers ${filled} of ${config.slots} slots.`;
          let detailSummary = '';
          if (!filled) {
            detailSummary = kidMode
              ? 'Catch pals to start filling your camp.'
              : 'Mark captured pals to start building your roster.';
          } else if (kidMode) {
            detailSummary = suggestionCount
              ? `${capturedCount} from your crew, ${suggestionCount} to catch next.`
              : `${capturedCount} from your crew ready to work.`;
          } else {
            const capturedLabel = `${capturedCount} slot${capturedCount === 1 ? '' : 's'} use captured pals`;
            detailSummary = suggestionCount
              ? `${capturedLabel}; ${suggestionCount} new recruit${suggestionCount === 1 ? '' : 's'} suggested.`
              : `${capturedLabel}.`;
          }
          elements.crewMeta.textContent = `${baseSummary} ${detailSummary}`.trim();
        } else {
          elements.crewMeta.textContent = '';
        }
      }
      if (elements.coverageGrid) {
        elements.coverageGrid.innerHTML = '';
        const weightEntries = Object.entries(weights || {})
          .filter(([, weight]) => weight && weight > 0)
          .sort((a, b) => b[1] - a[1]);
        const highestWeight = weightEntries.length ? weightEntries[0][1] : 1;
        if (resolvedRanchAssignment) {
          const summary = document.createElement('div');
          summary.className = 'base-coverage-item base-coverage-item--ranch';
          const header = document.createElement('div');
          header.className = 'base-coverage-item__header';
          const title = document.createElement('span');
          title.className = 'base-coverage-item__title';
          title.innerHTML = `🐑 <span>${kidMode ? 'Ranch focus' : 'Ranch assignment'}</span>`;
          header.appendChild(title);
          const status = document.createElement('span');
          status.className = 'base-coverage-item__status';
          status.textContent = resolvedRanchAssignment.itemName
            ? resolvedRanchAssignment.itemName
            : (kidMode ? 'Ranch planned' : 'Planned output');
          header.appendChild(status);
          summary.appendChild(header);
          const body = document.createElement('div');
          body.className = 'ranch-assignment-summary';
          const palLine = document.createElement('p');
          palLine.textContent = resolvedRanchAssignment.palName
            ? `${resolvedRanchAssignment.palName}${resolvedRanchAssignment.isCaught ? '' : kidMode ? ' (catch me!)' : ' (not caught yet)'}`
            : kidMode ? 'Choose a pal to keep on the Ranch.' : 'Select a pal to reserve on the Ranch.';
          body.appendChild(palLine);
          if (resolvedRanchAssignment.reasonKid || resolvedRanchAssignment.reasonGrown) {
            const reason = document.createElement('p');
            reason.textContent = kidMode
              ? resolvedRanchAssignment.reasonKid || resolvedRanchAssignment.reasonGrown
              : resolvedRanchAssignment.reasonGrown || resolvedRanchAssignment.reasonKid;
            body.appendChild(reason);
          }
          if (resolvedRanchAssignment.actionKid || resolvedRanchAssignment.actionGrown) {
            const action = document.createElement('p');
            action.className = 'ranch-assignment-summary__action';
            action.textContent = kidMode
              ? resolvedRanchAssignment.actionKid || resolvedRanchAssignment.actionGrown
              : resolvedRanchAssignment.actionGrown || resolvedRanchAssignment.actionKid;
            body.appendChild(action);
          }
          const clearBtn = document.createElement('button');
          clearBtn.type = 'button';
          clearBtn.className = 'ranch-assignment-summary__clear';
          clearBtn.textContent = kidMode ? 'Clear ranch plan' : 'Clear ranch assignment';
          clearBtn.addEventListener('click', event => {
            event.stopPropagation();
            clearRanchAssignment();
          });
          body.appendChild(clearBtn);
          summary.appendChild(body);
          elements.coverageGrid.appendChild(summary);
        }
        weightEntries.forEach(([key, weight]) => {
          const detail = getWorkTypeDetail(key);
          const canonical = canonicalWorkKey(key);
          const item = document.createElement('div');
          item.className = 'base-coverage-item';
          const header = document.createElement('div');
          header.className = 'base-coverage-item__header';
          const title = document.createElement('span');
          title.className = 'base-coverage-item__title';
          title.innerHTML = `${detail.icon || '⭐'} <span>${kidMode ? (detail.kidLabel || detail.label) : detail.label}</span>`;
          header.appendChild(title);
          const status = document.createElement('span');
          status.className = 'base-coverage-item__status';
          if (canonical === 'farming') {
            status.textContent = kidMode ? ranchPlan.summaryKid : ranchPlan.summaryGrown;
            header.appendChild(status);
            item.appendChild(header);
            const list = document.createElement('div');
            list.className = 'ranch-suggestion-list';
            if (ranchPlan.recommendations.length) {
              ranchPlan.recommendations.forEach(rec => {
                const suggestion = document.createElement('div');
                suggestion.className = 'ranch-suggestion';
                if (resolvedRanchAssignment && resolvedRanchAssignment.itemKey === rec.itemKey) {
                  suggestion.classList.add('ranch-suggestion--active');
                }
                const suggestionHeader = document.createElement('div');
                suggestionHeader.className = 'ranch-suggestion__header';
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'ranch-suggestion__item';
                button.textContent = rec.name;
                if (rec.hasDetail) {
                  button.dataset.itemKey = rec.itemKey;
                  button.addEventListener('click', event => {
                    event.stopPropagation();
                    openItemDetail(rec.itemKey);
                  });
                } else if (rec.openUrl) {
                  button.addEventListener('click', event => {
                    event.stopPropagation();
                    window.open(rec.openUrl, '_blank', 'noopener');
                  });
                } else {
                  button.disabled = true;
                }
                suggestionHeader.appendChild(button);
                const reasonText = kidMode ? rec.reasonKid : rec.reasonGrown;
                if (reasonText) {
                  const reason = document.createElement('span');
                  reason.className = 'ranch-suggestion__reason';
                  reason.textContent = reasonText;
                  suggestionHeader.appendChild(reason);
                }
                suggestion.appendChild(suggestionHeader);
                const action = document.createElement('p');
                action.className = 'ranch-suggestion__action';
                action.textContent = kidMode ? rec.actionKid : rec.actionGrown;
                suggestion.appendChild(action);
                const statusLine = document.createElement('p');
                statusLine.className = 'ranch-suggestion__status';
                if (rec.caughtProducers.length) {
                  statusLine.textContent = kidMode
                    ? `Ready pals: ${rec.caughtProducers.slice(0, 3).join(' & ')}.`
                    : `Ready producers: ${rec.caughtProducers.join(', ')}.`;
                } else if (rec.missingProducers.length) {
                  statusLine.textContent = kidMode
                    ? `Catch ${rec.missingProducers.slice(0, 3).join(' or ')} to start.`
                    : `Recruit ${rec.missingProducers.join(', ')} to unlock ${rec.name.toLowerCase()}.`;
                } else {
                  statusLine.textContent = kidMode
                    ? 'Choose a ranch pal to begin production.'
                    : 'Select a ranch hand to begin production.';
                }
                suggestion.appendChild(statusLine);
                const controls = document.createElement('div');
                controls.className = 'ranch-suggestion__controls';
                const preferred = pickPreferredRanchProducer(rec);
                const assignBtn = document.createElement('button');
                assignBtn.type = 'button';
                assignBtn.className = 'ranch-suggestion__assign';
                const isActive = resolvedRanchAssignment && resolvedRanchAssignment.itemKey === rec.itemKey;
                assignBtn.textContent = isActive
                  ? (kidMode ? 'Selected for ranch' : 'Ranch focus active')
                  : (kidMode
                      ? `Use ${preferred.name || 'this pal'}`
                      : `Assign ${preferred.name || 'recommended pal'}`);
                assignBtn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                assignBtn.addEventListener('click', event => {
                  event.stopPropagation();
                  setRanchAssignmentFromRecommendation(rec);
                });
                controls.appendChild(assignBtn);
                if (Array.isArray(rec.producers) && rec.producers.length) {
                  const producerList = document.createElement('div');
                  producerList.className = 'ranch-suggestion__producer-list';
                  const label = document.createElement('span');
                  label.className = 'ranch-suggestion__producer-label';
                  label.textContent = kidMode ? 'Pick pal:' : 'Choose ranch hand:';
                  producerList.appendChild(label);
                  rec.producers.forEach(name => {
                    const palButton = document.createElement('button');
                    palButton.type = 'button';
                    palButton.className = 'ranch-suggestion__producer';
                    const isPalCaught = isPalCaughtByName(name);
                    palButton.textContent = isPalCaught ? `${name} ✓` : name;
                    if (
                      resolvedRanchAssignment &&
                      resolvedRanchAssignment.itemKey === rec.itemKey &&
                      resolvedRanchAssignment.palName &&
                      resolvedRanchAssignment.palName.toLowerCase() === name.toLowerCase()
                    ) {
                      palButton.classList.add('is-selected');
                    }
                    palButton.addEventListener('click', event => {
                      event.stopPropagation();
                      setRanchAssignmentFromRecommendation(rec, { palName: name });
                    });
                    producerList.appendChild(palButton);
                  });
                  controls.appendChild(producerList);
                }
                suggestion.appendChild(controls);
                list.appendChild(suggestion);
              });
            } else {
              const empty = document.createElement('p');
              empty.className = 'ranch-suggestion__action';
              empty.textContent = kidMode
                ? 'Unlock the Ranch to start planning outputs.'
                : 'Unlock the Ranch to start planning outputs.';
              list.appendChild(empty);
            }
            item.appendChild(list);
            elements.coverageGrid.appendChild(item);
            return;
          }
          const total = crew.coverage[key] || 0;
          const descriptor = coverageDescriptor(weight, total, config, highestWeight);
          status.textContent = kidMode ? descriptor.kid : descriptor.grown;
          header.appendChild(status);
          item.appendChild(header);
          const meter = document.createElement('div');
          meter.className = 'base-coverage-meter';
          const fill = document.createElement('div');
          fill.className = 'base-coverage-meter__fill';
          const percent = Math.max(0, Math.min(100, descriptor.percent));
          fill.style.width = `${percent}%`;
          meter.appendChild(fill);
          item.appendChild(meter);
          elements.coverageGrid.appendChild(item);
        });
      }
    }
    function recommendBaseCrew(config, options = {}) {
      const slotCount = config?.slots || 0;
      if (!slotCount) {
        return { selections: [], coverage: {}, slotCount: 0, capturedCount: 0 };
      }
      const weights = options.weightsOverride
        ? { ...options.weightsOverride }
        : calculateEffectiveWorkWeights(config, options);
      const defaultWeight = config?.defaultWeight != null ? config.defaultWeight : 0.2;
      const available = Object.values(PALS || {}).filter(pal => {
        if (!pal || !pal.work) return false;
        return Object.values(pal.work).some(value => Number(value) > 0);
      });
      const coverage = {};
      const selections = [];
      const used = new Set();
      const addSelection = (candidate, { updateCoverage = true } = {}) => {
        if (!candidate || !candidate.pal) return;
        selections.push(candidate);
        used.add(candidate.pal.id);
        if (updateCoverage && Array.isArray(candidate.contributions)) {
          candidate.contributions.forEach(entry => {
            coverage[entry.key] = (coverage[entry.key] || 0) + entry.level;
          });
        }
      };
      let activeRanchAssignment = options.ranchAssignment || null;
      if (activeRanchAssignment && !activeRanchAssignment.pal && activeRanchAssignment.palName) {
        const fallbackPal = findPalByName(activeRanchAssignment.palName);
        if (fallbackPal) {
          activeRanchAssignment = { ...activeRanchAssignment, pal: fallbackPal, isCaught: !!caught[fallbackPal.id] };
        }
      }
      if (activeRanchAssignment && activeRanchAssignment.pal && selections.length < slotCount) {
        const pal = activeRanchAssignment.pal;
        let evaluation = scorePalForBase(pal, weights, {}, config, defaultWeight);
        if (!evaluation) {
          const workEntries = Object.entries(pal.work || {});
          const maxLevel = Math.max(1, MAX_WORK_LEVEL);
          const fallbackContributions = workEntries
            .map(([key, value]) => {
              const level = Number(value) || 0;
              if (!level) return null;
              const canonical = canonicalWorkKey(key);
              if (!canonical) return null;
              const weight = Object.prototype.hasOwnProperty.call(weights, canonical)
                ? weights[canonical]
                : defaultWeight;
              if (!weight) return null;
              const normalizedLevel = level / maxLevel;
              const baseContribution = weight * normalizedLevel;
              return {
                key: canonical,
                level,
                weight,
                baseContribution,
                contributionScore: baseContribution
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (b.contributionScore !== a.contributionScore) {
                return b.contributionScore - a.contributionScore;
              }
              return b.level - a.level;
            });
          evaluation = {
            score: 0,
            rawScore: 0,
            contributions: fallbackContributions,
            isCaught: !!caught[pal.id]
          };
        }
        const assignmentInfo = { ...activeRanchAssignment, type: 'ranch' };
        const contributions = Array.isArray(evaluation.contributions) ? evaluation.contributions.slice() : [];
        const candidate = {
          pal,
          score: evaluation.score,
          rawScore: evaluation.rawScore,
          contributions,
          isCaught: activeRanchAssignment.isCaught != null ? activeRanchAssignment.isCaught : evaluation.isCaught,
          assignment: assignmentInfo,
          assignmentType: 'ranch',
          note: kidMode
            ? (assignmentInfo.noteKid || assignmentInfo.actionKid || `Keep ${pal.name} on the Ranch.`)
            : (assignmentInfo.noteGrown || assignmentInfo.actionGrown || `Reserve ${pal.name} on the Ranch.`)
        };
        addSelection(candidate, { updateCoverage: false });
      }
      const pickBestFromPool = (pool, { coverageAware = true } = {}) => {
        let best = null;
        pool.forEach(pal => {
          if (!pal || used.has(pal.id)) return;
          const evaluation = scorePalForBase(pal, weights, coverageAware ? coverage : {}, config, defaultWeight);
          if (!evaluation) return;
          if (!best || evaluation.score > best.score || (evaluation.score === best.score && evaluation.rawScore > best.rawScore)) {
            best = { pal, ...evaluation };
          }
        });
        return best;
      };
      const fillFromPool = pool => {
        if (!Array.isArray(pool) || !pool.length) return;
        while (selections.length < slotCount) {
          const candidate = pickBestFromPool(pool);
          if (!candidate) break;
          addSelection(candidate);
        }
      };
      const caughtPool = available.filter(pal => pal && caught[pal.id]);
      const suggestionPool = available.filter(pal => pal && !caught[pal.id]);
      fillFromPool(caughtPool);
      fillFromPool(suggestionPool);
      if (selections.length < slotCount) {
        const remainder = available.filter(pal => pal && !used.has(pal.id));
        const fallback = remainder
          .map(pal => {
            const evaluation = scorePalForBase(pal, weights, {}, config, defaultWeight);
            if (!evaluation) return null;
            return { pal, ...evaluation };
          })
          .filter(Boolean)
          .sort((a, b) => {
            if (b.rawScore !== a.rawScore) {
              return b.rawScore - a.rawScore;
            }
            return (b.pal?.rarity || 0) - (a.pal?.rarity || 0);
          });
        while (selections.length < slotCount && fallback.length) {
          const next = fallback.shift();
          addSelection(next);
        }
      }
      const capturedCount = selections.filter(entry => entry && entry.isCaught).length;
      return { selections, coverage, slotCount, capturedCount, weights, ranchAssignment: activeRanchAssignment || null };
    }
    function scorePalForBase(pal, weights, coverage, config, defaultWeight) {
      if (!pal || !pal.work) return null;
      const contributions = [];
      let rawScore = 0;
      let score = 0;
      const coverageMap = coverage || {};
      const maxLevel = Math.max(1, MAX_WORK_LEVEL);
      const workEntries = Object.entries(pal.work || {});
      workEntries.forEach(([key, value]) => {
        const level = Number(value) || 0;
        if (!level) return;
        const canonical = canonicalWorkKey(key);
        if (!canonical) return;
        const weight = Object.prototype.hasOwnProperty.call(weights, canonical)
          ? weights[canonical]
          : defaultWeight;
        if (!weight) return;
        const normalizedLevel = level / maxLevel;
        const baseContribution = weight * normalizedLevel;
        rawScore += baseContribution;
        const existing = coverageMap[canonical] || 0;
        const coverageFactor = 1 / (1 + existing);
        const contributionScore = baseContribution * (1 + coverageFactor);
        score += contributionScore;
        contributions.push({ key: canonical, level, weight, baseContribution, contributionScore });
      });
      if (!contributions.length) return null;
      contributions.sort((a, b) => {
        if (b.contributionScore !== a.contributionScore) {
          return b.contributionScore - a.contributionScore;
        }
        return b.level - a.level;
      });
      const isCaught = !!caught[pal.id];
      if (isCaught) {
        score += 0.6;
      } else {
        score -= 0.15;
      }
      const preferred = config?.preferredRarity || 6;
      const rarity = pal?.rarity || 0;
      if (rarity && rarity > preferred) {
        const penalty = (rarity - preferred) * 0.35;
        score -= penalty;
        rawScore -= penalty * 0.6;
      }
      score += contributions.length * 0.05;
      return { score, rawScore, contributions, isCaught };
    }
    function openPalworldEmbed({ heading, url, fallbackUrl, note, summaryHtml }) {
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'external-embed';
      const actions = document.createElement('div');
      actions.className = 'embed-actions';
      const titleEl = document.createElement('h3');
      titleEl.textContent = heading;
      actions.appendChild(titleEl);
      if (url) {
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.rel = 'noopener';
        link.className = 'embed-link';
        link.textContent = 'Open in new tab';
        actions.appendChild(link);
      }
      wrap.appendChild(actions);
      const noteEl = document.createElement('p');
      noteEl.className = 'embed-note';
      noteEl.textContent = note || 'This view pulls live details from Palworld.gg while keeping your progress tracker close at hand.';
      wrap.appendChild(noteEl);
      if (summaryHtml) {
        const summary = document.createElement('div');
        summary.className = 'embed-summary';
        summary.innerHTML = summaryHtml;
        wrap.appendChild(summary);
      }
      if (url) {
        const frame = document.createElement('iframe');
        frame.src = url;
        frame.title = heading;
        frame.loading = 'lazy';
        frame.referrerPolicy = 'no-referrer-when-downgrade';
        frame.className = 'embed-frame';
        wrap.appendChild(frame);
      }
      const fallback = document.createElement('p');
      fallback.className = 'embed-fallback';
      const fallbackLink = document.createElement('a');
      fallbackLink.href = fallbackUrl || url || PALWORLD_BASE_URL;
      fallbackLink.target = '_blank';
      fallbackLink.rel = 'noopener';
      fallbackLink.textContent = 'Open on Palworld.gg';
      fallback.appendChild(document.createTextNode('If the page does not load, '));
      fallback.appendChild(fallbackLink);
      fallback.appendChild(document.createTextNode('.'));
      wrap.appendChild(fallback);
      modalBody.appendChild(wrap);
      openModal();
      return wrap;
    }
    async function loadDatasetSequentially() {
      const isFileProtocol = window.location.protocol === 'file:';
      if (isFileProtocol) {
        const embeddedPayload = await loadEmbeddedDataset();
        if (embeddedPayload) {
          return { payload: embeddedPayload, source: 'embedded fallback dataset' };
        }
        console.warn('File protocol detected but embedded dataset fallback was unavailable. Continuing with fetch attempts.');
      }
      const loadErrors = [];
      for (const source of DATA_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          if (!payload.pals || !payload.items || !payload.tech) {
            console.warn(`Dataset ${source} missing required keys. Skipping.`);
            continue;
          }
          return { payload, source };
        } catch (err) {
          loadErrors.push({ source, error: err });
          console.warn(`Failed to load dataset ${source}`, err);
        }
      }
      const embeddedFallback = await loadEmbeddedDataset();
      if (embeddedFallback) {
        return { payload: embeddedFallback, source: 'embedded fallback dataset' };
      }
      const errorSummary = loadErrors.length
        ? loadErrors.map(entry => {
            const reason = entry.error && entry.error.message ? entry.error.message : entry.error;
            return `${entry.source} (${reason})`;
          }).join('; ')
        : '';
      const summarySuffix = errorSummary ? ` ${errorSummary}` : '';
      throw new Error(`Unable to load any dataset from the data folder.${summarySuffix}`);
    }

    (async function initialisePalmate() {
      try {
        const { payload, source } = await loadDatasetSequentially();
        console.info(`Palmate data source: ${source}`);
        // Data is namespaced under pals, items and tech plus extra sections
        PALS = payload.pals || {};
        ITEMS = payload.items || {};
        TECH = payload.tech || [];
        rebuildTechLookup();
        SKILL_DETAILS = payload.skillsDetails || {};
        PASSIVE_DETAILS = payload.passiveDetails || {};
        ITEM_DETAILS = await loadItemDetails();
        PARTNER_SKILLS = await loadPartnerSkillDataset();
        // Build name‑to‑ID lookup map
        PAL_NAME_TO_ID = {};
        PAL_SLUG_TO_ID = {};
        Object.values(PALS).forEach(p => {
          PAL_NAME_TO_ID[p.name] = p.id;
          const slug = slugifyForPalworld(p.name);
          if(slug) PAL_SLUG_TO_ID[slug] = p.id;
        });
        // Build a global map of item drops for quick lookup
        DROPS_MAP = {};
        Object.values(PALS).forEach(pal => {
          (pal.drops || []).forEach(item => {
            if (!DROPS_MAP[item]) DROPS_MAP[item] = [];
            DROPS_MAP[item].push(pal.name);
          });
        });
        MAX_WORK_LEVEL = computeMaxWorkLevel();
        // Build pages
        buildPalPage();
        buildItemPage();
        buildTechPage();
        buildBasePage();
        buildBreedingPage();
        buildHomePage();
        renderRouteGuide();
        // Synchronise skills and traits dictionaries with the loaded data.
        // Override the static dictionaries with entries from the JSON file.
        skillsDictionary = { ...defaultSkillsDictionary };
        if (SKILL_DETAILS && Object.keys(SKILL_DETAILS).length) {
          const normalizedSkills = {};
          Object.entries(SKILL_DETAILS).forEach(([key, info = {}]) => {
            const normalizedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
            normalizedSkills[normalizedKey] = {
              name: (info.name || key).replace(/_/g, ' '),
              damage: info.power ? `Power ${info.power}` : (info.damage || 'Unknown'),
              type: info.element || info.type || 'Unknown',
              description: info.description || 'No description available.'
            };
          });
          skillsDictionary = { ...defaultSkillsDictionary, ...normalizedSkills };
        }
        traitsDictionary = { ...defaultTraitsDictionary };
        if (PASSIVE_DETAILS && Object.keys(PASSIVE_DETAILS).length) {
          traitsDictionary = { ...defaultTraitsDictionary, ...PASSIVE_DETAILS };
        }
        buildGlossaryPage();
        buildMapPage();
        buildProgressPage();
        updateProgressUI();
      } catch (err) {
        console.error(err);
        const reason = err && err.message ? ` (${err.message})` : '';
        const extraHelp = window.location.protocol === 'file:'
          ? ' Launching a local web server or regenerating data/palworld_complete_data_fallback.js usually resolves file:// restrictions.'
          : ' Please confirm that the data folder is deployed with the site.';
        document.body.insertAdjacentHTML('beforeend', `<p style="color:red">Failed to load data${reason}.${extraHelp}</p>`);
      }
    })();
    // Build pal page
    function buildPalPage() {
      const list = document.getElementById('palsList');
      const search = document.getElementById('palSearch');
      const filtersContainer = document.getElementById('palFilters');
      const statusGroup = filtersContainer ? filtersContainer.querySelector('[data-filter-group="status"]') : null;
      const workGroup = filtersContainer ? filtersContainer.querySelector('[data-filter-group="work"]') : null;
      const summaryEl = document.getElementById('palFilterSummary');
      const resetBtn = document.getElementById('palFilterReset');
      if (!list || !search) return;
      const filterState = {
        search: '',
        status: 'all',
        work: new Set()
      };
      const statusOptions = [
        { key: 'all', kid: 'All pals', grown: 'All pals' },
        { key: 'caught', kid: 'Caught pals', grown: 'Caught pals' },
        { key: 'missing', kid: 'Need to catch', grown: 'Missing pals' }
      ];
      const workRoleStats = (() => {
        const stats = {};
        Object.values(PALS || {}).forEach(pal => {
          Object.entries(pal.work || {}).forEach(([role, level]) => {
            if (level) {
              stats[role] = (stats[role] || 0) + 1;
            }
          });
        });
        return stats;
      })();
      if (filtersContainer) {
        const statusLabel = document.getElementById('palFilterStatusLabel');
        const workLabel = document.getElementById('palFilterWorkLabel');
        if (statusLabel) {
          statusLabel.textContent = kidMode ? 'Crew status' : 'Collection status';
        }
        if (workLabel) {
          workLabel.textContent = kidMode ? 'Work helpers' : 'Work roles';
        }
        if (resetBtn) {
          resetBtn.textContent = kidMode ? 'Clear filters' : 'Reset filters';
        }
      }
      if (statusGroup) {
        statusGroup.innerHTML = '';
        statusOptions.forEach(option => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'chip pal-filter-chip';
          btn.dataset.status = option.key;
          btn.setAttribute('aria-pressed', 'false');
          statusGroup.appendChild(btn);
        });
        statusGroup.addEventListener('click', event => {
          const btn = event.target.closest('button[data-status]');
          if (!btn) return;
          const key = btn.dataset.status;
          if (!key) return;
          if (filterState.status === key && key !== 'all') {
            filterState.status = 'all';
          } else {
            filterState.status = key;
          }
          render();
        });
      }
      if (workGroup) {
        workGroup.innerHTML = '';
        Object.keys(workRoleStats)
          .sort((a, b) => getWorkRoleLabel(a).localeCompare(getWorkRoleLabel(b), undefined, { sensitivity: 'base' }))
          .forEach(role => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'chip pal-filter-chip';
            btn.dataset.role = role;
            btn.setAttribute('aria-pressed', 'false');
            workGroup.appendChild(btn);
          });
        workGroup.addEventListener('click', event => {
          const btn = event.target.closest('button[data-role]');
          if (!btn) return;
          const role = btn.dataset.role;
          if (!role) return;
          if (filterState.work.has(role)) {
            filterState.work.delete(role);
          } else {
            filterState.work.add(role);
          }
          render();
        });
      }
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          filterState.status = 'all';
          filterState.work.clear();
          filterState.search = '';
          search.value = '';
          render();
          if (typeof search.focus === 'function') {
            try {
              search.focus({ preventScroll: true });
            } catch (err) {
              search.focus();
            }
          }
        });
      }
      function statusLabel(key) {
        const entry = statusOptions.find(option => option.key === key);
        if (!entry) return kidMode ? 'All pals' : 'All pals';
        return kidMode ? entry.kid : entry.grown;
      }
      function buildSearchHaystack(pal) {
        const parts = [pal.name];
        if (Array.isArray(pal.types)) parts.push(...pal.types);
        if (Array.isArray(pal.drops)) parts.push(...pal.drops);
        if (Array.isArray(pal.passives)) parts.push(...pal.passives);
        if (Array.isArray(pal.spawnAreas)) parts.push(...pal.spawnAreas);
        Object.entries(pal.work || {}).forEach(([role, level]) => {
          if (level) {
            parts.push(role);
            parts.push(getWorkRoleLabel(role));
          }
        });
        return parts.join(' ').toLowerCase();
      }
      function createWorkBadges(pal) {
        const entries = Object.entries(pal.work || {})
          .filter(([, level]) => level)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .slice(0, 3);
        if (!entries.length) return '';
        return entries.map(([role, level]) => {
          const label = getWorkRoleLabel(role);
          const highlight = filterState.work.size && filterState.work.has(role) ? ' pal-work-badge--active' : '';
          return `<span class='pal-work-badge${highlight}' data-role='${escapeHTML(role)}'><span class='pal-work-badge__label'>${escapeHTML(label)}</span><span class='pal-work-badge__level'>Lv ${escapeHTML(String(level))}</span></span>`;
        }).join('');
      }
      function updateStatusChips(totals) {
        if (!statusGroup) return;
        statusGroup.querySelectorAll('button[data-status]').forEach(btn => {
          const key = btn.dataset.status;
          const label = statusLabel(key);
          const count = key === 'all'
            ? totals.total
            : key === 'caught'
              ? totals.caught
              : totals.missing;
          btn.innerHTML = `<span class="pal-filter-chip__label">${escapeHTML(label)}</span><span class="pal-filter-chip__count">${count}</span>`;
          const active = filterState.status === key;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
          btn.classList.toggle('pal-filter-chip--active', active);
          btn.setAttribute('aria-label', `${label}: ${count} pals`);
        });
      }
      function updateWorkChips() {
        if (!workGroup) return;
        workGroup.querySelectorAll('button[data-role]').forEach(btn => {
          const role = btn.dataset.role;
          const label = getWorkRoleLabel(role);
          const count = workRoleStats[role] || 0;
          const active = filterState.work.has(role);
          btn.innerHTML = `<span class="pal-filter-chip__label">${escapeHTML(label)}</span><span class="pal-filter-chip__count">${count}</span>`;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
          btn.classList.toggle('pal-filter-chip--active', active);
          btn.setAttribute('aria-label', `${label}: ${count} pals`);
        });
      }
      function render() {
        const palsArray = Object.values(PALS || {});
        const totals = {
          total: palsArray.length,
          caught: palsArray.filter(p => caught[p.id]).length
        };
        totals.missing = totals.total - totals.caught;
        updateStatusChips(totals);
        updateWorkChips();
        const normalizedSearch = filterState.search.trim().toLowerCase();
        const results = palsArray
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }))
          .filter(pal => {
            if (filterState.status === 'caught' && !caught[pal.id]) return false;
            if (filterState.status === 'missing' && caught[pal.id]) return false;
            if (filterState.work.size) {
              const palWork = pal.work || {};
              let matchesWork = false;
              for (const role of filterState.work) {
                if (palWork[role]) {
                  matchesWork = true;
                  break;
                }
              }
              if (!matchesWork) return false;
            }
            if (normalizedSearch) {
              const haystack = buildSearchHaystack(pal);
              if (!haystack.includes(normalizedSearch)) return false;
            }
            return true;
          });
        list.innerHTML = '';
        if (summaryEl) {
          const count = results.length;
          if (!totals.total) {
            summaryEl.textContent = kidMode ? 'Pal data loading…' : 'Pal data loading…';
          } else if (count === totals.total && !normalizedSearch && filterState.status === 'all' && !filterState.work.size) {
            summaryEl.textContent = kidMode
              ? `Showing all ${count} pals.`
              : `Showing all ${count} pals.`;
          } else {
            summaryEl.textContent = kidMode
              ? `Showing ${count} pal${count === 1 ? '' : 's'}.`
              : `Showing ${count} of ${totals.total} pals.`;
          }
        }
        if (!results.length) {
          const empty = document.createElement('p');
          empty.className = 'empty-state pal-list-empty';
          empty.textContent = kidMode
            ? 'No pals match those filters yet.'
            : 'No pals match your filters yet.';
          list.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        results.forEach(pal => {
          const card = document.createElement('div');
          card.className = 'pal-card';
          const types = Array.isArray(pal.types) ? pal.types : [];
          const typeIcons = types.map(t => {
            const safe = escapeHTML(t);
            const icon = iconMap[t] || iconMap['Neutral'];
            return `<img src='${icon}' alt='${safe} icon' style='width:20px;height:20px;margin-right:2px;'>`;
          }).join('');
          const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
          let rarityLabel = rarityNames[rarity] || '';
          let starIcons = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          if (kidMode) {
            rarityLabel = '';
            starIcons = '';
          }
          const workBadges = createWorkBadges(pal);
          card.innerHTML = `
            <img alt="">
            <div class="name">${escapeHTML(pal.name)}</div>
            <div class="badge">${typeIcons}</div>
            ${workBadges ? `<div class="work">${workBadges}</div>` : ''}
            <div class="rarity"><span class="stars">${starIcons}</span> <span class="label">${escapeHTML(rarityLabel)}</span></div>
            <button class="catch-btn ${caught[pal.id] ? 'caught' : ''}">${caught[pal.id] ? 'Caught' : 'Catch'}</button>
          `;
          const portrait = card.querySelector('img');
          applyPalArtwork(portrait, pal, { alt: `${pal.name} portrait` });
          card.dataset.palId = pal.id;
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            showPalDetail(pal.id);
          });
          const btn = card.querySelector('button');
          btn.dataset.palId = pal.id;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            setPalCaught(pal.id);
          });
          fragment.appendChild(card);
        });
        list.appendChild(fragment);
      }
      filterState.search = search.value || '';
      search.addEventListener('input', () => {
        filterState.search = search.value;
        render();
      });
      render();
      refreshPalList = render;
    }
    function syncPalButtons(palId) {
      if (palId === undefined || palId === null) return;
      document.querySelectorAll(`.catch-btn[data-pal-id="${palId}"]`).forEach(btn => {
        const state = !!caught[palId];
        btn.classList.toggle('caught', state);
        btn.textContent = state ? 'Caught' : 'Catch';
      });
    }
    function setPalCaught(palId, value, { silent = false, skipAutoComplete = false, deferProgressUpdate = false } = {}) {
      if (palId === undefined || palId === null) return null;
      const current = !!caught[palId];
      const desired = value == null ? !current : !!value;
      if (current === desired) {
        syncPalButtons(palId);
        if (deferProgressUpdate) {
          updateBasePlanner();
        }
        return desired;
      }
      caught[palId] = desired;
      try {
        localStorage.setItem('caught', JSON.stringify(caught));
      } catch (err) {
        console.warn('Failed to save caught pals', err);
      }
      syncPalButtons(palId);
      if (!skipAutoComplete) {
        autoCompleteRouteStepsForPal(palId);
      }
      if (deferProgressUpdate) {
        updateBasePlanner();
      } else {
        updateProgressUI();
      }
      if (typeof refreshPalList === 'function') {
        refreshPalList();
      }
      if (!silent) {
        playSound(clickSound);
      }
      return desired;
    }
    function syncTechButtons(techKey, techName) {
      if (!techKey) return;
      document.querySelectorAll(`.unlock-btn[data-tech-key="${techKey}"]`).forEach(btn => {
        const lookupName = btn.dataset.techName || techName;
        const state = lookupName ? !!unlocked[lookupName] : false;
        btn.classList.toggle('unlocked', state);
        btn.textContent = state ? 'Unlocked' : 'Unlock';
        const card = btn.closest('.tech-card');
        if (card) {
          card.classList.toggle('tech-card--unlocked', state);
        }
      });
    }
    function setTechUnlocked(techName, value, { techKey, silent = false, skipAutoComplete = false, deferProgressUpdate = false } = {}) {
      if (!techName) return null;
      const current = !!unlocked[techName];
      const desired = value == null ? !current : !!value;
      if (current === desired) {
        if (techKey) syncTechButtons(techKey, techName);
        if (deferProgressUpdate) {
          updateBasePlanner();
        }
        return desired;
      }
      unlocked[techName] = desired;
      try {
        localStorage.setItem('unlocked', JSON.stringify(unlocked));
      } catch (err) {
        console.warn('Failed to save unlocked tech', err);
      }
      if (techKey) syncTechButtons(techKey, techName);
      if (!skipAutoComplete) {
        autoCompleteRouteStepsForTech(techKey, techName);
      }
      if (deferProgressUpdate) {
        updateBasePlanner();
      } else {
        updateProgressUI();
      }
      if (!silent) {
        playSound(clickSound);
      }
      return desired;
    }
    function updateItemCollectionButtons(itemKey) {
      document.querySelectorAll(`.item-card button.collect-btn[data-item-key="${itemKey}"]`).forEach(btn => {
        const state = !!collected[itemKey];
        btn.classList.toggle('collected', state);
        btn.textContent = state ? 'Collected' : 'Collect';
      });
    }
    // Show pal details in a modal by embedding the Palworld.gg page
    // alongside quick progress hints and a shortcut back to the map.
    function showPalDetail(id) {
      const pal = PALS[id];
      if (!pal) return;
      const slug = PALWORLD_PAL_SLUG_OVERRIDES[pal.name] || slugifyForPalworld(pal.name);
      const palUrl = slug ? `${PALWORLD_BASE_URL}/pal/${slug}` : `${PALWORLD_BASE_URL}/pals`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/pals?search=${encodeURIComponent(pal.name)}`;
      const habitats = pal.spawnAreas && pal.spawnAreas.length
        ? pal.spawnAreas.join(', ')
        : (environmentMap[pal.types && pal.types[0]] || 'Unknown');
      const sphere = raritySphere[pal.rarity] || 'Pal Sphere';
      const sphereInfo = sphereRates[sphere];
      const caughtStatus = caught[pal.id];
      const summaryLines = [];
      if (kidMode) {
        summaryLines.push(`<strong>Status:</strong> ${caughtStatus ? 'We caught this pal!' : 'Still looking for this pal.'}`);
        if (habitats && habitats !== 'Unknown') {
          summaryLines.push(`<strong>Where it lives:</strong> ${habitats}`);
        }
        summaryLines.push(`<strong>Catch tip:</strong> Try a ${sphere}.`);
      } else {
        summaryLines.push(`<strong>Tracking:</strong> ${caughtStatus ? 'Caught' : 'Not caught yet'}`);
        if (habitats) {
          summaryLines.push(`<strong>Habitats:</strong> ${habitats}`);
        }
        if (sphereInfo) {
          summaryLines.push(`<strong>Suggested Sphere:</strong> ${sphere} (${Math.round(sphereInfo.rate * 100)}% base) – ${sphereInfo.description}`);
        }
      }
      summaryLines.push(`<button type="button" class="open-map-button modal-action-btn">Open Map</button>`);
      const summaryHtml = summaryLines.map(line => `<p>${line}</p>`).join('');
      const note = kidMode
        ? 'We show the Palworld.gg page here so you can read about this pal without leaving your guide.'
        : 'Palworld.gg has the most complete breakdowns. Enjoy them in-place while Palmate keeps tracking your progress.';
      const wrap = openPalworldEmbed({
        heading: `${pal.name} – Palworld.gg`,
        url: palUrl,
        fallbackUrl,
        note,
        summaryHtml
      });
      const mapButton = wrap.querySelector('.open-map-button');
      if (mapButton) {
        mapButton.addEventListener('click', (event) => {
          event.preventDefault();
          closeModal();
          switchPage('map');
        });
      }
    }
    window.viewPal = function(identifier){
      if(identifier === undefined || identifier === null) return;
      if(typeof identifier === 'number'){
        showPalDetail(identifier);
        return;
      }
      const normalized = String(identifier).toLowerCase();
      const slugId = PAL_SLUG_TO_ID[normalized];
      if(slugId){
        showPalDetail(slugId);
        return;
      }
      const byName = PAL_NAME_TO_ID[capitalize(normalized)];
      if(byName){
        showPalDetail(byName);
        return;
      }
      focusSearch(identifier, { target: 'pals' });
    };
    // Build items page
    function buildItemPage() {
      const list = document.getElementById('itemsList');
      const search = document.getElementById('itemSearch');
      // Compute which pals drop each item
      const dropsMap = {};
      Object.values(PALS).forEach(pal => {
        (pal.drops || []).forEach(item => {
          if (!dropsMap[item]) dropsMap[item] = [];
          dropsMap[item].push(pal.name);
        });
      });
      const allItemKeys = Array.from(new Set([
        ...Object.keys(ITEMS || {}),
        ...Object.keys(ITEM_DETAILS || {})
      ])).sort((a, b) => niceName(a).localeCompare(niceName(b)));
      function render(filter = '') {
        list.innerHTML = '';
        const term = filter.trim().toLowerCase();
        allItemKeys.forEach(itemKey => {
          const detail = ITEM_DETAILS[itemKey] || {};
          const baseInfo = ITEMS[itemKey] || {};
          const displayName = detail.name || niceName(itemKey);
          const ranchProducers = Array.isArray(detail.ranchProducers)
            ? detail.ranchProducers
            : (Array.isArray(baseInfo.ranchProducers) ? baseInfo.ranchProducers : []);
          const searchable = [
            itemKey,
            displayName,
            detail.type,
            baseInfo.category,
            ...(ranchProducers || [])
          ].filter(Boolean).join(' ').toLowerCase();
          if (term && !searchable.includes(term)) return;

          const card = document.createElement('div');
          card.className = 'item-card';
          card.dataset.itemKey = itemKey;

          const art = document.createElement('div');
          art.className = 'item-card-art';
          const usePlaceholder = () => {
            if (!art.querySelector('.item-card-placeholder')) {
              const placeholder = document.createElement('div');
              placeholder.className = 'item-card-placeholder';
              placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
              art.appendChild(placeholder);
            }
          };
          const imageUrl = detail.image || baseInfo.image || null;
          if (imageUrl) {
            const img = document.createElement('img');
            img.loading = 'lazy';
            img.decoding = 'async';
            img.alt = `${displayName} icon`;
            img.referrerPolicy = 'no-referrer';
            img.src = imageUrl;
            img.onerror = () => {
              img.remove();
              usePlaceholder();
            };
            art.appendChild(img);
          }
          if (!art.hasChildNodes()) {
            usePlaceholder();
          }
          card.appendChild(art);

          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = displayName;
          card.appendChild(nameEl);

          const category = detail.type || baseInfo.category || 'Misc';
          const categoryEl = document.createElement('div');
          categoryEl.className = 'category';
          categoryEl.textContent = category;
          card.appendChild(categoryEl);

          const dropNames = dropsMap[itemKey] || [];
          const dropsEl = document.createElement('div');
          dropsEl.className = 'drops';
          dropsEl.textContent = `Dropped by: ${dropNames.length ? dropNames.join(', ') : 'None recorded'}`;
          card.appendChild(dropsEl);

          const ranchEl = document.createElement('div');
          ranchEl.className = 'ranch';
          if (ranchProducers.length) {
            ranchEl.textContent = `Ranch pals: ${ranchProducers.join(', ')}`;
          } else {
            ranchEl.textContent = 'Ranch pals: None recorded';
            ranchEl.classList.add('ranch--empty');
          }
          card.appendChild(ranchEl);

          const btn = document.createElement('button');
          btn.className = `collect-btn ${collected[itemKey] ? 'collected' : ''}`;
          btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
          btn.dataset.itemKey = itemKey;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            collected[itemKey] = !collected[itemKey];
            localStorage.setItem('collected', JSON.stringify(collected));
            btn.classList.toggle('collected', collected[itemKey]);
            btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
            updateProgressUI();
          });
          card.appendChild(btn);

          // Clicking the card opens the item details modal.  Exclude button clicks.
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            openItemDetail(itemKey);
          });
          list.appendChild(card);
        });
      }
      search.addEventListener('input', () => render(search.value));
      render();
    }
    // Build technology tree page
    function buildTechPage() {
      const list = document.getElementById('techList');
      if (!list) return;
      list.innerHTML = '';
      const levels = Array.isArray(TECH)
        ? TECH.slice().sort((a, b) => (a?.level || 0) - (b?.level || 0))
        : [];
      if (!levels.length) {
        const empty = document.createElement('p');
        empty.className = 'tech-empty';
        empty.textContent = kidMode
          ? 'Technology data is still loading. Check back soon!'
          : 'Technology data is still loading.';
        list.appendChild(empty);
        return;
      }

      const iconFallback = '<i class="fa-solid fa-gears"></i>';

      function createTechCard(item) {
        if (!item || !item.name) {
          return null;
        }
        const card = document.createElement('article');
        card.className = 'tech-card';
        const techKey = item.id || slugifyForPalworld(item.name);
        if (techKey) {
          card.id = `tech-${techKey}`;
        }
        card.dataset.branch = item.branch || 'Technology';
        const isUnlocked = !!unlocked[item.name];
        if (isUnlocked) {
          card.classList.add('tech-card--unlocked');
        }

        const art = document.createElement('div');
        art.className = 'tech-card__art';
        if (item.image) {
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.decoding = 'async';
          img.alt = `${item.name} image`;
          img.referrerPolicy = 'no-referrer';
          img.src = item.image;
          img.onerror = () => {
            img.remove();
            art.classList.add('tech-card__art--fallback');
            art.innerHTML = iconFallback;
          };
          art.appendChild(img);
        } else {
          art.classList.add('tech-card__art--fallback');
          art.innerHTML = iconFallback;
        }

        const info = document.createElement('div');
        info.className = 'tech-card__info';

        const title = document.createElement('div');
        title.className = 'tech-card__title';
        const nameEl = document.createElement('h5');
        nameEl.className = 'tech-card__name';
        nameEl.textContent = item.name;
        title.appendChild(nameEl);
        const cost = document.createElement('span');
        cost.className = 'tech-card__cost';
        const pointLabel = item.isAncient
          ? (kidMode ? 'Ancient Points' : 'AP')
          : (kidMode ? 'Tech Points' : 'TP');
        const points = typeof item.techPoints === 'number' ? item.techPoints : null;
        cost.textContent = points !== null ? `${points} ${pointLabel}` : pointLabel;
        title.appendChild(cost);
        info.appendChild(title);

        const chips = document.createElement('div');
        chips.className = 'tech-card__chips';
        const labels = new Set();
        if (item.category) labels.add(item.category);
        if (item.group) labels.add(item.group);
        labels.forEach(label => {
          const chip = document.createElement('span');
          chip.className = 'tech-chip';
          chip.textContent = label;
          chips.appendChild(chip);
        });
        if (chips.children.length) {
          info.appendChild(chips);
        }

        const description = document.createElement('p');
        description.className = 'tech-card__description';
        description.textContent = item.description
          || (kidMode
            ? `Unlocks ${item.name}.`
            : `Unlocks the ${item.name} blueprint.`);
        info.appendChild(description);

        if (item.materials && Object.keys(item.materials).length) {
          const materials = document.createElement('ul');
          materials.className = 'tech-card__materials';
          Object.entries(item.materials).forEach(([mat, qty]) => {
            const li = document.createElement('li');
            li.textContent = `${qty} × ${mat}`;
            materials.appendChild(li);
          });
          info.appendChild(materials);
        }

        const actions = document.createElement('div');
        actions.className = 'tech-card__actions';
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'unlock-btn';
        if (isUnlocked) {
          button.classList.add('unlocked');
        }
        if (techKey) {
          button.dataset.techKey = techKey;
        }
        button.dataset.techName = item.name;
        button.textContent = isUnlocked ? 'Unlocked' : 'Unlock';
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          setTechUnlocked(item.name, !unlocked[item.name], { techKey });
        });
        actions.appendChild(button);
        info.appendChild(actions);

        card.appendChild(art);
        card.appendChild(info);

        if (techKey) {
          card.addEventListener('click', () => {
            showTechDetail(techKey);
          });
        }
        return card;
      }

      levels.forEach(level => {
        if (!level) return;
        const section = document.createElement('article');
        section.className = 'tech-level-card';

        const header = document.createElement('div');
        header.className = 'tech-level-header';
        const number = document.createElement('div');
        number.className = 'tech-level-number';
        const label = document.createElement('span');
        label.textContent = 'Level';
        number.appendChild(label);
        const value = document.createElement('strong');
        value.textContent = level.level != null ? String(level.level) : '?';
        number.appendChild(value);
        header.appendChild(number);

        const techItems = Array.isArray(level.items) ? level.items.filter(item => item && !item.isAncient) : [];
        const ancientItems = Array.isArray(level.items) ? level.items.filter(item => item && item.isAncient) : [];
        const summary = document.createElement('div');
        summary.className = 'tech-level-summary';
        const summaryParts = [];
        if (techItems.length) summaryParts.push(`${techItems.length} Tech`);
        if (ancientItems.length) summaryParts.push(`${ancientItems.length} Ancient`);
        summary.textContent = summaryParts.length
          ? summaryParts.join(' • ')
          : (kidMode ? 'No blueprints at this level yet.' : 'No unlocks available at this level.');
        header.appendChild(summary);
        section.appendChild(header);

        const columns = document.createElement('div');
        columns.className = 'tech-columns';
        const columnData = [
          {
            key: 'tech',
            heading: 'Technology',
            items: techItems,
            emptyText: kidMode ? 'Nothing new here yet.' : 'No new technology unlocks.',
          },
          {
            key: 'ancient',
            heading: 'Ancient Technology',
            items: ancientItems,
            emptyText: kidMode ? 'No ancient relics unlocked now.' : 'No ancient tech at this level.',
          }
        ];

        columnData.forEach(columnInfo => {
          const column = document.createElement('div');
          column.className = `tech-column tech-column--${columnInfo.key}`;
          const heading = document.createElement('h4');
          heading.textContent = columnInfo.heading;
          column.appendChild(heading);
          if (!columnInfo.items.length) {
            const empty = document.createElement('p');
            empty.className = 'tech-empty';
            empty.textContent = columnInfo.emptyText;
            column.appendChild(empty);
          } else {
            const grid = document.createElement('div');
            grid.className = 'tech-card-grid';
            columnInfo.items.forEach(item => {
              const card = createTechCard(item);
              if (card) grid.appendChild(card);
            });
            column.appendChild(grid);
          }
          columns.appendChild(column);
        });

        section.appendChild(columns);
        list.appendChild(section);
      });
      applyQueuedTechFocus();
    }

    function queueTechFocus(key){
      if(!key){
        pendingTechFocus = null;
        return;
      }
      pendingTechFocus = key;
      setTimeout(applyQueuedTechFocus, 0);
    }

    function applyQueuedTechFocus(){
      if(!pendingTechFocus) return;
      const techCard = document.getElementById(`tech-${pendingTechFocus}`);
      if(!techCard) return;
      pendingTechFocus = null;
      requestAnimationFrame(() => {
        techCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        pulse(techCard);
      });
    }
    // Build breeding page
    function buildBreedingPage() {
      const parent1Grid = document.getElementById('parent1Grid');
      const parent2Grid = document.getElementById('parent2Grid');
      const babyGrid = document.getElementById('babyGrid');
      const result = document.getElementById('breedingResult');
      const combosContainer = document.getElementById('breedingCombos');
      const parent1Search = document.getElementById('parent1Search');
      const parent2Search = document.getElementById('parent2Search');
      const babySearch = document.getElementById('babySearch');
      const modeButtons = Array.from(document.querySelectorAll('.breeding-tab'));
      const modes = Array.from(document.querySelectorAll('.breeding-mode'));
      if (!parent1Grid || !parent2Grid || !babyGrid || !result || !combosContainer || !parent1Search || !parent2Search || !babySearch) {
        return;
      }
      const palsSorted = Object.values(PALS || {}).sort((a, b) => a.name.localeCompare(b.name));
      let parentState = {
        parent1: BREEDING_SELECTION.parent1Id ? PALS[BREEDING_SELECTION.parent1Id] : null,
        parent2: BREEDING_SELECTION.parent2Id ? PALS[BREEDING_SELECTION.parent2Id] : null
      };
      let selectedBaby = BREEDING_SELECTION.babyId ? PALS[BREEDING_SELECTION.babyId] : null;
      if (!parentState.parent1) parentState.parent1 = null;
      if (!parentState.parent2) parentState.parent2 = null;
      if (!selectedBaby) selectedBaby = null;

      function updateBreedingSelection() {
        BREEDING_SELECTION.parent1Id = parentState.parent1 ? parentState.parent1.id : null;
        BREEDING_SELECTION.parent2Id = parentState.parent2 ? parentState.parent2.id : null;
        BREEDING_SELECTION.babyId = selectedBaby ? selectedBaby.id : null;
      }

      function makeEmptyMessage(text) {
        const msg = document.createElement('p');
        msg.className = 'empty-state';
        msg.textContent = text;
        return msg;
      }

      function createPalCard(pal, options = {}) {
        const { compact = true, selectable = true, selected = false } = options;
        const card = document.createElement('div');
        card.classList.add('pal-card');
        if (compact) card.classList.add('compact');
        if (selectable) card.classList.add('selectable');
        else card.classList.add('static');
        if (selected) card.classList.add('selected');
        const img = document.createElement('img');
        applyPalArtwork(img, pal);
        card.appendChild(img);
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = pal.name;
        card.appendChild(name);
        const badge = document.createElement('div');
        badge.className = 'badge';
        if (Array.isArray(pal.types) && pal.types.length) {
          pal.types.forEach(type => {
            const icon = document.createElement('img');
            icon.src = iconMap[type] || iconMap['Neutral'];
            icon.alt = `${type} icon`;
            badge.appendChild(icon);
          });
        } else {
          const span = document.createElement('span');
          span.textContent = 'Unknown';
          badge.appendChild(span);
        }
        card.appendChild(badge);
        if (pal && typeof pal.id !== 'undefined') {
          const caughtStatus = document.createElement('div');
          const isCaught = !!caught[pal.id];
          caughtStatus.className = 'caught-status';
          caughtStatus.dataset.caught = isCaught ? 'true' : 'false';
          caughtStatus.textContent = isCaught
            ? (kidMode ? 'We caught it!' : 'Caught')
            : (kidMode ? 'Need this pal' : 'Not caught yet');
          card.appendChild(caughtStatus);
        }
        const rarityEl = document.createElement('div');
        rarityEl.className = 'rarity';
        const starSpan = document.createElement('span');
        starSpan.className = 'stars';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'label';
        const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
        if (!kidMode) {
          starSpan.innerHTML = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          labelSpan.textContent = rarityNames[rarity] || '';
        }
        rarityEl.appendChild(starSpan);
        rarityEl.appendChild(labelSpan);
        card.appendChild(rarityEl);
        return card;
      }

      function createComboCard(pal, fallbackName) {
        if (pal) {
          return createPalCard(pal, { compact: true, selectable: false });
        }
        const wrapper = document.createElement('div');
        wrapper.classList.add('pal-card', 'compact', 'static');
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = fallbackName;
        wrapper.appendChild(name);
        const badge = document.createElement('div');
        badge.className = 'badge';
        badge.textContent = kidMode ? 'Not in list yet' : 'Not in dataset yet';
        wrapper.appendChild(badge);
        const rarity = document.createElement('div');
        rarity.className = 'rarity';
        wrapper.appendChild(rarity);
        return wrapper;
      }

      function filterPals(term) {
        const normalized = (term || '').trim().toLowerCase();
        if (!normalized) return palsSorted.slice();
        return palsSorted.filter(pal => {
          const nameMatch = pal.name.toLowerCase().includes(normalized);
          const typeMatch = Array.isArray(pal.types) && pal.types.some(type => type && type.toLowerCase().includes(normalized));
          return nameMatch || typeMatch;
        });
      }

      function renderParentGrid(slot) {
        const grid = slot === 'parent1' ? parent1Grid : parent2Grid;
        const searchTerm = slot === 'parent1' ? parent1Search.value : parent2Search.value;
        grid.innerHTML = '';
        if (!palsSorted.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        const selected = slot === 'parent1' ? parentState.parent1 : parentState.parent2;
        let matches = filterPals(searchTerm);
        if (selected && !matches.some(p => p.id === selected.id)) {
          matches = [selected, ...matches];
        }
        if (!matches.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'No pals match your search yet.'));
          return;
        }
        matches.forEach(pal => {
          const isSelected = selected && selected.id === pal.id;
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: isSelected
          });
          card.addEventListener('click', () => {
            const alreadySelected = slot === 'parent1'
              ? parentState.parent1 && parentState.parent1.id === pal.id
              : parentState.parent2 && parentState.parent2.id === pal.id;
            if (slot === 'parent1') {
              parentState.parent1 = alreadySelected ? null : pal;
            } else {
              parentState.parent2 = alreadySelected ? null : pal;
            }
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
          });
          grid.appendChild(card);
        });
      }

      function updateParentGrids() {
        renderParentGrid('parent1');
        renderParentGrid('parent2');
      }

      function renderBabyGrid() {
        babyGrid.innerHTML = '';
        if (!palsSorted.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        let matches = filterPals(babySearch.value);
        if (selectedBaby && !matches.some(p => p.id === selectedBaby.id)) {
          matches = [selectedBaby, ...matches];
        }
        if (!matches.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'Try a different pal search.'));
          return;
        }
        matches.forEach(pal => {
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: selectedBaby && selectedBaby.id === pal.id
          });
          card.addEventListener('click', () => {
            if (selectedBaby && selectedBaby.id === pal.id) {
              selectedBaby = null;
            } else {
              selectedBaby = pal;
            }
            updateBreedingSelection();
            renderBabyGrid();
            showCombos();
          });
          babyGrid.appendChild(card);
        });
      }

      function showCombos() {
        combosContainer.innerHTML = '';
        if (!selectedBaby) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'Pick a pal above to see recipes.' : 'Select a pal to see which parents can produce it.'));
          return;
        }
        const header = document.createElement('div');
        header.className = 'breeding-baby-header';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? `Make ${selectedBaby.name}` : `Parent combos for ${selectedBaby.name}`;
        header.appendChild(heading);
        header.appendChild(createPalCard(selectedBaby, { compact: true, selectable: false }));
        combosContainer.appendChild(header);
        const combos = Array.isArray(selectedBaby.breedingCombos) ? selectedBaby.breedingCombos : [];
        if (!combos.length) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'No combos known yet.' : 'We do not have recorded breeding pairs for this pal yet.'));
          return;
        }
        combos.forEach(pair => {
          if (!Array.isArray(pair) || pair.length < 2) return;
          const [leftName, rightName] = pair;
          const leftPalId = PAL_NAME_TO_ID[leftName];
          const rightPalId = PAL_NAME_TO_ID[rightName];
          const leftPal = leftPalId ? PALS[leftPalId] : null;
          const rightPal = rightPalId ? PALS[rightPalId] : null;
          const row = document.createElement('div');
          row.className = 'breeding-combo';
          row.appendChild(createComboCard(leftPal, leftName));
          const plus = document.createElement('div');
          plus.className = 'combo-arrow';
          plus.textContent = '+';
          row.appendChild(plus);
          row.appendChild(createComboCard(rightPal, rightName));
          const arrow = document.createElement('div');
          arrow.className = 'combo-arrow';
          arrow.textContent = '→';
          row.appendChild(arrow);
          row.appendChild(createPalCard(selectedBaby, { compact: true, selectable: false }));
          row.addEventListener('click', () => {
            if (leftPal) parentState.parent1 = leftPal;
            if (rightPal) parentState.parent2 = rightPal;
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
            switchBreedingMode('breedingPredict');
            playSound(clickSound);
          });
          combosContainer.appendChild(row);
        });
      }

      function findPredictedBaby() {
        if (!parentState.parent1 || !parentState.parent2) return null;
        const power1 = parentState.parent1.breeding && typeof parentState.parent1.breeding.power === 'number'
          ? parentState.parent1.breeding.power
          : 0;
        const power2 = parentState.parent2.breeding && typeof parentState.parent2.breeding.power === 'number'
          ? parentState.parent2.breeding.power
          : 0;
        const avgPower = Math.floor((power1 + power2) / 2);
        let closest = null;
        let diff = Infinity;
        Object.values(PALS).forEach(p => {
          const power = p.breeding && typeof p.breeding.power === 'number' ? p.breeding.power : 0;
          const delta = Math.abs(power - avgPower);
          if (delta < diff) {
            diff = delta;
            closest = p;
          }
        });
        return { baby: closest, avgPower };
      }

      function updateResult() {
        result.innerHTML = '';
        if (!parentState.parent1 || !parentState.parent2) {
          result.appendChild(makeEmptyMessage(kidMode ? 'Pick two pals to guess the baby.' : 'Select two parents to see the likely offspring.'));
          return;
        }
        const prediction = findPredictedBaby();
        const baby = prediction ? prediction.baby : null;
        const avgPower = prediction ? prediction.avgPower : 0;
        const flow = document.createElement('div');
        flow.className = 'breeding-flow';
        flow.appendChild(createPalCard(parentState.parent1, { compact: true, selectable: false }));
        const plus = document.createElement('div');
        plus.className = 'combo-arrow';
        plus.textContent = '+';
        flow.appendChild(plus);
        flow.appendChild(createPalCard(parentState.parent2, { compact: true, selectable: false }));
        const arrow = document.createElement('div');
        arrow.className = 'combo-arrow';
        arrow.textContent = '→';
        flow.appendChild(arrow);
        if (baby) {
          flow.appendChild(createPalCard(baby, { compact: true, selectable: false }));
        } else {
          const placeholder = document.createElement('div');
          placeholder.classList.add('empty-state');
          placeholder.textContent = kidMode ? 'Unknown baby' : 'No matching baby yet';
          flow.appendChild(placeholder);
        }
        result.appendChild(flow);
        const tip = document.createElement('p');
        tip.className = 'breeding-tip';
        if (baby) {
          const babyPower = baby && baby.breeding && typeof baby.breeding.power === 'number' ? baby.breeding.power : 'Unknown';
          tip.innerHTML = kidMode
            ? `This pair is most likely to make <strong>${baby.name}</strong>. Pop a Cake into the box before you leave.`
            : `The parents average to breeding power ${avgPower}. That lines up closest with <strong>${baby.name}</strong> (Power ${babyPower}). Drop a Cake in the box to start incubation.`;
          result.appendChild(tip);
          const combosBtn = document.createElement('button');
          combosBtn.type = 'button';
          combosBtn.className = 'breeding-combo-link';
          combosBtn.textContent = kidMode ? 'Show how to make this pal' : 'See breeding combinations';
          combosBtn.addEventListener('click', () => {
            if (!baby) return;
            selectedBaby = baby;
            updateBreedingSelection();
            babySearch.value = '';
            renderBabyGrid();
            showCombos();
            switchBreedingMode('breedingDiscover');
            playSound(clickSound);
          });
          result.appendChild(combosBtn);
        } else {
          tip.textContent = kidMode ? 'We do not know the baby for this pair yet.' : 'We could not find a pal that matches this breeding power. Try another combination!';
          result.appendChild(tip);
        }
      }

      function switchBreedingMode(targetId) {
        modes.forEach(mode => {
          const isActive = mode.id === targetId;
          mode.classList.toggle('active', isActive);
          mode.setAttribute('aria-hidden', isActive ? 'false' : 'true');
          mode.setAttribute('tabindex', isActive ? '0' : '-1');
        });
        modeButtons.forEach(btn => {
          const isActive = btn.dataset.target === targetId;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        BREEDING_SELECTION.mode = targetId;
      }

      const savedMode = BREEDING_SELECTION.mode || 'breedingPredict';
      const availableModes = modes.map(mode => mode.id);
      const initialMode = availableModes.includes(savedMode) ? savedMode : 'breedingPredict';

      modeButtons.forEach(btn => {
        btn.onclick = () => {
          const target = btn.dataset.target;
          switchBreedingMode(target);
          playSound(clickSound);
        };
      });

      parent1Search.oninput = () => renderParentGrid('parent1');
      parent2Search.oninput = () => renderParentGrid('parent2');
      babySearch.oninput = () => renderBabyGrid();

      updateParentGrids();
      renderBabyGrid();
      showCombos();
      updateResult();
      switchBreedingMode(initialMode);
      updateBreedingSelection();
    }

    // Home page builder.  Highlights the two presentation modes,
    // shows quick progress snapshots, and surfaces the next pal to
    // recruit so returning players know where to jump in.
    function buildHomePage() {
      const home = document.getElementById('homeCards');
      if (!home) return;
      home.innerHTML = '';

      function createModeCard(mode) {
        const card = document.createElement('article');
        card.className = 'mode-card';
        card.dataset.modeCard = mode;

        const status = document.createElement('span');
        status.className = 'mode-card__status';
        status.textContent = mode === 'kid' ? 'Kid Mode' : 'Grown-up Mode';
        card.appendChild(status);

        const title = document.createElement('h3');
        title.textContent = mode === 'kid' ? 'Kid Mode' : 'Grown-up Mode';
        card.appendChild(title);

        const desc = document.createElement('p');
        desc.textContent = mode === 'kid'
          ? 'Friendly wording and bigger buttons keep younger Trainers confident.'
          : 'Detailed strategy notes and numbers help planners and older players.';
        card.appendChild(desc);

        const features = document.createElement('ul');
        features.className = 'mode-card__features';
        const featureLines = mode === 'kid'
          ? [
              'Simple step-by-step guide language.',
              'Larger tap targets and softer colours.',
              'Encouraging reminders instead of jargon.'
            ]
          : [
              'Expanded boss tips and resource callouts.',
              'Full material lists for every unlock.',
              'Extra context for breeding and combat choices.'
            ];
        featureLines.forEach(line => {
          const li = document.createElement('li');
          li.textContent = line;
          features.appendChild(li);
        });
        card.appendChild(features);

        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn mode-card__button';
        button.dataset.modeChoice = mode;
        button.textContent = mode === 'kid' ? 'Use Kid Mode' : 'Use Grown-up Mode';
        button.addEventListener('click', () => {
          const desired = mode === 'kid';
          const requiresRebuild = kidMode !== desired;
          setKidMode(desired, { rebuild: requiresRebuild });
          playSound(clickSound);
          switchPage('home');
        });
        card.appendChild(button);

        return card;
      }

      function createProgressCard(type) {
        const card = document.createElement('article');
        card.className = 'home-progress-card';

        const header = document.createElement('div');
        header.className = 'home-progress-card__header';
        const iconWrap = document.createElement('div');
        iconWrap.className = 'home-progress-card__icon';
        const icon = document.createElement('i');
        icon.className = 'fa-solid fa-compass';
        iconWrap.appendChild(icon);
        header.appendChild(iconWrap);

        const headerText = document.createElement('div');
        const title = document.createElement('h3');
        const subtitle = document.createElement('p');

        const meter = document.createElement('div');
        meter.className = 'home-progress-meter';
        meter.setAttribute('role', 'progressbar');
        meter.setAttribute('aria-valuemin', '0');
        meter.setAttribute('aria-valuemax', '100');
        meter.setAttribute('aria-valuenow', '0');
        const fill = document.createElement('div');
        fill.className = 'fill';
        const progressText = document.createElement('div');
        progressText.className = 'home-progress-text';
        progressText.setAttribute('aria-live', 'polite');
        const nextButton = document.createElement('button');
        nextButton.type = 'button';
        nextButton.className = 'home-progress-link home-progress-next';
        nextButton.disabled = true;
        const actions = document.createElement('div');
        actions.className = 'home-progress-actions';
        const actionBtn = document.createElement('button');
        actionBtn.type = 'button';
        actionBtn.className = 'btn';

        if (type === 'route') {
          icon.className = 'fa-solid fa-map-location-dot';
          title.textContent = kidMode ? 'Family Route Guide' : 'Story Route Guide';
          subtitle.textContent = kidMode
            ? 'Track tower goals and chapter steps together.'
            : 'See required steps before tackling the next boss.';
          meter.id = 'homeRouteProgressMeter';
          meter.setAttribute('aria-label', 'Route guide progress');
          fill.id = 'homeRouteProgressBar';
          progressText.id = 'homeRouteProgressText';
          nextButton.id = 'homeRouteNextStep';
          nextButton.textContent = kidMode ? 'Loading next guide step…' : 'Loading next guide step…';
          nextButton.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open the guide' : 'Open route guide';
          actionBtn.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
        } else if (type === 'pals') {
          icon.className = 'fa-solid fa-paw';
          title.textContent = kidMode ? 'Pal Squad Tracker' : 'Pal collection';
          subtitle.textContent = kidMode
            ? 'Mark pals as caught and celebrate new friends.'
            : 'See how many pals you have registered so far.';
          meter.id = 'homePalsProgressMeter';
          meter.setAttribute('aria-label', 'Pal collection progress');
          fill.id = 'homePalsProgressBar';
          progressText.id = 'homePalsProgressText';
          nextButton.id = 'homePalsNext';
          nextButton.textContent = kidMode ? 'Loading pal reminder…' : 'Loading pal reminder…';
          nextButton.addEventListener('click', () => {
            const palId = nextButton.dataset.palId;
            if (palId && PALS[palId]) {
              showPalDetail(palId);
            } else {
              switchPage('pals');
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open pal list' : 'Go to pal tracker';
          actionBtn.addEventListener('click', () => {
            switchPage('pals');
            playSound(clickSound);
          });
        } else {
          icon.className = 'fa-solid fa-screwdriver-wrench';
          title.textContent = kidMode ? 'Workshop Technology' : 'Technology progress';
          subtitle.textContent = kidMode
            ? 'Peek at what inventions are still locked.'
            : 'Review how many blueprints remain.';
          meter.id = 'homeTechProgressMeter';
          meter.setAttribute('aria-label', 'Technology progress');
          fill.id = 'homeTechProgressBar';
          progressText.id = 'homeTechProgressText';
          nextButton.id = 'homeTechNext';
          nextButton.textContent = kidMode ? 'Loading tech reminder…' : 'Loading tech reminder…';
          nextButton.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open tech tree' : 'View tech tree';
          actionBtn.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
        }

        headerText.appendChild(title);
        headerText.appendChild(subtitle);
        header.appendChild(headerText);
        card.appendChild(header);

        meter.appendChild(fill);
        card.appendChild(meter);
        progressText.textContent = kidMode ? 'Loading progress…' : 'Loading progress…';
        card.appendChild(progressText);
        nextButton.disabled = true;
        card.appendChild(nextButton);
        actions.appendChild(actionBtn);
        card.appendChild(actions);
        return card;
      }

      const hero = document.createElement('section');
      hero.className = 'home-hero';
      const intro = document.createElement('div');
      intro.className = 'home-hero__intro';
      intro.innerHTML = kidMode
        ? '<h3>Choose how you play tonight</h3><p>Kid Mode keeps directions bright and simple, while grown-up mode adds the deeper strategy notes adults crave.</p>'
        : '<h3>Two presentation styles for your crew</h3><p>Flip between Kid Mode for gentle guidance or Grown-up Mode for detailed callouts. Change it anytime and the whole guide updates instantly.</p>';
      hero.appendChild(intro);
      const modeGrid = document.createElement('div');
      modeGrid.className = 'mode-callouts';
      modeGrid.appendChild(createModeCard('kid'));
      modeGrid.appendChild(createModeCard('grown'));
      hero.appendChild(modeGrid);
      home.appendChild(hero);

      const progressSection = document.createElement('section');
      progressSection.className = 'home-progress';
      const progressHeader = document.createElement('div');
      progressHeader.className = 'home-section-header';
      progressHeader.innerHTML = kidMode
        ? '<h3>Where you left off</h3><p>Check the guide, your pal roster, and the workshop meter before diving back in.</p>'
        : '<h3>Continue your journey</h3><p>Quick status bars show route progress, pal collection, and technology unlocks at a glance.</p>';
      progressSection.appendChild(progressHeader);
      const progressGrid = document.createElement('div');
      progressGrid.className = 'home-progress-grid';
      progressGrid.appendChild(createProgressCard('route'));
      progressGrid.appendChild(createProgressCard('pals'));
      progressGrid.appendChild(createProgressCard('tech'));
      progressSection.appendChild(progressGrid);
      home.appendChild(progressSection);

      const spotlight = document.createElement('section');
      spotlight.className = 'home-spotlight';
      const spotlightHeader = document.createElement('div');
      spotlightHeader.className = 'home-section-header';
      spotlightHeader.innerHTML = kidMode
        ? '<h3>Pal spotlight</h3><p>Here’s a pal to chase down next based on your progress.</p>'
        : '<h3>Pal spotlight</h3><p>Use this reminder to see who you should recruit or train next.</p>';
      spotlight.appendChild(spotlightHeader);
      const spotlightBtn = document.createElement('button');
      spotlightBtn.type = 'button';
      spotlightBtn.className = 'home-spotlight-card';
      spotlightBtn.id = 'homePalSpotlight';
      spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Loading pal…</span><span class="home-spotlight-card__meta">We’ll suggest a buddy soon.</span></div>';
      spotlightBtn.addEventListener('click', () => {
        const palId = spotlightBtn.dataset.palId;
        if (palId && PALS[palId]) {
          showPalDetail(palId);
        } else {
          switchPage('pals');
        }
        playSound(clickSound);
      });
      spotlight.appendChild(spotlightBtn);
      home.appendChild(spotlight);

      refreshModeUI();
    }

    const ROUTE_STORAGE_KEY = 'palmarathon:route:v1';
    const ROUTE_PREFS_KEY = 'palmarathon:route:prefs:v1';
    const ROUTE_CONTEXT_KEY = 'palmarathon:route:context:v1';
    const DEFAULT_ROUTE_CONTEXT = {
      declaredLevel: null,
      hardcore: false,
      coop: false,
      availableTimeMinutes: null,
      goals: [],
      resourceGaps: []
    };
    let routeGuideData = null;
    let routeState = loadRouteState();
    const initialRoutePrefs = loadRoutePreferences();
    let routeHideOptional = !!initialRoutePrefs.hideOptional;
    let routeHiddenCategories = new Set(Array.isArray(initialRoutePrefs.hiddenCategories)
      ? initialRoutePrefs.hiddenCategories
          .map(value => routeCategorySlug(value, { strict: true }))
          .filter(Boolean)
      : []);
    let routeContext = loadRouteContext();
    let pendingRouteFocus = null;
    let pendingTechFocus = null;
    let currentRouteRecommendations = [];
    let routeSuggestionsAbort = null;
    const selectedRouteSuggestionIds = new Set();
    let selectedRouteSuggestionOrder = [];
    const routeSuggestionFilters = {
      types: new Set(),
      showCompleted: false,
      search: ''
    };
    const ROUTE_ART_IMAGE = 'assets/images/palworld-full-map-2.webp';
    const ROUTE_ICON_LIBRARY = {
      pal: {
        image: 'assets/images/route-icons/pal.svg',
        accent: '#9bd4ff',
        kidLabel: 'Pal adventures',
        adultLabel: 'Pal routes'
      },
      boss: {
        image: 'assets/images/route-icons/boss.svg',
        accent: '#d1b8ff',
        kidLabel: 'Boss battles',
        adultLabel: 'Boss routes'
      },
      technology: {
        image: 'assets/images/route-icons/technology.svg',
        accent: '#c8bfff',
        kidLabel: 'Tech unlocks',
        adultLabel: 'Tech routes'
      },
      npc: {
        image: 'assets/images/route-icons/npc.svg',
        accent: '#ffb3c1',
        kidLabel: 'Friend quests',
        adultLabel: 'NPC quests'
      },
      item: {
        image: 'assets/images/route-icons/item.svg',
        accent: '#ffe599',
        kidLabel: 'Item hunts',
        adultLabel: 'Item routes'
      }
    };
    const ROUTE_ART_LIBRARY = {
      boss: { overlay: 'rgba(126, 87, 255, 0.62)', accent: '#d1b8ff', icon: 'fa-chess-king', position: 'center 18%' },
      tower: { overlay: 'rgba(126, 87, 255, 0.62)', accent: '#d1b8ff', icon: 'fa-chess-king', position: 'center 18%' },
      farming: { overlay: 'rgba(42, 157, 143, 0.58)', accent: '#a7f2d2', icon: 'fa-seedling', position: 'center 68%' },
      gather: { overlay: 'rgba(42, 157, 143, 0.58)', accent: '#a7f2d2', icon: 'fa-seedling', position: 'center 68%' },
      capture: { overlay: 'rgba(255, 170, 102, 0.6)', accent: '#ffd6a5', icon: 'fa-paw', position: 'center 58%' },
      pal: { overlay: 'rgba(255, 170, 102, 0.6)', accent: '#ffd6a5', icon: 'fa-paw', position: 'center 58%' },
      exploration: { overlay: 'rgba(118, 206, 255, 0.6)', accent: '#9bd4ff', icon: 'fa-compass', position: 'center 32%' },
      travel: { overlay: 'rgba(118, 206, 255, 0.6)', accent: '#9bd4ff', icon: 'fa-compass', position: 'center 32%' },
      craft: { overlay: 'rgba(255, 214, 102, 0.58)', accent: '#ffe599', icon: 'fa-hammer', position: 'center 44%' },
      technology: { overlay: 'rgba(90, 126, 255, 0.58)', accent: '#c8bfff', icon: 'fa-gear', position: 'center 38%' },
      tech: { overlay: 'rgba(90, 126, 255, 0.58)', accent: '#c8bfff', icon: 'fa-gear', position: 'center 38%' },
      base: { overlay: 'rgba(90, 126, 255, 0.58)', accent: '#b8c3ff', icon: 'fa-house-flag', position: 'center 66%' },
      npc: { overlay: 'rgba(255, 159, 181, 0.58)', accent: '#ffb3c1', icon: 'fa-people-group', position: 'center 48%' },
      story: { overlay: 'rgba(255, 159, 181, 0.58)', accent: '#ffb3c1', icon: 'fa-people-group', position: 'center 48%' },
      item: { overlay: 'rgba(255, 214, 102, 0.58)', accent: '#ffe599', icon: 'fa-sack', position: 'center 60%' }
    };
    const ROUTE_ART_VARIANTS = [
      { overlay: 'rgba(148, 187, 233, 0.55)', accent: '#9bd4ff', icon: 'fa-route', position: 'center 40%' },
      { overlay: 'rgba(255, 123, 123, 0.52)', accent: '#ffb3c1', icon: 'fa-fire', position: 'center 64%' },
      { overlay: 'rgba(92, 225, 230, 0.52)', accent: '#bde7f8', icon: 'fa-compass', position: 'center 28%' },
      { overlay: 'rgba(255, 196, 77, 0.5)', accent: '#ffd6a5', icon: 'fa-sun', position: 'center 52%' }
    ];
    const ROUTE_SUGGESTION_TYPE_ORDER = ['pal', 'boss', 'technology', 'npc', 'item'];
    const DEFAULT_RECOMMENDER_WEIGHTS = {
      prerequisites_met: 6,
      level_fit: 5,
      unlock_value: 4,
      time_to_power_ratio: 2.5,
      progression_role: 3,
      coop_synergy: 2,
      risk_vs_mode: 2,
      tag_alignment: 3,
      novelty: 1.5,
      metric_efficiency: 2.5,
      resource_relief: 3,
      dynamic_alignment: 2,
      progress_momentum: 4,
      closeout_bonus: 3,
      goal_objective_alignment: 4,
      context_goal_keyword: 3,
      synergy_next_routes: 2,
      resource_urgency: 2.5,
      returning_focus: 2.5,
      tower_alignment: 3
    };
    let currentRouteSuggestionEntries = [];

    function rebuildTechLookup(){
      TECH_LOOKUP = {};
      (Array.isArray(TECH) ? TECH : []).forEach(level => {
        if(!level || !Array.isArray(level.items)) return;
        level.items.forEach(item => {
          if(!item) return;
          const identifiers = [];
          if(item.id) identifiers.push(item.id);
          if(item.name) identifiers.push(item.name);
          identifiers.forEach(identifier => {
            const slug = slugifyForPalworld(String(identifier));
            if(slug){
              TECH_LOOKUP[slug] = { item, level };
            }
          });
        });
      });
    }

    function ensureRouteGuide(){
      if(routeGuideData){
        return Promise.resolve(routeGuideData);
      }
      return fetch('guides.md')
        .then(res => {
          if(!res.ok){ throw new Error(`HTTP ${res.status}`); }
          return res.text();
        })
        .then(text => {
          const parsed = parseGuideMarkdown(text || '');
          routeGuideData = augmentGuideData(parsed);
          return routeGuideData;
        })
        .catch(err => {
          console.error('Failed to load adaptive guide', err);
          routeGuideData = { routes: [], chapters: [], tags: [], routeLookup: {}, metadata: null, recommender: null };
          return routeGuideData;
        });
    }

    function parseGuideMarkdown(markdown){
      const result = {
        metadata: null,
        xp: null,
        routes: [],
        routeSchema: null,
        levelEstimator: null,
        recommender: null,
        sourceRegistry: null,
        extras: [],
        errors: []
      };
      if(typeof markdown !== 'string' || !markdown.trim()){
        return result;
      }
      const blockPattern = /```json\s*([\s\S]*?)```/g;
      let match;
      while((match = blockPattern.exec(markdown))){
        const snippet = match[1] ? match[1].trim() : '';
        if(!snippet) continue;
        try {
          const json = JSON.parse(snippet);
          if(json && typeof json === 'object'){
            if(json.route_id){
              result.routes.push(json);
              continue;
            }
            if(Object.prototype.hasOwnProperty.call(json, 'schema_version')){
              result.metadata = json;
              continue;
            }
            if(json.route_schema){
              result.routeSchema = json.route_schema;
              continue;
            }
            if(Array.isArray(json.xp_thresholds)){
              result.xp = json;
              continue;
            }
            if(json.level_estimator){
              result.levelEstimator = json.level_estimator;
              continue;
            }
            if(json.recommender){
              result.recommender = json.recommender;
              continue;
            }
            if(json.source_registry){
              result.sourceRegistry = json.source_registry;
              continue;
            }
          }
          result.extras.push(json);
        } catch(err){
          console.warn('Failed to parse guide block', err);
          result.errors.push({ error: err, snippet });
        }
      }
      return result;
    }

    const ROUTE_ROLE_CORE_VALUES = new Set(['core', 'main', 'story', 'campaign', 'primary', 'critical']);
    const ROUTE_ROLE_SUPPORT_VALUES = new Set(['support', 'supporting', 'resource', 'farm', 'utility', 'supplemental']);
    const ROUTE_ROLE_OPTIONAL_VALUES = new Set(['optional', 'side', 'branch', 'bonus', 'supplementary', 'situational']);
    const STEP_REQUIRED_IMPORTANCE_VALUES = new Set(['required', 'core', 'critical', 'mandatory', 'main', 'story']);
    const STEP_OPTIONAL_IMPORTANCE_VALUES = new Set(['optional', 'support', 'supporting', 'bonus', 'stretch', 'side', 'branch', 'situational', 'contextual']);

    function normalizeRouteRole(value){
      const raw = typeof value === 'string' ? value.trim().toLowerCase() : '';
      if(ROUTE_ROLE_CORE_VALUES.has(raw)) return 'core';
      if(ROUTE_ROLE_SUPPORT_VALUES.has(raw)) return 'support';
      if(ROUTE_ROLE_OPTIONAL_VALUES.has(raw)) return 'optional';
      if(raw) return raw;
      return 'optional';
    }

    function normalizeStepImportance(step){
      if(!step || typeof step !== 'object') return 'required';
      const candidates = [
        step.importance,
        step.step_importance,
        step.stepImportance,
        step.role,
        step.step_role,
        step.progression_role,
        step.tier
      ];
      for(const candidate of candidates){
        if(typeof candidate === 'string' && candidate.trim()){
          return candidate.trim().toLowerCase();
        }
      }
      if(step.optional === true) return 'optional';
      if(step.optional === false) return 'required';
      if(Array.isArray(step.branching) && step.branching.length){
        return 'support';
      }
      return 'required';
    }

    function stepImportanceIsOptional(importance){
      return STEP_OPTIONAL_IMPORTANCE_VALUES.has(importance);
    }

    function stepImportanceIsRequired(importance){
      return STEP_REQUIRED_IMPORTANCE_VALUES.has(importance);
    }

    function deriveStepProgressionState(route, rawStep){
      const routeRole = normalizeRouteRole(route?.progression_role || route?.raw?.progression_role);
      const routeIsCore = routeRole === 'core';
      const importance = normalizeStepImportance(rawStep);
      const optionalByImportance = stepImportanceIsOptional(importance);
      const requiredByImportance = stepImportanceIsRequired(importance);
      let optional = null;
      if(requiredByImportance){
        optional = false;
      } else if(optionalByImportance){
        optional = true;
      }
      if(optional === null){
        optional = routeIsCore ? false : true;
      } else if(!routeIsCore){
        optional = true;
      }
      return { importance, optional: !!optional, routeRole };
    }

    function augmentGuideData(parsed){
      const routes = Array.isArray(parsed?.routes) ? parsed.routes : [];
      const augmentedRoutes = routes.map((route, index) => augmentRoute(route, index));
      const chapters = augmentedRoutes.map(entry => entry.chapter);
      const routeLookup = {};
      const tagSet = new Set();
      const resourceFrequency = new Map();
      augmentedRoutes.forEach(entry => {
        routeLookup[entry.id] = entry;
        entry.tags.forEach(tag => tagSet.add(tag));
        entry.resourceOutputs.forEach(itemId => {
          resourceFrequency.set(itemId, (resourceFrequency.get(itemId) || 0) + 1);
        });
      });
      const sortedResources = Array.from(resourceFrequency.entries())
        .sort((a, b) => b[1] - a[1])
        .map(entry => entry[0]);
      return {
        metadata: parsed?.metadata || null,
        xp: parsed?.xp || null,
        levelEstimator: parsed?.levelEstimator || null,
        recommender: parsed?.recommender || null,
        routes: augmentedRoutes,
        chapters,
        routeLookup,
        tags: Array.from(tagSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' })),
        keyResources: sortedResources.slice(0, 24),
        extras: parsed?.extras || [],
        errors: parsed?.errors || []
      };
    }

    function augmentRoute(route, index){
      const id = route?.route_id || `route-${index + 1}`;
      const tags = Array.isArray(route?.tags) ? route.tags.slice() : [];
      const objectives = Array.isArray(route?.objectives) ? route.objectives.slice() : [];
      const level = route?.recommended_level || {};
      const time = route?.estimated_time_minutes || {};
      const xpGain = route?.estimated_xp_gain || {};
      const risk = route?.risk_profile || 'medium';
      const normalizedRole = normalizeRouteRole(route?.progression_role);
      const adaptiveGuidance = route?.adaptive_guidance || {};
      const steps = Array.isArray(route?.steps) ? route.steps.slice() : [];
      const chapter = convertRouteToChapter(route, { index, role: normalizedRole });
      const resourceOutputs = collectRouteResourceOutputs(route);
      return {
        id,
        index,
        title: route?.title || 'Route',
        category: route?.category || 'progression',
        tags,
        progression_role: normalizedRole,
        progression_role_raw: route?.progression_role || null,
        recommended_level: level,
        modes: route?.modes || {},
        prerequisites: route?.prerequisites || { routes: [], tech: [], items: [], pals: [] },
        objectives,
        estimated_time_minutes: time,
        estimated_xp_gain: xpGain,
        risk_profile: risk,
        failure_penalties: route?.failure_penalties || {},
        adaptive_guidance: adaptiveGuidance,
        checkpoints: Array.isArray(route?.checkpoints) ? route.checkpoints.slice() : [],
        supporting_routes: route?.supporting_routes || { recommended: [], optional: [] },
        failure_recovery: route?.failure_recovery || {},
        steps,
        completion_criteria: Array.isArray(route?.completion_criteria) ? route.completion_criteria.slice() : [],
        yields: route?.yields || {},
        metrics: route?.metrics || {},
        next_routes: Array.isArray(route?.next_routes) ? route.next_routes.slice() : [],
        raw: route,
        chapter,
        resourceOutputs
      };
    }

    function convertRouteToChapter(route, { index = 0, role } = {}){
      const id = route?.route_id || `route-${index + 1}`;
      const steps = Array.isArray(route?.steps) ? route.steps : [];
      const title = route?.title || 'Route';
      const level = route?.recommended_level || {};
      const levelLabel = level && (level.min != null || level.max != null)
        ? `Lv ${level.min != null ? level.min : '?'}-${level.max != null ? level.max : '?'}`
        : '';
      const composedTitle = levelLabel ? `${title} — ${levelLabel}` : title;
      const objectives = Array.isArray(route?.objectives) ? route.objectives : [];
      const whyParts = [];
      if(objectives.length){
        whyParts.push(objectives.join('; '));
      }
      if(route?.risk_profile){
        whyParts.push(`Risk: ${capitalize(route.risk_profile)}`);
      }
      if(route?.estimated_time_minutes){
        const solo = route.estimated_time_minutes.solo;
        const coop = route.estimated_time_minutes.coop;
        if(solo || coop){
          const timeBits = [];
          if(solo) timeBits.push(`${solo}m solo`);
          if(coop) timeBits.push(`${coop}m co-op`);
          whyParts.push(`Time: ${timeBits.join(' / ')}`);
        }
      }
      const kidSummary = objectives.length ? objectives[0] : 'Follow the plan and have fun!';
      const normalizedRole = normalizeRouteRole(role || route?.progression_role);
      return {
        id,
        title: composedTitle,
        titleKid: title,
        why: whyParts.join(' • '),
        whyKid: kidSummary,
        steps: steps.map((step, stepIndex) => convertRouteStep(route, step, stepIndex, normalizedRole))
      };
    }

    function convertRouteStep(route, step, index, routeRoleOverride){
      const id = step?.step_id || `${route?.route_id || 'route'}:${String(index + 1).padStart(3, '0')}`;
      const type = step?.type || 'task';
      const categoryLabel = stepCategoryLabel(type);
      const detail = step?.detail || '';
      const summary = step?.summary || '';
      const text = detail || summary;
      const textKid = summary || detail || '';
      const routeRole = routeRoleOverride || normalizeRouteRole(route?.progression_role);
      const progressionState = deriveStepProgressionState({ progression_role: routeRole, raw: route }, step);
      const optional = progressionState.optional;
      const links = createStepLinks(step);
      return {
        id,
        category: categoryLabel,
        text,
        textKid,
        optional,
        importance: progressionState.importance,
        routeRole,
        links,
        raw: step,
        routeId: route?.route_id || null,
        type
      };
    }

    function stepCategoryLabel(type){
      const map = {
        'travel': 'Travel',
        'gather': 'Gather',
        'farm': 'Farm',
        'capture': 'Catch',
        'fight': 'Boss',
        'craft': 'Craft',
        'build': 'Build',
        'unlock-tech': 'Tech',
        'breed': 'Breed',
        'deliver': 'Deliver',
        'talk': 'Talk',
        'explore': 'Explore',
        'prepare': 'Prep'
      };
      return map[type] || capitalize(type || 'Task');
    }

    function createStepLinks(step){
      const links = [];
      if(step && Array.isArray(step.targets)){
        step.targets.forEach(target => {
          if(!target || !target.kind) return;
          if(target.kind === 'pal'){
            links.push({ type: 'pal', slug: target.id || target.slug, id: target.id || target.slug });
          } else if(target.kind === 'item'){
            links.push({ type: 'item', id: target.id });
          } else if(target.kind === 'tech' || target.kind === 'station'){
            links.push({ type: 'tech', id: target.id });
          } else if(target.kind === 'boss'){
            links.push({ type: 'tower', id: target.id || target.slug || target.name, map: target.map });
          }
        });
      }
      return links;
    }

    function collectRouteResourceOutputs(route){
      const items = new Set();
      if(route?.steps){
        route.steps.forEach(step => {
          const outputs = step?.outputs?.items || [];
          outputs.forEach(entry => {
            if(entry?.item_id){
              items.add(entry.item_id);
            }
          });
        });
      }
      const routeOutputs = route?.outputs?.items || [];
      routeOutputs.forEach(entry => {
        if(entry?.item_id){
          items.add(entry.item_id);
        }
      });
      return Array.from(items);
    }

    function routeChapterTitle(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.titleKid || chapter.title || '') : (chapter.title || chapter.titleKid || '');
    }

    function routeChapterWhy(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.whyKid || chapter.why || '') : (chapter.why || chapter.whyKid || '');
    }

    function routeStepText(step){
      if(!step) return '';
      if(!kidMode && step.textAdult) return step.textAdult;
      return kidMode ? (step.textKid || step.text || '') : (step.text || step.textKid || '');
    }

    function routeOptionalToggleLabel(hidden){
      if(kidMode){
        return hidden ? 'Show bonus steps' : 'Hide bonus steps';
      }
      return hidden ? 'Show Optional' : 'Hide Optional';
    }

    function routeCategorySlug(category, { fallback = 'task', strict = false } = {}){
      const raw = category == null ? '' : String(category);
      const slug = raw.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
      if(slug) return slug;
      return strict ? '' : fallback;
    }

    function classifyRouteGuideType(route){
      const category = (route?.category || '').toLowerCase();
      const tags = Array.isArray(route?.tags) ? route.tags.map(tag => String(tag || '').toLowerCase()) : [];
      const objectives = Array.isArray(route?.objectives) ? route.objectives.map(obj => String(obj || '').toLowerCase()) : [];
      const bucket = [category, ...tags, ...objectives];
      const matchesAny = (patterns) => bucket.some(entry => patterns.some(pattern => entry.includes(pattern)));
      if(matchesAny(['boss', 'tower', 'guardian', 'alpha', 'dungeon'])) return 'boss';
      if(matchesAny(['pal', 'capture', 'tame', 'egg', 'breed'])) return 'pal';
      if(matchesAny(['tech', 'technology', 'craft', 'build', 'upgrade', 'workbench', 'weapon', 'armor'])) return 'technology';
      if(matchesAny(['npc', 'quest', 'story', 'mission', 'rescue', 'friend'])) return 'npc';
      if(matchesAny(['item', 'resource', 'material', 'farm', 'gather', 'harvest', 'loot', 'supply'])) return 'item';
      if(category === 'support' || category === 'resource') return 'item';
      return 'pal';
    }

    function routeIconFor(route){
      const type = classifyRouteGuideType(route);
      const entry = ROUTE_ICON_LIBRARY[type] || ROUTE_ICON_LIBRARY.pal || Object.values(ROUTE_ICON_LIBRARY)[0] || {};
      const label = kidMode ? (entry.kidLabel || entry.adultLabel || capitalize(type)) : (entry.adultLabel || entry.kidLabel || capitalize(type));
      const image = entry.image || (ROUTE_ICON_LIBRARY.pal ? ROUTE_ICON_LIBRARY.pal.image : 'assets/images/route-icons/pal.svg');
      return {
        type,
        image,
        accent: entry.accent,
        label,
        alt: label || 'Guide icon'
      };
    }

    function routeArtFor(route){
      const category = (route?.category || '').toLowerCase();
      const tags = Array.isArray(route?.tags) ? route.tags.map(tag => (tag || '').toLowerCase()) : [];
      const lookupKeys = [category, ...tags];
      let art = null;
      for(const key of lookupKeys){
        if(!key) continue;
        if(ROUTE_ART_LIBRARY[key]){
          art = ROUTE_ART_LIBRARY[key];
          break;
        }
        if(key.includes('tower') || key.includes('boss')){
          art = ROUTE_ART_LIBRARY.tower || ROUTE_ART_LIBRARY.boss;
          break;
        }
        if(key.includes('farm')){
          art = ROUTE_ART_LIBRARY.farming;
        }
      }
      if(!art){
        const variants = ROUTE_ART_VARIANTS.length ? ROUTE_ART_VARIANTS : [{ overlay: 'rgba(148, 187, 233, 0.55)', accent: '#9bd4ff', icon: 'fa-route', position: 'center 40%' }];
        const variant = variants[Math.abs(hashString(route?.id || 'route')) % variants.length] || variants[0];
        art = variant;
      }
      const icon = routeIconFor(route);
      const accent = icon.accent || art.accent;
      return {
        image: ROUTE_ART_IMAGE,
        ...art,
        accent,
        iconImage: icon.image,
        iconAlt: icon.alt,
        iconLabel: icon.label,
        iconType: icon.type
      };
    }

    function routeProgressBreakdown(route){
      const chapter = route?.chapter;
      const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
      let requiredTotal = 0;
      let requiredDone = 0;
      let optionalTotal = 0;
      let optionalDone = 0;
      let totalDone = 0;
      steps.forEach(step => {
        if(!step || !step.id) return;
        const checked = !!routeState[step.id];
        if(checked) totalDone += 1;
        if(step.optional){
          optionalTotal += 1;
          if(checked) optionalDone += 1;
        } else {
          requiredTotal += 1;
          if(checked) requiredDone += 1;
        }
      });
      return {
        total: steps.length,
        totalDone,
        requiredTotal,
        requiredDone,
        optionalTotal,
        optionalDone
      };
    }

    function refreshRouteIntelligenceUI({ summary, levelEstimate, recommendations } = {}){
      if(!routeGuideData) return;
      const effectiveSummary = summary || calculateGuideProgressSummary();
      const effectiveLevel = levelEstimate || estimatePlayerLevel(routeContext);
      const effectiveRecommendations = recommendations || computeRouteRecommendations(routeGuideData, routeContext, effectiveLevel);
      currentRouteRecommendations = effectiveRecommendations;
      const suggestionCount = renderRouteSuggestions(effectiveRecommendations);
      renderRouteRecommendationsList(effectiveRecommendations, { offset: suggestionCount });
      updateRouteOverviewUI(effectiveSummary);
      renderBossRouteTimeline();
    }

    function routeSuggestionCtaLabel(selected){
      if(kidMode){
        return selected ? 'Pinned below' : 'Tap to pin below';
      }
      return selected ? 'Pinned to planner' : 'Pin to planner';
    }

    function selectSuggestedRoute(routeId){
      if(!routeId || selectedRouteSuggestionIds.has(routeId)) return;
      selectedRouteSuggestionIds.add(routeId);
      selectedRouteSuggestionOrder.push(routeId);
    }

    function deselectSuggestedRoute(routeId){
      if(!routeId) return;
      if(selectedRouteSuggestionIds.delete(routeId)){
        selectedRouteSuggestionOrder = selectedRouteSuggestionOrder.filter(id => id !== routeId);
      }
    }

    function applyRouteSuggestionFilters(recommendations){
      if(!Array.isArray(recommendations) || !recommendations.length) return [];
      const term = routeSuggestionFilters.search ? routeSuggestionFilters.search.trim().toLowerCase() : '';
      return recommendations.filter(entry => {
        const route = entry?.route;
        if(!route) return false;
        if(!routeSuggestionFilters.showCompleted && isRouteComplete(route)){
          return false;
        }
        if(routeSuggestionFilters.types.size){
          const type = classifyRouteGuideType(route);
          if(!routeSuggestionFilters.types.has(type)){
            return false;
          }
        }
        if(term){
          const haystack = [
            route.title,
            route.category,
            route.progression_role,
            Array.isArray(route.tags) ? route.tags.join(' ') : '',
            Array.isArray(route.objectives) ? route.objectives.join(' ') : ''
          ].join(' ').toLowerCase();
          if(!haystack.includes(term)){
            return false;
          }
        }
        return true;
      });
    }

    function updateRouteSuggestionCardStates(){
      const list = document.getElementById('routeSuggestionsList');
      if(!list) return;
      list.querySelectorAll('[data-suggestion-route]').forEach(card => {
        const id = card.dataset.suggestionRoute;
        const selected = selectedRouteSuggestionIds.has(id);
        card.classList.toggle('route-suggestion-card--selected', selected);
        card.setAttribute('aria-pressed', selected ? 'true' : 'false');
        const cta = card.querySelector('[data-role="suggestion-cta"]');
        if(cta){
          cta.textContent = routeSuggestionCtaLabel(selected);
        }
      });
    }

    function renderRouteSuggestions(recommendations){
      const card = document.getElementById('routeSuggestionsCard');
      const list = card ? card.querySelector('#routeSuggestionsList') : null;
      if(routeSuggestionsAbort){
        routeSuggestionsAbort.abort();
      }
      const filtered = applyRouteSuggestionFilters(recommendations);
      const entries = filtered.slice(0, 6);
      currentRouteSuggestionEntries = entries;
      const availableIds = new Set(entries.map(entry => entry?.route?.id).filter(Boolean));
      selectedRouteSuggestionOrder = selectedRouteSuggestionOrder.filter(id => availableIds.has(id));
      Array.from(selectedRouteSuggestionIds).forEach(id => {
        if(!availableIds.has(id)){
          selectedRouteSuggestionIds.delete(id);
        }
      });
      if(!selectedRouteSuggestionIds.size && entries.length){
        const firstId = entries[0].route?.id;
        if(firstId){
          selectSuggestedRoute(firstId);
        }
      }
      if(!entries.length){
        if(list){
          list.innerHTML = `<p class="route-suggestions__empty">${escapeHTML(kidMode
            ? 'Adjust the context above to unlock personalised picks.'
            : 'Fine-tune the context above to surface tailored paths.')}</p>`;
        }
        renderRouteSelectionPanel();
        return 0;
      }
      if(list){
        list.innerHTML = entries.map(entry => renderRouteSuggestionCard(entry, selectedRouteSuggestionIds.has(entry.route.id))).join('');
      }
      routeSuggestionsAbort = new AbortController();
      const { signal } = routeSuggestionsAbort;
      if(list){
        list.addEventListener('click', event => {
          const cardEl = event.target.closest('[data-suggestion-route]');
          if(!cardEl) return;
          const routeId = cardEl.dataset.suggestionRoute;
          if(!routeId) return;
          if(selectedRouteSuggestionIds.has(routeId)){
            deselectSuggestedRoute(routeId);
          } else {
            selectSuggestedRoute(routeId);
          }
          if(!selectedRouteSuggestionIds.size && entries.length){
            const fallbackId = entries[0].route?.id;
            if(fallbackId){
              selectSuggestedRoute(fallbackId);
            }
          }
          updateRouteSuggestionCardStates();
          renderRouteSelectionPanel();
          playSound(clickSound);
        }, { signal });
      }
      updateRouteSuggestionCardStates();
      renderRouteSelectionPanel();
      return entries.length;
    }

    function renderRouteSuggestionCard(entry, selected){
      const route = entry.route;
      const art = routeArtFor(route);
      const breakdown = routeProgressBreakdown(route);
      const overallPct = breakdown.total
        ? Math.round((breakdown.totalDone / breakdown.total) * 100)
        : (breakdown.requiredTotal ? Math.round((breakdown.requiredDone / breakdown.requiredTotal) * 100) : 0);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const reasonHighlight = Array.isArray(entry.reasons) && entry.reasons.length
        ? entry.reasons[0]
        : (kidMode ? 'Balanced for your crew.' : 'Balanced recommendation tailored to your context.');
      const scoreLabel = typeof entry.score === 'number' ? entry.score.toFixed(1) : '';
      const iconAlt = art.iconAlt || art.iconLabel || (kidMode ? 'Adventure icon' : 'Guide icon');
      return `
        <button type="button" class="route-suggestion-card${selected ? ' route-suggestion-card--selected' : ''}" data-suggestion-route="${escapeHTML(route.id)}" aria-pressed="${selected ? 'true' : 'false'}">
          <div class="route-suggestion-card__body">
            <div class="route-suggestion-card__top">
              <span class="route-suggestion-card__picture"><img src="${escapeHTML(art.iconImage)}" alt="${escapeHTML(iconAlt)}"></span>
              <div class="route-suggestion-card__text">
                <h4 class="route-suggestion-card__title">${escapeHTML(route.title)}</h4>
                ${metaLine ? `<p class="route-suggestion-card__meta">${escapeHTML(metaLine)}</p>` : ''}
              </div>
              ${scoreLabel ? `<span class="route-suggestion-card__score">${escapeHTML(scoreLabel)}</span>` : ''}
            </div>
            <div class="route-suggestion-card__progress">
              <div class="route-suggestion-card__progress-bar"><span style="width:${overallPct}%"></span></div>
              <span class="route-suggestion-card__progress-label">${escapeHTML(kidMode ? `${overallPct}% ready` : `${overallPct}% complete`)}</span>
            </div>
            <p class="route-suggestion-card__reason">${escapeHTML(reasonHighlight)}</p>
            <span class="route-suggestion-card__cta" data-role="suggestion-cta">${escapeHTML(routeSuggestionCtaLabel(selected))}</span>
          </div>
        </button>
      `;
    }

    function renderRouteSelectionPanel(){
      const detail = document.getElementById('routeSuggestionDetail');
      if(!detail) return;
      const entryMap = new Map((currentRouteSuggestionEntries || []).map(entry => [entry?.route?.id, entry]));
      const selectedEntries = selectedRouteSuggestionOrder
        .map(id => entryMap.get(id))
        .filter(entry => entry && entry.route);
      if(!selectedEntries.length){
        detail.innerHTML = `<p class="route-suggestions__placeholder">${escapeHTML(kidMode
          ? 'Tap the cards to pin adventures here.'
          : 'Select the cards to pin guides here.')}</p>`;
        detail.removeAttribute('data-chapter-id');
        detail.removeAttribute('data-route-id');
        return;
      }
      detail.innerHTML = selectedEntries.map(renderRouteSelectionCard).join('');
    }

    function renderRouteSelectionCard(entry){
      const route = entry.route;
      if(!route) return '';
      const art = routeArtFor(route);
      const breakdown = routeProgressBreakdown(route);
      const requiredLabel = breakdown.requiredTotal
        ? `${breakdown.requiredDone}/${breakdown.requiredTotal} ${kidMode ? 'big steps' : 'required'}`
        : '';
      const optionalLabel = breakdown.optionalTotal
        ? `${breakdown.optionalDone}/${breakdown.optionalTotal} ${kidMode ? 'bonus' : 'optional'}`
        : '';
      const progressDetail = [requiredLabel, optionalLabel].filter(Boolean).join(' • ');
      const overallPct = breakdown.total
        ? Math.round((breakdown.totalDone / breakdown.total) * 100)
        : (breakdown.requiredTotal ? Math.round((breakdown.requiredDone / breakdown.requiredTotal) * 100) : 0);
      const progressLabel = progressDetail || (kidMode ? `${overallPct}% ready` : `${overallPct}% complete`);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const reasons = Array.isArray(entry.reasons) && entry.reasons.length
        ? entry.reasons.slice(0, 3).map(reason => `<li>${escapeHTML(reason)}</li>`).join('')
        : '';
      const reasonsHtml = reasons
        ? `<ul class="route-selection__reasons">${reasons}</ul>`
        : `<p class="route-selection__reason">${escapeHTML(kidMode ? 'Balanced for your crew.' : 'Balanced recommendation tailored to your context.')}</p>`;
      const focusStep = entry.nextStepId || (findFirstIncompleteStepForRoute(route, { includeOptional: true })?.id || '');
      const roleLabel = route.progression_role ? capitalize(route.progression_role) : capitalize(route.category || 'route');
      const stepButton = focusStep
        ? `<button type="button" class="btn" data-step-focus="${escapeHTML(focusStep)}">${escapeHTML(kidMode ? 'Jump to this step' : 'Jump to this step')}</button>`
        : '';
      const overlay = art.overlay || 'rgba(8, 16, 32, 0.85)';
      const accent = art.accent || '#9bd4ff';
      const position = art.position || 'center 50%';
      const iconAlt = art.iconAlt || art.iconLabel || (kidMode ? 'Adventure icon' : 'Guide icon');
      const style = `--route-selection-image: url('${art.image}'); --route-selection-overlay: ${overlay}; --route-selection-accent: ${accent}; --route-selection-position: ${position};`;
      return `
        <article class="route-selection" data-route-id="${escapeHTML(route.id)}" style="${escapeHTML(style)}">
          <header class="route-selection__hero">
            <div class="route-selection__heading">
              <span class="route-selection__icon"><img src="${escapeHTML(art.iconImage)}" alt="${escapeHTML(iconAlt)}"></span>
              <div class="route-selection__title">
                <span class="route-selection__badge">${escapeHTML(roleLabel)}</span>
                <h4>${escapeHTML(route.title)}</h4>
                ${metaLine ? `<p class="route-selection__meta">${escapeHTML(metaLine)}</p>` : ''}
              </div>
              <button type="button" class="route-selection__remove" data-selection-remove="${escapeHTML(route.id)}" aria-label="${escapeHTML(kidMode ? 'Remove adventure' : 'Remove guide')}">&times;</button>
            </div>
            <div class="route-selection__progress">
              <div class="route-selection__progress-bar"><span style="width:${overallPct}%"></span></div>
              <span class="route-selection__progress-label">${escapeHTML(progressLabel)}</span>
            </div>
            ${reasonsHtml}
            <div class="route-selection__actions">
              <button type="button" class="btn" data-route-focus="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Open full guide' : 'Open full guide')}</button>
              ${stepButton}
            </div>
          </header>
          <div class="route-selection__body" data-chapter-id="${escapeHTML(route.chapter?.id || '')}">
            ${renderSteps(route.chapter, route)}
          </div>
        </article>
      `;
    }

    function bindRouteSelectionPanel(){
      const detail = document.getElementById('routeSuggestionDetail');
      if(!detail || detail.dataset.bound) return;
      detail.addEventListener('click', event => {
        const removeBtn = event.target.closest('[data-selection-remove]');
        if(removeBtn){
          const routeId = removeBtn.dataset.selectionRemove;
          deselectSuggestedRoute(routeId);
          if(!selectedRouteSuggestionIds.size && currentRouteSuggestionEntries.length){
            const fallback = currentRouteSuggestionEntries[0]?.route?.id;
            if(fallback){
              selectSuggestedRoute(fallback);
            }
          }
          updateRouteSuggestionCardStates();
          renderRouteSelectionPanel();
          playSound(clickSound);
          event.preventDefault();
          return;
        }
        const routeBtn = event.target.closest('[data-route-focus]');
        if(routeBtn){
          event.preventDefault();
          const routeId = routeBtn.dataset.routeFocus;
          const route = routeGuideData?.routeLookup?.[routeId];
          const nextStep = route ? findFirstIncompleteStepForRoute(route, { includeOptional: true }) : null;
          if(nextStep){
            queueRouteFocus(nextStep.id);
          } else if(route && route.chapter?.steps?.[0]){
            queueRouteFocus(route.chapter.steps[0].id);
          }
          switchPage('route');
          playSound(clickSound);
          return;
        }
        const stepBtn = event.target.closest('[data-step-focus]');
        if(stepBtn){
          event.preventDefault();
          const stepId = stepBtn.dataset.stepFocus;
          if(stepId){
            queueRouteFocus(stepId);
          }
          switchPage('route');
          playSound(clickSound);
          return;
        }
        handleRouteClick(event);
      });
      detail.addEventListener('change', handleRouteCheckboxChange);
      detail.dataset.bound = 'true';
    }

    function renderRouteSuggestionFiltersUI(){
      const container = document.getElementById('routeSuggestionsFilters');
      if(!container) return;
      const labelText = kidMode ? 'Adventure types' : 'Guide types';
      const showCompletedText = kidMode ? 'Include finished guides' : 'Include completed guides';
      const searchPlaceholder = kidMode ? 'Search for a guide' : 'Search guides';
      const chips = ROUTE_SUGGESTION_TYPE_ORDER.map(type => {
        const info = ROUTE_ICON_LIBRARY[type] || {};
        const chipLabel = kidMode ? (info.kidLabel || capitalize(type)) : (info.adultLabel || capitalize(type));
        const image = info.image || (ROUTE_ICON_LIBRARY.pal ? ROUTE_ICON_LIBRARY.pal.image : 'assets/images/route-icons/pal.svg');
        const alt = `${chipLabel} icon`;
        return `
          <button type="button" class="route-type-chip" data-suggestion-type="${escapeHTML(type)}" aria-pressed="false">
            <span class="route-type-chip__art"><img src="${escapeHTML(image)}" alt="${escapeHTML(alt)}"></span>
            <span class="route-type-chip__label">${escapeHTML(chipLabel)}</span>
          </button>`;
      }).join('');
      container.innerHTML = `
        <div class="route-suggestions__filter-group">
          <span class="route-suggestions__filter-label">${escapeHTML(labelText)}</span>
          <div class="route-type-chip-row">${chips}</div>
        </div>
        <div class="route-suggestions__filter-bar">
          <label class="route-suggestions__toggle">
            <input type="checkbox" id="routeSuggestionShowCompleted" />
            <span>${escapeHTML(showCompletedText)}</span>
          </label>
          <label class="route-suggestions__search">
            <span class="sr-only">${escapeHTML(kidMode ? 'Search adventures' : 'Search guides')}</span>
            <input type="search" id="routeSuggestionSearch" placeholder="${escapeHTML(searchPlaceholder)}" autocomplete="off" />
          </label>
        </div>
      `;
      if(!container.dataset.bound){
        container.addEventListener('click', handleRouteSuggestionFilterClick);
        container.addEventListener('change', handleRouteSuggestionFilterChange);
        container.addEventListener('input', handleRouteSuggestionFilterInput);
        container.dataset.bound = 'true';
      }
      updateRouteSuggestionFilterUI();
    }

    function updateRouteSuggestionFilterUI(){
      const container = document.getElementById('routeSuggestionsFilters');
      if(!container) return;
      container.querySelectorAll('[data-suggestion-type]').forEach(button => {
        const type = button.dataset.suggestionType;
        const active = routeSuggestionFilters.types.has(type);
        button.classList.toggle('route-type-chip--active', active);
        button.setAttribute('aria-pressed', active ? 'true' : 'false');
        const info = ROUTE_ICON_LIBRARY[type] || {};
        const chipLabel = kidMode ? (info.kidLabel || capitalize(type)) : (info.adultLabel || capitalize(type));
        const labelNode = button.querySelector('.route-type-chip__label');
        if(labelNode){
          labelNode.textContent = chipLabel;
        }
      });
      const labelText = kidMode ? 'Adventure types' : 'Guide types';
      const label = container.querySelector('.route-suggestions__filter-label');
      if(label){
        label.textContent = labelText;
      }
      const toggle = container.querySelector('#routeSuggestionShowCompleted');
      if(toggle){
        toggle.checked = !!routeSuggestionFilters.showCompleted;
        const toggleLabel = toggle.parentElement?.querySelector('span');
        if(toggleLabel){
          toggleLabel.textContent = kidMode ? 'Include finished guides' : 'Include completed guides';
        }
      }
      const search = container.querySelector('#routeSuggestionSearch');
      if(search){
        const { selectionStart, selectionEnd } = search;
        search.value = routeSuggestionFilters.search || '';
        search.placeholder = kidMode ? 'Search for a guide' : 'Search guides';
        if(document.activeElement === search && selectionStart != null && selectionEnd != null){
          search.setSelectionRange(selectionStart, selectionEnd);
        }
      }
    }

    function handleRouteSuggestionFilterClick(event){
      const button = event.target.closest('[data-suggestion-type]');
      if(!button) return;
      event.preventDefault();
      const type = button.dataset.suggestionType;
      if(!type) return;
      if(routeSuggestionFilters.types.has(type)){
        routeSuggestionFilters.types.delete(type);
      } else {
        routeSuggestionFilters.types.add(type);
      }
      playSound(clickSound);
      reapplyRouteSuggestionFilters();
    }

    function handleRouteSuggestionFilterChange(event){
      const target = event.target;
      if(target && target.id === 'routeSuggestionShowCompleted'){
        routeSuggestionFilters.showCompleted = target.checked;
        reapplyRouteSuggestionFilters();
      }
    }

    let routeSuggestionSearchFrame = null;
    function handleRouteSuggestionFilterInput(event){
      const target = event.target;
      if(!target || target.id !== 'routeSuggestionSearch') return;
      routeSuggestionFilters.search = target.value || '';
      if(routeSuggestionSearchFrame){
        cancelAnimationFrame(routeSuggestionSearchFrame);
      }
      routeSuggestionSearchFrame = requestAnimationFrame(() => {
        reapplyRouteSuggestionFilters();
        routeSuggestionSearchFrame = null;
      });
    }

    function reapplyRouteSuggestionFilters(){
      updateRouteSuggestionFilterUI();
      const recommendations = Array.isArray(currentRouteRecommendations) ? currentRouteRecommendations : [];
      const suggestionCount = renderRouteSuggestions(recommendations);
      renderRouteRecommendationsList(recommendations, { offset: suggestionCount });
    }

    function hashString(value){
      const str = String(value);
      let hash = 0;
      for(let i = 0; i < str.length; i += 1){
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }

    function getLastCompletedRouteMeta(){
      const meta = routeState?.__meta;
      if(!meta || typeof meta !== 'object' || !meta.completedRoutes) return null;
      const entries = Object.entries(meta.completedRoutes)
        .map(([id, info]) => ({
          id,
          title: info?.title || (routeGuideData?.routeLookup?.[id]?.title) || niceName(id),
          completedAt: info?.completedAt || null
        }));
      if(!entries.length) return null;
      entries.sort((a, b) => {
        const aTime = a.completedAt ? Date.parse(a.completedAt) : 0;
        const bTime = b.completedAt ? Date.parse(b.completedAt) : 0;
        return aTime - bTime;
      });
      return entries[entries.length - 1];
    }

    function formatGuideCompletionDate(iso){
      if(!iso) return '';
      const date = new Date(iso);
      if(Number.isNaN(date.getTime())) return '';
      try {
        return new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' }).format(date);
      } catch(err){
        return date.toLocaleDateString();
      }
    }

    function syncRouteCompletionMetadata(){
      if(!routeGuideData) return false;
      const meta = routeState.__meta && typeof routeState.__meta === 'object' ? { ...routeState.__meta } : {};
      const previous = meta.completedRoutes && typeof meta.completedRoutes === 'object' ? meta.completedRoutes : {};
      const updated = {};
      let changed = false;
      routeGuideData.routes.forEach(route => {
        const complete = isRouteComplete(route);
        const prior = previous[route.id];
        if(complete){
          const entry = {
            title: route.title,
            completedAt: prior?.completedAt || new Date().toISOString()
          };
          updated[route.id] = entry;
          if(!prior || prior.title !== entry.title){
            changed = true;
          }
        } else if(prior){
          changed = true;
        }
      });
      const previousKeys = Object.keys(previous);
      const updatedKeys = Object.keys(updated);
      if(previousKeys.length !== updatedKeys.length){
        changed = true;
      }
      if(changed){
        if(updatedKeys.length){
          routeState.__meta = { ...meta, completedRoutes: updated, updatedAt: new Date().toISOString() };
        } else if(routeState.__meta){
          delete routeState.__meta.completedRoutes;
          delete routeState.__meta.updatedAt;
          if(!Object.keys(routeState.__meta).length){
            delete routeState.__meta;
          }
        }
      }
      return changed;
    }

    function renderRouteGuide(){
      ensureRouteGuide().then(guide => {
        const node = document.getElementById('routePage');
        if(!node) return;
        const routes = Array.isArray(guide?.routes) ? guide.routes : [];
        const chapters = Array.isArray(guide?.chapters) ? guide.chapters : [];
        if(!routes.length || !chapters.length){
          node.innerHTML = '<section class="card"><h2>Adaptive Route Planner</h2><p>Route data unavailable.</p></section>';}
        else {
          routeGuideData = guide;
          routeState = loadRouteState();
          if(syncRouteCompletionMetadata()){
            saveRouteState(routeState);
          }
          routeContext = normalizeRouteContext(routeContext);
          const summary = calculateGuideProgressSummary(chapters);
          const levelEstimate = estimatePlayerLevel(routeContext);
          const recommendations = computeRouteRecommendations(guide, routeContext, levelEstimate);
          const heading = kidMode ? 'Adaptive Adventure Planner' : 'Adaptive Route Planner';
          const suggestionsLead = kidMode
            ? 'Palmate studies your level, party mode, and wish list to queue up perfect adventures. Highlight one to see every step.'
            : 'Palmate analyses the full guide library against your context. Highlight a path to preview the complete walkthrough.';
          const recommendationLead = kidMode
            ? 'Need other ideas? These extra adventures re-rank when your context changes.'
            : 'Want alternatives? The rest of the ranked library updates whenever your context shifts.';
          node.innerHTML = `
          <header class="page-header">
            <h2>${escapeHTML(heading)}</h2>
          </header>
          <section class="card route-context" id="routeContextCard">
            ${renderRouteContextOverview(routeContext, levelEstimate, summary)}
            ${renderRouteContextControls(routeGuideData, routeContext)}
          </section>
          <section class="card route-suggestions-card" id="routeSuggestionsCard">
            <div class="route-suggestions__header">
              <h3>${kidMode ? 'Tonight’s Adventure Paths' : 'Suggested Adventure Paths'}</h3>
              <p class="route-suggestions__intro">${escapeHTML(suggestionsLead)}</p>
            </div>
            <div class="route-suggestions__workspace">
              <aside class="route-suggestions__filters" id="routeSuggestionsFilters">
                <p class="route-suggestions__filters-empty">${escapeHTML(kidMode
                  ? 'Loading adventure types…'
                  : 'Loading adventure filters…')}</p>
              </aside>
              <div class="route-suggestions__content">
                <div class="route-suggestions__list" id="routeSuggestionsList">
                  <p class="route-suggestions__empty">${escapeHTML(kidMode
                    ? 'Adjust the context above to unlock personalised picks.'
                    : 'Fine-tune the context above to surface tailored paths.')}</p>
                </div>
                <div class="route-suggestions__selection" id="routeSuggestionDetail">
                  <p class="route-suggestions__placeholder">${escapeHTML(kidMode
                    ? 'Tap the cards to pin adventures here.'
                    : 'Select the cards to pin guides here.')}</p>
                </div>
              </div>
            </div>
          </section>
          <section class="card route-recommendations-card" id="routeRecommendationsCard">
            <div class="route-recommendations__header">
              <h3>${kidMode ? 'More adventures to consider' : 'More adaptive picks'}</h3>
              <p class="route-recommendations__intro">${escapeHTML(recommendationLead)}</p>
            </div>
            <details class="route-recommendations__collapsible" id="routeRecommendationsDetails">
              <summary><span id="routeRecommendationsSummaryLabel">${escapeHTML(kidMode
                ? 'Browse the full adventure library'
                : 'Browse the full guide library')}</span></summary>
              <div id="routeRecommendationsList" class="route-recommendations__list"></div>
            </details>
          </section>
          <section class="card route-controls">
            <p class="route-controls__lead">${escapeHTML(kidMode
              ? 'Check off each friendly step together. Hide bonus chores, focus categories, or jump straight to the next task.'
              : 'Track every objective across Palworld. Hide optional steps, filter by category, or jump straight to your next move.')}</p>
            <div class="route-controls__actions">
              <button type="button" class="btn" data-route-action="toggle-optional">${routeOptionalToggleLabel(routeHideOptional)}</button>
              <button type="button" class="btn" data-route-action="jump-next" data-step-id="">${kidMode ? 'Jump to next step' : 'Jump to next required'}</button>
            </div>
            <div class="route-controls__filters" data-route-role="filters" aria-label="Filter steps by category"></div>
          </section>
          <div id="routeChapters"></div>
        `;
          const wrap = node.querySelector('#routeChapters');
          routes.forEach((route, idx) => {
          wrap.appendChild(renderChapterCard(route.chapter, idx === 0, route));
          });
          wrap.addEventListener('change', handleRouteCheckboxChange);
          wrap.addEventListener('click', handleRouteClick);
          bindRouteActionButtons();
          renderRouteSuggestionFiltersUI();
          bindRouteSelectionPanel();
          renderRouteFiltersUI(summary.categories);
          applyQueuedRouteFocus();
          refreshRouteIntelligenceUI({ summary, levelEstimate, recommendations });
          updateProgressUI();
          bindRouteContextControls(node, { guide, summary, levelEstimate, recommendations });
        }
      });
    }


    function renderRouteContextOverview(context, levelEstimate, summary){
      const declared = context?.declaredLevel != null ? Number(context.declaredLevel) : null;
      const estimatedLevel = levelEstimate?.level != null ? levelEstimate.level : null;
      const xpTotal = levelEstimate?.totalXp != null ? Math.round(levelEstimate.totalXp) : null;
      const confidence = levelEstimate?.confidence != null ? Math.round(levelEstimate.confidence * 100) : null;
      const requiredPct = summary.requiredTotal ? Math.round((summary.requiredComplete / summary.requiredTotal) * 100) : 0;
      const optionalPct = summary.optionalTotal ? Math.round((summary.optionalComplete / summary.optionalTotal) * 100) : 0;
      const towersPct = summary.towersTotal ? Math.round((summary.towersComplete / summary.towersTotal) * 100) : 0;
      const declaredLabel = declared != null ? String(declared) : (kidMode ? 'Not set' : 'Not set');
      const estimatedLabel = estimatedLevel != null ? String(estimatedLevel) : '—';
      const xpLabel = xpTotal != null ? xpTotal.toLocaleString() : '';
      const confidenceLabel = confidence != null ? `${confidence}%` : '';
      const coreRoutes = summary?.routes?.core || { total: 0, complete: 0 };
      const stepsRemaining = summary.requiredTotal ? summary.requiredTotal - summary.requiredComplete : 0;
      const routesRemaining = coreRoutes.total ? coreRoutes.total - coreRoutes.complete : 0;
      let progressNote;
      if(summary.requiredTotal){
        if(routesRemaining > 0){
          const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
          const stepLabel = stepsRemaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
          progressNote = `${routesRemaining} ${routeLabel} • ${stepsRemaining} ${stepLabel} left`;
        } else if(stepsRemaining > 0){
          const stepLabel = stepsRemaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
          progressNote = `${stepsRemaining} ${stepLabel} remaining`;
        } else {
          progressNote = kidMode ? 'All big steps complete!' : 'All required steps complete.';
        }
      } else {
        progressNote = kidMode ? 'Start any route to begin the journey.' : 'Start a route to begin tracking progress.';
      }
      let optionalNote;
      if(summary.optionalTotal){
        const remainingOptional = summary.optionalTotal - summary.optionalComplete;
        if(remainingOptional === 0){
          optionalNote = kidMode ? 'Bonus adventures wrapped!' : 'All optional tasks completed.';
        } else {
          optionalNote = kidMode
            ? `${remainingOptional} bonus step${remainingOptional === 1 ? '' : 's'} to try`
            : `${remainingOptional} optional step${remainingOptional === 1 ? '' : 's'} remaining`;
        }
      } else {
        optionalNote = kidMode ? 'Extra fun chores' : 'Bonus cleanup and prep';
      }
      let towerNote;
      if(summary.towersTotal){
        const remainingTowers = summary.towersTotal - summary.towersComplete;
        if(remainingTowers === 0){
          towerNote = kidMode ? 'Every tower champion beaten!' : 'All tower bosses defeated.';
        } else {
          towerNote = kidMode
            ? `${remainingTowers} tower${remainingTowers === 1 ? '' : 's'} left`
            : `${remainingTowers} tower boss${remainingTowers === 1 ? '' : 'es'} remaining`;
        }
      } else {
        towerNote = kidMode ? 'Defeat bosses together' : 'Tower bosses defeated so far';
      }
      const lastCompleted = getLastCompletedRouteMeta();
      const lastLabel = (() => {
        if(!lastCompleted) return kidMode ? 'No routes completed yet.' : 'No routes completed yet.';
        const title = lastCompleted.title || niceName(lastCompleted.id);
        const dateLabel = lastCompleted.completedAt ? formatGuideCompletionDate(lastCompleted.completedAt) : '';
        if(kidMode){
          return dateLabel ? `Finished ${title} (${dateLabel})` : `Finished ${title}`;
        }
        return dateLabel ? `Last cleared: ${title} — ${dateLabel}` : `Last cleared: ${title}`;
      })();
      const requiredValue = summary.requiredTotal ? `${summary.requiredComplete}/${summary.requiredTotal}` : '0/0';
      const optionalValue = summary.optionalTotal ? `${summary.optionalComplete}/${summary.optionalTotal}` : '0/0';
      const towerValue = summary.towersTotal ? `${summary.towersComplete}/${summary.towersTotal}` : '0/0';
      return `
        <div class="route-overview__header">
          <div class="route-overview__stats">
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-signal"></i></span>
                <p class="route-overview__stat-title">${kidMode ? 'Declared level' : 'Declared level'}</p>
              </div>
              <p class="route-overview__stat-value">${escapeHTML(declaredLabel)}</p>
              <p class="route-overview__stat-sub">${escapeHTML(kidMode ? 'Use the slider below to tell Palmate your level.' : 'Override the estimated level with your own.')}</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-chart-line"></i></span>
                <p class="route-overview__stat-title">${kidMode ? 'Estimated level' : 'Estimated level'}</p>
              </div>
              <p class="route-overview__stat-value">${escapeHTML(estimatedLabel)}</p>
              <p class="route-overview__stat-sub">${xpLabel
                ? `${escapeHTML(xpLabel)} XP${confidenceLabel ? ` • ${escapeHTML(confidenceLabel)} confidence` : ''}`
                : escapeHTML(kidMode ? 'Complete steps to power up this estimate.' : 'Finish more steps to refine this estimate.')}</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-list-check"></i></span>
                <p class="route-overview__stat-title" data-route-role="required-title">${kidMode ? 'Big steps' : 'Required steps'}</p>
              </div>
              <p class="route-overview__stat-value" data-route-role="required-count">${escapeHTML(requiredValue)}</p>
              <div class="route-overview__meter" data-route-role="required-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${requiredPct}">
                <span class="fill" data-route-role="required-fill" style="width:${requiredPct}%"></span>
              </div>
              <p class="route-overview__stat-sub" data-route-role="required-note">${escapeHTML(progressNote)}</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                <p class="route-overview__stat-title" data-route-role="optional-title">${kidMode ? 'Bonus ideas' : 'Optional tasks'}</p>
              </div>
              <p class="route-overview__stat-value" data-route-role="optional-count">${escapeHTML(optionalValue)}</p>
              <div class="route-overview__meter" data-route-role="optional-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${optionalPct}">
                <span class="fill" data-route-role="optional-fill" style="width:${optionalPct}%"></span>
              </div>
              <p class="route-overview__stat-sub" data-route-role="optional-note">${escapeHTML(optionalNote)}</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-tower-broadcast"></i></span>
                <p class="route-overview__stat-title" data-route-role="tower-title">${kidMode ? 'Tower wins' : 'Towers cleared'}</p>
              </div>
              <p class="route-overview__stat-value" data-route-role="tower-count">${escapeHTML(towerValue)}</p>
              <div class="route-overview__meter" data-route-role="tower-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${towersPct}">
                <span class="fill" data-route-role="tower-fill" style="width:${towersPct}%"></span>
              </div>
              <p class="route-overview__stat-sub" data-route-role="tower-note">${escapeHTML(towerNote)}</p>
            </article>
          </div>
          <div class="route-overview__controls">
            <p class="route-overview__next" data-route-role="next-callout"></p>
            <p class="route-overview__history" data-route-role="last-completed">${escapeHTML(lastLabel)}</p>
          </div>
        </div>
      `;
    }

    function renderRouteContextControls(guide, context){
      const levelValue = context?.declaredLevel != null ? Number(context.declaredLevel) : '';
      const timeValue = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : '';
      const tags = Array.isArray(guide?.tags) ? guide.tags : [];
      const resourceOptions = Array.isArray(guide?.keyResources) ? guide.keyResources : [];
      const goalChips = tags.length
        ? tags.map(tag => {
            const active = context.goals.includes(tag);
            const classes = ['route-goal-chip', 'chip'];
            if(active) classes.push('route-goal-chip--active');
            return `<button type="button" class="${classes.join(' ')}" data-context-goal="${escapeHTML(tag)}">${escapeHTML(capitalize(tag))}</button>`;
          }).join('')
        : `<p class="route-context__empty">${escapeHTML(kidMode ? 'Goals load soon.' : 'No goals available yet.')}</p>`;
      const resourceChips = context.resourceGaps.length
        ? context.resourceGaps.map(entry => renderResourceGapChip(entry)).join('')
        : `<p class="route-context__empty">${escapeHTML(kidMode ? 'Add items you are missing.' : 'Add resource gaps to surface farming routes.')}</p>`;
      const optionsHtml = resourceOptions.length
        ? resourceOptions.map(itemId => `<option value="${escapeHTML(itemId)}">${escapeHTML(itemDisplayName(itemId))}</option>`).join('')
        : '';
      const levelSliderValue = levelValue === '' ? 1 : levelValue;
      const sliderEmptyAttr = levelValue === '' ? ' data-empty="true"' : '';
      return `
        <div class="route-context__controls">
          <div class="route-context__grid">
            <div class="route-context__field">
              <label class="route-context__label" for="routeLevelRange">${escapeHTML(kidMode ? 'Tell Palmate your level' : 'Declared level')}</label>
              <div class="route-context__level">
                <input type="range" id="routeLevelRange" min="1" max="50" value="${escapeHTML(String(levelSliderValue))}"${sliderEmptyAttr} />
                <input type="number" id="routeLevelInput" min="1" max="50" value="${levelValue === '' ? '' : escapeHTML(String(levelValue))}" placeholder="${escapeHTML(kidMode ? 'Unset' : 'Optional')}" />
              </div>
            </div>
            <div class="route-context__field">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Mode & party' : 'Difficulty & party')}</label>
              <div class="route-context__toggles">
                <button type="button" class="chip route-context__toggle${context.hardcore ? ' route-context__toggle--active' : ''}" data-context-toggle="hardcore">${escapeHTML(kidMode ? 'Hardcore' : 'Hardcore')}</button>
                <button type="button" class="chip route-context__toggle${context.coop ? ' route-context__toggle--active' : ''}" data-context-toggle="coop">${escapeHTML(kidMode ? 'Co-Op' : 'Co-Op')}</button>
              </div>
            </div>
            <div class="route-context__field">
              <label class="route-context__label" for="routeTimeInput">${escapeHTML(kidMode ? 'Time available (minutes)' : 'Available time (minutes)')}</label>
              <input type="number" id="routeTimeInput" min="5" max="480" step="5" value="${timeValue === '' ? '' : escapeHTML(String(timeValue))}" placeholder="${escapeHTML(kidMode ? 'Leave blank if unsure' : 'Leave blank if flexible')}" />
            </div>
            <div class="route-context__field">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Goals' : 'Focus goals')}</label>
              <div class="route-context__goals">${goalChips}</div>
            </div>
            <div class="route-context__field">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Resource gaps' : 'Resource shortages')}</label>
              <div class="route-context__resources">
                <div class="route-context__resource-add">
                  <select id="routeResourceSelect">
                    <option value="">${escapeHTML(kidMode ? 'Pick a resource' : 'Select a resource')}</option>
                    ${optionsHtml}
                  </select>
                  <input type="number" id="routeResourceQty" min="1" max="999" placeholder="${escapeHTML(kidMode ? 'Qty' : 'Qty')}" />
                  <button type="button" class="btn route-context__resource-add-btn" data-action="add-resource-gap">${escapeHTML(kidMode ? 'Add' : 'Add')}</button>
                </div>
                <div class="route-context__resource-list" id="routeResourceList">${resourceChips}</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function itemDisplayName(itemId){
      if(!itemId) return 'Item';
      const detail = ITEM_DETAILS?.[itemId];
      if(detail?.name) return detail.name;
      const item = ITEMS?.[itemId];
      if(item?.name) return item.name;
      return niceName(itemId);
    }

    function renderResourceGapChip(entry){
      const itemId = entry?.item_id || entry?.itemId || '';
      if(!itemId) return '';
      const qty = entry?.qty != null ? Number(entry.qty) : null;
      const qtyLabel = qty != null && !Number.isNaN(qty) ? ` ×${qty}` : '';
      return `<button type="button" class="chip route-resource-chip" data-resource-id="${escapeHTML(itemId)}">${escapeHTML(itemDisplayName(itemId))}${escapeHTML(qtyLabel)}<span class="route-resource-chip__remove" aria-hidden="true">&times;</span></button>`;
    }

    let routeRecommendationsAbort = null;

    function renderRouteRecommendationsList(recommendations, { offset = 0 } = {}){
      const card = document.getElementById('routeRecommendationsCard');
      const list = card ? card.querySelector('#routeRecommendationsList') : null;
      const details = card ? card.querySelector('#routeRecommendationsDetails') : null;
      const summaryLabel = card ? card.querySelector('#routeRecommendationsSummaryLabel') : null;
      if(!list) return;
      const totalRemaining = Array.isArray(recommendations) ? Math.max(0, recommendations.length - offset) : 0;
      if(summaryLabel){
        if(totalRemaining > 0){
          const noun = totalRemaining === 1 ? (kidMode ? 'adventure' : 'guide') : (kidMode ? 'adventures' : 'guides');
          summaryLabel.textContent = kidMode
            ? `Browse ${totalRemaining} more ${noun}`
            : `Browse ${totalRemaining} more ${noun}`;
        } else {
          summaryLabel.textContent = kidMode
            ? 'No other adventures right now'
            : 'No additional guides right now';
        }
      }
      if(details){
        if(totalRemaining > 0){
          details.removeAttribute('data-empty');
        } else {
          details.setAttribute('data-empty', 'true');
          details.open = false;
        }
      }
      if(totalRemaining <= 0){
        list.innerHTML = `<p class="route-recommendations__empty">${escapeHTML(kidMode ? 'Set your level or add goals to unlock more adventures.' : 'Adjust your context to surface additional guides.')}</p>`;
      } else {
        const cards = recommendations.slice(offset, offset + 5).map(renderRouteRecommendation).join('');
        list.innerHTML = cards;
      }
      if(routeRecommendationsAbort){
        routeRecommendationsAbort.abort();
      }
      routeRecommendationsAbort = new AbortController();
      const { signal } = routeRecommendationsAbort;
      list.addEventListener('click', event => {
        const btn = event.target.closest('[data-route-focus]');
        if(!btn) return;
        const routeId = btn.dataset.routeFocus;
        const requestedStep = btn.dataset.routeStep;
        const route = routeGuideData?.routeLookup?.[routeId];
        let stepId = requestedStep;
        if(!stepId && route){
          const nextStep = findFirstIncompleteStepForRoute(route, { includeOptional: true });
          if(nextStep) stepId = nextStep.id;
        }
        if(stepId){
          queueRouteFocus(stepId);
        }
        switchPage('route');
        playSound(clickSound);
      }, { signal });
    }

    function renderRouteRecommendation(entry){
      const route = entry.route;
      const art = routeArtFor(route);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const scoreLabel = typeof entry.score === 'number' ? entry.score.toFixed(1) : '';
      const tags = Array.isArray(route?.tags) && route.tags.length
        ? `<div class="route-recommendation__tags">${route.tags.map(tag => `<span class="chip route-recommendation__tag">${escapeHTML(tag)}</span>`).join('')}</div>`
        : '';
      const reasons = Array.isArray(entry.reasons) && entry.reasons.length
        ? `<ul class="route-recommendation__reasons">${entry.reasons.map(reason => `<li>${escapeHTML(reason)}</li>`).join('')}</ul>`
        : `<p class="route-recommendation__fallback">${escapeHTML(kidMode ? 'Palmate picked this route for balanced fun and progress.' : 'Palmate selected this route based on your context.')}</p>`;
      const focusStep = entry.nextStepId || route?.chapter?.steps?.[0]?.id || '';
      const iconAlt = art.iconAlt || art.iconLabel || (kidMode ? 'Adventure icon' : 'Guide icon');
      return `
        <article class="route-recommendation" data-route-id="${escapeHTML(route.id)}">
          <div class="route-recommendation__header">
            <div class="route-recommendation__title">
              <span class="route-recommendation__icon"><img src="${escapeHTML(art.iconImage)}" alt="${escapeHTML(iconAlt)}"></span>
              <div class="route-recommendation__text">
                <h4>${escapeHTML(route.title)}</h4>
                ${metaLine ? `<p class="route-recommendation__meta">${escapeHTML(metaLine)}</p>` : ''}
                ${tags}
              </div>
            </div>
            ${scoreLabel ? `<div class="route-recommendation__score">${escapeHTML(scoreLabel)}</div>` : ''}
          </div>
          ${reasons}
          <div class="route-recommendation__actions">
            <button type="button" class="btn" data-route-focus="${escapeHTML(route.id)}" data-route-step="${escapeHTML(focusStep)}">${escapeHTML(kidMode ? 'View steps' : 'Open route')}</button>
          </div>
        </article>
      `;
    }

    let routeContextControlAbort = null;

    function bindRouteContextControls(root, { guide } = {}){
      if(!root) return;
      if(routeContextControlAbort){
        routeContextControlAbort.abort();
      }
      routeContextControlAbort = new AbortController();
      const { signal } = routeContextControlAbort;
      const levelRange = root.querySelector('#routeLevelRange');
      const levelInput = root.querySelector('#routeLevelInput');
      const timeInput = root.querySelector('#routeTimeInput');
      const goalWrap = root.querySelector('.route-context__goals');
      const toggleButtons = root.querySelectorAll('.route-context__toggle');
      const resourceSelect = root.querySelector('#routeResourceSelect');
      const resourceQty = root.querySelector('#routeResourceQty');
      const resourceAdd = root.querySelector('[data-action="add-resource-gap"]');
      const resourceList = root.querySelector('#routeResourceList');

      if(levelRange){
        if(levelRange.dataset.empty === 'true'){ levelRange.value = '1'; }
        levelRange.addEventListener('input', () => {
          if(levelInput){
            levelInput.value = levelRange.dataset.empty === 'true' ? '' : levelRange.value;
          }
        }, { signal });
        levelRange.addEventListener('change', () => {
          levelRange.dataset.empty = 'false';
          updateRouteContextState({ declaredLevel: Number(levelRange.value) });
        }, { signal });
      }
      if(levelInput){
        levelInput.addEventListener('change', () => {
          const raw = levelInput.value;
          updateRouteContextState({ declaredLevel: raw === '' ? null : Number(raw) });
        }, { signal });
      }
      toggleButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          const key = btn.dataset.contextToggle;
          if(!key) return;
          const updated = { ...routeContext, [key]: !routeContext[key] };
          updateRouteContextState(updated);
        }, { signal });
      });
      if(timeInput){
        timeInput.addEventListener('change', () => {
          const raw = timeInput.value;
          updateRouteContextState({ availableTimeMinutes: raw === '' ? null : Number(raw) });
        }, { signal });
      }
      if(goalWrap){
        goalWrap.addEventListener('click', event => {
          const btn = event.target.closest('[data-context-goal]');
          if(!btn) return;
          const goal = btn.dataset.contextGoal;
          const next = new Set(routeContext.goals);
          if(next.has(goal)) next.delete(goal); else next.add(goal);
          updateRouteContextState({ goals: Array.from(next) });
        }, { signal });
      }
      if(resourceAdd){
        resourceAdd.addEventListener('click', () => {
          const itemId = resourceSelect ? resourceSelect.value : '';
          if(!itemId) return;
          const qty = resourceQty && resourceQty.value !== '' ? Number(resourceQty.value) : null;
          const next = routeContext.resourceGaps.slice();
          const existing = next.find(entry => entry.item_id === itemId);
          if(existing){
            existing.qty = qty;
          } else {
            next.push({ item_id: itemId, qty });
          }
          updateRouteContextState({ resourceGaps: next });
        }, { signal });
      }
      if(resourceList){
        resourceList.addEventListener('click', event => {
          const chip = event.target.closest('.route-resource-chip');
          if(!chip) return;
          const itemId = chip.dataset.resourceId;
          const next = routeContext.resourceGaps.filter(entry => entry.item_id !== itemId);
          updateRouteContextState({ resourceGaps: next });
        }, { signal });
      }
    }

    function updateRouteContextState(updates){
      routeContext = normalizeRouteContext({ ...routeContext, ...(updates || {}) });
      saveRouteContext(routeContext);
      renderRouteGuide();
    }

    function findFirstIncompleteStepForRoute(route, { includeOptional = false } = {}){
      if(!route) return null;
      const steps = Array.isArray(route?.chapter?.steps) ? route.chapter.steps : [];
      for(const step of steps){
        if(step.optional && !includeOptional) continue;
        if(!routeState[step.id]){
          return step;
        }
      }
      if(includeOptional){
        return steps.find(step => !routeState[step.id]) || null;
      }
      return null;
    }

    function formatTimeLabel(time){
      if(!time) return '';
      const solo = time.solo;
      const coop = time.coop;
      if(solo && coop) return `${solo}m solo / ${coop}m co-op`;
      if(solo) return `${solo}m solo`;
      if(coop) return `${coop}m co-op`;
      return '';
    }

    function formatRecommendationText(template, values = {}){
      if(!template) return '';
      return template.replace(/\{(\w+)\}/g, (match, key) => {
        const replacement = values[key];
        return replacement != null ? String(replacement) : match;
      });
    }

    function computeRouteRecommendations(guide, context, levelEstimate){
      const routes = Array.isArray(guide?.routes) ? guide.routes : [];
      if(!routes.length) return [];
      const weights = { ...DEFAULT_RECOMMENDER_WEIGHTS, ...(guide?.recommender?.scoring_signals || {}) };
      const templates = guide?.recommender?.explanation_templates || {};
      const completedRoutes = new Set(routes.filter(route => isRouteComplete(route)).map(route => route.id));
      const resourceMap = new Map();
      (context?.resourceGaps || []).forEach(entry => {
        if(entry && entry.item_id){
          resourceMap.set(entry.item_id, entry.qty != null ? Number(entry.qty) : null);
        }
      });
      const availableTime = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null;
      const playerLevel = context?.declaredLevel != null ? Number(context.declaredLevel) : (levelEstimate?.level ?? null);
      const goalSet = new Set((context?.goals || []).map(goal => String(goal || '').toLowerCase()));
      const results = [];
      routes.forEach(route => {
        const unmetRoutes = (route?.prerequisites?.routes || []).filter(id => !completedRoutes.has(id));
        if(unmetRoutes.length) return;
        const reasons = [];
        let score = 0;
        if(weights.prerequisites_met){
          score += weights.prerequisites_met;
          if(templates.prerequisites_met){
            reasons.push(formatRecommendationText(templates.prerequisites_met));
          }
        }
        const range = route?.recommended_level || {};
        if(playerLevel != null && (range.min != null || range.max != null)){
          if(range.min != null && range.max != null && playerLevel >= range.min && playerLevel <= range.max){
            score += weights.level_fit || 0;
            if(templates.level_fit){
              reasons.push(formatRecommendationText(templates.level_fit, { level: playerLevel, min: range.min, max: range.max }));
            }
          } else if(range.min != null && playerLevel < range.min){
            score -= (weights.level_fit || 0) / 2;
            if(route?.adaptive_guidance?.underleveled){
              reasons.push(formatRecommendationText(templates.adaptive_guidance, { recommendation: route.adaptive_guidance.underleveled }));
            }
          } else if(range.max != null && playerLevel > range.max){
            score -= (weights.level_fit || 0) / 2;
            if(route?.adaptive_guidance?.overleveled){
              reasons.push(formatRecommendationText(templates.adaptive_guidance, { recommendation: route.adaptive_guidance.overleveled }));
            }
          }
        }
        if(Array.isArray(route?.yields?.key_unlocks) && route.yields.key_unlocks.length){
          score += weights.unlock_value || 0;
          const unlockList = route.yields.key_unlocks.map(niceName).join(', ');
          if(templates.unlock_value){
            reasons.push(formatRecommendationText(templates.unlock_value, { unlocks: unlockList }));
          } else {
            reasons.push(kidMode ? `Unlocks ${unlockList}.` : `Unlocks: ${unlockList}`);
          }
        }
        if(availableTime != null){
          const desired = context.coop ? route?.estimated_time_minutes?.coop : route?.estimated_time_minutes?.solo;
          const fallback = context.coop ? route?.estimated_time_minutes?.solo : route?.estimated_time_minutes?.coop;
          const timeValue = desired != null ? desired : fallback;
          if(timeValue != null){
            if(timeValue <= availableTime){
              score += weights.time_to_power_ratio || 0;
            } else {
              score -= (weights.time_to_power_ratio || 0) / 2;
            }
          }
        }
        if(route?.progression_role){
          score += (weights.progression_role || 0) * (route.progression_role === 'core' ? 1 : 0.5);
          if(templates.progression_role){
            reasons.push(formatRecommendationText(templates.progression_role, { role: capitalize(route.progression_role) }));
          }
        }
        if(context.coop && route?.modes?.coop){
          score += weights.coop_synergy || 0;
        } else if(context.coop && route?.modes && route.modes.coop === false){
          score -= (weights.coop_synergy || 0) / 2;
        }
        if(context.hardcore){
          if(route?.risk_profile === 'high'){
            score -= weights.risk_vs_mode || 0;
          } else if(route?.risk_profile === 'low'){
            score += (weights.risk_vs_mode || 0) / 2;
          }
        }
        const normalizedTags = Array.isArray(route?.tags) ? route.tags.map(tag => String(tag || '').toLowerCase()) : [];
        const overlapTags = normalizedTags.filter(tag => goalSet.has(tag));
        if(overlapTags.length){
          const label = overlapTags.map(capitalize).join(', ');
          score += weights.tag_alignment || 0;
          reasons.push(kidMode ? `Goal match: ${label}` : `Goal focus: ${overlapTags.join(', ')}`);
        }
        const objectives = Array.isArray(route?.objectives) ? route.objectives.map(obj => String(obj || '').toLowerCase()) : [];
        const objectiveMatches = goalSet.size ? objectives.filter(obj => Array.from(goalSet).some(goal => obj.includes(goal))) : [];
        if(objectiveMatches.length){
          score += weights.goal_objective_alignment || 0;
          const display = objectiveMatches.slice(0, 2).map(niceName);
          reasons.push(kidMode ? `Matches goals: ${display.join(', ')}` : `Objectives align with: ${display.join(', ')}`);
        }
        if(goalSet.size && !overlapTags.length){
          const titleLower = (route.title || '').toLowerCase();
          const keywordMatch = Array.from(goalSet).find(goal => titleLower.includes(goal));
          if(keywordMatch){
            score += weights.context_goal_keyword || 0;
            reasons.push(kidMode ? `Focuses on ${capitalize(keywordMatch)}.` : `Title includes ${keywordMatch}.`);
          }
        }
        const normalizedCategory = (route?.category || '').toLowerCase();
        const isTowerRoute = normalizedCategory.includes('tower') || normalizedCategory.includes('boss') || normalizedTags.some(tag => tag.includes('tower') || tag.includes('boss'));
        const towerGoal = goalSet.has('tower') || goalSet.has('boss');
        if(isTowerRoute && towerGoal){
          score += weights.tower_alignment || 0;
          reasons.push(kidMode ? 'Perfect for tower showdowns.' : 'Aligns with your tower/boss focus.');
        }
        if(!completedRoutes.has(route.id)){
          score += weights.novelty || 0;
        } else {
          score -= (weights.novelty || 0) / 2;
        }
        const breakdown = routeProgressBreakdown(route);
        if(breakdown.requiredDone > 0 && breakdown.requiredDone < breakdown.requiredTotal){
          score += weights.progress_momentum || 0;
          reasons.push(kidMode ? 'You already started this route—keep going!' : 'Momentum bonus: you have partial progress here.');
        }
        const remainingRequired = breakdown.requiredTotal - breakdown.requiredDone;
        if(breakdown.requiredTotal && remainingRequired > 0 && remainingRequired <= 2){
          score += weights.closeout_bonus || 0;
          reasons.push(kidMode ? 'Only a couple big steps left!' : 'Close to completion — only a few required steps remain.');
        }
        if(breakdown.totalDone > 0 && !completedRoutes.has(route.id)){
          score += weights.returning_focus || 0;
          reasons.push(kidMode ? 'Let’s finish what you started.' : 'Finish the route you already began.');
        }
        const metrics = route?.metrics || {};
        const xpPerMinute = metrics.xp_per_minute;
        if(xpPerMinute && (xpPerMinute.solo || xpPerMinute.coop)){
          const values = [];
          if(xpPerMinute.solo) values.push(Number(xpPerMinute.solo));
          if(xpPerMinute.coop) values.push(Number(xpPerMinute.coop));
          const avg = values.length ? values.reduce((sum, val) => sum + (Number.isNaN(val) ? 0 : val), 0) / values.length : null;
          if(avg != null){
            score += weights.metric_efficiency || 0;
            if(templates.metric_efficiency){
              reasons.push(formatRecommendationText(templates.metric_efficiency, { xp_per_minute: avg.toFixed(1) }));
            } else {
              reasons.push(kidMode ? `Great XP: ${avg.toFixed(1)}/m.` : `XP efficiency: ${avg.toFixed(1)} per minute.`);
            }
          }
        }
        const resourceMatches = [];
        resourceMap.forEach((qty, itemId) => {
          if(route.resourceOutputs.includes(itemId)){
            resourceMatches.push({ itemId, qty });
          }
        });
        if(resourceMatches.length){
          score += weights.resource_relief || 0;
          if(templates.resource_need){
            resourceMatches.forEach(match => {
              reasons.push(formatRecommendationText(templates.resource_need, { item: niceName(match.itemId) }));
            });
          } else {
            const names = resourceMatches.map(match => niceName(match.itemId));
            reasons.push(kidMode ? `Helps gather ${names.join(', ')}.` : `Addresses shortages: ${names.join(', ')}`);
          }
          if(resourceMatches.some(match => match.qty != null && match.qty >= 20)){
            score += weights.resource_urgency || 0;
            reasons.push(kidMode ? 'Big resource refill.' : 'High priority resource shortage covered.');
          }
        }
        const dynamicHits = evaluateDynamicRules(route, context, levelEstimate, resourceMap);
        if(dynamicHits.length){
          score += weights.dynamic_alignment || 0;
          dynamicHits.forEach(hit => {
            reasons.push(formatRecommendationText(templates.dynamic_alignment, { rule_adjustment: hit }));
          });
        }
        const futureRoutes = Array.isArray(route?.next_routes) ? route.next_routes.filter(id => !completedRoutes.has(id)) : [];
        if(futureRoutes.length){
          score += weights.synergy_next_routes || 0;
          reasons.push(kidMode ? 'Opens new adventures next.' : 'Sets up follow-up routes.');
        }
        const nextStep = findFirstIncompleteStepForRoute(route, { includeOptional: true });
        results.push({ route, score, reasons, nextStepId: nextStep ? nextStep.id : null });
      });
      return results.sort((a, b) => (b.score || 0) - (a.score || 0));
    }

    function evaluateDynamicRules(route, context, levelEstimate, resourceMap){
      const hits = [];
      const rules = route?.adaptive_guidance?.dynamic_rules;
      if(!Array.isArray(rules) || !rules.length) return hits;
      const level = context?.declaredLevel != null ? Number(context.declaredLevel) : (levelEstimate?.level ?? null);
      const timeBudget = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null;
      rules.forEach(rule => {
        if(!rule || !rule.signal) return;
        const scope = Array.isArray(rule.mode_scope) ? rule.mode_scope : [];
        if(scope.includes('hardcore') && !context.hardcore) return;
        if(scope.includes('solo') && context.coop) return;
        if(scope.includes('coop') && !context.coop) return;
        let triggered = false;
        if(rule.signal.startsWith('level_gap')){
          if(level == null) return;
          const recommended = route?.recommended_level || {};
          if(rule.signal.includes('over')){
            if(recommended.max != null && level >= recommended.max + 2){
              triggered = true;
            }
          } else if(rule.signal.includes('under')){
            if(recommended.min != null && level <= recommended.min - 2){
              triggered = true;
            }
          }
        } else if(rule.signal === 'time_budget_short'){
          if(timeBudget != null && timeBudget < 30){
            triggered = true;
          }
        } else if(rule.signal.startsWith('resource_gap:')){
          const itemId = rule.signal.split(':')[1];
          if(itemId && resourceMap.has(itemId)){
            triggered = true;
          }
        } else if(rule.signal.startsWith('mode:hardcore')){
          if(context.hardcore) triggered = true;
        }
        if(triggered && rule.adjustment){
          hits.push(rule.adjustment);
        }
      });
      return hits;
    }

    function estimatePlayerLevel(context = routeContext){
      if(!routeGuideData) return { level: null, totalXp: 0, confidence: 0 };
      const estimator = routeGuideData.levelEstimator || {};
      const xpThresholds = Array.isArray(routeGuideData?.xp?.xp_thresholds) ? routeGuideData.xp.xp_thresholds : [];
      const fallbackRanges = estimator.per_step_xp_ranges || {};
      const metricUsage = estimator.metric_usage || {};
      let totalXp = 0;
      let stepsWithXp = 0;
      let completedSteps = 0;
      routeGuideData.routes.forEach(route => {
        const rawSteps = Array.isArray(route?.steps) ? route.steps : [];
        let routeXp = 0;
        let routeCompleted = true;
        rawSteps.forEach(step => {
          const stepId = step?.step_id || step?.id;
          if(!stepId) return;
          if(!routeState[stepId]){
            routeCompleted = false;
            return;
          }
          completedSteps += 1;
          let xpMin = step?.xp_award_estimate?.min;
          let xpMax = step?.xp_award_estimate?.max;
          if((xpMin == null || xpMax == null) && step?.type){
            const fallback = fallbackRanges[step.type];
            if(fallback){
              if(xpMin == null) xpMin = fallback.min;
              if(xpMax == null) xpMax = fallback.max;
            }
          }
          if(xpMin != null || xpMax != null){
            const minVal = xpMin != null ? Number(xpMin) : Number(xpMax);
            const maxVal = xpMax != null ? Number(xpMax) : Number(xpMin);
            const median = (Number(minVal) + Number(maxVal)) / 2;
            if(!Number.isNaN(median)){
              totalXp += median;
              routeXp += median;
              stepsWithXp += 1;
            }
          }
          const isBoss = step?.type === 'fight' || (Array.isArray(step?.targets) && step.targets.some(target => target?.kind === 'boss'));
          if(isBoss){
            totalXp += 500;
            routeXp += 500;
          }
        });
        if(routeCompleted && context?.hardcore){
          totalXp += routeXp * 0.1;
        }
        const metrics = route?.metrics || {};
        const xpPerMinute = metrics.xp_per_minute;
        if(xpPerMinute && (xpPerMinute.solo || xpPerMinute.coop)){
          const values = [];
          if(xpPerMinute.solo) values.push(Number(xpPerMinute.solo));
          if(xpPerMinute.coop) values.push(Number(xpPerMinute.coop));
          const avg = values.length ? values.reduce((sum, val) => sum + (Number.isNaN(val) ? 0 : val), 0) / values.length : null;
          if(avg != null){
            totalXp += avg * (metricUsage.xp_per_minute_weight || 0);
          }
        }
        if(metrics.travel_distance_m){
          const travel = Number(metrics.travel_distance_m);
          if(!Number.isNaN(travel)){
            totalXp += travel * (metricUsage.travel_distance_weight || 0);
          }
        }
        if(Array.isArray(metrics.consumable_cost)){
          const consumableTotal = metrics.consumable_cost.reduce((sum, entry) => {
            const qty = Number(entry?.qty);
            return sum + (Number.isNaN(qty) ? 0 : qty);
          }, 0);
          if(consumableTotal){
            totalXp += consumableTotal * (metricUsage.consumable_cost_weight || 0);
          }
        }
      });
      let level = null;
      if(xpThresholds.length){
        level = xpThresholds.reduce((acc, entry) => {
          if(entry && typeof entry.cumulative_xp === 'number' && totalXp >= entry.cumulative_xp){
            return entry.level != null ? entry.level : acc;
          }
          return acc;
        }, xpThresholds[0]?.level || 1);
      }
      if(level == null) level = 1;
      const confidenceBase = completedSteps ? stepsWithXp / completedSteps : 0;
      const confidence = Math.max(0, Math.min(1, confidenceBase + 0.1));
      return { level, totalXp, confidence };
    }

    function normalizeRouteContext(context){
      const base = { ...DEFAULT_ROUTE_CONTEXT, ...(context || {}) };
      base.declaredLevel = base.declaredLevel != null && base.declaredLevel !== '' ? clampNumber(base.declaredLevel, 1, 50) : null;
      base.availableTimeMinutes = base.availableTimeMinutes != null && base.availableTimeMinutes !== '' ? clampNumber(base.availableTimeMinutes, 5, 480) : null;
      base.hardcore = !!base.hardcore;
      base.coop = !!base.coop;
      base.goals = Array.from(new Set((Array.isArray(base.goals) ? base.goals : []).map(value => value == null ? '' : String(value).trim()))).filter(Boolean);
      base.resourceGaps = Array.isArray(base.resourceGaps)
        ? base.resourceGaps.map(entry => {
            const itemId = entry?.item_id || entry?.itemId || '';
            if(!itemId) return null;
            const qty = entry?.qty != null ? clampNumber(entry.qty, 1, 999) : null;
            return { item_id: itemId, qty };
          }).filter(Boolean)
        : [];
      return base;
    }

    function clampNumber(value, min, max){
      const num = Number(value);
      if(Number.isNaN(num)) return null;
      if(min != null && num < min) return min;
      if(max != null && num > max) return max;
      return num;
    }
    function queueRouteFocus(stepId){
      if(!stepId){
        pendingRouteFocus = null;
        return;
      }
      pendingRouteFocus = stepId;
      setTimeout(applyQueuedRouteFocus, 0);
    }

    function applyQueuedRouteFocus(){
      if(!pendingRouteFocus) return;
      const routePage = document.getElementById('routePage');
      if(!routePage) return;
      const stepId = pendingRouteFocus;
      const target = routePage.querySelector(`input[data-step="${stepId}"]`);
      if(!target){
        let revealed = false;
        if(ensureRouteOptionalVisible(stepId)){
          revealed = true;
        }
        if(ensureRouteCategoryVisible(stepId)){
          revealed = true;
        }
        if(revealed){
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          updateRouteOverviewUI();
          requestAnimationFrame(applyQueuedRouteFocus);
        }
        return;
      }
      pendingRouteFocus = null;
      requestAnimationFrame(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const label = target.closest('.step');
        if(label) pulse(label);
        if(typeof target.focus === 'function'){
          try {
            target.focus({ preventScroll: true });
          } catch (err) {
            target.focus();
          }
        }
      });
    }

    function ensureRouteOptionalVisible(stepId){
      if(!routeHideOptional || !stepId || !routeGuideData) return false;
      const chapters = Array.isArray(routeGuideData.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const step = steps.find(entry => entry && entry.id === stepId);
        if(step && step.optional){
          routeHideOptional = false;
          updateRouteToggleButtons();
          persistRoutePreferences();
          return true;
        }
      }
      return false;
    }

    function ensureRouteCategoryVisible(stepId){
      if(!stepId || !routeGuideData) return false;
      const chapters = Array.isArray(routeGuideData.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const step = steps.find(entry => entry && entry.id === stepId);
        if(step){
          const slug = routeCategorySlug(step.category);
          if(routeHiddenCategories.has(slug)){
            routeHiddenCategories.delete(slug);
            persistRoutePreferences();
            return true;
          }
          break;
        }
      }
      return false;
    }

    function renderChapterCard(chapter, openByDefault, route){
      const section = document.createElement('section');
      section.className = 'card route-card';
      section.id = `chapter-${chapter.id}`;
      section.dataset.chapterId = chapter.id;
      section.innerHTML = buildRouteCardInnerHTML(chapter, openByDefault, route);
      return section;
    }

    function buildRouteCardInnerHTML(chapter, openByDefault, route){
      const progress = chapterProgress(chapter);
      const meta = renderRouteMeta(route);
      const why = routeChapterWhy(chapter);
      const completeLabel = progress.requiredDone
        ? `<span class="route-card__complete">✅ ${escapeHTML(kidMode ? 'Route complete' : 'Chapter complete')}</span>`
        : '';
      return `
        <div class="route-card__header">
          <div class="route-card__title">
            <h3>${escapeHTML(routeChapterTitle(chapter))}</h3>
            ${why ? `<p class="route-card__why">${escapeHTML(why)}</p>` : ''}
            ${meta}
          </div>
          <div class="route-card__progress">${renderProgress(progress)}</div>
        </div>
        <details class="route-card__details"${openByDefault ? ' open' : ''}>
          <summary class="btn route-card__toggle">${escapeHTML(kidMode ? 'Show steps' : 'Open steps')}</summary>
          ${renderSteps(chapter, route)}
          <div class="route-card__actions">
            <button class="btn" data-action="markRequired" data-ch="${chapter.id}">${escapeHTML(kidMode ? 'Mark big steps complete' : 'Mark Required Complete')}</button>
            <button class="btn" data-action="resetChapter" data-ch="${chapter.id}">${escapeHTML(kidMode ? 'Reset route' : 'Reset Chapter')}</button>
            ${completeLabel}
          </div>
        </details>
      `;
    }

    function rerenderChapter(chapter){
      const node = document.querySelector(`#chapter-${chapter.id}`);
      if(!node) return;
      const details = node.querySelector('.route-card__details');
      const wasOpen = details ? details.open : false;
      const route = routeGuideData?.routeLookup?.[chapter.id] || null;
      node.innerHTML = buildRouteCardInnerHTML(chapter, wasOpen, route);
    }


    function renderRouteMeta(route){
      if(!route) return '';
      const parts = [];
      if(route.category){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(capitalize(route.category))}</span>`);
      }
      const level = route.recommended_level || {};
      if(level.min != null || level.max != null){
        parts.push(`<span class="chip route-meta-chip">Lv ${escapeHTML(level.min != null ? String(level.min) : '?')}-${escapeHTML(level.max != null ? String(level.max) : '?')}</span>`);
      }
      if(route.risk_profile){
        parts.push(`<span class="chip route-meta-chip route-meta-chip--${escapeHTML(route.risk_profile)}">${escapeHTML(capitalize(route.risk_profile))} risk</span>`);
      }
      const timeLabel = formatTimeLabel(route.estimated_time_minutes);
      if(timeLabel){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(timeLabel)}</span>`);
      }
      const xpGain = route.estimated_xp_gain || {};
      if(xpGain.min != null || xpGain.max != null){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(`${xpGain.min != null ? xpGain.min : '?'}-${xpGain.max != null ? xpGain.max : '?'} XP`)}</span>`);
      }
      if(Array.isArray(route.tags) && route.tags.length){
        const tagHtml = route.tags.map(tag => `<span class="chip route-meta-chip route-meta-chip--tag">${escapeHTML(tag)}</span>`).join('');
        parts.push(`<span class="route-meta-tags">${tagHtml}</span>`);
      }
      return parts.length ? `<div class="route-card__meta">${parts.join('')}</div>` : '';
    }

    function renderStepDetail(step, route){
      const raw = step?.raw || findRawStep(route, step.id);
      if(!raw) return '';
      const blocks = [];
      const description = raw.detail && raw.detail !== raw.summary ? raw.detail : (raw.detail || raw.summary || '');
      if(description){
        blocks.push(`<p class="step-extra__text">${escapeHTML(description)}</p>`);
      }
      if(Array.isArray(raw.locations) && raw.locations.length){
        blocks.push(renderStepLocations(raw.locations));
      }
      if(raw.recommended_loadout && (Array.isArray(raw.recommended_loadout.gear) && raw.recommended_loadout.gear.length || Array.isArray(raw.recommended_loadout.pals) && raw.recommended_loadout.pals.length || Array.isArray(raw.recommended_loadout.consumables) && raw.recommended_loadout.consumables.length)){
        blocks.push(renderStepLoadout(raw.recommended_loadout));
      }
      if(raw.mode_adjustments && (raw.mode_adjustments.hardcore || raw.mode_adjustments.coop)){
        blocks.push(renderStepModeAdjustments(raw.mode_adjustments));
      }
      if(raw.outputs){
        const outputBlock = renderStepOutputs(raw.outputs);
        if(outputBlock) blocks.push(outputBlock);
      }
      if(Array.isArray(raw.branching) && raw.branching.length){
        const branchList = raw.branching.map(entry => {
          const condition = entry?.condition ? entry.condition : '';
          const action = entry?.action ? ` → ${entry.action}` : '';
          const subroute = entry?.subroute_ref ? ` (${entry.subroute_ref})` : '';
          return `<li>${escapeHTML(condition)}${escapeHTML(action)}${escapeHTML(subroute)}</li>`;
        }).join('');
        blocks.push(`<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'If you need' : 'Branching')}</h5><ul class="step-extra__list">${branchList}</ul></div>`);
      }
      if(raw.xp_award_estimate && (raw.xp_award_estimate.min != null || raw.xp_award_estimate.max != null)){
        blocks.push(`<p class="step-extra__xp">${escapeHTML(`XP estimate: ${raw.xp_award_estimate.min != null ? raw.xp_award_estimate.min : '?'}-${raw.xp_award_estimate.max != null ? raw.xp_award_estimate.max : '?'}`)}</p>`);
      }
      return blocks.length ? `<div class="step-extra">${blocks.join('')}</div>` : '';
    }

    function renderStepLocations(locations){
      if(!Array.isArray(locations) || !locations.length) return '';
      const entries = locations.map(loc => {
        const parts = [];
        if(loc.region_id) parts.push(niceName(loc.region_id));
        if(Array.isArray(loc.coords) && loc.coords.length === 2){
          parts.push(`(${loc.coords[0]}, ${loc.coords[1]})`);
        }
        if(loc.time && loc.time !== 'any') parts.push(`Time: ${loc.time}`);
        if(loc.weather && loc.weather !== 'any') parts.push(`Weather: ${loc.weather}`);
        return `<li>${escapeHTML(parts.join(' • '))}</li>`;
      }).join('');
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'Where to go' : 'Locations')}</h5><ul class="step-extra__list">${entries}</ul></div>`;
    }

    function renderStepLoadout(loadout){
      const rows = [];
      if(Array.isArray(loadout.gear) && loadout.gear.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Gear' : 'Gear')}:</strong> ${escapeHTML(loadout.gear.map(niceName).join(', '))}</li>`);
      }
      if(Array.isArray(loadout.pals) && loadout.pals.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Pals' : 'Pals')}:</strong> ${escapeHTML(loadout.pals.map(niceName).join(', '))}</li>`);
      }
      if(Array.isArray(loadout.consumables) && loadout.consumables.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Items' : 'Consumables')}:</strong> ${escapeHTML(loadout.consumables.map(entry => `${entry?.qty != null ? `${entry.qty}× ` : ''}${niceName(entry?.item_id || entry?.itemId || '')}`).join(', '))}</li>`);
      }
      if(!rows.length) return '';
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'Bring this' : 'Recommended loadout')}</h5><ul class="step-extra__list">${rows.join('')}</ul></div>`;
    }

    function renderStepModeAdjustments(adjustments){
      const sections = [];
      if(adjustments.hardcore){
        const tactics = adjustments.hardcore.tactics ? `<p>${escapeHTML(adjustments.hardcore.tactics)}</p>` : '';
        const items = Array.isArray(adjustments.hardcore.safety_buffer_items) && adjustments.hardcore.safety_buffer_items.length
          ? `<ul class="step-extra__list">${adjustments.hardcore.safety_buffer_items.map(item => `<li>${escapeHTML(`${item.qty != null ? `${item.qty}× ` : ''}${niceName(item.item_id || item.itemId || '')}`)}</li>`).join('')}</ul>`
          : '';
        sections.push(`<div class="step-mode__entry"><h6>${escapeHTML(kidMode ? 'Hardcore tip' : 'Hardcore')}</h6>${tactics}${items}</div>`);
      }
      if(adjustments.coop){
        const roles = Array.isArray(adjustments.coop.role_splits) && adjustments.coop.role_splits.length
          ? `<ul class="step-extra__list">${adjustments.coop.role_splits.map(role => `<li><strong>${escapeHTML(capitalize(role.role || 'Role'))}:</strong> ${escapeHTML(role.tasks || '')}</li>`).join('')}</ul>`
          : '';
        const loot = adjustments.coop.loot_rules ? `<p>${escapeHTML(adjustments.coop.loot_rules)}</p>` : '';
        sections.push(`<div class="step-mode__entry"><h6>${escapeHTML(kidMode ? 'Play together' : 'Co-Op')}</h6>${roles}${loot}</div>`);
      }
      if(!sections.length) return '';
      return `<div class="step-extra__section step-mode"><h5>${escapeHTML(kidMode ? 'Mode tweaks' : 'Mode adjustments')}</h5>${sections.join('')}</div>`;
    }

    function renderStepOutputs(outputs){
      const parts = [];
      if(Array.isArray(outputs.items) && outputs.items.length){
        parts.push(`${escapeHTML(kidMode ? 'Items' : 'Items')}: ${outputs.items.map(item => `${item.qty != null ? `${item.qty}× ` : ''}${niceName(item.item_id || item.itemId || '')}`).join(', ')}`);
      }
      if(Array.isArray(outputs.pals) && outputs.pals.length){
        parts.push(`${escapeHTML(kidMode ? 'Pals' : 'Pals')}: ${outputs.pals.map(niceName).join(', ')}`);
      }
      const unlocks = outputs.unlocks || {};
      if(Array.isArray(unlocks.tech) && unlocks.tech.length){
        parts.push(`${escapeHTML(kidMode ? 'Unlocks' : 'Unlocks')}: ${unlocks.tech.map(niceName).join(', ')}`);
      }
      if(Array.isArray(unlocks.stations) && unlocks.stations.length){
        parts.push(`${escapeHTML(kidMode ? 'Stations' : 'Stations')}: ${unlocks.stations.map(niceName).join(', ')}`);
      }
      if(!parts.length) return '';
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'You get' : 'Outputs')}</h5><ul class="step-extra__list">${parts.map(line => `<li>${escapeHTML(line)}</li>`).join('')}</ul></div>`;
    }

    function findRawStep(route, stepId){
      if(!route) return null;
      const rawSteps = Array.isArray(route?.steps) ? route.steps : [];
      return rawSteps.find(entry => entry?.step_id === stepId) || null;
    }

    function isRouteComplete(route){
      if(!route) return false;
      const steps = Array.isArray(route?.chapter?.steps) ? route.chapter.steps : [];
      if(!steps.length) return false;
      const requiredSteps = steps.filter(step => !step.optional);
      const targetSteps = requiredSteps.length ? requiredSteps : steps;
      return targetSteps.every(step => routeState[step.id]);
    }
    async function handleRouteCheckboxChange(event){
      const target = event.target;
      if(!target.matches('input[type="checkbox"][data-step]')) return;
      const stepId = target.dataset.step;
      const isChecked = target.checked;
      const container = target.closest('[data-chapter-id]');
      let chapter = null;
      let step = null;
      let chapterId = container ? container.dataset.chapterId : '';
      if(!chapterId){
        const legacySection = target.closest('section.card');
        if(legacySection){
          chapterId = legacySection.dataset.chapterId || legacySection.id.replace('chapter-','');
        }
      }
      if(chapterId){
        chapter = (routeGuideData?.chapters || []).find(ch => ch.id === chapterId) || null;
        if(chapter){
          step = (chapter.steps || []).find(s => s.id === stepId) || null;
        }
      }
      if(isChecked && step){
        const options = buildStepProgressOptions(step);
        if(options.length > 1){
          const selection = await showStepChoiceDialog(step, options);
          if(selection === null){
            target.checked = false;
            return;
          }
          applyStepProgressSelection(options, selection);
        } else if(options.length === 1){
          applyStepProgressSelection(options, [options[0].key]);
        }
      }
      routeState[stepId] = isChecked;
      syncRouteCompletionMetadata();
      saveRouteState(routeState);
      if(chapter){
        rerenderChapter(chapter);
      }
      refreshRouteIntelligenceUI();
      updateProgressUI();
    }

    function handleRouteClick(event){
      const link = event.target.closest('[data-link]');
      if(link){
        const payload = JSON.parse(link.dataset.link);
        navigateLink(payload);
        event.preventDefault();
        return;
      }
      const btn = event.target.closest('button[data-action]');
      if(!btn) return;
      const chapterId = btn.dataset.ch;
      const chapter = (routeGuideData?.chapters || []).find(ch => ch.id === chapterId);
      if(!chapter) return;
      if(btn.dataset.action === 'markRequired'){
        chapter.steps.filter(step => !step.optional).forEach(step => {
          routeState[step.id] = true;
          const options = buildStepProgressOptions(step);
          if(options.length === 1){
            applyStepProgressSelection(options, [options[0].key]);
          }
        });
        syncRouteCompletionMetadata();
        saveRouteState(routeState);
        rerenderChapter(chapter);
        refreshRouteIntelligenceUI();
        updateProgressUI();
      } else if(btn.dataset.action === 'resetChapter'){
        chapter.steps.forEach(step => {
          delete routeState[step.id];
        });
        syncRouteCompletionMetadata();
        saveRouteState(routeState);
        rerenderChapter(chapter);
        refreshRouteIntelligenceUI();
        updateProgressUI();
      }
    }

    function renderSteps(chapter, route){
      const fragments = [];
      const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
      steps.forEach(step => {
        if(routeHideOptional && step.optional) return;
        const category = step.category || 'Task';
        const categorySlug = routeCategorySlug(category);
        if(routeHiddenCategories.has(categorySlug)) return;
        const checked = !!routeState[step.id];
        const optionalHint = step.optional ? ` <em>(${escapeHTML(kidMode ? 'Bonus' : 'Optional')})</em>` : '';
        const detailHtml = renderStepDetail(step, route);
        fragments.push(`
          <label class="step ${step.optional ? 'optional' : ''}">
            <input type="checkbox" data-step="${step.id}" ${checked ? 'checked' : ''} />
            <span class="step-meta">
              <span class="step-category step-category--${categorySlug}">${escapeHTML(category)}</span>
              <span class="step-text">${escapeHTML(routeStepText(step))}${optionalHint}</span>
              ${detailHtml}
            </span>
            ${renderLinks(step.links || [])}
          </label>
        `);
      });
      if(!fragments.length){
        return '<p class="route-steps-empty">' + escapeHTML(kidMode ? 'All steps hidden by filters.' : 'All steps hidden by filters.') + '</p>';
      }
      return `<div class="step-list">${fragments.join('')}</div>`;
    }

    function renderRouteFiltersUI(categories){
      const containers = document.querySelectorAll('[data-route-role="filters"]');
      if(!containers.length) return;
      const headingLabel = kidMode ? 'Step types:' : 'Step categories:';
      const showAllLabel = kidMode ? 'Show every step type' : 'Show all categories';
      containers.forEach(container => {
        if(!Array.isArray(categories) || !categories.length){
          container.innerHTML = `<p class="route-filters__empty">${kidMode ? 'Step categories will appear once the guide loads.' : 'Step categories will appear once the guide loads.'}</p>`;
          return;
        }
        const chips = categories.map(cat => {
          const slug = cat.slug;
          const label = cat.label || niceName(slug);
          const total = cat.total || 0;
          const complete = cat.complete || 0;
          const active = !routeHiddenCategories.has(slug);
          const ariaLabel = `${label}: ${complete} of ${total} steps complete`;
          return `
            <button type="button" class="chip route-filter${active ? '' : ' route-filter--inactive'}" data-category="${slug}" aria-pressed="${active}" aria-label="${escapeHTML(ariaLabel)}">
              <span class="route-filter__label">${escapeHTML(label)}</span>
              <span class="route-filter__count">${complete}/${total}</span>
            </button>
          `;
        }).join('');
        const resetButton = routeHiddenCategories.size
          ? `<button type="button" class="home-progress-link route-filters__reset" data-action="route-filters-reset">${escapeHTML(showAllLabel)}</button>`
          : '';
        container.innerHTML = `
          <div class="route-filters__header">
            <span class="route-filters__label">${escapeHTML(headingLabel)}</span>
            ${resetButton}
          </div>
          <div class="route-filters__chips">
            ${chips}
          </div>
        `;
        if(!container.dataset.bound){
          container.addEventListener('click', handleRouteFilterClick);
          container.dataset.bound = 'true';
        }
      });
    }

    function renderBossRouteTimeline(){
      const timeline = document.getElementById('progressBossTimeline');
      if(!timeline) return;
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const bosses = [];
      chapters.forEach((chapter, index) => {
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const bossStep = steps.find(step => step && step.category === 'Boss');
        if(!bossStep) return;
        const towerLink = (bossStep.links || []).find(link => link && link.type === 'tower');
        bosses.push({
          order: index + 1,
          chapter,
          step: bossStep,
          map: towerLink && towerLink.map ? towerLink.map : null
        });
      });
      if(!bosses.length){
        timeline.innerHTML = '<p class="progress-route__empty">Boss route data loading…</p>';
        return;
      }
      let nextAssigned = false;
      const cards = bosses.map(entry => {
        const { order, chapter, step, map } = entry;
        const complete = !!routeState[step.id];
        let status = 'upcoming';
        if(complete){
          status = 'complete';
        } else if(!nextAssigned){
          status = 'next';
          nextAssigned = true;
        }
        const title = map?.label || map?.title || routeChapterTitle(chapter) || `Tower ${order}`;
        const weakness = extractBossWeakness(step);
        const region = map?.region || '';
        const metaParts = [];
        if(region) metaParts.push(region);
        if(weakness) metaParts.push(`${kidMode ? 'Weak to' : 'Weakness'}: ${weakness}`);
        const metaLine = metaParts.length ? metaParts.join(' • ') : '';
        const copySourceKid = Array.isArray(map?.kid) && map.kid.length ? map.kid[0] : (step.textKid || step.text || '');
        const copySourceGrown = Array.isArray(map?.grown) && map.grown.length ? map.grown[0] : (step.text || step.textKid || '');
        const copy = kidMode ? copySourceKid : copySourceGrown;
        const statusLabel = status === 'complete'
          ? (kidMode ? 'Complete' : 'Complete')
          : status === 'next'
            ? (kidMode ? 'Next up' : 'Next')
            : (kidMode ? 'Upcoming' : 'Planned');
        return `
          <article class="progress-route__boss progress-route__boss--${status}">
            <div class="progress-route__boss-head">
              <span class="progress-route__boss-index">Tower ${order}</span>
              <div class="progress-route__boss-body">
                <h4>${escapeHTML(title)}</h4>
                ${metaLine ? `<p>${escapeHTML(metaLine)}</p>` : ''}
              </div>
              <span class="progress-route__boss-status">${escapeHTML(statusLabel)}</span>
            </div>
            <p class="progress-route__boss-copy">${escapeHTML(copy)}</p>
          </article>
        `;
      }).join('');
      timeline.innerHTML = cards;
    }

    function extractBossWeakness(step){
      if(!step) return '';
      const adult = step.text || '';
      const match = adult.match(/\(weak to ([^)]+)\)/i);
      if(match && match[1]){
        return match[1].trim();
      }
      return '';
    }

    function handleRouteFilterClick(event){
      const reset = event.target.closest('[data-action="route-filters-reset"]');
      if(reset){
        if(routeHiddenCategories.size){
          routeHiddenCategories.clear();
          persistRoutePreferences();
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          updateRouteOverviewUI();
        }
        return;
      }
      const btn = event.target.closest('button[data-category]');
      if(!btn) return;
      const slug = btn.dataset.category;
      if(!slug) return;
      const isActive = btn.getAttribute('aria-pressed') !== 'false';
      if(isActive){
        routeHiddenCategories.add(slug);
      } else {
        routeHiddenCategories.delete(slug);
      }
      persistRoutePreferences();
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      chapters.forEach(ch => rerenderChapter(ch));
      updateRouteOverviewUI();
    }

    function buildStepProgressOptions(step){
      if(!step || !Array.isArray(step.links)) return [];
      const options = [];
      const seen = new Set();
      step.links.forEach(link => {
        if(!link || !link.type) return;
        if(link.type === 'pal'){
          const palId = resolvePalIdFromLink(link);
          if(palId !== undefined && palId !== null){
            const key = `pal:${palId}`;
            if(!seen.has(key)){
              seen.add(key);
              const pal = PALS[palId];
              const labelSource = link.name || link.slug || link.id;
              options.push({
                key,
                type: 'pal',
                palId,
                label: pal ? pal.name : (labelSource ? niceName(labelSource) : 'Pal'),
                selected: !!caught[palId]
              });
            }
          }
        } else if(link.type === 'tech'){
          const techInfo = resolveTechFromLink(link);
          if(techInfo && techInfo.item){
            const key = `tech:${techInfo.slug}`;
            if(!seen.has(key)){
              seen.add(key);
              const rawName = techInfo.item.name || link.name || link.id;
              const techName = rawName ? String(rawName) : '';
              const label = rawName ? String(rawName) : 'Tech';
              options.push({
                key,
                type: 'tech',
                slug: techInfo.slug,
                techName,
                label,
                selected: techName ? !!unlocked[techName] : false
              });
            }
          }
        }
      });
      return options;
    }

    function resolvePalIdFromLink(link){
      if(!link) return null;
      if(link.id && PALS[link.id]) return link.id;
      const candidates = [link.slug, link.id, link.name];
      for(const cand of candidates){
        if(!cand) continue;
        const slug = slugifyForPalworld(String(cand));
        if(slug && PAL_SLUG_TO_ID[slug]) return PAL_SLUG_TO_ID[slug];
        const byName = PAL_NAME_TO_ID[capitalize(String(cand))];
        if(byName) return byName;
      }
      return null;
    }

    function resolveTechFromLink(link){
      if(!link) return null;
      const identifiers = [link.id, link.slug, link.name];
      for(const ident of identifiers){
        if(!ident) continue;
        const slug = slugifyForPalworld(String(ident));
        if(slug && TECH_LOOKUP[slug]){
          return { ...TECH_LOOKUP[slug], slug };
        }
      }
      return null;
    }

    function applyStepProgressSelection(options, selectedKeys){
      if(!Array.isArray(options) || !options.length) return false;
      const selected = new Set(selectedKeys || []);
      let caughtChanged = false;
      let techChanged = false;
      options.forEach(option => {
        const isSelected = selected.has(option.key);
        if(option.type === 'pal' && option.palId !== undefined && option.palId !== null){
          const current = !!caught[option.palId];
          if(current !== isSelected){
            setPalCaught(option.palId, isSelected, { silent: true, skipAutoComplete: true, deferProgressUpdate: true });
            caughtChanged = true;
          }
        } else if(option.type === 'tech'){
          const techName = option.techName;
          if(techName){
            const current = !!unlocked[techName];
            if(current !== isSelected){
              setTechUnlocked(techName, isSelected, { techKey: option.slug, silent: true, skipAutoComplete: true, deferProgressUpdate: true });
              techChanged = true;
            } else if(option.slug){
              syncTechButtons(option.slug, techName);
            }
          } else if(option.slug){
            syncTechButtons(option.slug, techName);
          }
        }
      });
      return caughtChanged || techChanged;
    }

    function autoCompleteRouteStepsForPal(palId){
      if(palId === undefined || palId === null) return;
      autoCompleteRouteSteps({ type: 'pal', palId });
    }

    function autoCompleteRouteStepsForTech(rawKey, techName){
      const slugSource = rawKey || techName;
      if(!slugSource && !techName) return;
      const slug = slugifyForPalworld(slugSource || '');
      const name = typeof techName === 'string' ? techName.toLowerCase() : '';
      autoCompleteRouteSteps({ type: 'tech', slug, name });
    }

    function autoCompleteRouteSteps(change){
      if(!change) return;
      ensureRouteGuide()
        .then(guide => {
          const chapters = Array.isArray(guide?.chapters) ? guide.chapters : [];
          if(!chapters.length) return;
          routeState = loadRouteState();
          const rerenderIds = new Set();
          let stateChanged = false;

          chapters.forEach(chapter => {
            const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
            steps.forEach(step => {
              if(!step || !step.id) return;
              const options = buildStepProgressOptions(step);
              if(!Array.isArray(options) || !options.length) return;
              const matches = options.some(option => {
                if(change.type === 'pal'){
                  return option.type === 'pal' && option.palId === change.palId;
                }
                if(change.type === 'tech'){
                  if(option.type !== 'tech') return false;
                  const slugMatch = change.slug && option.slug === change.slug;
                  const nameMatch = change.name && option.techName && option.techName.toLowerCase() === change.name;
                  return slugMatch || nameMatch;
                }
                return false;
              });
              if(!matches) return;
              if(shouldAutoCompleteStep(step, options) && !routeState[step.id]){
                routeState[step.id] = true;
                stateChanged = true;
                rerenderIds.add(chapter.id);
              }
            });
          });

          if(stateChanged){
            saveRouteState(routeState);
            rerenderIds.forEach(id => {
              const chapter = chapters.find(ch => ch.id === id);
              if(chapter) rerenderChapter(chapter);
            });
            updateProgressUI();
          }
        })
        .catch(err => {
          console.error('Failed to auto-sync route progress', err);
        });
    }

    function shouldAutoCompleteStep(step, options){
      if(!step || !Array.isArray(options) || !options.length) return false;
      const relevant = options.filter(option => option.type === 'pal' || option.type === 'tech');
      if(!relevant.length) return false;
      const satisfiedCount = relevant.filter(optionIsComplete).length;
      if(satisfiedCount === 0) return false;
      if(stepRequiresAllOptions(step, relevant)){
        return satisfiedCount === relevant.length;
      }
      return true;
    }

    function stepRequiresAllOptions(step, options){
      if(!Array.isArray(options) || options.length <= 1) return true;
      const samples = [];
      if(typeof step.text === 'string') samples.push(step.text);
      if(typeof step.textKid === 'string') samples.push(step.textKid);
      if(typeof step.textAdult === 'string') samples.push(step.textAdult);
      const orPattern = /\b(or|either)\b/i;
      return !samples.some(sample => orPattern.test(sample));
    }

    function optionIsComplete(option){
      if(!option) return false;
      if(option.type === 'pal'){
        return option.palId !== undefined && option.palId !== null && !!caught[option.palId];
      }
      if(option.type === 'tech'){
        if(option.techName){
          const direct = unlocked[option.techName];
          if(direct) return true;
          const normalized = option.techName.toLowerCase();
          if(normalized){
            const match = Object.keys(unlocked || {}).some(key => {
              return unlocked[key] && typeof key === 'string' && key.toLowerCase() === normalized;
            });
            if(match) return true;
          }
        }
        if(option.slug){
          const entry = TECH_LOOKUP && TECH_LOOKUP[option.slug];
          const itemName = entry?.item?.name;
          if(itemName && unlocked[itemName]) return true;
        }
      }
      return false;
    }

    function showStepChoiceDialog(step, options){
      return new Promise(resolve => {
        if(!Array.isArray(options) || !options.length){
          resolve([]);
          return;
        }
        const overlay = document.createElement('div');
        overlay.className = 'progress-choice-backdrop';
        const dialog = document.createElement('div');
        dialog.className = 'progress-choice-dialog';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? 'Pick what you finished' : 'Track this step';
        dialog.appendChild(heading);
        if(step && step.text){
          const stepLine = document.createElement('p');
          stepLine.textContent = step.text;
          stepLine.style.fontStyle = 'italic';
          stepLine.style.color = 'var(--light)';
          dialog.appendChild(stepLine);
        }
        const desc = document.createElement('p');
        desc.textContent = kidMode
          ? 'Choose the pals or inventions you just completed. Uncheck anything you skipped.'
          : 'Select which pals or tech you completed. Uncheck anything you skipped.';
        dialog.appendChild(desc);
        const list = document.createElement('div');
        list.className = 'progress-choice-options';
        const checkboxes = [];
        options.forEach(option => {
          const row = document.createElement('label');
          row.className = 'progress-choice-option';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = option.key;
          input.checked = !!option.selected;
          row.appendChild(input);
          const text = document.createElement('span');
          text.textContent = option.label;
          row.appendChild(text);
          list.appendChild(row);
          checkboxes.push(input);
        });
        dialog.appendChild(list);
        if(options.length > 1){
          const helpers = document.createElement('div');
          helpers.className = 'progress-choice-helpers';
          const selectAllBtn = document.createElement('button');
          selectAllBtn.type = 'button';
          selectAllBtn.className = 'btn';
          selectAllBtn.textContent = kidMode ? 'Select everything' : 'Select all';
          selectAllBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = true;
            });
          });
          const clearBtn = document.createElement('button');
          clearBtn.type = 'button';
          clearBtn.className = 'btn';
          clearBtn.textContent = kidMode ? 'Clear choices' : 'Clear';
          clearBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = false;
            });
          });
          helpers.appendChild(selectAllBtn);
          helpers.appendChild(clearBtn);
          dialog.appendChild(helpers);
        }
        const actions = document.createElement('div');
        actions.className = 'progress-choice-actions';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'btn';
        cancelBtn.textContent = kidMode ? 'Go back' : 'Cancel';
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'btn';
        saveBtn.textContent = kidMode ? 'All done!' : 'Save choices';
        actions.appendChild(cancelBtn);
        actions.appendChild(saveBtn);
        dialog.appendChild(actions);
        overlay.appendChild(dialog);
        overlay.addEventListener('click', (ev) => {
          if(ev.target === overlay){
            cleanup(null);
          }
        });
        const cleanup = (result) => {
          overlay.remove();
          document.removeEventListener('keydown', onKeydown);
          resolve(result);
        };
        cancelBtn.addEventListener('click', () => cleanup(null));
        saveBtn.addEventListener('click', () => {
          const selectedValues = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
          cleanup(selectedValues);
        });
        const onKeydown = (ev) => {
          if(ev.key === 'Escape'){
            ev.preventDefault();
            cleanup(null);
          }
          if(ev.key === 'Enter' && ev.target && ev.target.tagName !== 'TEXTAREA'){
            ev.preventDefault();
            saveBtn.click();
          }
        };
        document.addEventListener('keydown', onKeydown);
        document.body.appendChild(overlay);
        setTimeout(() => {
          if(checkboxes.length){
            checkboxes[0].focus();
          } else {
            saveBtn.focus();
          }
        }, 0);
      });
    }

    function chapterProgress(chapter){
      const required = (chapter.steps || []).filter(step => !step.optional);
      const requiredChecked = required.filter(step => routeState[step.id]).length;
      return {
        requiredCount: required.length,
        requiredChecked,
        requiredDone: required.length > 0 && requiredChecked === required.length
      };
    }

    function renderProgress(progress){
      const pct = progress.requiredCount ? Math.round((progress.requiredChecked / progress.requiredCount) * 100) : 0;
      const label = kidMode
        ? `${progress.requiredChecked}/${progress.requiredCount} steps done (${pct}%)`
        : `${progress.requiredChecked}/${progress.requiredCount} required done (${pct}%)`;
      return `
        <div class="progress" aria-label="Chapter progress" style="display:grid;gap:6px">
          <div style="height:10px;border-radius:999px;background:#22314A;overflow:hidden">
            <div style="height:10px;width:${pct}%;background:var(--accent)"></div>
          </div>
          <div style="font-size:.9rem;color:var(--muted)">${label}</div>
        </div>
      `;
    }

    function calculateGuideProgressSummary(chaptersOverride){
      const chapters = Array.isArray(chaptersOverride)
        ? chaptersOverride
        : (Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : []);
      const routeLookup = routeGuideData?.routeLookup || {};
      let requiredTotal = 0;
      let requiredComplete = 0;
      let optionalTotal = 0;
      let optionalComplete = 0;
      let towersTotal = 0;
      let towersComplete = 0;
      const routesByRole = {
        core: { total: 0, complete: 0 },
        support: { total: 0, complete: 0 },
        optional: { total: 0, complete: 0 }
      };
      const categoryMap = new Map();
      chapters.forEach(chapter => {
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const route = routeLookup[chapter?.id];
        const role = normalizeRouteRole(route?.progression_role || route?.progression_role_raw);
        const roleKey = routesByRole[role] ? role : 'optional';
        routesByRole[roleKey].total += 1;
        if(route && isRouteComplete(route)){
          routesByRole[roleKey].complete += 1;
        }
        steps.forEach(step => {
          if(!step || !step.id) return;
          const slug = routeCategorySlug(step.category);
          if(!categoryMap.has(slug)){
            categoryMap.set(slug, {
              slug,
              label: step.category || 'Task',
              total: 0,
              complete: 0,
              optional: 0,
              optionalComplete: 0
            });
          }
          const catStats = categoryMap.get(slug);
          catStats.total += 1;
          if(routeState[step.id]){
            catStats.complete += 1;
          }
          if(step.optional){
            optionalTotal += 1;
            catStats.optional += 1;
            if(routeState[step.id]){
              optionalComplete += 1;
              catStats.optionalComplete += 1;
            }
          } else {
            requiredTotal += 1;
            if(routeState[step.id]){
              requiredComplete += 1;
            }
          }
          if(step.category === 'Boss'){
            towersTotal += 1;
            if(routeState[step.id]) towersComplete += 1;
          }
        });
      });
      const percent = requiredTotal ? Math.round((requiredComplete / requiredTotal) * 100) : 0;
      const categories = Array.from(categoryMap.values())
        .sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base' }));
      return {
        requiredTotal,
        requiredComplete,
        optionalTotal,
        optionalComplete,
        towersTotal,
        towersComplete,
        percent,
        categories,
        routes: routesByRole
      };
    }

    function updateRouteOverviewUI(summaryOverride){
      const summary = summaryOverride || calculateGuideProgressSummary();
      const requiredPct = summary.requiredTotal
        ? Math.round((summary.requiredComplete / summary.requiredTotal) * 100)
        : 0;
      const optionalPct = summary.optionalTotal
        ? Math.round((summary.optionalComplete / summary.optionalTotal) * 100)
        : 0;
      const towersPct = summary.towersTotal
        ? Math.round((summary.towersComplete / summary.towersTotal) * 100)
        : 0;

      document.querySelectorAll('[data-route-role="required-title"]').forEach(el => {
        el.textContent = kidMode ? 'Big steps' : 'Required steps';
      });
      document.querySelectorAll('[data-route-role="optional-title"]').forEach(el => {
        el.textContent = kidMode ? 'Bonus ideas' : 'Optional tasks';
      });
      document.querySelectorAll('[data-route-role="tower-title"]').forEach(el => {
        el.textContent = kidMode ? 'Tower wins' : 'Towers cleared';
      });

      document.querySelectorAll('[data-route-role="required-count"]').forEach(el => {
        el.textContent = summary.requiredTotal
          ? `${summary.requiredComplete}/${summary.requiredTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="required-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(requiredPct));
      });
      document.querySelectorAll('[data-route-role="required-fill"]').forEach(el => {
        el.style.width = `${requiredPct}%`;
      });
      document.querySelectorAll('[data-route-role="required-note"]').forEach(el => {
        if(summary.requiredTotal){
          const remaining = summary.requiredTotal - summary.requiredComplete;
          const coreRoutes = summary.routes?.core || { total: 0, complete: 0 };
          const routesRemaining = coreRoutes.total ? coreRoutes.total - coreRoutes.complete : 0;
          if(remaining === 0){
            if(routesRemaining === 0){
              el.textContent = kidMode
                ? 'All big steps complete!'
                : 'All required steps complete.';
            } else {
              const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
              el.textContent = kidMode
                ? `${routesRemaining} ${routeLabel} left`
                : `${routesRemaining} ${routeLabel} remaining`;
            }
          } else {
            const stepLabel = remaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
            if(routesRemaining > 0){
              const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
              el.textContent = kidMode
                ? `${routesRemaining} ${routeLabel} • ${remaining} ${stepLabel} left`
                : `${routesRemaining} ${routeLabel} • ${remaining} ${stepLabel} remaining`;
            } else {
              el.textContent = kidMode
                ? `${remaining} ${stepLabel} left`
                : `${remaining} ${stepLabel} remaining`;
            }
          }
        } else {
          el.textContent = kidMode ? 'Main path goals' : 'Main path objectives';
        }
      });

      document.querySelectorAll('[data-route-role="optional-count"]').forEach(el => {
        el.textContent = summary.optionalTotal
          ? `${summary.optionalComplete}/${summary.optionalTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="optional-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(optionalPct));
      });
      document.querySelectorAll('[data-route-role="optional-fill"]').forEach(el => {
        el.style.width = `${optionalPct}%`;
      });
      document.querySelectorAll('[data-route-role="optional-note"]').forEach(el => {
        if(summary.optionalTotal){
          const remainingOptional = summary.optionalTotal - summary.optionalComplete;
          if(remainingOptional === 0){
            el.textContent = kidMode
              ? 'Bonus adventures wrapped!'
              : 'All optional tasks completed.';
          } else {
            el.textContent = kidMode
              ? `${remainingOptional} bonus step${remainingOptional === 1 ? '' : 's'} to try`
              : `${remainingOptional} optional step${remainingOptional === 1 ? '' : 's'} remaining`;
          }
        } else {
          el.textContent = kidMode ? 'Extra fun chores' : 'Bonus cleanup and prep';
        }
      });

      document.querySelectorAll('[data-route-role="tower-count"]').forEach(el => {
        el.textContent = summary.towersTotal
          ? `${summary.towersComplete}/${summary.towersTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="tower-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(towersPct));
      });
      document.querySelectorAll('[data-route-role="tower-fill"]').forEach(el => {
        el.style.width = `${towersPct}%`;
      });
      document.querySelectorAll('[data-route-role="tower-note"]').forEach(el => {
        if(summary.towersTotal){
          const remainingTowers = summary.towersTotal - summary.towersComplete;
          if(remainingTowers === 0){
            el.textContent = kidMode
              ? 'Every tower champion beaten!'
              : 'All tower bosses defeated.';
          } else {
            el.textContent = kidMode
              ? `${remainingTowers} tower${remainingTowers === 1 ? '' : 's'} left`
              : `${remainingTowers} tower boss${remainingTowers === 1 ? '' : 'es'} remaining`;
          }
        } else {
          el.textContent = kidMode ? 'Defeat bosses together' : 'Tower bosses defeated so far';
        }
      });

      const nextRequired = findNextRouteStep();
      const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });

      document.querySelectorAll('[data-route-role="next-callout"]').forEach(el => {
        if(nextAny && nextAny.step){
          const isOptional = nextAny.step.optional && !nextRequired;
          const prefix = isOptional
            ? (kidMode ? 'Bonus idea:' : 'Optional focus:')
            : (kidMode ? 'Next big step:' : 'Next priority:');
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopy = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const chapterHtml = chapterTitle
            ? ` <span class="route-overview__next-chapter">(${escapeHTML(chapterTitle)})</span>`
            : '';
          el.innerHTML = `<strong>${escapeHTML(prefix)}</strong> ${escapeHTML(stepCopy)}${chapterHtml}`;
        } else {
          el.innerHTML = kidMode
            ? '<strong>Guide complete!</strong> Revisit bonus adventures anytime.'
            : '<strong>Guide complete!</strong> Re-run towers or tidy up optional chores.';
        }
      });

      const lastMeta = getLastCompletedRouteMeta();
      document.querySelectorAll('[data-route-role="last-completed"]').forEach(el => {
        if(lastMeta){
          const title = lastMeta.title || niceName(lastMeta.id);
          const dateLabel = lastMeta.completedAt ? formatGuideCompletionDate(lastMeta.completedAt) : '';
          if(kidMode){
            el.textContent = dateLabel ? `Finished ${title} (${dateLabel})` : `Finished ${title}`;
          } else {
            el.textContent = dateLabel ? `Last cleared: ${title} — ${dateLabel}` : `Last cleared: ${title}`;
          }
        } else {
          el.textContent = kidMode ? 'No routes completed yet.' : 'No routes completed yet.';
        }
      });

      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        const targetStep = nextAny && nextAny.step ? nextAny.step.id : '';
        btn.dataset.stepId = targetStep || '';
        if(targetStep){
          btn.disabled = false;
          btn.textContent = nextRequired
            ? (kidMode ? 'Jump to next step' : 'Jump to next required')
            : (kidMode ? 'Jump to bonus step' : 'Jump to optional step');
        } else {
          btn.disabled = true;
          btn.textContent = kidMode ? 'All steps done!' : 'All steps complete';
        }
      });

      updateRouteToggleButtons();

      const summarySlugs = new Set(summary.categories.map(cat => cat.slug));
      const currentHidden = Array.from(routeHiddenCategories);
      const trimmed = currentHidden.filter(slug => summarySlugs.has(slug));
      if(trimmed.length !== currentHidden.length){
        routeHiddenCategories = new Set(trimmed);
        persistRoutePreferences();
      }
      renderRouteFiltersUI(summary.categories);
      renderBossRouteTimeline();
    }

    function findNextRouteStep(options = {}){
      const includeOptional = !!options.includeOptional;
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
        for(const step of steps){
          if(step.optional && !includeOptional) continue;
          if(!routeState[step.id]){
            return { chapter, step };
          }
        }
      }
      return null;
    }

    function findNextPalTarget(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const sorted = palsArray.slice().sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      const next = sorted.find(pal => !caught[pal.id]);
      return next || null;
    }

    function findRandomPalCandidate(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const accessible = palsArray.filter(p => (p.rarity || 0) <= 3);
      const pool = accessible.length ? accessible : palsArray;
      return pool[Math.floor(Math.random() * pool.length)] || null;
    }

    function findNextTechUnlock(){
      const levels = Array.isArray(TECH)
        ? TECH.slice().sort((a, b) => (a?.level || 0) - (b?.level || 0))
        : [];
      for(const level of levels){
        const items = Array.isArray(level?.items) ? level.items : [];
        for(const item of items){
          if(!item || !item.name) continue;
          if(!unlocked[item.name]){
            const techKey = item.id || slugifyForPalworld(item.name);
            return { level, item, techKey };
          }
        }
      }
      return null;
    }

    function renderLinks(links){
      if(!links || !links.length) return '';
      return `<span class="badges">${links.map(link => {
        const payload = JSON.stringify(link)
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
        return `<a href="#" class="chip link" data-link="${payload}" role="button">${escapeHTML(linkLabel(link))}</a>`;
      }).join('')}</span>`;
    }

    function linkLabel(link){
      if(link.type === 'pal'){
        const source = link.slug || link.id || link.name;
        return capitalize(source);
      }
      if(link.type === 'item') return niceName(link.id);
      if(link.type === 'passive') return capitalize(link.id);
      if(link.type === 'move') return niceName(link.id);
      if(link.type === 'tech') return niceName(link.id);
      if(link.type === 'glossary') return niceName(link.id);
      if(link.type === 'tower') return niceName(link.id);
      return 'Open';
    }

    function navigateLink(link){
      if(!link) return;
      if(link.type === 'pal'){
        if(window.viewPal){
          window.viewPal(link.slug || link.id);
        } else {
          focusSearch(link.slug || link.id, { target: 'pals' });
        }
      } else if(link.type === 'item'){
        const itemKey = link.id || link.slug;
        if(itemKey && ITEMS[itemKey]){
          openItemDetail(itemKey);
        } else {
          focusSearch(itemKey, { target: 'items' });
        }
      } else if(link.type === 'tech'){
        showTechDetail(link.id);
      } else if(link.type === 'passive'){
        showTraitDetail(capitalize(link.id));
      } else if(link.type === 'move'){
        showSkillDetail(link.id);
      } else if(link.type === 'glossary'){
        showGlossaryDetail(link.id);
      } else if(link.type === 'tower'){
        openTowerMap(link);
      }
    }

    function showTechDetail(techId){
      if(!techId) return;
      const slug = slugifyForPalworld(String(techId));
      const entry = TECH_LOOKUP[slug];
      const displayName = entry?.item?.name || niceName(techId);
      const safeName = escapeHTML(displayName);
      const techUrl = entry?.item?.url || `${PALWORLD_BASE_URL}/technology-tree?search=${encodeURIComponent(displayName)}`;
      const summaryParts = [];
      if(kidMode){
        summaryParts.push(`<p>Let's get <strong>${safeName}</strong> ready!</p>`);
      } else {
        summaryParts.push(`<p><strong>${safeName}</strong> quick reference.</p>`);
      }
      if(entry?.level?.level){
        summaryParts.push(`<p><strong>Tech Level:</strong> ${escapeHTML(String(entry.level.level))}</p>`);
      }
      if(entry?.item?.branch){
        summaryParts.push(`<p><strong>Branch:</strong> ${escapeHTML(String(entry.item.branch))}</p>`);
      }
      if(typeof entry?.item?.techPoints === 'number'){
        const label = entry.item.isAncient ? 'Ancient Tech Points' : 'Tech Points';
        summaryParts.push(`<p><strong>${label}:</strong> ${escapeHTML(String(entry.item.techPoints))}</p>`);
      }
      if(entry?.item?.materials && Object.keys(entry.item.materials).length){
        const materials = Object.entries(entry.item.materials)
          .map(([material, qty]) => `<li>${escapeHTML(`${qty} × ${material}`)}</li>`)
          .join('');
        if(materials){
          summaryParts.push(`<p>${kidMode ? 'You will need:' : 'Materials required:'}</p><ul>${materials}</ul>`);
        }
      }
      if(entry?.item?.description){
        summaryParts.push(`<p>${escapeHTML(entry.item.description)}</p>`);
      } else if(entry){
        summaryParts.push(`<p>${kidMode
          ? 'Check the Palworld.gg window for a picture and placement tips once you unlock it.'
          : 'Use the Palworld.gg panel for placement notes and unlock requirements.'}</p>`);
      } else {
        summaryParts.push(`<p>${kidMode
          ? 'Palmate will peek at Palworld.gg so you can see what it looks like without leaving this checklist.'
          : 'Palmate opens the Palworld.gg technology tree so you can confirm crafting details without changing pages.'}</p>`);
      }
      const note = entry
        ? 'Palmate keeps this tech guide handy so you can stay on the route checklist.'
        : 'Palmate opens the Palworld.gg technology tree while keeping your route progress on screen.';
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url: techUrl,
        fallbackUrl: techUrl,
        note,
        summaryHtml: summaryParts.join('')
      });
    }

    function showGlossaryDetail(identifier){
      if(!identifier) return;
      const key = String(identifier).toLowerCase();
      const entry = ROUTE_GLOSSARY_SUMMARIES[key];
      const displayName = entry?.title || niceName(identifier);
      const url = entry?.url || `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(displayName)}`;
      const note = entry?.note || 'Palmate keeps this glossary entry in a modal so you never lose your place.';
      const lines = entry
        ? (kidMode ? entry.kid : entry.grown)
        : [kidMode
          ? `Let's learn about ${displayName}. Palworld.gg will open beside your checklist so you can keep exploring.`
          : `Palmate is opening a Palworld.gg search for ${displayName} so you can review it without leaving the route.`];
      const summaryHtml = lines.map(text => `<p>${escapeHTML(text)}</p>`).join('');
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url,
        fallbackUrl: url,
        note,
        summaryHtml
      });
    }

    window.showTechDetail = showTechDetail;
    window.showGlossaryDetail = showGlossaryDetail;

    function pulse(el){
      el.classList.add('pulse');
      setTimeout(() => el.classList.remove('pulse'), 1500);
    }

    function focusSearch(term, { target } = {}) {
      const desiredTarget = target === 'items' ? 'items' : 'pals';
      const inputId = desiredTarget === 'items' ? 'itemSearch' : 'palSearch';
      const input = document.getElementById(inputId);
      if (!input) return;
      switchPage(desiredTarget);
      const applySearch = () => {
        if (typeof input.focus === 'function') {
          try {
            input.focus({ preventScroll: true });
          } catch (err) {
            input.focus();
          }
        }
        if (typeof input.select === 'function') {
          input.select();
        }
        input.value = term == null ? '' : String(term);
        input.dispatchEvent(new Event('input', { bubbles: true }));
      };
      if (typeof window.requestAnimationFrame === 'function') {
        window.requestAnimationFrame(applySearch);
      } else {
        applySearch();
      }
    }

    function loadRouteState(){
      try {
        return JSON.parse(localStorage.getItem(ROUTE_STORAGE_KEY)) || {};
      } catch(err){
        console.warn('Failed to load route progress', err);
        return {};
      }
    }

    function loadRoutePreferences(){
      try {
        const stored = JSON.parse(localStorage.getItem(ROUTE_PREFS_KEY));
        if(stored && typeof stored === 'object'){
          return stored;
        }
      } catch(err){
        console.warn('Failed to load route preferences', err);
      }
      return {};
    }

    function loadRouteContext(){
      try {
        const stored = JSON.parse(localStorage.getItem(ROUTE_CONTEXT_KEY));
        if(stored && typeof stored === 'object'){
          return {
            ...DEFAULT_ROUTE_CONTEXT,
            ...stored,
            goals: Array.isArray(stored.goals) ? stored.goals.slice() : [],
            resourceGaps: Array.isArray(stored.resourceGaps) ? stored.resourceGaps.map(entry => ({
              item_id: entry?.item_id || entry?.itemId || '',
              qty: typeof entry?.qty === 'number' ? entry.qty : null
            })).filter(entry => entry.item_id) : []
          };
        }
      } catch(err){
        console.warn('Failed to load route context', err);
      }
      return { ...DEFAULT_ROUTE_CONTEXT };
    }

    function persistRoutePreferences(){
      const payload = {
        hideOptional: !!routeHideOptional,
        hiddenCategories: Array.from(routeHiddenCategories)
      };
      try {
        localStorage.setItem(ROUTE_PREFS_KEY, JSON.stringify(payload));
      } catch(err){
        console.warn('Failed to save route preferences', err);
      }
    }

    function saveRouteState(state){
      localStorage.setItem(ROUTE_STORAGE_KEY, JSON.stringify(state));
    }

    function saveRouteContext(context){
      if(!context || typeof context !== 'object') return;
      const payload = {
        declaredLevel: context.declaredLevel != null ? Number(context.declaredLevel) : null,
        hardcore: !!context.hardcore,
        coop: !!context.coop,
        availableTimeMinutes: context.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null,
        goals: Array.isArray(context.goals) ? context.goals.slice() : [],
        resourceGaps: Array.isArray(context.resourceGaps) ? context.resourceGaps.map(entry => ({
          item_id: entry?.item_id || entry?.itemId || '',
          qty: entry?.qty != null ? Number(entry.qty) : null
        })).filter(entry => entry.item_id) : []
      };
      try {
        localStorage.setItem(ROUTE_CONTEXT_KEY, JSON.stringify(payload));
      } catch(err){
        console.warn('Failed to save route context', err);
      }
    }

    function escapeHTML(str){
      return (str || '').replace(/[&<>"']/g, ch => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch] || ch));
    }

    function capitalize(value){
      return (value || '').replace(/(^|[-_])\w/g, m => m.toUpperCase()).replace(/[-_]/g, ' ');
    }

    function niceName(id){
      return capitalize(String(id).replace(/_/g, ' '));
    }
    // with their descriptions.  Elements and work suitabilities are
    // summarised in organised sections with quick filters for faster lookup.
    function buildGlossaryPage() {
      const container = document.getElementById('glossaryContent');
      if (!container) return;
      container.innerHTML = '';

      const normalizedSkillDetails = {};
      Object.entries(SKILL_DETAILS || {}).forEach(([name, info = {}]) => {
        const normalizedKey = name.toLowerCase().replace(/[\s-]+/g, '_');
        normalizedSkillDetails[normalizedKey] = { name, ...info };
      });

      const nav = document.createElement('div');
      nav.className = 'glossary-nav';
      container.appendChild(nav);

      function createSection(id, title, description) {
        const section = document.createElement('section');
        section.className = 'glossary-section card';
        section.id = id;
        const heading = document.createElement('h3');
        heading.textContent = title;
        section.appendChild(heading);
        if (description) {
          const desc = document.createElement('p');
          desc.textContent = description;
          section.appendChild(desc);
        }
        container.appendChild(section);

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = title;
        btn.dataset.target = id;
        btn.setAttribute('aria-controls', id);
        btn.addEventListener('click', () => {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
        nav.appendChild(btn);

        return section;
      }

      function createSearch(placeholder) {
        const input = document.createElement('input');
        input.type = 'search';
        input.className = 'glossary-search';
        input.placeholder = placeholder;
        input.setAttribute('aria-label', placeholder);
        return input;
      }

      const elementsDescription = kidMode
        ? 'Check which elements pals are strong or weak against.'
        : 'Reference chart for attack advantages and resistances.';
      const elemSection = createSection('glossary-elements', 'Elements & Type Chart', elementsDescription);

      const typeRelations = {
        Neutral: { strong: [], weak: ['Dark'] },
        Fire: { strong: ['Grass', 'Ice'], weak: ['Water'] },
        Water: { strong: ['Fire'], weak: ['Electric'] },
        Electric: { strong: ['Water'], weak: ['Ground'] },
        Grass: { strong: ['Ground'], weak: ['Fire'] },
        Ice: { strong: ['Dragon'], weak: ['Fire'] },
        Ground: { strong: ['Electric'], weak: ['Grass'] },
        Dragon: { strong: ['Dark', 'Dragon'], weak: ['Ice'] },
        Dark: { strong: ['Neutral'], weak: ['Dragon'] }
      };

      const typeColors = {
        Neutral: '#a5b2c8',
        Fire: '#ff704a',
        Water: '#41c5ff',
        Grass: '#6fe07a',
        Electric: '#ffd45c',
        Ice: '#8fe5ff',
        Ground: '#dba667',
        Dragon: '#c490ff',
        Dark: '#8a7bff'
      };

      function toRGBString(hex) {
        if (!hex) return '154, 166, 198';
        const cleaned = hex.replace('#', '').trim();
        const normalized = cleaned.length === 3
          ? cleaned.split('').map(ch => ch + ch).join('')
          : (cleaned + '000000').slice(0, 6);
        const r = parseInt(normalized.slice(0, 2), 16);
        const g = parseInt(normalized.slice(2, 4), 16);
        const b = parseInt(normalized.slice(4, 6), 16);
        if ([r, g, b].some(num => Number.isNaN(num))) {
          return '154, 166, 198';
        }
        return `${r}, ${g}, ${b}`;
      }

      const typeColorRGB = {};
      Object.entries(typeColors).forEach(([type, color]) => {
        typeColorRGB[type] = toRGBString(color);
      });

      function getTypeIconSource(type) {
        const source = iconMap[type];
        if (typeof source === 'string' && source.trim().length) {
          return source;
        }
        return iconMap['Neutral'] || 'assets/icons/neutral.png';
      }

      const typeMapLayout = document.createElement('div');
      typeMapLayout.className = 'type-map-layout';
      elemSection.appendChild(typeMapLayout);

      const typeMap = document.createElement('div');
      typeMap.className = 'type-map';
      typeMapLayout.appendChild(typeMap);

      const svgNS = 'http://www.w3.org/2000/svg';
      const connections = document.createElementNS(svgNS, 'svg');
      connections.classList.add('type-map__connections');
      connections.setAttribute('viewBox', '0 0 100 100');
      connections.setAttribute('aria-hidden', 'true');

      const defs = document.createElementNS(svgNS, 'defs');
      const marker = document.createElementNS(svgNS, 'marker');
      marker.id = 'type-map-arrowhead';
      marker.setAttribute('viewBox', '0 0 10 10');
      marker.setAttribute('refX', '10');
      marker.setAttribute('refY', '5');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('orient', 'auto');
      const markerPath = document.createElementNS(svgNS, 'path');
      markerPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
      markerPath.setAttribute('fill', 'currentColor');
      marker.appendChild(markerPath);
      defs.appendChild(marker);
      connections.appendChild(defs);

      const connectionGroup = document.createElementNS(svgNS, 'g');
      connectionGroup.classList.add('type-map__link-group');
      connections.appendChild(connectionGroup);
      typeMap.appendChild(connections);

      const nodesLayer = document.createElement('div');
      nodesLayer.className = 'type-map__nodes';
      typeMap.appendChild(nodesLayer);

      const detailPanel = document.createElement('aside');
      detailPanel.className = 'type-map__detail';
      detailPanel.setAttribute('aria-live', 'polite');
      typeMapLayout.appendChild(detailPanel);

      const legend = document.createElement('p');
      legend.className = 'type-map__legend';
      legend.textContent = kidMode
        ? 'Follow the glowing arrows—each line shows which pals hit super hard!'
        : 'Arrows flow from the attacking element to the element it overwhelms.';
      elemSection.appendChild(legend);

      const sourceNote = document.createElement('p');
      sourceNote.className = 'type-map__source';
      const sourceLink = document.createElement('a');
      sourceLink.href = 'https://palworld.wiki.gg/wiki/Elements';
      sourceLink.target = '_blank';
      sourceLink.rel = 'noreferrer noopener';
      sourceLink.textContent = kidMode ? 'Palworld Wiki type chart' : 'Palworld Wiki type chart (rev. 18881)';
      sourceNote.append(
        kidMode ? 'Matchup data double-checked with the ' : 'Strengths and weaknesses verified against the ',
        sourceLink,
        kidMode ? ' so you have the latest info.' : ' to keep this guide current.'
      );
      elemSection.appendChild(sourceNote);

      const critiqueWrap = document.createElement('div');
      critiqueWrap.className = 'type-audit';
      const critiqueTitle = document.createElement('h4');
      critiqueTitle.className = 'type-audit__title';
      critiqueTitle.textContent = kidMode ? 'Element highlights' : 'Matchup audit highlights';
      critiqueWrap.appendChild(critiqueTitle);
      const critiqueList = document.createElement('ul');
      critiqueList.className = 'type-audit__list';
      const critiqueData = [
        {
          type: 'Fire',
          kid: 'Fire pals roast Grass and Ice, but water buddies soak them fast.',
          grown: 'Fire is still the only element with two offensive wins (Grass, Ice) yet a single Water counter.'
        },
        {
          type: 'Water',
          kid: 'Water pals splash out Fire, but Electric shocks hurt the most.',
          grown: 'Water now only checks Fire consistently and is punished sharply by Electric damage.'
        },
        {
          type: 'Grass',
          kid: 'Grass beats Ground pals, yet hates taking Fire hits.',
          grown: 'Grass focuses on grounding Ground-types while Fire remains its lone hard weakness.'
        },
        {
          type: 'Ground',
          kid: 'Ground pals zap Electric foes but should dodge Grass moves.',
          grown: 'Ground reliably blanks Electric attacks, though modern charts show Grass as its clean counter.'
        },
        {
          type: 'Dragon',
          kid: 'Dragon pals smash Dark foes, but Ice chills them instantly.',
          grown: 'Dragon still rules mirrors and Dark types, yet every build must respect Ice coverage.'
        },
        {
          type: 'Dark',
          kid: 'Dark pals scare Neutral friends, but Dragons scare them back.',
          grown: 'Dark stays the dedicated Neutral breaker, with Dragon remaining its only elemental check.'
        }
      ];
      critiqueData.forEach(entry => {
        const item = document.createElement('li');
        item.className = 'type-audit__item';
        const header = document.createElement('div');
        header.className = 'type-audit__item-header';
        const icon = document.createElement('img');
        icon.className = 'type-audit__item-icon';
        icon.src = getTypeIconSource(entry.type);
        icon.alt = '';
        icon.loading = 'lazy';
        icon.setAttribute('aria-hidden', 'true');
        header.appendChild(icon);
        const label = document.createElement('span');
        label.textContent = entry.type;
        header.appendChild(label);
        const text = document.createElement('p');
        text.className = 'type-audit__item-text';
        text.textContent = kidMode ? entry.kid : entry.grown;
        item.appendChild(header);
        item.appendChild(text);
        critiqueList.appendChild(item);
      });
      critiqueWrap.appendChild(critiqueList);
      elemSection.appendChild(critiqueWrap);

      const orbitElements = Object.keys(typeRelations).filter(type => type !== 'Neutral');
      const nodePositions = {};
      const smallScreen = window.matchMedia('(max-width: 520px)').matches;
      const mediumScreen = window.matchMedia('(max-width: 880px)').matches;
      const radius = smallScreen ? 40 : (mediumScreen ? 38 : 36);
      orbitElements.forEach((type, index) => {
        const angle = (index / orbitElements.length) * (Math.PI * 2) - Math.PI / 2;
        const x = 50 + radius * Math.cos(angle);
        const y = 50 + radius * Math.sin(angle);
        nodePositions[type] = { x, y };
      });
      nodePositions.Neutral = { x: 50, y: 50 };

      const links = [];

      function createPath(start, end) {
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const distance = Math.hypot(dx, dy) || 1;
        const offset = Math.min(12, distance / 3);
        const controlX = midX + (-dy / distance) * offset;
        const controlY = midY + (dx / distance) * offset;
        return `M ${start.x} ${start.y} Q ${controlX} ${controlY} ${end.x} ${end.y}`;
      }

      Object.entries(typeRelations).forEach(([source, info]) => {
        const start = nodePositions[source];
        if (!start) return;
        (info.strong || []).forEach(target => {
          if (target === source) return;
          const end = nodePositions[target];
          if (!end) return;
          const path = document.createElementNS(svgNS, 'path');
          path.classList.add('type-map__link');
          path.dataset.source = source;
          path.dataset.target = target;
          path.setAttribute('d', createPath(start, end));
          const color = typeColors[source] || '#f0f4f8';
          const rgb = typeColorRGB[source] || toRGBString(color);
          path.style.setProperty('--type-color', color);
          path.style.setProperty('--type-color-rgb', rgb);
          path.style.color = color;
          path.setAttribute('marker-end', 'url(#type-map-arrowhead)');
          connectionGroup.appendChild(path);
          links.push(path);
        });
      });

      const nodeButtons = [];

      function createNode(type) {
        const pos = nodePositions[type];
        if (!pos) return;
        const strong = (typeRelations[type] && typeRelations[type].strong) || [];
        const weak = (typeRelations[type] && typeRelations[type].weak) || [];
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'type-map__node';
        button.dataset.type = type;
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        button.style.setProperty('--type-color', color);
        button.style.setProperty('--type-color-rgb', rgb);
        button.style.setProperty('--type-x', `${pos.x}%`);
        button.style.setProperty('--type-y', `${pos.y}%`);
        button.setAttribute('aria-label', `${type} element: strong against ${strong.length ? strong.join(', ') : 'no elements'}; weak against ${weak.length ? weak.join(', ') : 'no elements'}`);
        button.setAttribute('aria-pressed', 'false');
        const iconSrc = getTypeIconSource(type);
        button.innerHTML = `
          <span class="type-map__node-ring"></span>
          <span class="type-map__node-visual">
            <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__node-icon" aria-hidden="true">
          </span>
          <span class="type-map__node-name">${escapeHTML(type)}</span>
          <span class="type-map__node-meta">
            <span class="type-map__node-pill type-map__node-pill--strong" title="${kidMode ? 'Number of elements you overpower' : 'Advantage count'}">${strong.length}</span>
            <span class="type-map__node-pill type-map__node-pill--weak" title="${kidMode ? 'Number of elements that overpower you' : 'Weakness count'}">${weak.length}</span>
          </span>
        `;
        button.addEventListener('click', () => selectType(type));
        nodesLayer.appendChild(button);
        nodeButtons.push(button);
      }

      Object.keys(typeRelations).forEach(createNode);

      function renderList(items, empty) {
        if (!items || items.length === 0) {
          return `<p class="type-map__detail-empty">${empty}</p>`;
        }
        return `
          <ul class="type-map__detail-list">
            ${items.map(item => `<li>${escapeHTML(item)}</li>`).join('')}
          </ul>
        `;
      }

      function selectType(type) {
        const info = typeRelations[type] || { strong: [], weak: [] };
        const strongSet = new Set(info.strong);
        const weakSet = new Set(info.weak);
        nodeButtons.forEach(btn => {
          const nodeType = btn.dataset.type;
          const isFocus = nodeType === type;
          btn.classList.toggle('type-map__node--focus', isFocus);
          btn.classList.toggle('type-map__node--ally', strongSet.has(nodeType));
          btn.classList.toggle('type-map__node--danger', weakSet.has(nodeType));
          btn.setAttribute('aria-pressed', isFocus ? 'true' : 'false');
        });
        links.forEach(path => {
          const fromSelected = path.dataset.source === type;
          const toSelected = path.dataset.target === type;
          path.classList.toggle('type-map__link--active', fromSelected);
          path.classList.toggle('type-map__link--incoming', toSelected);
          path.classList.toggle('type-map__link--dim', !fromSelected && !toSelected);
        });

        const strongLabel = kidMode ? 'Super Effective On' : 'Dominates';
        const weakLabel = kidMode ? 'Takes Big Damage From' : 'Vulnerable To';
        const noteText = kidMode
          ? 'Tap another element to see who it blasts or who blasts it.'
          : 'Select different nodes to trace optimal matchups and counters.';
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        const iconSrc = getTypeIconSource(type);
        detailPanel.style.setProperty('--type-color', color);
        detailPanel.style.setProperty('--type-color-rgb', rgb);
        detailPanel.innerHTML = `
          <header class="type-map__detail-header">
            <span class="type-map__detail-chip">
              <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__detail-icon" aria-hidden="true">
              ${escapeHTML(type)}
            </span>
            <span class="type-map__detail-sub">${info.strong.length} advantage${info.strong.length === 1 ? '' : 's'} • ${info.weak.length} weakness${info.weak.length === 1 ? '' : 'es'}</span>
          </header>
          <div class="type-map__detail-columns">
            <div>
              <h4>${strongLabel}</h4>
              ${renderList(info.strong, kidMode ? 'No super strengths.' : 'No direct advantages recorded.')}
            </div>
            <div>
              <h4>${weakLabel}</h4>
              ${renderList(info.weak, kidMode ? 'No big threats.' : 'No notable weaknesses recorded.')}
            </div>
          </div>
          <p class="type-map__detail-note">${noteText}</p>
        `;
      }

      selectType('Fire');

      const workDescription = kidMode
        ? 'These jobs tell you what pals can help with at base.'
        : 'Use these notes to decide which pals to station at each production line.';
      const workSection = createSection('glossary-work', 'Work Suitabilities', workDescription);
      const workLevelLabels = {
        5: kidMode ? 'Mythic helper' : 'Mythic specialist',
        4: kidMode ? 'Master helper' : 'Master specialist',
        3: kidMode ? 'Elite helper' : 'Expert artisan',
        2: kidMode ? 'Trained helper' : 'Skilled worker',
        1: kidMode ? 'Rookie helper' : 'Apprentice',
        0: kidMode ? 'Needs practice' : 'Untrained'
      };

      const tierLookup = {
        5: { badge: 'SS', className: 'work-tier-badge work-tier-badge--ss' },
        4: { badge: 'S', className: 'work-tier-badge work-tier-badge--s' },
        3: { badge: 'A', className: 'work-tier-badge work-tier-badge--a' },
        2: { badge: 'B', className: 'work-tier-badge work-tier-badge--b' },
        1: { badge: 'C', className: 'work-tier-badge work-tier-badge--c' },
        0: { badge: '—', className: 'work-tier-badge work-tier-badge--d' }
      };

      const tierLegend = document.createElement('div');
      tierLegend.className = 'work-tier-legend';
      const tierLegendLabel = document.createElement('span');
      tierLegendLabel.className = 'work-tier-legend__label';
      tierLegendLabel.textContent = kidMode
        ? 'Badges show how strong a pal is at the job:'
        : 'Tier badges convert work levels at a glance:';
      tierLegend.appendChild(tierLegendLabel);
      const tierLegendItems = document.createElement('div');
      tierLegendItems.className = 'work-tier-legend__items';
      [4, 3, 2, 1].forEach(level => {
        const tierInfo = tierLookup[level];
        if (!tierInfo) return;
        const item = document.createElement('span');
        item.className = 'work-tier-legend__item';
        const badge = document.createElement('span');
        badge.className = tierInfo.className;
        badge.textContent = tierInfo.badge;
        const text = document.createElement('span');
        text.textContent = `${kidMode ? 'Level' : 'Level'} ${level} • ${workLevelLabels[level]}`;
        item.appendChild(badge);
        item.appendChild(text);
        tierLegendItems.appendChild(item);
      });
      if (tierLegendItems.childElementCount) {
        tierLegend.appendChild(tierLegendItems);
        workSection.appendChild(tierLegend);
      }

      const allPals = Object.values(PALS || {});
      let highestWorkLevel = 0;
      allPals.forEach(pal => {
        const work = pal?.work || {};
        Object.values(work).forEach(val => {
          if (typeof val === 'number' && val > highestWorkLevel) {
            highestWorkLevel = val;
          }
        });
      });
      if (!highestWorkLevel) {
        highestWorkLevel = 4;
      }

      function getWorkLevel(pal, keys) {
        const work = pal?.work || {};
        return keys.reduce((max, key) => {
          const value = work?.[key] ?? 0;
          return typeof value === 'number' && value > max ? value : max;
        }, 0);
      }

      function findTopPals(keys) {
        return allPals
          .map(pal => ({ pal, level: getWorkLevel(pal, keys) }))
          .filter(item => item.level > 0 && item.pal && item.pal.name)
          .sort((a, b) => {
            if (b.level !== a.level) return b.level - a.level;
            return (a.pal.name || '').localeCompare(b.pal.name || '', undefined, { sensitivity: 'base' });
          })
          .slice(0, 5);
      }

      function getTierInfo(level) {
        if (level >= 5 && tierLookup[5]) return tierLookup[5];
        if (level >= 4) return tierLookup[4];
        if (level >= 3) return tierLookup[3];
        if (level >= 2) return tierLookup[2];
        if (level >= 1) return tierLookup[1];
        return tierLookup[0];
      }

      function getWorkLabel(level) {
        if (level > 0) {
          const descriptor = workLevelLabels[level] != null
            ? workLevelLabels[level]
            : (kidMode ? 'Trusted helper' : 'Seasoned worker');
          return `${kidMode ? 'Level' : 'Level'} ${level} • ${descriptor}`;
        }
        return workLevelLabels[0];
      }

      const workEntries = [
        { id: 'kindling', name: 'Kindling', icon: '🔥', keys: ['kindling'], desc: 'Lights furnaces, cooking pots and heaters so crafting stays on schedule.' },
        { id: 'watering', name: 'Watering', icon: '💧', keys: ['watering'], desc: 'Keeps berry plantations, mill wheels and condensers supplied with water.' },
        { id: 'planting', name: 'Planting', icon: '🌱', keys: ['planting'], desc: 'Sows seeds in your fields and refills ranch plots automatically.' },
        { id: 'electricity', name: 'Electricity', icon: '⚡', keys: ['generating_electricity', 'electricity'], desc: 'Generates power for batteries, assembly lines and refrigerators.' },
        { id: 'handiwork', name: 'Handiwork', icon: '🛠️', keys: ['handiwork'], desc: 'Builds structures, crafts gear and assists with any construction queue.' },
        { id: 'gathering', name: 'Gathering', icon: '🎒', keys: ['gathering'], desc: 'Picks up dropped items around base and hauls them to nearby chests.' },
        { id: 'lumbering', name: 'Lumbering', icon: '🪓', keys: ['lumbering'], desc: 'Cuts logs at the logging site and processes wood for crafting.' },
        { id: 'mining', name: 'Mining', icon: '⛏️', keys: ['mining'], desc: 'Breaks ore nodes and keeps refining stations stocked with stone and ingots.' },
        { id: 'medicine', name: 'Medicine', icon: '💊', keys: ['medicine_production', 'medicine'], desc: 'Brews medical supplies at the workbench and treats sick pals faster.' },
        { id: 'cooling', name: 'Cooling', icon: '❄️', keys: ['cooling'], desc: 'Runs refrigerators, air conditioners and ice workbenches.' },
        { id: 'transporting', name: 'Transporting', icon: '📦', keys: ['transporting'], desc: 'Moves materials between stations and storage so production never stalls.' },
        { id: 'farming', name: 'Farming', icon: '🐑', keys: ['farming'], desc: 'Produces rare drops like milk, wool and eggs while stationed at the ranch.' }
      ];

      const workGrid = document.createElement('div');
      workGrid.className = 'glossary-work-grid';

      workEntries.forEach(entry => {
        const card = document.createElement('article');
        card.className = 'work-role-card';
        card.id = `work-${entry.id}`;

        const header = document.createElement('header');
        header.className = 'work-role-card__header';

        const icon = document.createElement('span');
        icon.className = 'work-role-card__icon';
        icon.textContent = entry.icon || '⭐';
        icon.setAttribute('aria-hidden', 'true');
        header.appendChild(icon);

        const titles = document.createElement('div');
        titles.className = 'work-role-card__titles';

        const title = document.createElement('h4');
        title.className = 'work-role-card__name';
        title.textContent = entry.name;
        titles.appendChild(title);

        const blurb = document.createElement('p');
        blurb.className = 'work-role-card__blurb';
        blurb.textContent = entry.desc;
        titles.appendChild(blurb);

        header.appendChild(titles);
        card.appendChild(header);

        const palGrid = document.createElement('div');
        palGrid.className = 'work-pal-grid';

        const topPals = findTopPals(entry.keys);
        if (!topPals.length) {
          const emptyState = document.createElement('p');
          emptyState.className = 'work-pal-empty';
          emptyState.textContent = kidMode
            ? 'No pals recorded yet.'
            : 'No pals currently specialise in this task.';
          palGrid.appendChild(emptyState);
        } else {
          topPals.forEach((item, index) => {
            const { pal, level } = item;
            const palId = pal.id || pal.key || '';
            const palName = pal.name || 'Unknown Pal';
            const tierInfo = getTierInfo(level);
            const label = getWorkLabel(level);
            const normalizedWidth = Math.min(100, Math.max(0, (level / Math.max(1, highestWorkLevel)) * 100));
            const initial = (palName || '?').trim().charAt(0) || '?';

            const cardBtn = document.createElement('button');
            cardBtn.type = 'button';
            cardBtn.className = 'work-pal-card';
            cardBtn.dataset.palId = palId;
            cardBtn.dataset.workRole = entry.id;
            cardBtn.dataset.workLevel = String(level);
            cardBtn.setAttribute('aria-label', `${palName} ${label}`);
            cardBtn.title = `${palName} — ${label}`;

            const rank = document.createElement('span');
            rank.className = 'work-pal-card__rank';
            rank.textContent = `#${index + 1}`;
            cardBtn.appendChild(rank);

            const artWrap = document.createElement('span');
            artWrap.className = 'work-pal-card__art';
            const placeholder = document.createElement('span');
            placeholder.className = 'work-pal-card__placeholder';
            placeholder.textContent = initial;
            artWrap.appendChild(placeholder);

            const artImg = document.createElement('img');
            artImg.alt = palName;
            artImg.addEventListener('load', () => {
              placeholder.hidden = true;
            });
            applyPalArtwork(artImg, pal, { alt: palName });
            artWrap.appendChild(artImg);
            cardBtn.appendChild(artWrap);

            const infoWrap = document.createElement('span');
            infoWrap.className = 'work-pal-card__info';

            const head = document.createElement('span');
            head.className = 'work-pal-card__head';
            const nameEl = document.createElement('span');
            nameEl.className = 'work-pal-card__name';
            nameEl.textContent = palName;
            head.appendChild(nameEl);

            const badge = document.createElement('span');
            badge.className = tierInfo.className;
            badge.textContent = tierInfo.badge;
            head.appendChild(badge);
            infoWrap.appendChild(head);

            const skill = document.createElement('span');
            skill.className = 'work-pal-card__skill';
            skill.textContent = label;
            infoWrap.appendChild(skill);

            const meter = document.createElement('span');
            meter.className = 'work-skill-meter';
            meter.setAttribute('aria-hidden', 'true');
            const meterFill = document.createElement('span');
            meterFill.className = 'work-skill-meter__fill';
            meterFill.style.width = `${normalizedWidth.toFixed(0)}%`;
            meter.appendChild(meterFill);
            infoWrap.appendChild(meter);

            cardBtn.appendChild(infoWrap);
            palGrid.appendChild(cardBtn);
          });
        }

        card.appendChild(palGrid);
        workGrid.appendChild(card);
      });

      workSection.appendChild(workGrid);

      const partnerSkillsData = Array.isArray(PARTNER_SKILLS) ? PARTNER_SKILLS.slice() : [];
      const partnerDescription = kidMode
        ? 'Press the Partner Skill button to trigger these buddy powers.'
        : 'Every ability you unlock with the Partner button, from mount bonuses to farming helpers.';
      const partnerSection = createSection('glossary-partners', 'Partner Skills', partnerDescription);

      const partnerSummary = document.createElement('div');
      partnerSummary.className = 'glossary-callout';
      const partnerCountLabel = kidMode
        ? `Palmate now tracks ${partnerSkillsData.length} partner skills.`
        : `${partnerSkillsData.length} partner skills catalogued across the full roster.`;
      partnerSummary.innerHTML = kidMode
        ? `<strong>Partner skill quick facts</strong><ul><li>${partnerCountLabel}—that’s even more than the 94 skills Palworld launched with.</li><li>Mount badges mark pals that boost you while you ride—look for the Damage Boost tag when you want your own attacks to hit harder.</li><li>Utility and farming pals are flagged so you can find harvest bonuses fast.</li></ul>`
        : `<strong>Partner skill quick reference</strong><ul><li>${partnerCountLabel} (the roster has already grown past the ~94 launch abilities). Use the filters to zero in on combat, mount or production buffs.</li><li>The Damage Boost tag highlights mounts that amplify player or pal damage while ridden.</li><li>Utility and Ranch labels surface weight carriers, harvest multipliers and other base-side perks.</li></ul>`;
      partnerSection.appendChild(partnerSummary);

      const condenserCallout = document.createElement('div');
      condenserCallout.className = 'glossary-callout';
      condenserCallout.innerHTML = kidMode
        ? `<strong>Power Condenser bonuses</strong><ul><li>Feed extra pals into the Power Condenser to add blue stars—each star raises the partner skill level.</li><li>Stars also boost a pal's stats, and the fourth star gives every job +1 level.</li><li>It takes 4 + 16 + 32 + 64 pals (116 total) to reach five stars, so mark your favorites before condensing.</li></ul>`
        : `<strong>Power Condenser benefits</strong><ul><li>The Pal Essence Condenser consumes 4, 16, 32 and 64 duplicates (116 total) to push a partner skill to Lv.5.</li><li>Each condensation star raises base stats; the 4★ upgrade grants +1 to every work suitability.</li><li>Damage-focused partner skills scale with those levels—mount element swaps and active skill multipliers can double or better by rank 5.</li></ul>`;
      partnerSection.appendChild(condenserCallout);

      const partnerSearch = createSearch(kidMode ? 'Search partner skills…' : 'Filter partner skills by name, pal or effect…');
      partnerSection.appendChild(partnerSearch);

      const partnerFilterBar = document.createElement('div');
      partnerFilterBar.className = 'partner-filter-bar';
      partnerSection.appendChild(partnerFilterBar);

      const partnerFilterState = { category: 'all', damageOnly: false };
      const partnerCategoryButtons = [];
      const partnerCategoryOptions = [
        { key: 'all', kid: 'All', grown: 'All roles' },
        { key: 'mount', kid: 'Mounts', grown: 'Mount bonuses' },
        { key: 'combat', kid: 'Battle', grown: 'Combat' },
        { key: 'utility', kid: 'Helpers', grown: 'Utility' },
        { key: 'farming', kid: 'Ranch', grown: 'Farming' }
      ];
      partnerCategoryOptions.forEach(option => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'partner-filter';
        btn.dataset.category = option.key;
        btn.textContent = kidMode ? option.kid : option.grown;
        btn.setAttribute('aria-pressed', option.key === partnerFilterState.category ? 'true' : 'false');
        btn.addEventListener('click', () => {
          if (partnerFilterState.category === option.key) return;
          partnerFilterState.category = option.key;
          updatePartnerCategoryButtons();
          renderPartnerSkills();
        });
        partnerCategoryButtons.push(btn);
        partnerFilterBar.appendChild(btn);
      });

      const damageToggle = document.createElement('button');
      damageToggle.type = 'button';
      damageToggle.className = 'partner-filter';
      damageToggle.dataset.filter = 'damage';
      damageToggle.textContent = kidMode ? 'Damage boost' : 'Damage boosts';
      damageToggle.setAttribute('aria-pressed', partnerFilterState.damageOnly ? 'true' : 'false');
      damageToggle.addEventListener('click', () => {
        partnerFilterState.damageOnly = !partnerFilterState.damageOnly;
        damageToggle.setAttribute('aria-pressed', partnerFilterState.damageOnly ? 'true' : 'false');
        renderPartnerSkills();
      });
      partnerFilterBar.appendChild(damageToggle);

      const partnerCount = document.createElement('p');
      partnerCount.className = 'glossary-count';
      partnerSection.appendChild(partnerCount);

      const partnerGrid = document.createElement('div');
      partnerGrid.className = 'partner-skill-grid';
      partnerSection.appendChild(partnerGrid);

      const partnerEmpty = document.createElement('p');
      partnerEmpty.className = 'glossary-empty';
      partnerEmpty.textContent = kidMode
        ? 'No partner skills found. Try a different word or filter.'
        : 'No partner skills match the current filters.';
      partnerEmpty.hidden = true;
      partnerSection.appendChild(partnerEmpty);

      const categoryLabels = {
        'Combat': { kid: 'Battle', grown: 'Combat' },
        'Utility': { kid: 'Helper', grown: 'Utility' },
        'Farming': { kid: 'Ranch', grown: 'Farming' },
        'Mount': { kid: 'Ride', grown: 'Mount' },
        'Mount (Flying)': { kid: 'Fly', grown: 'Flying Mount' },
        'Mount (Glider)': { kid: 'Glide', grown: 'Glider Mount' },
        'Mount (Swimmer)': { kid: 'Swim', grown: 'Swim Mount' },
        'Mount (Ridden)': { kid: 'Ground', grown: 'Ground Mount' }
      };

      const decoratedPartnerSkills = partnerSkillsData.map(skill => {
        const categories = Array.isArray(skill.categories) ? skill.categories.slice() : [];
        const normalizedCategories = new Set();
        const hasSpecializedMount = categories.some(cat => /^Mount \(/i.test(cat));
        categories.forEach(cat => {
          const lower = String(cat || '').toLowerCase();
          if (!lower) return;
          if (lower.includes('combat')) normalizedCategories.add('combat');
          if (lower.includes('utility')) normalizedCategories.add('utility');
          if (lower.includes('farming')) normalizedCategories.add('farming');
          if (lower.startsWith('mount')) {
            normalizedCategories.add('mount');
            if (lower.includes('flying')) normalizedCategories.add('mount-flying');
            if (lower.includes('glider')) normalizedCategories.add('mount-glider');
            if (lower.includes('swimmer')) normalizedCategories.add('mount-swimmer');
            if (lower.includes('ridden')) normalizedCategories.add('mount-ridden');
          }
        });
        const description = typeof skill.description === 'string' ? skill.description : '';
        const descLower = description.toLowerCase();
        const modifiesPlayerDamage = descLower.includes('player') && descLower.includes('mounted') && (descLower.includes('damage') || descLower.includes('attack'));
        const modifiesPalDamage = descLower.includes('pal') && descLower.includes('mounted') && descLower.includes('damage');
        const modifiesAnyDamage = (descLower.includes('damage') || descLower.includes('attack')) && descLower.includes('mounted');
        const dropBoost = descLower.includes('drop') || descLower.includes('harvest') || descLower.includes('ranch');
        const workBoost = descLower.includes('work') || descLower.includes('carry') || descLower.includes('weight');
        const speedBoost = descLower.includes('speed') && descLower.includes('mount');
        const mountCategory = categories.find(cat => /^Mount/i.test(cat));
        const palEntries = (Array.isArray(skill.pals) ? skill.pals : []).map(name => {
          const palId = PAL_NAME_TO_ID[name];
          const pal = palId != null ? PALS[palId] : null;
          return { name, pal, palId };
        });
        const searchText = [
          skill.name || '',
          description,
          skill.type || '',
          (Array.isArray(skill.pals) ? skill.pals.join(' ') : '')
        ].join(' ').toLowerCase();
        return {
          ...skill,
          categories,
          normalizedCategories,
          hasSpecializedMount,
          mountCategory,
          modifiesPlayerDamage,
          modifiesPalDamage,
          modifiesAnyDamage,
          dropBoost,
          workBoost,
          speedBoost,
          palEntries,
          searchText,
          descLower
        };
      });

      function updatePartnerCategoryButtons() {
        partnerCategoryButtons.forEach(btn => {
          const active = btn.dataset.category === partnerFilterState.category;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
      }

      function renderPartnerSkills() {
        const totalSkills = decoratedPartnerSkills.length;
        if (!totalSkills) {
          partnerGrid.innerHTML = '';
          partnerCount.textContent = kidMode
            ? 'Partner skill data is loading…'
            : 'Partner skill dataset unavailable.';
          partnerEmpty.hidden = false;
          partnerEmpty.textContent = kidMode
            ? 'Partner skill list will appear once the data loads.'
            : 'Partner skill dataset is unavailable.';
          return;
        }
        const term = partnerSearch.value.trim().toLowerCase();
        const category = partnerFilterState.category;
        const requireDamage = partnerFilterState.damageOnly;
        partnerGrid.innerHTML = '';
        let visible = 0;
        decoratedPartnerSkills.forEach(skill => {
          const matchesTerm = !term || skill.searchText.includes(term);
          const matchesCategory = category === 'all' || skill.normalizedCategories.has(category);
          const matchesDamage = !requireDamage || skill.modifiesAnyDamage;
          if (!matchesTerm || !matchesCategory || !matchesDamage) {
            return;
          }
          visible += 1;
          const card = document.createElement('article');
          card.className = 'partner-skill-card';
          card.dataset.skillId = skill.id || '';

          const header = document.createElement('header');
          header.className = 'partner-skill-card__header';
          const nameEl = document.createElement('h4');
          nameEl.className = 'partner-skill-card__name';
          nameEl.textContent = skill.name || 'Partner Skill';
          const numberEl = document.createElement('span');
          numberEl.className = 'partner-skill-card__number';
          numberEl.textContent = skill.number != null ? String(skill.number).padStart(3, '0') : '—';
          header.appendChild(nameEl);
          header.appendChild(numberEl);
          card.appendChild(header);

          const tags = document.createElement('div');
          tags.className = 'partner-skill-card__tags';
          const shownTags = new Set();
          const hasMountSpecialisation = skill.hasSpecializedMount;
          skill.categories.forEach(cat => {
            if (!cat) return;
            if (cat === 'Mount' && hasMountSpecialisation) return;
            const mapping = categoryLabels[cat];
            const label = mapping ? (kidMode ? mapping.kid : mapping.grown) : cat;
            const tagKey = `cat:${label}`;
            if (shownTags.has(tagKey)) return;
            shownTags.add(tagKey);
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            if (/^Mount/i.test(cat)) {
              tag.classList.add('partner-skill-card__tag--mount');
            }
            tag.textContent = label;
            tags.appendChild(tag);
          });
          if (skill.modifiesAnyDamage) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag partner-skill-card__tag--damage';
            tag.textContent = kidMode
              ? (skill.modifiesPlayerDamage ? 'You hit harder' : 'Pal hits harder')
              : (skill.modifiesPlayerDamage ? 'Player damage' : 'Pal damage');
            tags.appendChild(tag);
          }
          if (skill.dropBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag partner-skill-card__tag--drops';
            tag.textContent = kidMode ? 'More drops' : 'Drop bonus';
            tags.appendChild(tag);
          }
          if (skill.workBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            tag.textContent = kidMode ? 'Helper boost' : 'Support bonus';
            tags.appendChild(tag);
          }
          if (skill.speedBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            tag.textContent = kidMode ? 'Faster ride' : 'Speed boost';
            tags.appendChild(tag);
          }
          if (tags.childElementCount) {
            card.appendChild(tags);
          }

          const description = document.createElement('p');
          description.className = 'partner-skill-card__description';
          description.textContent = skill.description || (kidMode ? 'Partner skill info unavailable.' : 'No description available.');
          card.appendChild(description);

          if (skill.palEntries.length) {
            const palWrap = document.createElement('div');
            palWrap.className = 'partner-skill-card__pals';
            skill.palEntries.forEach(entry => {
              const palBtn = document.createElement('button');
              palBtn.type = 'button';
              palBtn.className = 'partner-skill-card__pal';
              const palId = entry.palId;
              if (palId != null) {
                palBtn.dataset.palId = String(palId);
              } else {
                palBtn.setAttribute('aria-disabled', 'true');
                palBtn.disabled = true;
              }
              const avatar = document.createElement('span');
              avatar.className = 'partner-skill-card__pal-avatar';
              if (entry.pal) {
                const img = document.createElement('img');
                img.alt = '';
                applyPalArtwork(img, entry.pal, { alt: '' });
                avatar.appendChild(img);
              } else {
                avatar.textContent = entry.name ? entry.name.charAt(0).toUpperCase() : '?';
              }
              const label = document.createElement('span');
              label.textContent = entry.name || (kidMode ? 'Pal' : 'Unknown Pal');
              palBtn.appendChild(avatar);
              palBtn.appendChild(label);
              palWrap.appendChild(palBtn);
            });
            card.appendChild(palWrap);
          }

          partnerGrid.appendChild(card);
        });

        partnerCount.textContent = visible === totalSkills
          ? `${visible} partner skills listed.`
          : `Showing ${visible} of ${totalSkills} partner skills.`;
        partnerEmpty.hidden = visible !== 0;
      }

      updatePartnerCategoryButtons();
      partnerSearch.addEventListener('input', renderPartnerSkills);
      renderPartnerSkills();

      const passiveDescription = kidMode
        ? 'All partner traits pals can roll. Tap a trait to read what it does.'
        : 'Complete alphabetical list of every passive trait. Select any entry for detailed effects.';
      const passiveSection = createSection('glossary-passives', 'Passive Skills', passiveDescription);
      const passiveSearch = createSearch(kidMode ? 'Search passive traits…' : 'Filter passive traits…');
      passiveSection.appendChild(passiveSearch);
      const passiveCount = document.createElement('p');
      passiveCount.className = 'glossary-count';
      passiveSection.appendChild(passiveCount);
      const passiveWrap = document.createElement('div');
      passiveWrap.className = 'glossary-chip-grid';
      passiveSection.appendChild(passiveWrap);
      const passiveEmpty = document.createElement('p');
      passiveEmpty.className = 'glossary-empty';
      passiveEmpty.textContent = kidMode
        ? 'No passives found. Try a different word.'
        : 'No passive traits match your search.';
      passiveEmpty.hidden = true;
      passiveSection.appendChild(passiveEmpty);

      const passiveEntries = Object.keys(traitsDictionary || {})
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      passiveEntries.forEach(trait => {
        const description = typeof traitsDictionary[trait] === 'string' ? traitsDictionary[trait] : '';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip passive';
        btn.dataset.trait = trait;
        const slug = slugifyForPalworld(trait);
        if (slug) {
          btn.id = `passive-${slug}`;
        }
        btn.title = description || trait;
        btn.textContent = trait;
        btn.dataset.search = `${trait} ${description}`.toLowerCase();
        passiveWrap.appendChild(btn);
      });

      const totalPassives = passiveEntries.length;
      function filterPassives() {
        const term = passiveSearch.value.trim().toLowerCase();
        let visible = 0;
        passiveWrap.querySelectorAll('.chip.passive').forEach(btn => {
          const searchable = btn.dataset.search || '';
          const matches = !term || searchable.includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        passiveCount.textContent = totalPassives
          ? (visible === totalPassives
            ? `${totalPassives} passive traits listed.`
            : `Showing ${visible} of ${totalPassives} passive traits.`)
          : 'No passive traits available.';
        passiveEmpty.hidden = visible !== 0;
      }
      filterPassives();
      passiveSearch.addEventListener('input', filterPassives);

      const activeDescription = kidMode
        ? 'Every move pals can learn. Search by name, element or effect.'
        : 'Complete catalogue of partner and weapon skills. Filter by name, element or effect.';
      const activeSection = createSection('glossary-active', 'Active Skills', activeDescription);
      const rainbowCallout = document.createElement('div');
      rainbowCallout.className = 'glossary-callout';
      rainbowCallout.innerHTML = `<strong>Rainbow skills</strong>Rainbow-fruit moves ignore normal type weaknesses and resistances, so they deal steady damage even when enemies resist your pal’s element. They can be taught to any pal, making them perfect coverage options for favourite partners.`;
      activeSection.appendChild(rainbowCallout);

      const skillSearch = createSearch(kidMode ? 'Search active skills…' : 'Filter active skills by name, element or effect…');
      activeSection.appendChild(skillSearch);
      const skillCount = document.createElement('p');
      skillCount.className = 'glossary-count';
      activeSection.appendChild(skillCount);
      const skillsWrap = document.createElement('div');
      skillsWrap.className = 'glossary-skill-grid';
      activeSection.appendChild(skillsWrap);
      const skillEmpty = document.createElement('p');
      skillEmpty.className = 'glossary-empty';
      skillEmpty.textContent = kidMode
        ? 'No skills found. Try another word or element.'
        : 'No active skills match your filters.';
      skillEmpty.hidden = true;
      activeSection.appendChild(skillEmpty);

      const skillEntriesMap = new Map();
      Object.entries(normalizedSkillDetails).forEach(([key, info]) => {
        skillEntriesMap.set(key, {
          key,
          displayName: info.name || key,
          element: info.element || 'Unknown',
          power: typeof info.power === 'number' ? info.power : null,
          cooldown: typeof info.ct === 'number' ? info.ct : null,
          description: info.description || ''
        });
      });
      Object.entries(skillsDictionary || {}).forEach(([rawKey, info = {}]) => {
        const normalizedKey = rawKey.toLowerCase();
        const existing = skillEntriesMap.get(normalizedKey);
        const baseName = info.name || niceName(rawKey);
        const fallbackPower = typeof info.power === 'number'
          ? info.power
          : (() => {
              const match = (info.damage || '').match(/(\d+)/);
              return match ? Number(match[1]) : null;
            })();
        const description = info.description || existing?.description || '';
        const element = (existing && existing.element && existing.element !== 'Unknown')
          ? existing.element
          : (info.element || info.type || 'Unknown');
        const cooldown = existing?.cooldown != null ? existing.cooldown : null;
        const merged = {
          key: normalizedKey,
          displayName: baseName,
          element,
          power: existing?.power != null ? existing.power : fallbackPower,
          cooldown,
          description
        };
        skillEntriesMap.set(normalizedKey, { ...existing, ...merged });
      });

      const skillEntries = Array.from(skillEntriesMap.values())
        .filter(entry => entry && entry.displayName)
        .sort((a, b) => a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' }));
      skillEntries.forEach(entry => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'glossary-skill';
        btn.dataset.skill = entry.key;
        const slug = slugifyForPalworld(entry.displayName);
        if (slug) {
          btn.id = `move-${slug}`;
        }
        const metaBits = [];
        if (typeof entry.power === 'number' && !Number.isNaN(entry.power)) {
          metaBits.push(`Power ${entry.power}`);
        }
        if (typeof entry.cooldown === 'number' && !Number.isNaN(entry.cooldown)) {
          metaBits.push(`CT ${entry.cooldown}s`);
        }
        const metaText = metaBits.join(' • ');
        btn.innerHTML = `
          <span class="glossary-skill__header">
            <span class="glossary-skill__name">${escapeHTML(entry.displayName)}</span>
            <span class="glossary-skill__element">${escapeHTML(entry.element || 'Unknown')}</span>
          </span>
          ${metaText ? `<span class="glossary-skill__meta">${escapeHTML(metaText)}</span>` : ''}
          <span class="glossary-skill__description">${escapeHTML(entry.description || 'No description available.')}</span>
        `;
        const searchableChunks = [
          entry.displayName,
          entry.element,
          entry.description,
          metaText
        ].filter(Boolean);
        btn.dataset.search = searchableChunks.join(' ').toLowerCase();
        skillsWrap.appendChild(btn);
      });

      const totalSkills = skillEntries.length;
      function filterSkills() {
        const term = skillSearch.value.trim().toLowerCase();
        let visible = 0;
        skillsWrap.querySelectorAll('.glossary-skill').forEach(btn => {
          const matches = !term || (btn.dataset.search || '').includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        skillCount.textContent = totalSkills
          ? (visible === totalSkills
            ? `${totalSkills} active skills listed.`
            : `Showing ${visible} of ${totalSkills} active skills.`)
          : 'No active skills available.';
        skillEmpty.hidden = visible !== 0;
      }
      filterSkills();
      skillSearch.addEventListener('input', filterSkills);

      if (!container.dataset.listenerBound) {
        container.addEventListener('click', (e) => {
          const passiveBtn = e.target.closest('.chip.passive');
          if (passiveBtn) {
            e.preventDefault();
            const trait = passiveBtn.dataset.trait;
            showTraitDetail(trait);
            return;
          }
          const workPalCard = e.target.closest('.work-pal-card');
          if (workPalCard && workPalCard.dataset.palId) {
            e.preventDefault();
            showPalDetail(workPalCard.dataset.palId);
            return;
          }
          const partnerPalBtn = e.target.closest('.partner-skill-card__pal');
          if (partnerPalBtn) {
            e.preventDefault();
            const palId = partnerPalBtn.dataset.palId;
            if (palId) {
              showPalDetail(palId);
            }
            return;
          }
          const moveBtn = e.target.closest('.glossary-skill');
          if (moveBtn) {
            e.preventDefault();
            const key = moveBtn.dataset.skill;
            showSkillDetail(key);
          }
        });
        container.dataset.listenerBound = 'true';
      }
    }

    // Map page builder.  Creates toggles for different layers and
    // instructions to open the external interactive map.  We do not
    // re‑host community map tiles; instead we encourage opening
    // palworld.gg with the appropriate filters.  A simple overlay is
    // available via environment highlights but hidden by default.
    function buildMapPage() {
      const layers = document.getElementById('mapLayers');
      if (!layers) return;
      layers.innerHTML = '';
      const categories = [
        { name: 'Pals', desc: 'See spawn locations on the external map', url: 'https://palworld.gg/map' },
        { name: 'Alpha Pals', desc: 'Locate strong alpha variants', url: 'https://palworld.gg/map' },
        { name: 'Towers', desc: 'Find tower bosses and fast travel points', url: 'https://palworld.gg/map' },
        { name: 'Dungeons', desc: 'Open map to see dungeon entrances', url: 'https://palworld.gg/map' },
        { name: 'Effigies', desc: 'Locate Lifmunk Effigies for free levels', url: 'https://palworld.gg/map' },
        { name: 'Skill Fruit Trees', desc: 'Find Skill Fruit trees to learn moves', url: 'https://palworld.gg/map' },
        { name: 'Fast Travel', desc: 'Discover fast travel statues', url: 'https://palworld.gg/map' }
      ];
      categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = 'collect-btn';
        btn.style.margin = '4px';
        btn.textContent = cat.name;
        btn.addEventListener('click', () => {
          window.open(cat.url, '_blank');
        });
        layers.appendChild(btn);
      });
    }
    function buildProgressPage() {
      const guideText = document.getElementById('guideProgressText');
      if (guideText) {
        guideText.textContent = kidMode
          ? 'Check off story steps to power up this bar!'
          : 'Check off route steps to track your run.';
      }
      const towersBadge = document.getElementById('towersClearedBadge');
      if (towersBadge) {
        towersBadge.textContent = 'Towers cleared: 0/0';
      }
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = kidMode
          ? 'Catch pals to fill your squad meter.'
          : 'Mark pals as caught to track your crew.';
      }
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = kidMode
          ? 'Unlock new gadgets to light up this meter.'
          : 'Unlock tech to power up your workshop.';
      }
      const routeLead = document.getElementById('progressRouteLead');
      if (routeLead) {
        routeLead.textContent = kidMode
          ? 'Check tower victories, next big steps, and filters without leaving this hub.'
          : 'Review tower progress, upcoming priorities, and tune filters from the progress dashboard.';
      }
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        btn.textContent = routeOptionalToggleLabel(routeHideOptional);
        btn.setAttribute('aria-pressed', routeHideOptional ? 'true' : 'false');
      });
      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        btn.disabled = true;
        btn.textContent = kidMode ? 'Loading next step…' : 'Loading next step…';
        btn.dataset.stepId = '';
      });
      const resetGuideBtn = document.getElementById('resetRouteProgress');
      if (resetGuideBtn) {
        resetGuideBtn.onclick = () => {
          if (confirm('Reset all guide progress?')) {
            localStorage.removeItem(ROUTE_STORAGE_KEY);
            routeState = {};
            renderRouteGuide();
            updateProgressUI();
          }
        };
      }
    }
    // Update progress bars
    function updateProgressUI() {
      const palsFallback = kidMode
        ? 'Catch pals to fill your squad meter.'
        : 'Mark pals as caught to track your crew.';
      const techFallback = kidMode
        ? 'Unlock new gadgets to light up this meter.'
        : 'Unlock tech to power up your workshop.';
      const guideFallback = kidMode
        ? 'Check off story steps to power up this bar!'
        : 'Check off route steps to track your run.';

      const totalPals = Object.keys(PALS).length;
      const caughtCount = Object.keys(caught).filter(k => caught[k]).length;
      const palsPct = totalPals ? Math.round((caughtCount / totalPals) * 100) : 0;
      const palsBar = document.getElementById('palsProgress');
      if (palsBar) palsBar.style.width = palsPct + '%';
      const palsMeter = document.getElementById('palsProgressMeter');
      if (palsMeter) palsMeter.setAttribute('aria-valuenow', palsPct);
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = totalPals
          ? `${caughtCount} / ${totalPals} pals recruited`
          : palsFallback;
      }
      const homePalsBar = document.getElementById('homePalsProgressBar');
      if (homePalsBar) homePalsBar.style.width = palsPct + '%';
      const homePalsMeter = document.getElementById('homePalsProgressMeter');
      if (homePalsMeter) homePalsMeter.setAttribute('aria-valuenow', palsPct);
      const homePalsText = document.getElementById('homePalsProgressText');
      if (homePalsText) {
        if (totalPals) {
          homePalsText.textContent = kidMode
            ? `${caughtCount} pals recruited so far`
            : `${caughtCount} / ${totalPals} pals recruited`;
        } else {
          homePalsText.textContent = palsFallback;
        }
      }

      const homePalsNext = document.getElementById('homePalsNext');
      if (homePalsNext) {
        const nextPal = findNextPalTarget();
        if (nextPal) {
          const typeLabel = Array.isArray(nextPal.types) && nextPal.types.length
            ? nextPal.types.join(kidMode ? ' & ' : ' / ')
            : (kidMode ? 'Mystery type' : 'Type unknown');
          homePalsNext.textContent = kidMode
            ? `Next recruit: ${nextPal.name}`
            : `Next recruit: ${nextPal.name} — ${typeLabel}`;
          homePalsNext.dataset.palId = nextPal.id || '';
        } else {
          homePalsNext.textContent = caughtCount && totalPals
            ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete! Open the pal list to revisit favourites.')
            : (kidMode ? 'Pal list loading…' : 'Pal data loading…');
          homePalsNext.dataset.palId = '';
        }
        homePalsNext.disabled = false;
      }

      let totalRecipes = 0;
      (Array.isArray(TECH) ? TECH : []).forEach(lvl => {
        if (lvl && Array.isArray(lvl.items)) {
          totalRecipes += lvl.items.length;
        }
      });
      const unlockedCount = Object.keys(unlocked).filter(k => unlocked[k]).length;
      const techPct = totalRecipes ? Math.round((unlockedCount / totalRecipes) * 100) : 0;
      const techBar = document.getElementById('techProgress');
      if (techBar) techBar.style.width = techPct + '%';
      const techMeter = document.getElementById('techProgressMeter');
      if (techMeter) techMeter.setAttribute('aria-valuenow', techPct);
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = totalRecipes
          ? `${unlockedCount} / ${totalRecipes} inventions unlocked`
          : techFallback;
      }
      const homeTechBar = document.getElementById('homeTechProgressBar');
      if (homeTechBar) homeTechBar.style.width = techPct + '%';
      const homeTechMeter = document.getElementById('homeTechProgressMeter');
      if (homeTechMeter) homeTechMeter.setAttribute('aria-valuenow', techPct);
      const homeTechText = document.getElementById('homeTechProgressText');
      if (homeTechText) {
        if (totalRecipes) {
          homeTechText.textContent = kidMode
            ? `${unlockedCount} inventions unlocked`
            : `${unlockedCount} / ${totalRecipes} inventions unlocked`;
        } else {
          homeTechText.textContent = techFallback;
        }
      }

      const nextTech = findNextTechUnlock();
      const homeTechNext = document.getElementById('homeTechNext');
      if (homeTechNext) {
        if (nextTech && nextTech.item) {
          const levelLabel = nextTech.level && nextTech.level.level != null
            ? `Lv ${nextTech.level.level}`
            : (kidMode ? '' : 'Lv ?');
          homeTechNext.textContent = kidMode
            ? `Next unlock: ${nextTech.item.name}${levelLabel ? ` (${levelLabel})` : ''}`
            : `Next unlock: ${levelLabel || 'Level ?'} — ${nextTech.item.name}`;
          homeTechNext.dataset.techKey = nextTech.techKey || '';
        } else {
          homeTechNext.textContent = kidMode
            ? 'Workshop complete! Explore favourites.'
            : 'Workshop complete! Review unlocked blueprints anytime.';
          homeTechNext.dataset.techKey = '';
        }
        homeTechNext.disabled = false;
      }

      const guideSummary = calculateGuideProgressSummary();
      const guideBar = document.getElementById('guideProgress');
      if (guideBar) guideBar.style.width = guideSummary.percent + '%';
      const guideMeter = document.getElementById('guideProgressMeter');
      if (guideMeter) guideMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const guideText = document.getElementById('guideProgressText');
      const coreRouteStats = guideSummary.routes?.core || { total: 0, complete: 0 };
      if (guideText) {
        if (guideSummary.requiredTotal) {
          const stepLine = `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} guide steps complete`;
          const routeLine = coreRouteStats.total
            ? ` • ${coreRouteStats.complete}/${coreRouteStats.total} core routes cleared`
            : '';
          guideText.textContent = stepLine + routeLine;
        } else {
          guideText.textContent = guideFallback;
        }
      }
      const homeRouteBar = document.getElementById('homeRouteProgressBar');
      if (homeRouteBar) homeRouteBar.style.width = guideSummary.percent + '%';
      const homeRouteMeter = document.getElementById('homeRouteProgressMeter');
      if (homeRouteMeter) homeRouteMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const homeRouteText = document.getElementById('homeRouteProgressText');
      if (homeRouteText) {
        if (guideSummary.requiredTotal) {
          const routeLine = coreRouteStats.total
            ? kidMode
              ? ` • ${coreRouteStats.complete}/${coreRouteStats.total} adventures`
              : ` • ${coreRouteStats.complete}/${coreRouteStats.total} core routes`
            : '';
          homeRouteText.textContent = kidMode
            ? `${guideSummary.requiredComplete} of ${guideSummary.requiredTotal} big steps done${routeLine}`
            : `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} required steps complete${routeLine}`;
        } else {
          homeRouteText.textContent = guideFallback;
        }
      }
      const homeRouteNext = document.getElementById('homeRouteNextStep');
      if (homeRouteNext) {
        const nextRequired = findNextRouteStep();
        const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });
        if (nextAny && nextAny.step) {
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopy = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const prefix = nextAny.step.optional && !nextRequired
            ? (kidMode ? 'Bonus step' : 'Optional step')
            : (kidMode ? 'Next step' : 'Next required step');
          const chapterHtml = chapterTitle ? ` — <strong>${escapeHTML(chapterTitle)}</strong>` : '';
          homeRouteNext.innerHTML = `${escapeHTML(prefix)}${chapterHtml}<br>${escapeHTML(stepCopy)}`;
          homeRouteNext.dataset.stepId = nextAny.step.id || '';
        } else {
          homeRouteNext.textContent = kidMode
            ? 'Guide complete! Revisit bonus adventures anytime.'
            : 'Guide complete! Revisit optional chores or rerun towers.';
          homeRouteNext.dataset.stepId = '';
        }
        homeRouteNext.disabled = false;
      }
      const towersBadge = document.getElementById('towersClearedBadge');
      if (towersBadge) {
        towersBadge.textContent = guideSummary.towersTotal
          ? `Towers cleared: ${guideSummary.towersComplete}/${guideSummary.towersTotal}`
          : 'Towers cleared: 0/0';
      }

      const spotlightBtn = document.getElementById('homePalSpotlight');
      if (spotlightBtn) {
        const primaryPal = findNextPalTarget();
        const spotlightPal = primaryPal || findRandomPalCandidate();
        if (spotlightPal) {
          const typeLabel = Array.isArray(spotlightPal.types) && spotlightPal.types.length
            ? spotlightPal.types.join(' • ')
            : '';
          const metaText = primaryPal
            ? (kidMode ? 'Next pal to recruit' : 'Next pal to recruit')
            : (caughtCount === totalPals && totalPals
              ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete — browse pals anytime.')
              : (kidMode ? 'Suggested pal to train next' : 'Suggested pal to train next'));
          const typesHtml = typeLabel
            ? `<span class="home-spotlight-card__types">${escapeHTML(typeLabel)}</span>`
            : '';
          spotlightBtn.innerHTML = `
            <img alt="">
            <div class="home-spotlight-card__text">
              <span class="home-spotlight-card__title">${escapeHTML(spotlightPal.name || 'Pal')}</span>
              <span class="home-spotlight-card__meta">${escapeHTML(metaText)}</span>
              ${typesHtml}
            </div>
          `;
          const spotlightImg = spotlightBtn.querySelector('img');
          applyPalArtwork(spotlightImg, spotlightPal, { alt: `${spotlightPal.name || 'Pal'} portrait` });
          spotlightBtn.dataset.palId = spotlightPal.id || '';
          spotlightBtn.disabled = false;
        } else {
          spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Pal data loading…</span><span class="home-spotlight-card__meta">Keep playing while we fetch pals.</span></div>';
          spotlightBtn.dataset.palId = '';
          spotlightBtn.disabled = true;
        }
      }
      updateRouteOverviewUI(guideSummary);
      updateBasePlanner();
    }

    // Display detailed information about an item using a Palworld-inspired card.
    function openItemDetail(itemKey) {
      const item = ITEMS[itemKey] || {};
      const detail = ITEM_DETAILS[itemKey] || {};
      if (!Object.keys(item).length && !Object.keys(detail).length) return;
      const human = detail.name || humaniseItemKey(itemKey);
      const slug = PALWORLD_ITEM_SLUG_OVERRIDES[itemKey] || slugifyForPalworld(human);
      const itemUrl = slug ? `${PALWORLD_BASE_URL}/item/${slug}` : `${PALWORLD_BASE_URL}/items`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(human)}`;
      const drops = (DROPS_MAP[itemKey] || []).slice();
      const collectedStatus = !!collected[itemKey];
      const recipes = [];
      const ranchProducers = Array.isArray(detail.ranchProducers)
        ? detail.ranchProducers
        : (Array.isArray(item.ranchProducers) ? item.ranchProducers : []);
      const categoryLabel = detail.type || item.category || 'Item';
      TECH.forEach(level => {
        level.items.forEach(it => {
          if (it.materials && it.materials[itemKey]) {
            recipes.push({ name: it.name, qty: it.materials[itemKey], level: level.level });
          }
        });
      });
      modalBody.innerHTML = '';
      const card = document.createElement('article');
      card.className = 'item-detail-card';

      const header = document.createElement('div');
      header.className = 'item-detail-header';
      const headingWrap = document.createElement('div');
      headingWrap.className = 'item-detail-heading';
      const art = document.createElement('div');
      art.className = 'item-detail-image';
      const renderPlaceholder = () => {
        if (!art.querySelector('.item-detail-placeholder')) {
          const placeholder = document.createElement('div');
          placeholder.className = 'item-detail-placeholder';
          placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
          art.appendChild(placeholder);
        }
      };
      if (detail.image) {
        const img = document.createElement('img');
        img.src = detail.image;
        img.alt = human;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.referrerPolicy = 'no-referrer';
        img.onerror = () => {
          img.remove();
          renderPlaceholder();
        };
        art.appendChild(img);
      }
      if (!art.hasChildNodes()) {
        renderPlaceholder();
      }
      const meta = document.createElement('div');
      meta.className = 'item-detail-meta';
      const titleEl = document.createElement('h3');
      titleEl.textContent = human;
      const typeEl = document.createElement('span');
      const typeLabel = categoryLabel;
      typeEl.className = 'type-tag';
      typeEl.textContent = typeLabel;
      meta.appendChild(titleEl);
      meta.appendChild(typeEl);
      headingWrap.appendChild(art);
      headingWrap.appendChild(meta);
      header.appendChild(headingWrap);
      const collectBtn = document.createElement('button');
      collectBtn.className = `detail-collect-btn${collectedStatus ? ' collected' : ''}`;
      collectBtn.textContent = collectedStatus ? 'Collected' : 'Mark as collected';
      collectBtn.addEventListener('click', () => {
        collected[itemKey] = !collected[itemKey];
        localStorage.setItem('collected', JSON.stringify(collected));
        const state = !!collected[itemKey];
        collectBtn.classList.toggle('collected', state);
        collectBtn.textContent = state ? 'Collected' : 'Mark as collected';
        updateItemCollectionButtons(itemKey);
        updateProgressUI();
        playSound(clickSound);
      });
      header.appendChild(collectBtn);
      card.appendChild(header);

      const descriptionLines = Array.isArray(detail.description) && detail.description.length
        ? detail.description
        : [`${human} belongs to the ${categoryLabel} family.`];
      const descWrapper = document.createElement('div');
      descWrapper.className = 'item-detail-description';
      const maxParagraphs = kidMode ? Math.min(2, descriptionLines.length) : descriptionLines.length;
      for (let idx = 0; idx < maxParagraphs; idx += 1) {
        const p = document.createElement('p');
        p.textContent = descriptionLines[idx];
        descWrapper.appendChild(p);
      }
      card.appendChild(descWrapper);

      const statsEntries = Object.entries(detail.stats || {});
      if (categoryLabel && !statsEntries.some(entry => entry[0].toLowerCase() === 'category')) {
        statsEntries.push(['Category', categoryLabel]);
      }
      if (statsEntries.length) {
        const statGrid = document.createElement('div');
        statGrid.className = 'item-detail-stats';
        statsEntries.forEach(([label, value]) => {
          const pill = document.createElement('div');
          pill.className = 'stat-pill';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'label';
          labelSpan.textContent = label;
          const valueSpan = document.createElement('span');
          valueSpan.className = 'value';
          valueSpan.textContent = value;
          pill.appendChild(labelSpan);
          pill.appendChild(valueSpan);
          statGrid.appendChild(pill);
        });
        card.appendChild(statGrid);
      }

      const summarySection = document.createElement('section');
      summarySection.className = 'item-detail-section item-detail-summary';
      const summaryHeading = document.createElement('h4');
      summaryHeading.textContent = kidMode ? 'Quick Take' : 'Tracker Notes';
      summarySection.appendChild(summaryHeading);
      if (kidMode) {
        const dropPreview = drops.length ? drops.slice(0, 4).join(', ') + (drops.length > 4 ? '…' : '') : 'Not sure yet';
        const ranchPreview = ranchProducers.length
          ? ranchProducers.slice(0, 4).join(', ') + (ranchProducers.length > 4 ? '…' : '')
          : 'Not recorded yet';
        const summaryLines = [
          `Status: ${collectedStatus ? 'We have this item!' : 'Let’s go find this!'}`,
          `Item type: ${typeLabel}`,
          `Find it from: ${dropPreview}`,
          `Ranch pals: ${ranchPreview}`
        ];
        if (recipes.length) {
          summaryLines.push(`Used for: ${recipes.length} tech unlock${recipes.length === 1 ? '' : 's'}.`);
        }
        summaryLines.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          summarySection.appendChild(p);
        });
      } else {
        const summaryList = document.createElement('ul');
        const lines = [
          `Tracking status: ${collectedStatus ? 'Collected' : 'Not collected yet'}`,
          `Category: ${categoryLabel}`,
          drops.length ? `Drops recorded: ${drops.length}` : 'Drops recorded: none yet',
          ranchProducers.length
            ? `Ranch producers: ${ranchProducers.join(', ')}`
            : 'Ranch producers: none recorded yet',
          recipes.length ? `Tech unlocks: ${recipes.length} recipe${recipes.length === 1 ? '' : 's'} listed below.` : 'Tech unlocks: none recorded yet.'
        ];
        if (detail.fromPalworld === false) {
          lines.push('Data source: Palmate placeholder entry until Palworld.gg publishes more info.');
        } else {
          lines.push('Data source: Palworld.gg item compendium.');
        }
        lines.forEach(text => {
          const li = document.createElement('li');
          li.textContent = text;
          summaryList.appendChild(li);
        });
        summarySection.appendChild(summaryList);
      }
      card.appendChild(summarySection);

      const dropSection = document.createElement('section');
      dropSection.className = 'item-detail-section';
      const dropHeading = document.createElement('h4');
      dropHeading.textContent = 'Dropped by';
      dropSection.appendChild(dropHeading);
      if (drops.length) {
        const dropList = document.createElement('div');
        dropList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, drops.length) : drops.length;
        drops.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          dropList.appendChild(chip);
        });
        if (drops.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${drops.length - limit} more`;
          dropList.appendChild(more);
        }
        dropSection.appendChild(dropList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to drop this item yet.';
        dropSection.appendChild(none);
      }
      card.appendChild(dropSection);

      const ranchSection = document.createElement('section');
      ranchSection.className = 'item-detail-section';
      const ranchHeading = document.createElement('h4');
      ranchHeading.textContent = 'Ranch producers';
      ranchSection.appendChild(ranchHeading);
      if (ranchProducers.length) {
        const ranchList = document.createElement('div');
        ranchList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, ranchProducers.length) : ranchProducers.length;
        ranchProducers.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          ranchList.appendChild(chip);
        });
        if (ranchProducers.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${ranchProducers.length - limit} more`;
          ranchList.appendChild(more);
        }
        ranchSection.appendChild(ranchList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to produce this item at the ranch yet.';
        ranchSection.appendChild(none);
      }
      card.appendChild(ranchSection);

      if (Array.isArray(detail.recipe) && detail.recipe.length) {
        const recipeSection = document.createElement('section');
        recipeSection.className = 'item-detail-section';
        const recipeHeading = document.createElement('h4');
        recipeHeading.textContent = 'Crafting recipe';
        recipeSection.appendChild(recipeHeading);
        const ingredientGrid = document.createElement('div');
        ingredientGrid.className = 'ingredient-grid';
        detail.recipe.forEach(entry => {
          const ingredientCard = document.createElement('div');
          ingredientCard.className = 'ingredient-card';
          if (entry.icon) {
            const img = document.createElement('img');
            img.src = entry.icon;
            img.alt = entry.name;
            img.loading = 'lazy';
            ingredientCard.appendChild(img);
          }
          const textWrap = document.createElement('div');
          textWrap.className = 'ingredient-text';
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = entry.name;
          textWrap.appendChild(nameEl);
          if (entry.quantity) {
            const qty = document.createElement('div');
            qty.textContent = `x${entry.quantity}`;
            textWrap.appendChild(qty);
          }
          ingredientCard.appendChild(textWrap);
          ingredientGrid.appendChild(ingredientCard);
        });
        recipeSection.appendChild(ingredientGrid);
        card.appendChild(recipeSection);
      }

      if (recipes.length) {
        const techSection = document.createElement('section');
        techSection.className = 'item-detail-section';
        const techHeading = document.createElement('h4');
        techHeading.textContent = 'Used in tech';
        techSection.appendChild(techHeading);
        const techList = document.createElement('ul');
        const maxEntries = kidMode ? Math.min(5, recipes.length) : recipes.length;
        recipes.slice(0, maxEntries).forEach(recipe => {
          const li = document.createElement('li');
          li.textContent = `Level ${recipe.level}: ${recipe.name} (x${recipe.qty})`;
          techList.appendChild(li);
        });
        if (recipes.length > maxEntries) {
          const li = document.createElement('li');
          li.textContent = `+${recipes.length - maxEntries} more unlock${recipes.length - maxEntries === 1 ? '' : 's'} in higher tiers.`;
          techList.appendChild(li);
        }
        techSection.appendChild(techList);
        card.appendChild(techSection);
      }

      const footer = document.createElement('div');
      footer.className = 'item-detail-footer';
      const link = document.createElement('a');
      link.href = slug ? itemUrl : fallbackUrl;
      link.target = '_blank';
      link.rel = 'noopener';
      link.textContent = detail.fromPalworld === false ? 'Search on Palworld.gg' : 'View on Palworld.gg';
      footer.appendChild(link);
      const note = document.createElement('p');
      note.className = 'item-detail-note';
      note.textContent = detail.fromPalworld === false
        ? 'Palworld.gg has not published a full entry for this item yet. Details shown use Palmate data.'
        : 'Stats, art, and rarities mirror the Palworld.gg item database.';
      footer.appendChild(note);
      card.appendChild(footer);

      modalBody.appendChild(card);
      openModal();
    }

    // Show details about an active skill.  Looks up the skill in the
    // dictionary; if it’s missing we display a generic placeholder.
    function showSkillDetail(key) {
      const normalisedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
      const info = skillsDictionary[normalisedKey] || skillsDictionary[key] || { name: key.replace(/_/g,' '), damage: 'Unknown', type: 'Unknown', description: 'This skill\'s effects are a mystery! Try it out in battle.' };
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${info.name}</h3><p><strong>Damage:</strong> ${info.damage}</p><p><strong>Type:</strong> ${info.type}</p><p>${info.description}</p>`;
      modalBody.appendChild(div);
      openModal();
    }

    // Show details about a passive trait.  Retrieves the description
    // from the trait dictionary.  Unknown traits yield a default
    // explanation encouraging exploration.
    function showTraitDetail(name) {
      const desc = traitsDictionary[name] || 'This trait has mysterious effects that aren\'t fully documented. See how it behaves in-game!';
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${name}</h3><p>${desc}</p>`;
      modalBody.appendChild(div);
      openModal();
    }
  </script>
</body>
</html>
