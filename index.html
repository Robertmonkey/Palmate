<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Palmate – Palworld Companion</title>
  <!-- Chart.js for radar charts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <!-- Font Awesome for interface icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  <link rel="stylesheet" href="css/styles.css">
  <script type="module" src="js/guide-bundle.js"></script>
  <!-- Core styles: cosmic blue theme with smooth scrollbars -->
  <style>
    /*
      Colour palette for our epic cosmic theme.  We move away from the
      flat blues of the original and embrace rich purples and golds
      inspired by the Palworld universe.  These variables define the
      background, primary and secondary navigation colours, accent
      highlights, light text, card backgrounds and success/danger
      notifications.  Feel free to tweak these values for your own
      flavour.
    */
    :root {
      /*
        Updated colour palette to give the UI a warmer, more inviting
        atmosphere.  The dark navy base contrasts with desaturated
        blues and soft greens, while the accent colour pops against
        the card backgrounds.  Light colours are slightly brighter to
        improve readability for younger players.  Feel free to tweak
        these values to suit your own tastes.
      */
      --bg: #0d1b2a;
      --primary: #1b263b;
      --secondary: #415a77;
      --accent: #778da9;
      --light: #e0e1dd;
      --card-bg: #1e3246;
      --card-hover: #2e4a62;
      --text: #f0f4f8;
      --muted: rgba(224,225,221,0.7);
      --danger: #e76f51;
      --success: #2a9d8f;
      --layout-max-width: clamp(1200px, 92vw, 1640px);
      --layout-page-padding: clamp(16px, 3vw, 32px);
    }
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      /* Set a cosmic background image across the entire page.  We use
         background-attachment: fixed so the stars stay put as you
         scroll, lending a sense of depth.  The fallback colour
         ensures readability while the image loads. */
      background: var(--bg) url('assets/images/background.png') center/cover fixed no-repeat;
      color: var(--text);
      font-family: "Trebuchet MS", sans-serif;
      height: 100%;
    }
    body {
      display: flex;
      flex-direction: column;
      min-height: 100dvh;
      overflow-x: hidden;
      line-height: 1.6;
    }
    /* Remove the old #app layout (previously used for sidebar).  The
       content area now sits below the navbar and fills the remaining
       space. */
    /* Top navigation bar styling */
    #navbar {
      position: sticky;
      top: 0;
      z-index: 10;
      background: var(--primary);
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      width: 100%;
    }
    #navbar .nav-shell {
      --navbar-padding-block: clamp(10px, 2vw, 18px);
      display: flex;
      align-items: center;
      gap: 12px;
      width: min(100%, var(--layout-max-width));
      margin: 0 auto;
      padding-inline: clamp(12px, 3vw, 28px);
      padding-block: var(--navbar-padding-block);
      padding-block-start: calc(env(safe-area-inset-top, 0px) + var(--navbar-padding-block));
    }
    .nav-brand {
      display: flex;
      align-items: center;
      gap: 12px;
      flex: 0 0 auto;
    }
    #navbar .logo {
      font-size: 1.4rem;
      font-weight: bold;
      letter-spacing: 1px;
      flex-shrink: 0;
    }
    .nav-links {
      display: flex;
      align-items: center;
      gap: 8px;
      flex: 1 1 auto;
      flex-wrap: wrap;
      row-gap: 6px;
      min-width: 0;
    }
    .nav-actions {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-left: auto;
      flex: 0 0 auto;
    }
    .nav-toggle {
      display: none;
      align-items: center;
      justify-content: center;
      width: 44px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid transparent;
      background: rgba(14, 32, 52, 0.35);
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .nav-toggle:hover,
    .nav-toggle:focus-visible {
      color: var(--accent);
      border-color: rgba(224, 225, 221, 0.25);
      background: rgba(14, 32, 52, 0.5);
      outline: none;
    }
    .sr-only {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    #navbar .nav-item {
      border: none;
      background: none;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 10px 16px;
      font-size: 0.9rem;
      cursor: pointer;
      border-bottom: 3px solid transparent;
      transition: border-color 0.3s, color 0.3s;
      flex: 0 0 auto;
      min-height: 44px;
    }
    #navbar .nav-item i {
      font-size: 1.1rem;
    }
    #navbar .nav-item:hover {
      color: var(--accent);
    }
    #navbar .nav-item.active {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Mode toggle button styling */
    .mode-btn {
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 10px;
      transition: color 0.3s;
      flex: 0 0 auto;
    }
    .mode-btn:hover {
      color: var(--accent);
    }

    @media (min-width: 900px) {
      #navbar .nav-shell {
        gap: clamp(8px, 1.5vw, 16px);
      }
      .nav-brand {
        min-width: 0;
      }
      .nav-links {
        flex-wrap: nowrap;
        justify-content: center;
        gap: clamp(4px, 0.7vw, 8px);
        padding-inline: clamp(0px, 0.6vw, 10px);
        overflow-x: auto;
        scrollbar-width: thin;
        scrollbar-color: rgba(119, 141, 169, 0.55) transparent;
        scrollbar-gutter: stable both-edges;
      }
      #navbar .nav-item {
        flex: 0 1 auto;
        justify-content: center;
        padding: 6px 10px;
      }
      .nav-links::-webkit-scrollbar {
        height: 6px;
      }
      .nav-links::-webkit-scrollbar-thumb {
        background: rgba(119, 141, 169, 0.55);
        border-radius: 999px;
      }
      .nav-links::-webkit-scrollbar-track {
        background: transparent;
      }
      .nav-actions {
        padding-left: clamp(2px, 0.8vw, 10px);
      }
    }

    @media (max-width: 720px) {
      #navbar .nav-shell {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .nav-brand {
        justify-content: space-between;
      }
      .nav-actions {
        width: 100%;
        justify-content: flex-end;
        margin-left: 0;
      }
      .nav-toggle {
        display: inline-flex;
      }
      .nav-links {
        display: none;
        flex-direction: column;
        gap: 6px;
        width: 100%;
        max-height: 0;
        overflow: hidden;
        padding: 0 12px;
        border-radius: 14px;
        border-top: 1px solid rgba(224, 225, 221, 0.08);
        background: rgba(13, 27, 42, 0.85);
        box-shadow: 0 0 0 rgba(0, 0, 0, 0);
      }
      #navbar[data-open="true"] .nav-shell {
        gap: 16px;
      }
      #navbar[data-open="true"] .nav-links {
        display: flex;
        max-height: 600px;
        padding-top: 8px;
        padding-bottom: 12px;
        box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
        border-top-color: rgba(224, 225, 221, 0.2);
      }
      .nav-links .nav-item {
        width: 100%;
        justify-content: flex-start;
      }
    }

    /* Kid mode adjustments: larger targets and font sizes, simplified cards */
    body.kid-mode .pal-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .item-card img {
      width: 120px;
      height: 120px;
    }
    body.kid-mode .pal-card .name,
    body.kid-mode .item-card .name {
      font-size: 1.2rem;
    }
    body.kid-mode .nav-item span {
      font-size: 1rem;
    }
    body.kid-mode .search-bar input {
      font-size: 1rem;
    }
    /* Main content area.  This section fills the page below the
       navbar.  We add a top margin equal to the navbar height to
       ensure the content does not scroll underneath it. */
    #content {
      flex: 1 1 auto;
      width: 100%;
      max-width: var(--layout-max-width);
      margin-inline: auto;
      margin-block: clamp(12px, 2vw, 24px) clamp(36px, 6vw, 72px);
      padding: var(--layout-page-padding);
    }
    .page {
      display: none;
    }
    .page.active {
      display: block;
    }
    .page > p {
      max-width: 68ch;
      margin-bottom: 24px;
    }
    .glossary-nav {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
      padding: 18px;
      margin: 0 0 28px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(13, 27, 42, 0.78), rgba(35, 68, 107, 0.62));
      box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.28);
      backdrop-filter: blur(12px);
    }
    .glossary-nav button {
      background: transparent;
      color: var(--text);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 9px 18px;
      font-size: 0.85rem;
      font-weight: 600;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .glossary-nav button:hover,
    .glossary-nav button:focus-visible {
      background: rgba(119, 141, 169, 0.16);
      border-color: var(--accent);
      transform: translateY(-1px);
      box-shadow: 0 6px 14px rgba(0, 0, 0, 0.25);
      outline: none;
    }
    .glossary-section {
      position: relative;
      padding: 24px;
      margin-bottom: 32px;
      border-radius: 22px;
      background: linear-gradient(155deg, rgba(12, 24, 38, 0.92), rgba(20, 42, 66, 0.82));
      box-shadow: 0 28px 48px rgba(2, 12, 24, 0.45);
      border: 1px solid rgba(119, 141, 169, 0.25);
      overflow: hidden;
    }
    .glossary-section::before {
      content: '';
      position: absolute;
      inset: -120px -120px auto auto;
      width: 220px;
      height: 220px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.18), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .glossary-section > * {
      position: relative;
      z-index: 1;
    }
    .glossary-section h3 {
      margin-top: 0;
      font-size: 1.6rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .glossary-search {
      width: 100%;
      padding: 12px 16px;
      margin: 18px 0 20px;
      border-radius: 14px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(9, 19, 33, 0.6);
      color: var(--text);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .glossary-search::placeholder {
      color: rgba(224, 225, 221, 0.55);
      letter-spacing: 0.02em;
    }
    .glossary-chip-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .glossary-skill-grid {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .glossary-count {
      margin: 0 0 14px;
      color: rgba(224, 225, 221, 0.75);
      font-size: 0.85rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
    }
    .glossary-empty {
      margin: 10px 0 0;
      font-style: italic;
      color: rgba(224, 225, 221, 0.6);
    }
    .chip.passive,
    .chip.move,
    .glossary-skill {
      transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .chip.passive:hover,
    .chip.passive:focus-visible,
    .chip.move:hover,
    .chip.move:focus-visible,
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      transform: translateY(-2px);
      outline: none;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      width: 100%;
      text-align: left;
      border: 1px solid rgba(119, 141, 169, 0.26);
      border-radius: 16px;
      padding: 18px 20px;
      background: linear-gradient(160deg, rgba(14, 27, 42, 0.92), rgba(21, 43, 67, 0.78));
      color: inherit;
      cursor: pointer;
      box-shadow: 0 16px 30px rgba(0, 0, 0, 0.35);
    }
    .glossary-skill:hover,
    .glossary-skill:focus-visible {
      border-color: var(--accent);
      background: linear-gradient(160deg, rgba(18, 36, 56, 0.95), rgba(32, 64, 98, 0.82));
    }
    .glossary-skill__header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      width: 100%;
      align-items: center;
      margin-bottom: 6px;
    }
    .glossary-skill__name {
      font-weight: 700;
      font-size: 1.05rem;
    }
    .glossary-skill__element {
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(119,141,169,0.25);
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.82);
    }
    .glossary-skill__meta {
      font-size: 0.8rem;
      color: rgba(224, 225, 221, 0.7);
      margin-bottom: 8px;
    }
    .glossary-skill__description {
      font-size: 0.92rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.86);
    }
    .glossary-callout {
      border-left: 4px solid var(--accent);
      padding: 16px 20px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(23, 46, 68, 0.85), rgba(42, 78, 108, 0.72));
      margin-bottom: 20px;
      font-size: 0.95rem;
      box-shadow: inset 0 0 0 1px rgba(119, 141, 169, 0.2);
    }
    .glossary-callout strong {
      display: block;
      font-size: 1.05rem;
      margin-bottom: 6px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .glossary-callout ul {
      margin: 8px 0 0;
      padding-left: 20px;
      color: rgba(224, 225, 221, 0.78);
      line-height: 1.45;
    }
    .glossary-callout li {
      margin-bottom: 4px;
    }
    .partner-filter-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 0 0 16px;
    }
    .partner-filter {
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.32);
      background: rgba(12, 26, 42, 0.65);
      color: var(--text);
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 7px 16px;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
    }
    .partner-filter:hover,
    .partner-filter:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      transform: translateY(-1px);
    }
    .partner-filter[aria-pressed="true"] {
      background: linear-gradient(135deg, rgba(35, 68, 107, 0.78), rgba(57, 102, 147, 0.72));
      border-color: var(--accent);
      box-shadow: 0 10px 24px rgba(7, 19, 38, 0.5);
    }
    .partner-skill-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .partner-skill-card {
      display: flex;
      flex-direction: column;
      gap: 12px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      border-radius: 18px;
      padding: 20px;
      background: linear-gradient(165deg, rgba(14, 28, 44, 0.92), rgba(26, 52, 78, 0.78));
      box-shadow: 0 18px 34px rgba(0, 0, 0, 0.38);
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
    }
    .partner-skill-card:hover,
    .partner-skill-card:focus-within {
      border-color: var(--accent);
      box-shadow: 0 22px 40px rgba(0, 0, 0, 0.42);
      transform: translateY(-2px);
      outline: none;
    }
    .partner-skill-card__header {
      display: flex;
      flex-wrap: wrap;
      align-items: baseline;
      justify-content: space-between;
      gap: 8px;
    }
    .partner-skill-card__name {
      font-size: 1.15rem;
      font-weight: 700;
      letter-spacing: 0.03em;
      flex: 1 1 auto;
    }
    .partner-skill-card__number {
      font-size: 0.78rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.2);
      border-radius: 999px;
      padding: 4px 10px;
      color: rgba(224, 225, 221, 0.75);
      flex: 0 0 auto;
    }
    .partner-skill-card__tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .partner-skill-card__tag {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.72rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.22);
      color: rgba(224, 225, 221, 0.86);
    }
    .partner-skill-card__tag--mount {
      background: rgba(129, 199, 245, 0.22);
      color: rgba(224, 242, 255, 0.9);
    }
    .partner-skill-card__tag--damage {
      background: rgba(255, 138, 101, 0.22);
      color: rgba(255, 214, 186, 0.92);
    }
    .partner-skill-card__tag--drops {
      background: rgba(144, 238, 144, 0.22);
      color: rgba(226, 255, 226, 0.88);
    }
    .partner-skill-card__description {
      font-size: 0.92rem;
      line-height: 1.55;
      color: rgba(224, 225, 221, 0.88);
    }
    .partner-skill-card__pals {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: auto;
    }
    .partner-skill-card__pal {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 5px 12px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.32);
      background: rgba(12, 24, 38, 0.7);
      color: inherit;
      font-size: 0.85rem;
      cursor: pointer;
      transition: border-color 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease, background 0.2s ease;
    }
    .partner-skill-card__pal:hover,
    .partner-skill-card__pal:focus-visible {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 10px 24px rgba(0, 0, 0, 0.38);
      transform: translateY(-1px);
    }
    .partner-skill-card__pal[aria-disabled="true"] {
      cursor: default;
      opacity: 0.7;
      border-style: dashed;
    }
    .partner-skill-card__pal-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      overflow: hidden;
      background: rgba(119, 141, 169, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 0 0 auto;
    }
    .partner-skill-card__pal-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .work-tier-legend {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px 18px;
      padding: 16px 20px;
      margin: 0 0 24px;
      border-radius: 16px;
      background: linear-gradient(135deg, rgba(17, 34, 51, 0.82), rgba(31, 58, 88, 0.7));
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }
    .work-tier-legend__label {
      font-size: 0.9rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-tier-legend__items {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }
    .work-tier-legend__item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-tier-badge {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 38px;
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      box-shadow: 0 0 0 1px rgba(12, 24, 38, 0.6), 0 6px 16px rgba(0, 0, 0, 0.35);
    }
    .work-tier-badge--ss {
      background: linear-gradient(135deg, #f6d365, #fda085);
      color: #1a1a1a;
    }
    .work-tier-badge--s {
      background: linear-gradient(135deg, #56ccf2, #2f80ed);
      color: #0b1a2a;
    }
    .work-tier-badge--a {
      background: linear-gradient(135deg, #6be67e, #2ecc71);
      color: #0b2214;
    }
    .work-tier-badge--b {
      background: linear-gradient(135deg, #f2c94c, #f2994a);
      color: #301b07;
    }
    .work-tier-badge--c {
      background: linear-gradient(135deg, #ff758f, #a83279);
      color: #fff;
    }
    .work-tier-badge--d {
      background: linear-gradient(135deg, rgba(149, 158, 174, 0.35), rgba(96, 110, 133, 0.3));
      color: rgba(224, 225, 221, 0.8);
    }
    .glossary-work-grid {
      display: grid;
      gap: 24px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .work-role-card {
      display: flex;
      flex-direction: column;
      gap: 18px;
      padding: 22px;
      border-radius: 20px;
      background: linear-gradient(165deg, rgba(10, 22, 37, 0.92), rgba(23, 46, 68, 0.78));
      border: 1px solid rgba(119, 141, 169, 0.24);
      box-shadow: 0 24px 44px rgba(0, 0, 0, 0.45);
    }
    .work-role-card__header {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }
    .work-role-card__icon {
      width: 56px;
      height: 56px;
      border-radius: 16px;
      display: grid;
      place-items: center;
      font-size: 2rem;
      background: linear-gradient(135deg, rgba(224, 225, 221, 0.12), rgba(119, 141, 169, 0.18));
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.18);
    }
    .work-role-card__titles {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-role-card__name {
      margin: 0;
      font-size: 1.25rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }
    .work-role-card__blurb {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
      color: rgba(224, 225, 221, 0.72);
    }
    .work-pal-grid {
      display: grid;
      gap: 14px;
    }
    @media (min-width: 540px) {
      .work-pal-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .work-pal-card {
      position: relative;
      display: flex;
      align-items: center;
      gap: 16px;
      width: 100%;
      padding: 16px 18px;
      border-radius: 18px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      background: linear-gradient(155deg, rgba(15, 32, 50, 0.9), rgba(31, 58, 88, 0.75));
      color: inherit;
      cursor: pointer;
      text-align: left;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.4);
      overflow: hidden;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .work-pal-card:hover,
    .work-pal-card:focus-visible {
      border-color: var(--accent);
      transform: translateY(-3px);
      box-shadow: 0 24px 46px rgba(0, 0, 0, 0.5);
      outline: none;
    }
    .work-pal-card::after {
      content: '';
      position: absolute;
      inset: -60px -60px auto auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(119, 141, 169, 0.16), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
    }
    .work-pal-card__rank {
      position: absolute;
      top: 12px;
      right: 16px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.75);
    }
    .work-pal-card__art {
      width: 76px;
      height: 76px;
      border-radius: 18px;
      background: rgba(5, 14, 26, 0.65);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.12);
      display: grid;
      place-items: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .work-pal-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.45));
    }
    .work-pal-card__placeholder {
      font-size: 1.6rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .work-pal-card__info {
      flex: 1;
      display: grid;
      gap: 6px;
      min-width: 0;
    }
    .work-pal-card__head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .work-pal-card__name {
      font-size: 1.05rem;
      font-weight: 700;
      letter-spacing: 0.02em;
    }
    .work-pal-card__skill {
      font-size: 0.85rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.7);
    }
    .work-skill-meter {
      position: relative;
      width: 100%;
      height: 10px;
      border-radius: 999px;
      background: rgba(8, 17, 30, 0.6);
      overflow: hidden;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.1);
    }
    .work-skill-meter__fill {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background: linear-gradient(90deg, var(--accent), rgba(119, 141, 169, 0.85));
      transition: width 0.4s ease;
    }
    .work-pal-card__empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.6);
    }
    .work-pal-empty {
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.7);
      font-style: italic;
    }
    body.kid-mode .glossary-nav button {
      font-size: 0.95rem;
      padding: 12px 20px;
    }
    body.kid-mode .glossary-section h3 {
      font-size: 1.8rem;
    }
    body.kid-mode .glossary-search {
      font-size: 1rem;
    }
    body.kid-mode .work-role-card__name {
      font-size: 1.4rem;
    }
    body.kid-mode .work-role-card__blurb {
      font-size: 1.05rem;
    }
    body.kid-mode .work-pal-card__name {
      font-size: 1.15rem;
    }
    body.kid-mode .work-pal-card__skill {
      font-size: 0.95rem;
    }
    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 16px;
    }

    @media (max-width: 900px) {
      #navbar .nav-item {
        padding: 10px 12px;
        font-size: 0.85rem;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(170px, 1fr));
      }
    }

    @media (max-width: 600px) {
      .nav-brand .logo {
        font-size: 1.15rem;
      }
      #content {
        padding: clamp(16px, 6vw, 28px);
        margin-block: clamp(10px, 2vw, 18px) clamp(28px, 7vw, 60px);
      }
      .page-header {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
      }
      .search-bar {
        max-width: none;
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
        gap: 14px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      }
    }

    @media (max-width: 480px) {
      .nav-brand .logo {
        font-size: 1.05rem;
      }
      #navbar .nav-item {
        padding: 8px 10px;
        font-size: 0.8rem;
      }
      #navbar .nav-item i {
        font-size: 1rem;
      }
      #content {
        padding: clamp(14px, 7vw, 24px);
      }
      .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 12px;
      }
      body.kid-mode .card-grid {
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      }
      .pal-card img,
      .item-card img {
        width: 90px;
        height: 90px;
      }
    }
    .search-bar {
      width: 100%;
      max-width: 400px;
    }
    .search-bar input {
      width: 100%;
      padding: 8px 10px;
      border-radius: 6px;
      border: none;
      background: var(--card-bg);
      color: var(--text);
      font-size: 0.9rem;
    }
    /* Grid for cards */
    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
    }

    body.kid-mode .card-grid {
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 20px;
    }

    #homeCards {
      display: grid;
      gap: clamp(28px, 4vw, 44px);
    }

    .home-section {
      position: relative;
      display: grid;
      gap: clamp(20px, 2.6vw, 28px);
      padding: clamp(28px, 3.4vw, 44px);
      border-radius: 30px;
      border: 1px solid rgba(119, 141, 169, 0.3);
      background: linear-gradient(155deg, rgba(16, 33, 54, 0.9), rgba(9, 20, 36, 0.88));
      box-shadow: 0 32px 62px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    .home-hero {
      position: relative;
      padding: clamp(32px, 4.2vw, 52px);
      display: grid;
      grid-template-columns: minmax(0, 1.05fr) minmax(280px, 0.95fr);
      grid-template-areas:
        "intro intro"
        "mode focus";
      gap: clamp(28px, 5vw, 56px);
      background: radial-gradient(circle at top left, rgba(119, 141, 169, 0.55), transparent 55%),
        linear-gradient(135deg, rgba(31, 52, 78, 0.95), rgba(13, 27, 42, 0.85));
      border: 1px solid rgba(148, 210, 189, 0.32);
      overflow: visible;
      align-items: start;
    }

    .home-hero::after {
      content: '';
      position: absolute;
      inset: auto -140px -180px auto;
      width: clamp(260px, 38vw, 440px);
      height: clamp(260px, 38vw, 440px);
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.28), transparent 70%);
      opacity: 0.9;
      pointer-events: none;
      transform: rotate(18deg);
    }

    .home-hero__intro {
      grid-area: intro;
      position: relative;
      z-index: 1;
      display: grid;
      gap: 18px;
      align-content: start;
    }

    .home-hero__intro h3 {
      margin: 0;
      font-size: clamp(1.75rem, 3.2vw, 2.2rem);
      line-height: 1.2;
    }

    .home-hero__intro p {
      margin: 0;
      color: var(--muted);
      font-size: 1rem;
      max-width: 52ch;
    }

    .home-hero__eyebrow {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.25);
      color: var(--light);
      width: fit-content;
    }

    .home-hero__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }

    .home-hero__actions .btn {
      flex: 0 0 auto;
      min-width: 180px;
    }

    .home-hero__mode {
      grid-area: mode;
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 12px;
      border-radius: 16px;
      background: rgba(13, 27, 42, 0.65);
      border: 1px solid rgba(119, 141, 169, 0.25);
      flex-wrap: wrap;
      align-self: stretch;
    }

    .home-hero__mode-label {
      font-size: 0.85rem;
      color: var(--muted);
    }

    .mode-toggle {
      display: flex;
      gap: 8px;
    }

    .mode-card {
      background: rgba(27, 38, 59, 0.8);
      border: 1px solid rgba(119, 141, 169, 0.25);
      border-radius: 14px;
      padding: 14px 16px;
      display: grid;
      gap: 10px;
      min-width: 180px;
      transition: border-color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
    }

    .mode-card.active {
      border-color: rgba(114, 229, 196, 0.65);
      box-shadow: 0 0 0 1px rgba(114, 229, 196, 0.2);
      transform: translateY(-2px);
    }

    .mode-card__status {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.18);
      width: fit-content;
    }

    .mode-card.active .mode-card__status {
      background: rgba(42, 157, 143, 0.2);
      color: var(--success);
    }

    .mode-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }

    .mode-card p {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .mode-card__features {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 4px;
      font-size: 0.85rem;
      color: var(--light);
    }

    .mode-card__features li::before {
      content: '\f00c';
      font-family: 'Font Awesome 6 Free';
      font-weight: 900;
      margin-right: 6px;
      color: var(--success);
    }

    .mode-card__button {
      justify-self: start;
      padding-inline: 18px;
    }

    .home-hero__panel {
      grid-area: focus;
      position: relative;
      z-index: 1;
      display: grid;
      align-content: start;
      gap: clamp(18px, 2.4vw, 26px);
    }

    .home-focus-card {
      background: rgba(13, 27, 42, 0.82);
      border: 1px solid rgba(119, 141, 169, 0.3);
      border-radius: 22px;
      padding: clamp(20px, 2.8vw, 30px);
      display: grid;
      gap: 18px;
      box-shadow: 0 16px 36px rgba(8, 16, 32, 0.45);
    }

    .home-focus-card__badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(114, 229, 196, 0.15);
      color: var(--success);
    }

    .home-focus-card h4 {
      margin: 0;
      font-size: 1.3rem;
    }

    .home-focus-card p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .home-focus-meter {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.18);
      overflow: hidden;
    }

    .home-focus-meter .fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.6s ease;
    }

    .home-focus-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .home-section-header h3 {
      margin: 0;
      font-size: 1.3rem;
    }

    .home-section-header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .home-progress {
      gap: clamp(18px, 2.6vw, 26px);
    }

    .home-breeding {
      gap: clamp(18px, 2.6vw, 28px);
    }

    .home-breeding-card {
      background: linear-gradient(165deg, rgba(12, 26, 44, 0.94), rgba(22, 40, 64, 0.92));
      border-radius: 26px;
      padding: clamp(22px, 2.8vw, 30px);
      display: grid;
      gap: clamp(14px, 2.2vw, 18px);
      position: relative;
      border: 1px solid rgba(119, 141, 169, 0.26);
      box-shadow: 0 26px 52px rgba(0, 0, 0, 0.46);
    }

    .home-breeding-card__header {
      display: flex;
      align-items: flex-start;
      gap: 16px;
    }

    .home-breeding-card__icon {
      width: 50px;
      height: 50px;
      border-radius: 16px;
      background: rgba(119, 141, 169, 0.2);
      color: var(--accent);
      display: grid;
      place-items: center;
      font-size: 1.5rem;
      flex-shrink: 0;
    }

    .home-breeding-card__title {
      margin: 0;
      font-size: 1.2rem;
    }

    .home-breeding-card__subtitle {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 0.95rem;
      line-height: 1.45;
    }

    .home-breeding-status {
      font-weight: 600;
      font-size: 1rem;
    }

    .home-breeding-card[data-state='locked'] .home-breeding-status,
    .home-breeding-card[data-state='empty'] .home-breeding-status {
      color: var(--muted);
    }

    .home-breeding-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
    }

    .home-breeding-item {
      background: rgba(119, 141, 169, 0.14);
      border-radius: 18px;
      padding: 14px 16px;
      display: grid;
      gap: 6px;
    }

    .home-breeding-item__title {
      font-weight: 600;
      font-size: 1rem;
    }

    .home-breeding-item__meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.9rem;
      color: var(--muted);
    }

    .home-breeding-item__note {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .home-breeding-item__meta span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .home-breeding-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 6px;
    }

    .home-breeding-actions .btn,
    .home-breeding-actions .home-progress-link {
      flex: 1 1 auto;
      min-width: 160px;
    }

    .home-progress-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: clamp(18px, 2.4vw, 26px);
    }

    .home-progress-card {
      background: linear-gradient(160deg, rgba(10, 21, 36, 0.94), rgba(18, 34, 56, 0.92));
      border-radius: 24px;
      padding: clamp(20px, 2.6vw, 28px);
      display: grid;
      gap: 14px;
      position: relative;
      overflow: hidden;
      min-height: 240px;
      border: 1px solid rgba(119, 141, 169, 0.26);
      box-shadow: 0 22px 44px rgba(0, 0, 0, 0.45);
    }

    .home-progress-card__header {
      display: flex;
      align-items: flex-start;
      gap: 14px;
    }

    .home-progress-card__icon {
      width: 48px;
      height: 48px;
      border-radius: 14px;
      display: grid;
      place-items: center;
      background: rgba(119, 141, 169, 0.2);
      color: var(--accent);
      font-size: 1.4rem;
      flex-shrink: 0;
    }

    .home-progress-card__header h3 {
      margin: 0;
      font-size: 1.15rem;
    }

    .home-progress-card__header p {
      margin: 4px 0 0;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .home-progress-meter {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.28);
      overflow: hidden;
    }

    .home-progress-meter .fill {
      width: 0;
      height: 100%;
      background: linear-gradient(90deg, var(--accent), rgba(42, 157, 143, 0.9));
      transition: width 0.4s ease;
    }

    .home-progress-text {
      font-size: 1rem;
      font-weight: 600;
    }

    .home-progress-next {
      font-size: 0.9rem;
      color: var(--muted);
      text-align: left;
      line-height: 1.5;
    }

    .home-progress-link {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 0.95rem;
      padding: 0;
      text-align: left;
      cursor: pointer;
      text-decoration: underline;
      align-self: flex-start;
      font-weight: 600;
    }

    .home-progress-link:disabled {
      color: var(--muted);
      cursor: default;
      text-decoration: none;
    }

    .home-progress-actions {
      margin-top: auto;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .home-progress-actions .btn {
      flex: 1 1 auto;
      min-width: 180px;
    }

    .home-progress-card--queue {
      display: grid;
      gap: 18px;
    }

    .home-progress-card--queue .home-progress-card__header {
      align-items: flex-start;
    }

    .adaptive-queue {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
    }

    .adaptive-queue__item {
      display: flex;
      gap: 14px;
      justify-content: space-between;
      align-items: flex-start;
      padding: 16px 18px;
      border-radius: 18px;
      background: rgba(13, 27, 42, 0.78);
      border: 1px solid rgba(119, 141, 169, 0.28);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.04);
    }

    .adaptive-queue__meta {
      display: grid;
      gap: 4px;
    }

    .adaptive-queue__title {
      margin: 0;
      font-weight: 600;
      font-size: 0.95rem;
    }

    .adaptive-queue__stats {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .adaptive-queue__badge {
      font-size: 0.75rem;
      color: var(--accent);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }

    .adaptive-queue__cta {
      align-self: center;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 8px 14px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(27, 38, 59, 0.72);
      color: var(--light);
      font-size: 0.85rem;
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease;
    }

    .adaptive-queue__cta:hover {
      transform: translateY(-1px);
      border-color: rgba(114, 229, 196, 0.5);
      background: rgba(27, 38, 59, 0.85);
    }

    .adaptive-queue__cta:disabled {
      opacity: 0.6;
      cursor: default;
      transform: none;
    }

    .home-spotlight {
      gap: clamp(20px, 3vw, 32px);
      grid-template-columns: minmax(0, 1fr) minmax(280px, 340px);
      align-items: center;
    }

    .home-spotlight .home-section-header {
      grid-column: 1 / -1;
    }

    .home-spotlight-card {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: clamp(18px, 3vw, 28px);
      background: linear-gradient(160deg, rgba(10, 21, 36, 0.92), rgba(18, 34, 56, 0.9));
      border-radius: 24px;
      padding: clamp(20px, 3vw, 30px);
      border: 1px solid rgba(119, 141, 169, 0.26);
      color: inherit;
      text-align: left;
      cursor: pointer;
      transition: transform 0.25s ease, border-color 0.25s ease, box-shadow 0.25s ease;
      box-shadow: 0 20px 44px rgba(0, 0, 0, 0.45);
    }

    .home-spotlight-card:hover:not(:disabled) {
      transform: translateY(-3px);
      border-color: rgba(148, 210, 189, 0.45);
      box-shadow: 0 26px 52px rgba(0, 0, 0, 0.55);
    }

    .home-spotlight-card:disabled {
      cursor: default;
      opacity: 0.85;
    }

    .home-spotlight-card:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    .home-spotlight-card img {
      width: 108px;
      height: 108px;
      object-fit: contain;
      border-radius: 18px;
      background: rgba(13, 27, 42, 0.82);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.35);
    }

    .home-spotlight-card__text {
      display: grid;
      gap: 8px;
    }

    .home-spotlight-card__title {
      font-size: 1.25rem;
      font-weight: 600;
    }

    .home-spotlight-card__meta {
      font-size: 0.9rem;
      color: var(--muted);
      line-height: 1.5;
    }

    .home-spotlight-card__types {
      font-size: 0.85rem;
      color: var(--accent);
      font-weight: 600;
      display: inline-flex;
      gap: 6px;
      align-items: center;
    }

    body.kid-mode .home-hero__intro h3 {
      font-size: 1.8rem;
    }

    body.kid-mode .mode-card__features {
      font-size: 1rem;
    }

    body.kid-mode .home-progress-text {
      font-size: 1.05rem;
    }

    body.kid-mode .home-progress-link {
      font-size: 1rem;
    }

    @media (max-width: 900px) {
      .home-hero {
        grid-template-columns: 1fr;
        grid-template-areas:
          "intro"
          "mode"
          "focus";
      }
      .home-spotlight {
        grid-template-columns: 1fr;
      }
      .home-spotlight-card {
        flex-direction: column;
        align-items: flex-start;
      }
    }

    @media (max-width: 768px) {
      .home-progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
      .home-hero__mode {
        flex-direction: column;
        align-items: flex-start;
      }
      .mode-toggle {
        width: 100%;
      }
      .mode-card {
        width: 100%;
      }
    }

    @media (max-width: 540px) {
      #homeCards {
        gap: 20px;
      }
      .home-hero {
        padding: 20px;
      }
      .home-progress {
        padding: 20px;
      }
      .home-spotlight {
        padding: 20px;
      }
      .home-spotlight-card {
        flex-direction: column;
        align-items: flex-start;
      }
      .home-spotlight-card img {
        width: 90px;
        height: 90px;
      }
    }
    /* Pal and item cards */
    .pal-card, .item-card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 12px;
      text-align: center;
      transition: transform 0.2s, background 0.2s, box-shadow 0.2s;
      cursor: pointer;
      position: relative;
    }
    .pal-card:hover, .item-card:hover {
      transform: translateY(-4px);
      background: var(--card-hover);
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    .pal-card img, .item-card img {
      /* Increase the size of the images to make each pal and item
         card more visually striking and easier for younger players
         to recognise. */
      width: 100px;
      height: 100px;
      object-fit: contain;
      margin-bottom: 8px;
    }
    .item-card-art {
      width: 100%;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    .item-card-art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-card-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .pal-card .name, .item-card .name {
      font-size: 1rem;
      font-weight: bold;
      margin-bottom: 6px;
    }
    .pal-card .badge {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
      margin-bottom: 4px;
      color: var(--text);
      font-size: 0.8rem;
    }
    .pal-card .badge img {
      width: 22px;
      height: 22px;
    }
    .pal-card .rarity {
      font-size: 0.8rem;
      margin-bottom: 6px;
      color: var(--light);
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 4px;
    }
    .pal-card .rarity .stars i {
      color: #E4B914;
      font-size: 0.8rem;
      margin-right: 2px;
    }
    .pal-card .rarity .label {
      color: var(--accent);
      font-weight: bold;
      text-transform: capitalize;
    }
    .pal-card .catch-btn {
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.75rem;
      transition: background 0.2s;
    }
    .pal-card .catch-btn.caught {
      background: var(--secondary);
    }
    /* Modal */
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s;
      z-index: 200;
    }
    #modal.active {
      opacity: 1;
      pointer-events: auto;
    }
    #modalContent {
      background: var(--card-bg);
      border-radius: 10px;
      padding: 20px;
      max-width: 900px;
      width: 90%;
      max-height: 90vh;
      overflow-y: auto;
      position: relative;
    }
    #modalClose {
      position: absolute;
      top: 10px;
      right: 10px;
      background: var(--danger);
      color: #fff;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
    }
    .external-embed {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .external-embed .embed-actions {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    .external-embed .embed-actions h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .external-embed .embed-link {
      color: var(--accent);
      text-decoration: none;
      font-weight: bold;
    }
    .external-embed .embed-link:hover,
    .external-embed .embed-link:focus {
      text-decoration: underline;
    }
    .external-embed .embed-note,
    .external-embed .embed-fallback {
      font-size: 0.9rem;
      color: var(--light);
      margin: 0;
    }
    .external-embed .embed-summary {
      background: rgba(65, 90, 119, 0.35);
      border-radius: 8px;
      padding: 12px;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    body.kid-mode .external-embed .embed-summary {
      font-size: 1rem;
    }
    .map-iframe-wrapper {
      width: 100%;
      height: clamp(320px, 70vh, 720px);
      border-radius: 18px;
      overflow: hidden;
      margin-bottom: 16px;
      border: 1px solid rgba(119, 141, 169, 0.3);
      box-shadow: 0 18px 36px rgba(5, 15, 30, 0.45);
      background: #000;
    }
    .map-iframe-wrapper iframe {
      width: 100%;
      height: 100%;
      border: none;
      display: block;
    }
    #mapLayers {
      margin-bottom: 12px;
    }
    @media (max-width: 600px) {
      .map-iframe-wrapper {
        height: clamp(260px, 60vh, 480px);
        border-radius: 14px;
      }
    }
    .external-embed .embed-frame {
      width: 100%;
      min-height: clamp(320px, 65vh, 640px);
      border: none;
      border-radius: 10px;
      background: #fff;
    }
    .item-detail-card {
      display: grid;
      gap: 18px;
      background: var(--card-bg);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.35);
    }
    .item-detail-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }
    .item-detail-heading {
      display: flex;
      align-items: center;
      gap: 16px;
      flex: 1 1 auto;
      min-width: 0;
    }
    .item-detail-image {
      width: 96px;
      height: 96px;
      border-radius: 14px;
      background: rgba(0, 0, 0, 0.25);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      flex-shrink: 0;
    }
    .item-detail-image img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }
    .item-detail-placeholder {
      font-size: 2rem;
      color: var(--accent);
    }
    .item-detail-meta {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 0;
    }
    .item-detail-meta h3 {
      margin: 0;
      font-size: 1.6rem;
      line-height: 1.2;
    }
    .item-detail-meta .type-tag {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
    }
    .detail-collect-btn {
      background: var(--secondary);
      border: none;
      color: var(--text);
      padding: 10px 18px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .detail-collect-btn:hover,
    .detail-collect-btn:focus {
      background: var(--accent);
      transform: translateY(-1px);
    }
    .detail-collect-btn.collected {
      background: var(--success);
      color: #fff;
    }
    .item-detail-description p {
      margin: 0 0 8px;
      line-height: 1.6;
      font-size: 1rem;
    }
    .item-detail-description p:last-child {
      margin-bottom: 0;
    }
    .item-detail-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .item-detail-stats .stat-pill {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 12px;
    }
    .item-detail-stats .stat-pill .label {
      display: block;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      margin-bottom: 4px;
    }
    .item-detail-stats .stat-pill .value {
      font-size: 1.1rem;
      font-weight: 600;
    }
    .item-detail-section {
      background: rgba(255, 255, 255, 0.03);
      border-radius: 12px;
      padding: 16px;
      display: grid;
      gap: 8px;
    }
    .item-detail-section h4 {
      margin: 0;
      font-size: 1.1rem;
    }
    .item-detail-section p {
      margin: 0;
      line-height: 1.5;
    }
    .item-detail-summary ul {
      margin: 0;
      padding-left: 20px;
      line-height: 1.5;
    }
    .chip-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .chip-list .chip {
      background: rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.85rem;
    }
    .chip-list .chip.highlight {
      background: rgba(42, 157, 143, 0.35);
    }
    .ingredient-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }
    .ingredient-card {
      display: flex;
      align-items: center;
      gap: 12px;
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 10px 12px;
    }
    .ingredient-card img {
      width: 48px;
      height: 48px;
      object-fit: contain;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.25);
    }
    .ingredient-card .ingredient-text {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .ingredient-card .name {
      font-weight: 600;
    }
    .item-detail-footer {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      font-size: 0.9rem;
    }
    .item-detail-footer a {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }
    .item-detail-footer a:hover,
    .item-detail-footer a:focus {
      text-decoration: underline;
    }
    .item-detail-note {
      color: var(--accent);
      font-size: 0.85rem;
    }
    body.kid-mode .item-detail-card {
      gap: 14px;
      padding: 20px;
    }
    body.kid-mode .item-detail-meta h3 {
      font-size: 1.4rem;
    }
    body.kid-mode .item-detail-description p {
      font-size: 1.05rem;
    }
    body.kid-mode .item-detail-stats {
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }
    body.kid-mode .item-detail-stats .stat-pill {
      padding: 10px;
    }
    body.kid-mode .item-detail-stats .stat-pill .value {
      font-size: 1rem;
    }
    body.kid-mode .detail-collect-btn {
      font-size: 1rem;
      padding: 12px 20px;
    }
    body.kid-mode .chip-list .chip {
      font-size: 0.95rem;
      padding: 8px 16px;
    }
    body.kid-mode .item-detail-section h4 {
      font-size: 1rem;
    }
    .modal-action-btn {
      background: var(--accent);
      border: none;
      color: var(--text);
      padding: 6px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .modal-action-btn:hover,
    .modal-action-btn:focus {
      background: var(--secondary);
      transform: translateY(-1px);
    }
    body.kid-mode .modal-action-btn {
      font-size: 1rem;
    }
    /* Environment map */
    #mapContainer {
      position: relative;
      width: 100%;
      margin: 10px 0;
      border-radius: 8px;
      overflow: hidden;
    }
    #mapContainer img {
      width: 100%;
      height: auto;
      display: block;
    }
    #mapOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #mapOverlay .zone {
      position: absolute;
      opacity: 0;
      background: var(--accent);
      border: 2px solid var(--light);
      /* Make the highlight circular/elliptical to better approximate
         natural habitats instead of square boxes */
      border-radius: 50%;
      transition: opacity 0.3s;
    }
    #mapOverlay .zone.active {
      /* Lower opacity for a gentler highlight that doesn’t overpower the map */
      opacity: 0.2;
    }
    .map-modal {
      display: grid;
      gap: 12px;
    }
    .map-modal h3 {
      margin: 0;
    }
    .map-modal-note {
      margin: 0;
      color: var(--muted);
      font-size: 0.9rem;
    }
    .map-modal-details {
      display: grid;
      gap: 6px;
      font-size: 0.95rem;
    }
    .map-modal-canvas {
      position: relative;
      border-radius: 10px;
      overflow: hidden;
      background: var(--primary);
      box-shadow: 0 2px 10px rgba(0,0,0,0.4);
    }
    .map-modal-canvas img {
      display: block;
      width: 100%;
      height: auto;
    }
    .map-marker {
      position: absolute;
      width: 18px;
      height: 18px;
      background: var(--danger);
      border: 2px solid var(--light);
      border-radius: 50%;
      --marker-tail-length: 16px;
      --marker-horizontal-adjust: 0px;
      transform: translate(
        calc(-50% + var(--marker-horizontal-adjust)),
        calc(-100% - var(--marker-tail-length))
      );
      box-shadow: 0 2px 6px rgba(0,0,0,0.5);
    }
    .map-marker::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      width: 2px;
      height: var(--marker-tail-length);
      background: var(--danger);
      transform: translateX(-50%);
    }
    .map-marker-label {
      position: absolute;
      top: calc(100% + 6px);
      left: 50%;
      transform: translate(-50%, 0);
      background: rgba(13,27,42,0.85);
      color: var(--text);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.75rem;
      white-space: nowrap;
      pointer-events: none;
    }
    body.kid-mode .map-modal-details p {
      font-size: 1rem;
    }
    /* Items */
    .item-card .name {
      font-weight: bold;
      font-size: 0.9rem;
      margin-bottom: 4px;
    }
    .item-card .category {
      font-size: 0.75rem;
      color: var(--light);
      margin-bottom: 6px;
    }
    .item-card .drops {
      font-size: 0.7rem;
      color: var(--text);
    }
    .item-card .ranch {
      font-size: 0.7rem;
      color: var(--light);
      margin-top: 4px;
    }
    .item-card .ranch--empty {
      opacity: 0.75;
      font-style: italic;
    }
    .item-card .collect-btn {
      margin-top: 6px;
      background: var(--success);
      border: none;
      color: #fff;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
    }
    .item-card .collect-btn.collected {
      background: var(--secondary);
    }
    /* Tech tree */
    #techList {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .tech-controls {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 20px;
      border: 1px solid rgba(119,141,169,0.25);
      background: linear-gradient(135deg, rgba(17,32,51,0.9), rgba(11,23,39,0.95));
      box-shadow: 0 18px 36px rgba(0,0,0,0.35);
      backdrop-filter: blur(6px);
    }
    .tech-controls__row {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 12px;
    }
    .tech-filter {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .tech-filter__label {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(224,225,221,0.65);
    }
    .tech-search {
      position: relative;
      flex: 1 1 280px;
    }
    .tech-search input {
      width: 100%;
      padding: 12px 16px 12px 42px;
      border-radius: 14px;
      border: 1px solid rgba(119,141,169,0.35);
      background: rgba(9,18,32,0.85);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .tech-search input::placeholder {
      color: rgba(224,225,221,0.55);
    }
    .tech-search input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(119,141,169,0.35);
    }
    .tech-search i {
      position: absolute;
      left: 16px;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(224,225,221,0.55);
      pointer-events: none;
      font-size: 0.95rem;
    }
    .tech-summary {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .tech-pills {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(119,141,169,0.16);
    }
    .tech-pill {
      border: none;
      border-radius: 999px;
      padding: 6px 14px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      cursor: pointer;
      background: transparent;
      color: var(--light);
      transition: background 0.2s ease, color 0.2s ease;
    }
    .tech-pill:hover,
    .tech-pill:focus-visible {
      background: rgba(119,141,169,0.28);
      outline: none;
    }
    .tech-pill.active {
      background: var(--accent);
      color: #0d1b2a;
      font-weight: 700;
    }
    .tech-select {
      min-width: 200px;
      padding: 10px 14px;
      border-radius: 14px;
      border: 1px solid rgba(119,141,169,0.35);
      background: rgba(9,18,32,0.85);
      color: var(--text);
      font-size: 0.85rem;
    }
    .tech-reset-btn {
      border: 1px solid rgba(119,141,169,0.35);
      border-radius: 999px;
      padding: 8px 18px;
      background: transparent;
      color: var(--light);
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .tech-reset-btn:hover:not(:disabled),
    .tech-reset-btn:focus-visible:not(:disabled) {
      background: rgba(119,141,169,0.28);
      outline: none;
    }
    .tech-reset-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    .tech-results {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .tech-level-card {
      background: linear-gradient(135deg, rgba(23,40,59,0.92), rgba(18,32,48,0.92));
      border-radius: 20px;
      border: 1px solid rgba(119,141,169,0.25);
      box-shadow: 0 18px 36px rgba(0,0,0,0.35);
      padding: 20px;
      backdrop-filter: blur(6px);
    }
    .tech-level-header {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 16px;
    }
    .tech-level-number {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--accent);
      text-shadow: 0 0 12px rgba(119,141,169,0.4);
    }
    .tech-level-number span {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--light);
    }
    .tech-level-header__meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      font-size: 0.85rem;
      color: rgba(224,225,221,0.75);
    }
    .tech-level-summary {
      font-size: 0.85rem;
      color: var(--muted);
    }
    .tech-columns {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .tech-column {
      display: flex;
      flex-direction: column;
      gap: 12px;
      background: rgba(13,27,42,0.6);
      border: 1px solid rgba(119,141,169,0.18);
      border-radius: 16px;
      padding: 16px;
    }
    .tech-column h4 {
      margin: 0;
      font-size: 1rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    }
    .tech-card {
      position: relative;
      display: grid;
      grid-template-columns: 88px minmax(0, 1fr);
      gap: 16px;
      align-items: stretch;
      padding: 16px;
      border-radius: 16px;
      border: 1px solid rgba(119,141,169,0.25);
      background: rgba(15,28,45,0.9);
      box-shadow: 0 12px 28px rgba(0,0,0,0.35);
      cursor: pointer;
      transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .tech-card:hover {
      transform: translateY(-2px);
      border-color: var(--accent);
      box-shadow: 0 18px 32px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked {
      border-color: rgba(42,157,143,0.6);
      box-shadow: 0 0 0 2px rgba(42,157,143,0.35), 0 18px 32px rgba(0,0,0,0.45);
    }
    .tech-card--unlocked .tech-card__cost {
      background: rgba(42,157,143,0.25);
      color: var(--success);
    }
    .tech-card__art {
      width: 88px;
      height: 88px;
      border-radius: 14px;
      background: rgba(119,141,169,0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      overflow: hidden;
    }
    .tech-card__art img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 4px 6px rgba(0,0,0,0.35));
    }
    .tech-card__art--fallback {
      color: var(--light);
      font-size: 1.6rem;
    }
    .tech-card__info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-width: 0;
    }
    .tech-card__meta {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .tech-card__name {
      margin: 0;
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--text);
    }
    .tech-card__cost {
      font-size: 0.75rem;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(119,141,169,0.22);
      color: var(--light);
      letter-spacing: 0.08em;
    }
    .tech-card__chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .tech-chip {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.35);
      background: rgba(119,141,169,0.15);
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--light);
    }
    .tech-card__description {
      margin: 0;
      font-size: 0.88rem;
      color: rgba(224,225,221,0.82);
      line-height: 1.45;
    }
    .tech-card__materials {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .tech-card__materials li {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .tech-card__note {
      margin: 0;
      font-size: 0.78rem;
      color: rgba(224,225,221,0.65);
      font-style: italic;
    }
    .tech-card__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: auto;
      flex-wrap: wrap;
    }
    .tech-card__status {
      font-size: 0.78rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224,225,221,0.65);
    }
    .tech-card__status--unlocked {
      color: rgba(42,157,143,0.85);
    }
    .tech-card .unlock-btn {
      border-radius: 999px;
      border: 1px solid rgba(119,141,169,0.4);
      background: transparent;
      color: var(--text);
      padding: 7px 18px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border 0.2s ease;
    }
    .tech-card .unlock-btn:hover,
    .tech-card .unlock-btn:focus-visible {
      background: rgba(119,141,169,0.35);
      outline: none;
    }
    .tech-card .unlock-btn.unlocked {
      background: var(--success);
      border-color: var(--success);
      color: #0d1b2a;
    }
    .tech-empty {
      margin: 0;
      font-size: 0.8rem;
      color: var(--muted);
      font-style: italic;
    }
    .tech-results__empty {
      text-align: center;
      font-size: 0.9rem;
      color: rgba(224,225,221,0.75);
      padding: 40px 20px;
      border: 1px dashed rgba(119,141,169,0.3);
      border-radius: 16px;
      background: rgba(12,24,40,0.65);
    }
    .tech-modal {
      display: grid;
      gap: 20px;
      color: var(--text);
    }
    .tech-modal__header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 12px;
    }
    .tech-modal__title {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .tech-modal__title h3 {
      margin: 0;
      font-size: 1.6rem;
    }
    .tech-modal__badges {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .tech-modal__meta {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      font-size: 0.9rem;
      color: rgba(224,225,221,0.75);
    }
    .tech-modal__body {
      display: grid;
      gap: 18px;
      grid-template-columns: minmax(0, 1fr);
    }
    .tech-modal__media {
      width: 160px;
      height: 160px;
      border-radius: 18px;
      background: rgba(119,141,169,0.18);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .tech-modal__media img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,0.35));
    }
    .tech-modal__media--fallback {
      font-size: 2rem;
      color: rgba(224,225,221,0.75);
    }
    .tech-modal__content {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .tech-modal__description {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224,225,221,0.85);
      line-height: 1.6;
    }
    .tech-modal__materials h4 {
      margin: 0 0 8px;
      font-size: 1rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      color: rgba(224,225,221,0.85);
    }
    .tech-modal__materials-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }
    .tech-modal__materials-list li {
      list-style: none;
      margin: 0;
      padding: 0;
    }
    .chip.link.tech-modal__materials-link {
      display: flex;
      width: 100%;
      justify-content: flex-start;
    }
    .chip.link.tech-modal__materials-link .chip__body {
      align-items: flex-start;
    }
    .tech-modal__status {
      font-size: 0.85rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224,225,221,0.7);
    }
    .tech-modal__status--unlocked {
      color: rgba(42,157,143,0.85);
    }
    .tech-modal__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .tech-modal__external {
      color: var(--accent);
      font-weight: 600;
      text-decoration: none;
    }
    .tech-modal__external:hover,
    .tech-modal__external:focus-visible {
      text-decoration: underline;
      outline: none;
    }
    .tech-modal--missing {
      text-align: center;
      gap: 14px;
    }
    .tech-modal--missing p {
      margin: 0;
      color: rgba(224,225,221,0.85);
    }
    @media (min-width: 768px) {
      .tech-controls__row {
        gap: 16px;
      }
      .tech-modal__body {
        grid-template-columns: 200px minmax(0, 1fr);
        align-items: start;
      }
    }
    @media (max-width: 540px) {
      .tech-card {
        grid-template-columns: minmax(0, 1fr);
      }
      .tech-card__art {
        width: 100%;
        height: 120px;
      }
    }
    /* Breeding page */
    .breeding-hero {
      position: relative;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 24px;
      padding: 28px;
      margin-bottom: 28px;
      border-radius: 24px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.92), rgba(13, 27, 42, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.4);
      box-shadow: 0 22px 45px rgba(5, 15, 30, 0.55);
      overflow: hidden;
    }
    .breeding-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: radial-gradient(circle at top right, rgba(224, 225, 221, 0.18), transparent 55%);
      pointer-events: none;
    }
    .breeding-hero__icon {
      width: 84px;
      height: 84px;
      display: grid;
      place-items: center;
      border-radius: 28px;
      background: linear-gradient(140deg, rgba(224, 225, 221, 0.25), rgba(119, 141, 169, 0.2));
      border: 1px solid rgba(224, 225, 221, 0.3);
      box-shadow: 0 18px 36px rgba(6, 18, 35, 0.4);
      font-size: 2.2rem;
      color: #fff;
    }
    .breeding-hero__content {
      position: relative;
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .breeding-hero__title {
      display: flex;
      align-items: center;
      gap: 18px;
    }
    .breeding-hero__title h2 {
      margin: 0;
      font-size: 2rem;
      letter-spacing: 0.02em;
    }
    .breeding-hero__intro {
      margin: 0;
      font-size: 1.05rem;
      color: var(--light);
      max-width: 42ch;
    }
    .breeding-perks {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }
    .breeding-perks li {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95rem;
      background: rgba(13, 27, 42, 0.32);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 14px;
      padding: 10px 14px;
      backdrop-filter: blur(8px);
    }
    .breeding-perks i {
      color: var(--accent);
    }
    .breeding-hero__callout {
      position: relative;
      z-index: 1;
      align-self: stretch;
      display: flex;
      flex-direction: column;
      justify-content: center;
      gap: 10px;
      padding: 24px;
      border-radius: 20px;
      background: linear-gradient(160deg, rgba(119, 141, 169, 0.32), rgba(13, 27, 42, 0.6));
      border: 1px solid rgba(224, 225, 221, 0.22);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .breeding-hero__callout span {
      font-size: 0.75rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-hero__callout p {
      margin: 0;
      font-size: 0.95rem;
      line-height: 1.5;
    }
    .breeding-workspace {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .breeding-tabs {
      position: relative;
      display: inline-flex;
      flex-wrap: wrap;
      gap: 10px;
      padding: 6px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.65);
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
      width: fit-content;
    }
    .breeding-tab {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 18px;
      border-radius: 999px;
      border: 1px solid transparent;
      background: transparent;
      color: rgba(224, 225, 221, 0.78);
      cursor: pointer;
      font-size: 0.95rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      transition: background 0.25s ease, color 0.25s ease, border-color 0.25s ease, transform 0.25s ease;
    }
    .breeding-tab i {
      font-size: 1rem;
    }
    .breeding-tab:hover,
    .breeding-tab:focus-visible {
      color: #fff;
      transform: translateY(-1px);
    }
    .breeding-tab.active {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.9), rgba(119, 141, 169, 0.7));
      color: #0d1b2a;
      border-color: rgba(224, 225, 221, 0.65);
      box-shadow: 0 12px 24px rgba(7, 21, 36, 0.45);
    }
    .breeding-mode {
      display: none;
      border-radius: 24px;
      padding: 24px;
      background: linear-gradient(160deg, rgba(18, 34, 49, 0.78), rgba(10, 21, 33, 0.88));
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 18px 32px rgba(5, 15, 30, 0.48);
    }
    .breeding-mode.active {
      display: block;
    }
    .breeding-advisor {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .breeding-advisor__header {
      display: grid;
      gap: 6px;
    }
    .breeding-advisor__header h3 {
      margin: 0;
      font-size: 1.3rem;
    }
    .breeding-advisor__header p {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .breeding-advisor__grid {
      display: grid;
      gap: 18px;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      align-items: stretch;
    }
    .breeding-advisor__empty {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .advisor-card {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 20px;
      background: linear-gradient(155deg, rgba(13, 27, 42, 0.78), rgba(65, 90, 119, 0.52));
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 20px 36px rgba(5, 15, 30, 0.48);
      overflow: hidden;
    }
    .advisor-card::after {
      content: '';
      position: absolute;
      inset: auto -60px -60px auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.22), transparent 70%);
      opacity: 0.7;
      pointer-events: none;
    }
    .advisor-card__header {
      position: relative;
      z-index: 1;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 14px;
    }
    .advisor-card__titleblock {
      display: grid;
      gap: 4px;
    }
    .advisor-card__eyebrow {
      font-size: 0.7rem;
      letter-spacing: 0.18em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.7);
    }
    .advisor-card__title {
      margin: 0;
      font-size: 1.2rem;
    }
    .advisor-card__subtitle {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.78);
    }
    .advisor-card__icon {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      display: grid;
      place-items: center;
      background: rgba(224, 225, 221, 0.16);
      border: 1px solid rgba(224, 225, 221, 0.28);
      color: #fff;
      font-size: 1.4rem;
      box-shadow: 0 12px 22px rgba(5, 15, 30, 0.4);
    }
    .advisor-card__badges {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }
    .advisor-card__badge {
      padding: 4px 10px;
      font-size: 0.7rem;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.65);
      border: 1px solid rgba(224, 225, 221, 0.18);
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .advisor-card__pal {
      position: relative;
      z-index: 1;
    }
    .advisor-card .pal-card {
      background: rgba(9, 19, 30, 0.55);
      border: 1px solid rgba(224, 225, 221, 0.18);
      border-radius: 18px;
      padding: 16px;
    }
    .advisor-card__highlights {
      position: relative;
      z-index: 1;
      margin: 0;
      padding-left: 20px;
      display: grid;
      gap: 6px;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .advisor-card__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      position: relative;
      z-index: 1;
    }
    .advisor-card__action {
      padding: 10px 16px;
      border-radius: 12px;
      background: rgba(119, 141, 169, 0.28);
      border: 1px solid rgba(224, 225, 221, 0.32);
      color: var(--text);
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .advisor-card__action:hover,
    .advisor-card__action:focus-visible {
      background: rgba(224, 225, 221, 0.4);
      transform: translateY(-1px);
    }
    .advisor-card__note {
      margin: 0;
      font-size: 0.8rem;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-atlas {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .breeding-atlas__picker {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px;
      border-radius: 20px;
      background: rgba(13, 27, 42, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.28);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
    }
    .breeding-atlas__diagram {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 20px;
      background: rgba(13, 27, 42, 0.72);
      border: 1px solid rgba(119, 141, 169, 0.3);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .breeding-atlas__diagram header h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .breeding-atlas__diagram header p {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-atlas__empty {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-tree {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .breeding-tree__focus {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 18px;
      border-radius: 18px;
      background: rgba(9, 19, 30, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.28);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.08);
    }
    .breeding-tree__focus h4 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-tree__meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .breeding-tree__meta span {
      font-size: 0.75rem;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(65, 90, 119, 0.4);
      border: 1px solid rgba(224, 225, 221, 0.22);
      letter-spacing: 0.06em;
      text-transform: uppercase;
    }
    .breeding-tree__branches {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .breeding-branch {
      border-radius: 16px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      background: rgba(12, 24, 37, 0.72);
      box-shadow: 0 12px 24px rgba(5, 15, 30, 0.4);
      overflow: hidden;
    }
    .breeding-branch summary {
      list-style: none;
      cursor: pointer;
      padding: 14px 18px;
      display: flex;
      align-items: center;
      gap: 14px;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
    }
    .breeding-branch summary::-webkit-details-marker {
      display: none;
    }
    .breeding-branch__marker {
      width: 26px;
      height: 26px;
      border-radius: 8px;
      display: grid;
      place-items: center;
      background: rgba(119, 141, 169, 0.28);
      border: 1px solid rgba(224, 225, 221, 0.26);
      font-size: 0.85rem;
    }
    .breeding-branch__summary {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .breeding-branch__summary-flow {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .breeding-branch__summary-result {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .breeding-branch__summary-arrow {
      font-weight: 700;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-branch__layout {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 0 18px 18px;
    }
    .breeding-branch__pyramid {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .breeding-branch__connector {
      width: 2px;
      height: 26px;
      background: linear-gradient(180deg, rgba(224, 225, 221, 0.4), rgba(119, 141, 169, 0.05));
    }
    .breeding-branch__summary-chips {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
    }
    .breeding-branch__parent-grid {
      display: grid;
      gap: 16px;
    }
    @media (min-width: 720px) {
      .breeding-branch__parent-grid {
        grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      }
    }
    .breeding-branch__parent {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 16px;
      border-radius: 14px;
      background: rgba(9, 19, 30, 0.55);
      border: 1px solid rgba(119, 141, 169, 0.22);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
    }
    .breeding-branch__parent::before {
      content: '';
      position: absolute;
      inset: 14px auto auto -12px;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(119, 141, 169, 0.4);
      box-shadow: 0 0 0 3px rgba(13, 27, 42, 0.8);
    }
    .breeding-branch__parent h5 {
      margin: 0;
      font-size: 1rem;
    }
    .breeding-branch__children {
      margin-top: 12px;
      padding-left: 18px;
      border-left: 2px dashed rgba(119, 141, 169, 0.3);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .breeding-branch__notice {
      margin: 0;
      font-size: 0.8rem;
      color: rgba(224, 225, 221, 0.7);
    }
    .breeding-chip {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      padding: 8px 12px;
      border-radius: 16px;
      background: rgba(119, 141, 169, 0.2);
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 12px 24px rgba(4, 14, 28, 0.35);
      min-width: 0;
    }
    .breeding-chip--parent {
      background: rgba(119, 141, 169, 0.22);
      border-color: rgba(119, 141, 169, 0.45);
    }
    .breeding-chip--child {
      background: rgba(148, 210, 189, 0.2);
      border-color: rgba(148, 210, 189, 0.45);
      box-shadow: 0 16px 32px rgba(148, 210, 189, 0.18);
    }
    .breeding-chip--condensed {
      padding: 6px 10px;
      border-radius: 14px;
      gap: 8px;
    }
    .breeding-chip__art {
      width: 42px;
      height: 42px;
      border-radius: 12px;
      overflow: hidden;
      background: rgba(13, 27, 42, 0.6);
      border: 1px solid rgba(224, 225, 221, 0.12);
      display: grid;
      place-items: center;
      flex: 0 0 auto;
    }
    .breeding-chip--condensed .breeding-chip__art {
      width: 36px;
      height: 36px;
      border-radius: 10px;
    }
    .breeding-chip__art img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .breeding-chip__placeholder {
      font-weight: 700;
      font-size: 1.2rem;
      color: rgba(224, 225, 221, 0.7);
    }
    .breeding-chip__body {
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }
    .breeding-chip__label {
      font-weight: 600;
      font-size: 0.95rem;
      line-height: 1.2;
      color: var(--text);
      word-break: break-word;
    }
    .breeding-chip--condensed .breeding-chip__label {
      font-size: 0.85rem;
    }
    .breeding-chip__meta {
      font-size: 0.7rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.65);
      word-break: break-word;
    }
    .breeding-panels {
      display: flex;
      flex-direction: column;
      gap: 22px;
    }
    .breeding-panel {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 18px;
      border-radius: 18px;
      background: rgba(13, 27, 42, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
      min-height: 100%;
    }
    .breeding-panel__header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .breeding-panel__header h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-panel__description {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.72);
    }
    .breeding-panel .pal-search input {
      width: 100%;
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(13, 27, 42, 0.6);
      color: var(--text);
      font-size: 0.95rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .breeding-panel .pal-search input:focus {
      outline: none;
      border-color: rgba(224, 225, 221, 0.5);
      box-shadow: 0 0 0 3px rgba(119, 141, 169, 0.25);
    }
    .pal-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 14px;
      max-height: clamp(280px, 60vh, 420px);
      overflow-y: auto;
      padding: 12px;
      border-radius: 16px;
      background: rgba(9, 19, 30, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.2);
      box-shadow: inset 0 0 18px rgba(5, 15, 30, 0.45);
    }
    .pal-grid::-webkit-scrollbar {
      width: 8px;
    }
    .pal-grid::-webkit-scrollbar-track {
      background: rgba(13, 27, 42, 0.6);
      border-radius: 999px;
    }
    .pal-grid::-webkit-scrollbar-thumb {
      background: rgba(119, 141, 169, 0.45);
      border-radius: 999px;
    }
    body.kid-mode .pal-grid {
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    }
    .pal-card.compact {
      padding: 12px;
      border-radius: 14px;
      backdrop-filter: blur(2px);
    }
    .pal-card.compact img {
      width: 90px;
      height: 90px;
    }
    .pal-card.compact .name {
      font-size: 1rem;
    }
    .pal-card.compact .badge {
      font-size: 0.78rem;
    }
    .pal-card.compact .rarity {
      font-size: 0.72rem;
    }
    .pal-card.static {
      cursor: default;
    }
    .pal-card.static:hover {
      transform: none;
      background: var(--card-bg);
      box-shadow: none;
    }
    .pal-card.selectable {
      cursor: pointer;
    }
    .pal-card.selected {
      outline: 3px solid rgba(224, 225, 221, 0.55);
      box-shadow: 0 0 0 4px rgba(119, 141, 169, 0.35);
    }
    .breeding-result-card {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 20px;
      border-radius: 18px;
      background: linear-gradient(140deg, rgba(119, 141, 169, 0.35), rgba(13, 27, 42, 0.65));
      border: 1px solid rgba(224, 225, 221, 0.25);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
    }
    .breeding-result-card header {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .breeding-result-card h3 {
      margin: 0;
      font-size: 1.1rem;
    }
    .breeding-result-card p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .breeding-result {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-flow {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
    }
    .combo-arrow {
      font-size: 1.5rem;
      color: rgba(224, 225, 221, 0.85);
      font-weight: 700;
    }
    .breeding-tip {
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
      line-height: 1.5;
    }
    .breeding-combo-link {
      align-self: flex-start;
      padding: 10px 18px;
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.85), rgba(42, 157, 143, 0.65));
      color: #0d1b2a;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      font-size: 0.9rem;
      font-weight: 600;
      letter-spacing: 0.03em;
      box-shadow: 0 12px 24px rgba(2, 20, 22, 0.45);
      transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
    }
    .breeding-combo-link:hover,
    .breeding-combo-link:focus-visible {
      transform: translateY(-2px);
      opacity: 0.95;
      outline: none;
      box-shadow: 0 16px 32px rgba(2, 20, 22, 0.55);
    }
    .breeding-combos {
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .breeding-combo {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      gap: 10px;
      padding: 12px 16px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(13, 27, 42, 0.75), rgba(65, 90, 119, 0.45));
      border: 1px solid rgba(119, 141, 169, 0.25);
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }
    .breeding-combo:hover,
    .breeding-combo:focus-visible {
      transform: translateY(-3px);
      box-shadow: 0 16px 28px rgba(5, 15, 30, 0.55);
      border-color: rgba(224, 225, 221, 0.45);
      outline: none;
    }
    .breeding-combo--disabled {
      cursor: default;
      opacity: 0.65;
      border-style: dashed;
      pointer-events: none;
    }
    .breeding-combo--disabled:hover,
    .breeding-combo--disabled:focus-visible {
      transform: none;
      box-shadow: none;
      border-color: rgba(119, 141, 169, 0.25);
    }
    .breeding-combo .combo-arrow {
      font-size: 1.3rem;
    }
    .breeding-workspace .pal-card .badge {
      gap: 2px;
    }
    .breeding-workspace .pal-card .badge img {
      width: 14px;
      height: 14px;
    }
    .breeding-workspace .pal-card .caught-status {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      margin-bottom: 4px;
      color: var(--text);
      background: rgba(119, 141, 169, 0.2);
      text-align: center;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="true"] {
      background: rgba(42, 157, 143, 0.25);
      color: #daf5f0;
    }
    .breeding-workspace .pal-card .caught-status[data-caught="false"] {
      background: rgba(231, 111, 81, 0.25);
      color: #ffe0d8;
    }
    .breeding-baby-header {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      justify-content: space-between;
    }
    .breeding-baby-header h3 {
      margin: 0;
    }
    .empty-state {
      font-size: 0.92rem;
      color: rgba(224, 225, 221, 0.75);
      padding: 12px 0;
    }
    body.kid-mode .breeding-hero {
      background: linear-gradient(135deg, rgba(119, 141, 169, 0.92), rgba(65, 90, 119, 0.88));
    }
    body.kid-mode .breeding-hero__intro {
      font-size: 1rem;
    }
    body.kid-mode .breeding-panel__description,
    body.kid-mode .breeding-hero__callout p,
    body.kid-mode .breeding-advisor__header p,
    body.kid-mode .breeding-atlas__diagram header p {
      font-size: 0.9rem;
    }
    @media (max-width: 1024px) {
      .breeding-hero {
        grid-template-columns: minmax(0, 1fr);
      }
      .breeding-hero__callout {
        order: 3;
      }
    }
    @media (max-width: 768px) {
      .breeding-mode {
        padding: 20px 18px;
      }
      .pal-grid {
        max-height: clamp(240px, 55vh, 360px);
      }
      .breeding-tabs {
        width: 100%;
        justify-content: center;
      }
      .advisor-card {
        padding: 18px;
      }
      .breeding-combo {
        justify-content: center;
      }
    }
    /* Progress page */
    .progress-grid {
      display: grid;
      gap: 16px;
      margin-top: 16px;
    }
    @media (min-width: 640px) {
      .progress-grid {
        grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      }
    }
    .progress-card {
      position: relative;
      padding: 18px;
      border-radius: 18px;
      background: linear-gradient(135deg, rgba(65, 90, 119, 0.85), rgba(119, 141, 169, 0.6));
      box-shadow: 0 12px 24px rgba(13, 27, 42, 0.35);
      overflow: hidden;
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .progress-card::after {
      content: '';
      position: absolute;
      inset: auto -40px -40px auto;
      width: 160px;
      height: 160px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.35), transparent 70%);
      opacity: 0.8;
      pointer-events: none;
      transform: rotate(15deg);
    }
    .progress-card--hero {
      background: linear-gradient(135deg, rgba(42, 157, 143, 0.9), rgba(119, 141, 169, 0.65));
    }
    @media (min-width: 960px) {
      .progress-card--hero {
        grid-column: span 2;
      }
    }
    .progress-card__header {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
      z-index: 1;
    }
    .progress-card__icon {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      background: rgba(13, 27, 42, 0.35);
      display: grid;
      place-items: center;
      font-size: 1.6rem;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-card h3 {
      margin: 0;
      font-size: 1.2rem;
    }
    .progress-card p {
      margin: 0;
      font-size: 0.9rem;
      color: var(--muted);
    }
    .progress-meter {
      width: 100%;
      height: 14px;
      border-radius: 999px;
      background: rgba(13, 27, 42, 0.4);
      overflow: hidden;
      position: relative;
      z-index: 1;
    }
    .progress-meter .meter-fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.6s ease;
    }
    .progress-card__footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 8px;
      font-size: 0.85rem;
      position: relative;
      z-index: 1;
    }
    .progress-text {
      color: var(--light);
    }
    .progress-badge {
      background: rgba(13, 27, 42, 0.45);
      border-radius: 999px;
      padding: 4px 12px;
      font-size: 0.75rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--light);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.2);
    }

    .progress-overview {
      display: grid;
      gap: 18px;
      margin-top: clamp(12px, 2vw, 20px);
    }

    @media (min-width: 720px) {
      .progress-overview {
        grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      }
    }

    .progress-stage-card {
      position: relative;
      border-radius: 20px;
      padding: clamp(20px, 3vw, 32px);
      border: 1px solid rgba(119, 141, 169, 0.25);
      background: linear-gradient(135deg, rgba(27, 38, 59, 0.88), rgba(13, 27, 42, 0.82));
      overflow: hidden;
      display: grid;
      gap: 16px;
    }

    .progress-stage-card::after {
      content: '';
      position: absolute;
      inset: -80px auto auto -80px;
      width: clamp(220px, 30vw, 320px);
      height: clamp(220px, 30vw, 320px);
      background: radial-gradient(circle at center, rgba(114, 229, 196, 0.25), transparent 70%);
      opacity: 0.6;
      pointer-events: none;
    }

    .progress-stage-card__content {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }

    .progress-stage-card__badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(114, 229, 196, 0.12);
      color: var(--success);
    }

    .progress-stage-card__title {
      margin: 0;
      font-size: clamp(1.35rem, 2.3vw, 1.75rem);
    }

    .progress-stage-card__subtitle {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .progress-stage-card__meter {
      display: grid;
      gap: 6px;
    }

    .progress-stage-card__meter .label {
      font-size: 0.8rem;
      color: var(--muted);
    }

    .progress-stage-meter {
      width: 100%;
      height: 12px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.18);
      overflow: hidden;
    }

    .progress-stage-meter .fill {
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--success), var(--accent));
      transition: width 0.6s ease;
    }

    .progress-stage-card__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }

    .progress-stage-card__actions .btn {
      min-width: 160px;
    }
    .progress-route {
      position: relative;
      margin-top: clamp(16px, 4vw, 28px);
      padding: clamp(20px, 3vw, 32px);
      background: linear-gradient(135deg, rgba(35, 55, 88, 0.92), rgba(119, 141, 169, 0.55));
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 28px 48px rgba(8, 16, 32, 0.45);
      overflow: hidden;
      display: grid;
      gap: clamp(16px, 3vw, 28px);
    }
    .progress-route::after {
      content: '';
      position: absolute;
      inset: auto -60px -80px auto;
      width: 240px;
      height: 240px;
      background: radial-gradient(circle at center, rgba(224, 225, 221, 0.35), transparent 70%);
      opacity: 0.65;
      pointer-events: none;
      transform: rotate(18deg);
    }
    .progress-route__header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      gap: 18px;
      flex-wrap: wrap;
      position: relative;
      z-index: 1;
    }
    .progress-route__intro {
      display: grid;
      gap: 10px;
      max-width: 520px;
    }
    .progress-route__intro h3 {
      margin: 0;
      font-size: clamp(1.35rem, 2.2vw, 1.65rem);
    }
    .progress-route__intro p {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.85);
    }
    .progress-route__eyebrow {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 0.75rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      background: rgba(13, 27, 42, 0.45);
      padding: 6px 14px;
      border-radius: 999px;
      color: rgba(224, 225, 221, 0.85);
      font-weight: 700;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-route__eyebrow i {
      font-size: 0.85rem;
    }
    .progress-route__actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    .progress-route__stats {
      position: relative;
      z-index: 1;
    }
    .progress-route__next {
      margin: 0;
      font-size: 0.95rem;
      color: var(--light);
      position: relative;
      z-index: 1;
    }
    .progress-route__next strong {
      color: var(--text);
    }
    .progress-route__filters {
      position: relative;
      z-index: 1;
    }
    .progress-route__timeline {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 14px;
      padding-left: 42px;
    }
    .progress-route__timeline::before {
      content: '';
      position: absolute;
      left: 18px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: linear-gradient(180deg, rgba(224, 225, 221, 0.35), rgba(224, 225, 221, 0.05));
    }
    .progress-route__boss {
      position: relative;
      background: rgba(13, 27, 42, 0.55);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      box-shadow: 0 18px 36px rgba(0, 0, 0, 0.45);
      padding: 18px 20px 18px 22px;
      display: grid;
      gap: 10px;
      overflow: hidden;
    }
    .progress-route__boss::before {
      content: '';
      position: absolute;
      left: -30px;
      top: 22px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      box-shadow: 0 0 0 4px rgba(119, 141, 169, 0.35);
    }
    .progress-route__boss::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), transparent 65%);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    .progress-route__boss:hover::after,
    .progress-route__boss:focus-within::after {
      opacity: 0.35;
    }
    .progress-route__boss-head {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
    }
    .progress-route__boss-index {
      font-size: 0.85rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: rgba(224, 225, 221, 0.14);
      color: rgba(224, 225, 221, 0.9);
      padding: 6px 12px;
      border-radius: 999px;
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.2);
    }
    .progress-route__boss-body {
      flex: 1 1 auto;
      display: grid;
      gap: 4px;
      min-width: 0;
    }
    .progress-route__boss-body h4 {
      margin: 0;
      font-size: 1.05rem;
    }
    .progress-route__boss-body p {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.75);
    }
    .progress-route__boss-status {
      font-size: 0.8rem;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      color: rgba(224, 225, 221, 0.9);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.25);
    }
    .progress-route__boss-copy {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.82);
    }
    .progress-route__boss--complete::before {
      background: var(--success);
      box-shadow: 0 0 0 4px rgba(42, 157, 143, 0.35);
    }
    .progress-route__boss--complete .progress-route__boss-status {
      background: rgba(42, 157, 143, 0.28);
      color: #bff7ec;
      box-shadow: inset 0 0 0 1px rgba(42, 157, 143, 0.45);
    }
    .progress-route__boss--next::before {
      background: #ffd166;
      box-shadow: 0 0 0 4px rgba(255, 209, 102, 0.35);
    }
    .progress-route__boss--next .progress-route__boss-status {
      background: rgba(255, 209, 102, 0.25);
      color: #fff2c6;
      box-shadow: inset 0 0 0 1px rgba(255, 209, 102, 0.45);
    }
    .progress-route__boss--upcoming::before {
      background: rgba(119, 141, 169, 0.6);
    }
    .progress-route__boss--upcoming .progress-route__boss-status {
      background: rgba(119, 141, 169, 0.22);
      color: rgba(224, 225, 221, 0.7);
    }
    .progress-route__empty {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .route-controls {
      display: grid;
      gap: 14px;
      margin-bottom: clamp(12px, 3vw, 24px);
    }
    .route-controls__lead {
      margin: 0;
      font-size: 0.95rem;
      color: rgba(224, 225, 221, 0.82);
    }
    .route-controls__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    .route-controls__filters {
      margin-top: 4px;
    }
    .progress-choice-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(10, 16, 29, 0.72);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
      z-index: 2000;
    }
    .progress-choice-dialog {
      background: var(--card-bg);
      border-radius: 18px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.45);
      padding: 24px;
      width: min(420px, 100%);
      display: grid;
      gap: 16px;
    }
    body.kid-mode .progress-choice-dialog {
      border-radius: 22px;
    }
    .progress-choice-dialog h3 {
      margin: 0;
    }
    .progress-choice-dialog p {
      margin: 0;
      color: var(--muted);
      font-size: 0.95rem;
    }
    .progress-choice-options {
      display: grid;
      gap: 8px;
    }
    .progress-choice-option {
      display: flex;
      align-items: center;
      gap: 10px;
      background: rgba(255, 255, 255, 0.06);
      border-radius: 12px;
      padding: 8px 12px;
    }
    .progress-choice-option span {
      font-size: 0.95rem;
    }
    .progress-choice-helpers {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-helpers .btn {
      flex: 1 1 auto;
    }
    .progress-choice-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
    }
    .progress-choice-actions .btn {
      flex: 1 1 auto;
    }
    /* Base planner styles */
    .base-planner-layout {
      display: grid;
      gap: 24px;
      align-items: stretch;
      grid-template-columns: minmax(280px, 360px) minmax(0, 1fr);
      grid-template-areas:
        "intel intel"
        "level crew";
    }
    @media (max-width: 1024px) {
      .base-planner-layout {
        grid-template-columns: 1fr;
        grid-template-areas:
          "intel"
          "level"
          "crew";
      }
    }
    .base-card {
      background: linear-gradient(145deg, rgba(30, 50, 70, 0.92), rgba(21, 36, 53, 0.92));
      border-radius: 20px;
      padding: 20px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: 0 18px 36px rgba(8, 16, 32, 0.4);
      backdrop-filter: blur(12px);
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    .base-card--intel {
      grid-area: intel;
      position: relative;
      overflow: hidden;
      padding: 28px;
    }
    .base-card--intel::before {
      content: "";
      position: absolute;
      inset: -40% -10% auto -10%;
      height: 320px;
      background: radial-gradient(circle at 50% 50%, rgba(119, 141, 169, 0.3), transparent 60%);
      opacity: 0.75;
      pointer-events: none;
      transform: rotate(2deg);
    }
    .base-card--intel > * {
      position: relative;
      z-index: 1;
    }
    .base-card--level {
      grid-area: level;
      align-self: start;
    }
    .base-card--crew {
      grid-area: crew;
    }
    .base-intel__shuffle {
      background: rgba(119, 141, 169, 0.18);
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.45);
      color: var(--light);
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      padding: 6px 14px;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }
    .base-card__header--intel {
      align-items: center;
      gap: 18px;
      flex-wrap: wrap;
    }
    .base-card__header--intel .base-card__title {
      font-size: 1.4rem;
    }
    .base-card__header--intel .base-card__meta {
      font-size: 0.95rem;
    }
    .base-intel__shuffle:hover,
    .base-intel__shuffle:focus-visible {
      background: rgba(224, 225, 221, 0.2);
      transform: translateY(-1px);
      outline: none;
    }
    .base-intel__context {
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: flex-start;
      justify-content: flex-start;
      overflow-wrap: anywhere;
    }
    .base-intel-stage {
      flex: 1 1 260px;
    }
    .base-intel__controls {
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: flex-end;
      justify-content: flex-start;
    }
    .base-intel__hint {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: rgba(224, 225, 221, 0.65);
      text-align: right;
    }
    @media (max-width: 640px) {
      .base-card--intel {
        padding: 22px;
      }
      .base-intel__controls {
        width: 100%;
        align-items: stretch;
      }
      .base-intel__controls .base-intel__shuffle {
        width: 100%;
        text-align: center;
      }
      .base-intel__controls .base-intel__hint {
        text-align: center;
      }
    }
    .base-intel-stage {
      font-size: 0.82rem;
      color: rgba(224, 225, 221, 0.72);
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      background: rgba(10, 21, 34, 0.6);
      border-radius: 16px;
      padding: 12px 18px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.05);
    }
    .base-intel-stage__badge {
      background: rgba(42, 157, 143, 0.2);
      border: 1px solid rgba(42, 157, 143, 0.4);
      color: #9be8d8;
      border-radius: 999px;
      padding: 4px 10px;
      font-size: 0.7rem;
      letter-spacing: 0.05em;
      text-transform: uppercase;
    }
    .base-intel-stage span:first-child {
      font-weight: 600;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: var(--text);
    }
    .base-intel-notes {
      position: relative;
      display: grid;
      min-height: 180px;
      padding-top: 6px;
      overflow-wrap: anywhere;
    }
    .base-note {
      position: relative;
      grid-area: 1 / 1;
      border-radius: 18px;
      padding: 16px;
      background: rgba(10, 21, 34, 0.68);
      border: 1px solid rgba(119, 141, 169, 0.3);
      box-shadow: inset 0 0 0 1px rgba(224, 225, 221, 0.06);
      display: flex;
      flex-direction: column;
      overflow-wrap: anywhere;
      gap: 10px;
      opacity: 0;
      transform: translateY(8px) scale(0.98);
      transition: opacity 0.45s ease, transform 0.45s ease;
      pointer-events: none;
    }
    .base-note--active {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }
    .base-note__header {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .base-note__icon {
      width: 42px;
      height: 42px;
      border-radius: 14px;
      background: rgba(119, 141, 169, 0.2);
      display: grid;
      place-items: center;
      font-size: 1.4rem;
    }
    .base-note__title {
      margin: 0;
      font-size: 1rem;
    }
    .base-note__body {
      margin: 0;
      font-size: 0.9rem;
      color: rgba(224, 225, 221, 0.85);
      line-height: 1.45;
      overflow-wrap: anywhere;
    }
    .base-note__title {
      overflow-wrap: anywhere;
    }
    .base-note__body + .base-note__body {
      margin-top: -4px;
    }
    .base-note__badge {
      align-self: flex-start;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(148, 210, 189, 0.18);
      color: #e0f2f1;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(148, 210, 189, 0.35);
    }
    .base-note__footer {
      margin-top: auto;
      font-size: 0.78rem;
      color: rgba(224, 225, 221, 0.65);
    }
    body.kid-mode .base-note__body {
      font-size: 0.95rem;
    }
    .base-card__header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }
    .base-card__title {
      margin: 0;
      font-size: 1.2rem;
    }
    .base-card__meta {
      font-size: 0.85rem;
      color: var(--muted);
      margin-top: 2px;
    }
    .base-card__badge {
      align-self: flex-start;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      background: rgba(119, 141, 169, 0.2);
      color: var(--light);
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.3);
    }
    .base-level-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
    }
    .base-level-controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .base-level-summary__item {
      background: rgba(10, 22, 36, 0.55);
      border-radius: 14px;
      padding: 12px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .base-level-summary__label {
      font-size: 0.75rem;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--muted);
    }
    .base-level-summary__value {
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--text);
    }
    .base-level-slider {
      width: 100%;
      accent-color: var(--accent);
      margin: 6px 0 4px;
    }
    .base-toggle {
      background: rgba(119, 141, 169, 0.2);
      border: 1px solid rgba(119, 141, 169, 0.35);
      border-radius: 999px;
      color: var(--light);
      padding: 6px 14px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .base-toggle[aria-pressed="true"] {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .base-toggle:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .base-priority-list {
      display: grid;
      gap: 10px;
      margin: 0;
      padding: 0;
      list-style: none;
    }
    .base-priority-item {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      background: rgba(13, 27, 42, 0.65);
      border-radius: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-priority-item__icon {
      font-size: 1.1rem;
      line-height: 1;
    }
    .base-priority-item__content {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .base-priority-item__label {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .base-priority-item__note {
      font-size: 0.8rem;
      color: var(--muted);
      margin: 0;
    }
    .base-slot-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 16px;
    }
    .base-slot-card {
      position: relative;
      background: linear-gradient(155deg, rgba(25, 45, 65, 0.88), rgba(15, 28, 46, 0.92));
      border-radius: 18px;
      border: 1px solid rgba(119, 141, 169, 0.3);
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }
    .base-slot-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 18px 32px rgba(6, 14, 28, 0.45);
    }
    .base-slot-card__header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .base-slot-card__slot {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted);
    }
    .base-slot-card__status {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(119, 141, 169, 0.18);
      color: var(--light);
    }
    .base-slot-card__status--caught {
      border-color: rgba(42, 157, 143, 0.6);
      background: rgba(42, 157, 143, 0.2);
      color: var(--success);
    }
    .base-slot-card__status--missing {
      border-color: rgba(231, 111, 81, 0.55);
      background: rgba(231, 111, 81, 0.18);
      color: var(--danger);
    }
    .base-slot-card__pal {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .base-slot-card__portrait {
      width: 72px;
      height: 72px;
      border-radius: 16px;
      background: rgba(9, 20, 34, 0.9);
      object-fit: contain;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-slot-card__info {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .base-slot-card__name {
      margin: 0;
      font-size: 1rem;
    }
    .base-slot-card__types {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      font-size: 0.75rem;
      color: var(--muted);
    }
    .base-slot-card__types img {
      width: 18px;
      height: 18px;
    }
    .base-slot-card__work {
      margin: 0;
      padding: 0;
      list-style: none;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .base-slot-card__work li {
      background: rgba(119, 141, 169, 0.18);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 0.75rem;
      display: flex;
      gap: 6px;
      align-items: center;
      border: 1px solid rgba(119, 141, 169, 0.25);
    }
    .base-slot-card__actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .base-slot-card__action {
      background: rgba(119, 141, 169, 0.15);
      border: 1px solid rgba(119, 141, 169, 0.3);
      border-radius: 999px;
      color: var(--light);
      font-size: 0.75rem;
      padding: 6px 14px;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .base-slot-card__action:hover {
      background: rgba(119, 141, 169, 0.25);
      color: var(--text);
    }
    .base-slot-card__action--primary {
      background: var(--accent);
      color: var(--bg);
      border-color: var(--accent);
    }
    .base-slot-card__empty {
      min-height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 0.9rem;
      color: var(--muted);
      border: 1px dashed rgba(119, 141, 169, 0.3);
      border-radius: 18px;
      padding: 24px;
    }
    .base-coverage-grid {
      display: grid;
      gap: 10px;
    }
    .base-coverage-item {
      display: grid;
      gap: 6px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(13, 27, 42, 0.6);
      border: 1px solid rgba(119, 141, 169, 0.2);
    }
    .base-coverage-item__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.85rem;
      gap: 10px;
    }
    .base-coverage-item__title {
      font-weight: 600;
      display: flex;
      gap: 8px;
      align-items: center;
    }
    .base-coverage-item__status {
      font-size: 0.75rem;
      color: var(--muted);
    }
    .base-coverage-meter {
      width: 100%;
      height: 6px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.18);
      overflow: hidden;
    }
    .base-coverage-meter__fill {
      height: 100%;
      background: linear-gradient(90deg, rgba(119, 141, 169, 0.8), rgba(224, 225, 221, 0.9));
      border-radius: 999px;
      transition: width 0.3s ease;
    }
    .ranch-suggestion-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 8px;
    }
    .ranch-suggestion {
      padding: 12px;
      border-radius: 12px;
      background: rgba(15, 40, 64, 0.55);
      border: 1px solid rgba(119, 141, 169, 0.2);
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .ranch-suggestion__header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .ranch-suggestion__item {
      border: none;
      background: rgba(119, 141, 169, 0.15);
      color: inherit;
      padding: 6px 12px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-suggestion__item:hover,
    .ranch-suggestion__item:focus-visible {
      background: rgba(119, 141, 169, 0.3);
      color: var(--light);
      outline: none;
    }
    .ranch-suggestion__item[disabled] {
      cursor: not-allowed;
      opacity: 0.7;
    }
    .ranch-suggestion__reason {
      font-size: 0.9rem;
      color: var(--muted);
      flex: 1 1 160px;
    }
    .ranch-suggestion__action {
      margin: 0;
      font-size: 0.95rem;
    }
    .ranch-suggestion__producers {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.8);
    }
    .ranch-suggestion__producers--missing {
      color: var(--danger);
    }
    .ranch-suggestion__status {
      margin: 0;
      font-size: 0.85rem;
      color: rgba(224, 225, 221, 0.78);
    }
    .ranch-suggestion__controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    .ranch-suggestion__assign {
      border: 1px solid rgba(148, 210, 189, 0.4);
      background: rgba(148, 210, 189, 0.18);
      color: #d3f5eb;
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 0.85rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, transform 0.2s ease;
    }
    .ranch-suggestion__assign:hover,
    .ranch-suggestion__assign:focus-visible {
      background: rgba(148, 210, 189, 0.35);
      color: #0b1f2f;
      outline: none;
      transform: translateY(-1px);
    }
    .ranch-suggestion__assign[aria-pressed="true"] {
      background: rgba(148, 210, 189, 0.5);
      color: #0b1f2f;
      border-color: rgba(148, 210, 189, 0.65);
    }
    .ranch-suggestion__producer-list {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }
    .ranch-suggestion__producer-label {
      font-size: 0.75rem;
      color: rgba(224, 225, 221, 0.65);
      text-transform: uppercase;
      letter-spacing: 0.06em;
    }
    .ranch-suggestion__producer {
      border: 1px solid rgba(119, 141, 169, 0.35);
      background: rgba(13, 27, 42, 0.6);
      color: var(--light);
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 0.8rem;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-suggestion__producer:hover,
    .ranch-suggestion__producer:focus-visible {
      background: rgba(119, 141, 169, 0.35);
      outline: none;
    }
    .ranch-suggestion__producer.is-selected {
      background: rgba(148, 210, 189, 0.4);
      border-color: rgba(148, 210, 189, 0.7);
      color: #0b1f2f;
    }
    .ranch-suggestion--active {
      border-color: rgba(148, 210, 189, 0.6);
      box-shadow: 0 0 0 1px rgba(148, 210, 189, 0.2);
    }
    .base-coverage-item--ranch {
      border-color: rgba(148, 210, 189, 0.45);
      background: rgba(13, 40, 52, 0.7);
    }
    .ranch-assignment-list {
      display: grid;
      gap: 12px;
      margin-top: 12px;
    }
    .ranch-assignment-entry {
      display: grid;
      gap: 8px;
      padding: 12px;
      border: 1px solid rgba(148, 210, 189, 0.25);
      border-radius: 14px;
      background: rgba(12, 32, 44, 0.6);
    }
    .ranch-assignment-entry__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    .ranch-assignment-entry__title {
      margin: 0;
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--light);
    }
    .ranch-assignment-entry__count {
      font-size: 0.8rem;
      font-weight: 700;
      color: rgba(148, 210, 189, 0.85);
      background: rgba(148, 210, 189, 0.12);
      border: 1px solid rgba(148, 210, 189, 0.4);
      padding: 2px 8px;
      border-radius: 999px;
    }
    .ranch-assignment-entry__pal,
    .ranch-assignment-entry__reason,
    .ranch-assignment-entry__action {
      margin: 0;
      font-size: 0.82rem;
      color: rgba(224, 225, 221, 0.82);
    }
    .ranch-assignment-entry__controls {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }
    .ranch-assignment-entry__control {
      border: 1px solid rgba(148, 210, 189, 0.45);
      background: rgba(13, 27, 42, 0.7);
      color: var(--light);
      width: 32px;
      height: 32px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
      display: grid;
      place-items: center;
    }
    .ranch-assignment-entry__control:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }
    .ranch-assignment-entry__control:hover:not(:disabled),
    .ranch-assignment-entry__control:focus-visible:not(:disabled) {
      background: rgba(148, 210, 189, 0.25);
      border-color: rgba(148, 210, 189, 0.65);
      color: #0b1f2f;
      outline: none;
    }
    .ranch-assignment-entry__remove {
      border: 1px solid rgba(231, 111, 81, 0.5);
      background: rgba(231, 111, 81, 0.12);
      color: rgba(231, 188, 172, 0.95);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-assignment-entry__remove:hover,
    .ranch-assignment-entry__remove:focus-visible {
      background: rgba(231, 111, 81, 0.35);
      color: #fff5ef;
      outline: none;
    }
    .ranch-assignment-entry__footer {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
    }
    .ranch-assignment-summary__clear {
      justify-self: flex-start;
      border: 1px solid rgba(231, 111, 81, 0.5);
      background: rgba(231, 111, 81, 0.15);
      color: rgba(231, 188, 172, 0.95);
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease;
    }
    .ranch-assignment-summary__clear:hover,
    .ranch-assignment-summary__clear:focus-visible {
      background: rgba(231, 111, 81, 0.35);
      color: #fff5ef;
      outline: none;
    }
    .ranch-assignment-summary__quick {
      border: 1px solid rgba(148, 210, 189, 0.45);
      background: rgba(148, 210, 189, 0.14);
      color: rgba(224, 255, 244, 0.9);
      padding: 6px 14px;
      border-radius: 999px;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      transition: background 0.2s ease, color 0.2s ease, border-color 0.2s ease;
    }
    .ranch-assignment-summary__quick:hover,
    .ranch-assignment-summary__quick:focus-visible {
      background: rgba(148, 210, 189, 0.32);
      border-color: rgba(148, 210, 189, 0.65);
      color: #0b1f2f;
      outline: none;
    }
    .ranch-suggestion__badge {
      margin-left: auto;
      font-size: 0.75rem;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(148, 210, 189, 0.18);
      border: 1px solid rgba(148, 210, 189, 0.38);
      color: rgba(224, 255, 244, 0.85);
    }
    .ranch-roster {
      margin-top: 16px;
      padding: 16px;
      border-radius: 12px;
      background: rgba(17, 32, 48, 0.55);
      border: 1px solid rgba(119, 141, 169, 0.35);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .ranch-roster__title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }
    .ranch-roster__intro {
      margin: 0;
      font-size: 0.85rem;
      color: var(--muted);
    }
    .ranch-roster__list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .ranch-roster-option {
      border-radius: 10px;
      border: 1px solid rgba(119, 141, 169, 0.25);
      padding: 12px;
      background: rgba(14, 28, 44, 0.5);
      display: flex;
      flex-direction: column;
      gap: 8px;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .ranch-roster-option.is-active {
      border-color: rgba(119, 141, 169, 0.6);
      background: rgba(22, 40, 60, 0.65);
    }
    .ranch-roster-option__header {
      display: flex;
      align-items: center;
      gap: 8px;
      justify-content: space-between;
      flex-wrap: wrap;
    }
    .ranch-roster-option__name {
      font-weight: 600;
      font-size: 0.95rem;
    }
    .ranch-roster-option__badge {
      font-size: 0.75rem;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(119, 141, 169, 0.2);
      color: var(--light);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .ranch-roster-option__reason {
      margin: 0;
      font-size: 0.82rem;
      color: var(--muted);
      line-height: 1.4;
    }
    .ranch-roster-option__pal-list {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .ranch-roster-option__pal {
      border-radius: 999px;
      border: 1px solid rgba(119, 141, 169, 0.35);
      padding: 6px 12px;
      background: rgba(12, 24, 38, 0.65);
      color: var(--light);
      font-size: 0.82rem;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .ranch-roster-option__pal:hover,
    .ranch-roster-option__pal:focus-visible {
      outline: none;
      border-color: rgba(224, 225, 221, 0.45);
      background: rgba(29, 52, 74, 0.75);
    }
    .ranch-roster-option__pal.is-selected {
      background: rgba(42, 157, 143, 0.28);
      border-color: rgba(42, 157, 143, 0.75);
      color: var(--text);
    }
    .base-slot-card--ranch {
      border-color: rgba(148, 210, 189, 0.65);
      box-shadow: 0 0 0 1px rgba(148, 210, 189, 0.18);
    }
    .base-slot-card__assignment {
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(148, 210, 189, 0.6);
      background: rgba(148, 210, 189, 0.25);
      color: #d4f7eb;
    }
    .base-slot-card__note {
      font-size: 0.8rem;
      color: var(--muted);
      margin: 0;
    }
    .base-card__hint {
      font-size: 0.85rem;
      color: var(--muted);
      margin: 0;
    }
    /* Custom scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: var(--primary);
    }
    ::-webkit-scrollbar-thumb {
      background: var(--secondary);
      border-radius: 4px;
    }
  </style>
</head>
<body>
  <!-- Top navigation bar.  We move away from the vertical sidebar and instead
       present a horizontal bar across the top of the page.  Each button
       contains an icon and label.  The active tab is highlighted
       via a coloured underline defined in CSS. -->
  <nav id="navbar" data-open="false" aria-label="Primary navigation">
    <div class="nav-shell">
      <div class="nav-brand">
        <button type="button" id="navToggle" class="nav-toggle" aria-expanded="false" aria-controls="navbarLinks" aria-label="Open navigation menu">
          <span class="sr-only">Toggle navigation</span>
          <i class="fa-solid fa-bars"></i>
        </button>
        <div class="logo">Pal Marathon</div>
      </div>
      <!-- Navigation items.  We add Home, Map, Route and Glossary to
           provide quick access to all major sections of the app.  The
           first item (Home) is active by default.  Icons chosen via
           Font Awesome provide an intuitive visual cue for each tab. -->
      <div id="navbarLinks" class="nav-links">
        <button type="button" class="nav-item active" data-page="home"><i class="fa-solid fa-house"></i><span>Home</span></button>
        <button type="button" class="nav-item" data-page="pals"><i class="fa-solid fa-paw"></i><span>Pals</span></button>
        <button type="button" class="nav-item" data-page="map"><i class="fa-solid fa-map"></i><span>Map</span></button>
        <button type="button" class="nav-item" data-page="route"><i class="fa-solid fa-road"></i><span>Route</span></button>
        <button type="button" class="nav-item" data-page="tech"><i class="fa-solid fa-cog"></i><span>Tech</span></button>
        <button type="button" class="nav-item" data-page="base"><i class="fa-solid fa-helmet-safety"></i><span>Base</span></button>
        <button type="button" class="nav-item" data-page="items"><i class="fa-solid fa-box"></i><span>Items</span></button>
        <button type="button" class="nav-item" data-page="glossary"><i class="fa-solid fa-book-open"></i><span>Glossary</span></button>
        <button type="button" class="nav-item" data-page="breeding"><i class="fa-solid fa-egg"></i><span>Breeding</span></button>
        <button type="button" class="nav-item" data-page="progress"><i class="fa-solid fa-chart-line"></i><span>Progress</span></button>
      </div>
      <!-- Mode toggle button sits on the far right.  Clicking it
           switches between Kid Mode (simplified UI) and Grown‑up
           Mode (full details).  The icon updates accordingly. -->
      <div class="nav-actions">
        <button type="button" id="modeToggle" class="mode-btn" title="Switch to grown-up mode"><i class="fa-solid fa-child"></i></button>
      </div>
    </div>
  </nav>
  <main id="content" role="main">
      <!-- Home page -->
      <section id="homePage" class="page active">
        <header class="page-header">
          <h2>Tonight’s Plan</h2>
        </header>
        <p>Welcome to Pal Marathon, your companion guide for completing Palworld with your family. Pick the presentation style that fits your crew and use the snapshots below to jump back into the adventure.</p>
        <div id="homeCards"></div>
      </section>
      <!-- Pals page -->
      <section id="palsPage" class="page">
        <header class="page-header">
          <h2>Pals</h2>
          <div class="search-bar"><input id="palSearch" type="text" placeholder="Search pals by name, type, work or drops..."></div>
        </header>
        <div id="palFilters" class="pal-filters" aria-label="Filter pals">
          <div class="pal-filters__groups">
            <div class="pal-filter-group">
              <span class="pal-filter-label" id="palFilterStatusLabel">Collection status</span>
              <div class="pal-filter-chips" role="group" aria-labelledby="palFilterStatusLabel" data-filter-group="status"></div>
            </div>
            <div class="pal-filter-group">
              <span class="pal-filter-label" id="palFilterWorkLabel">Work roles</span>
              <div class="pal-filter-chips" role="group" aria-labelledby="palFilterWorkLabel" data-filter-group="work"></div>
            </div>
          </div>
          <div class="pal-filter-tools">
            <p id="palFilterSummary" class="pal-filter-summary" aria-live="polite"></p>
            <button type="button" id="palFilterReset" class="pal-filters__reset">Reset filters</button>
          </div>
        </div>
        <div id="palsList" class="card-grid"></div>
      </section>
      <!-- Items page -->
      <section id="itemsPage" class="page">
        <header class="page-header">
          <h2>Items</h2>
          <div class="search-bar"><input id="itemSearch" type="text" placeholder="Search items..."></div>
        </header>
        <div id="itemsList" class="card-grid"></div>
      </section>
      <!-- Map page -->
      <section id="mapPage" class="page">
        <header class="page-header">
          <h2>Map</h2>
        </header>
        <p>Explore Palpagos! Toggle layers to highlight points of interest. Open the interactive map for detailed navigation.</p>
        <div id="mapLayers"></div>
        <!-- Interactive map iframe: embed the palworld.gg map directly in the app with a larger viewing window. -->
        <div id="interactiveMapWrapper" class="map-iframe-wrapper">
          <iframe id="mapIframe" src="https://palworld.gg/map" title="Palworld Interactive Map" loading="lazy"></iframe>
        </div>
      </section>
      <!-- Route page -->
      <section id="routePage" class="page"></section>
      <!-- Tech page -->
      <section id="techPage" class="page">
        <header class="page-header">
          <h2>Technology Tree</h2>
        </header>
        <p>Browse every Technology and Ancient Technology tier just like the in-game tree. Review costs, materials, and mark blueprints as you unlock them.</p>
        <div id="techList"></div>
      </section>
      <!-- Base page -->
      <section id="basePage" class="page"></section>
      <!-- Breeding page -->
      <section id="breedingPage" class="page">
        <div class="breeding-hero">
          <div class="breeding-hero__content">
            <div class="breeding-hero__title">
              <div class="breeding-hero__icon"><i class="fa-solid fa-egg"></i></div>
              <h2>Breeding Workshop</h2>
            </div>
            <p class="breeding-hero__intro">Shape legendary partners with a smarter lab that scouts upgrades, maps ancestry, and predicts every egg you could incubate.</p>
            <ul class="breeding-perks">
              <li><i class="fa-solid fa-star-shooting"></i><span>Advisor cards spotlight your best new allies based on the pals you already own.</span></li>
              <li><i class="fa-solid fa-sitemap"></i><span>Ancestry Atlas paints every parent chain with elegant, tappable branches.</span></li>
              <li><i class="fa-solid fa-people-arrows"></i><span>Planner and lookup panels stay synced so combos drop into the pair lab instantly.</span></li>
            </ul>
          </div>
          <div class="breeding-hero__callout">
            <span>Pro tip</span>
            <p>Flag pals as caught from the Paldex grid and the advisor will re-rank every recipe to keep your breeding queue meaningful.</p>
          </div>
        </div>
        <div class="breeding-workspace">
          <div class="breeding-tabs" role="tablist" aria-label="Breeding planner modes">
            <button type="button" id="breedingTabAdvisor" class="breeding-tab active" data-target="breedingAdvisor" role="tab" aria-controls="breedingAdvisor" aria-selected="true" aria-pressed="true">
              <i class="fa-solid fa-crystal-ball"></i>
              <span>Insight Deck</span>
            </button>
            <button type="button" id="breedingTabAtlas" class="breeding-tab" data-target="breedingAtlas" role="tab" aria-controls="breedingAtlas" aria-selected="false" aria-pressed="false">
              <i class="fa-solid fa-tree"></i>
              <span>Ancestry Atlas</span>
            </button>
            <button type="button" id="breedingTabPairs" class="breeding-tab" data-target="breedingPairs" role="tab" aria-controls="breedingPairs" aria-selected="false" aria-pressed="false">
              <i class="fa-solid fa-people-group"></i>
              <span>Pair Lab</span>
            </button>
            <button type="button" id="breedingTabDiscover" class="breeding-tab" data-target="breedingDiscover" role="tab" aria-controls="breedingDiscover" aria-selected="false" aria-pressed="false">
              <i class="fa-solid fa-compass"></i>
              <span>Parent Finder</span>
            </button>
          </div>
          <div id="breedingAdvisor" class="breeding-mode active" role="tabpanel" aria-labelledby="breedingTabAdvisor" aria-hidden="false" tabindex="0">
            <div class="breeding-advisor">
              <header class="breeding-advisor__header">
                <h3 id="breedingAdvisorTitle">Advisor queue</h3>
                <p id="breedingAdvisorCopy">We scan your roster, reachable offspring, and partner skills to surface the smartest next hatches.</p>
              </header>
              <div class="breeding-advisor__grid" id="breedingAdvisorGrid" role="list"></div>
              <p class="breeding-advisor__empty" id="breedingAdvisorEmpty" hidden></p>
            </div>
          </div>
          <div id="breedingAtlas" class="breeding-mode" role="tabpanel" aria-labelledby="breedingTabAtlas" aria-hidden="true" tabindex="-1">
            <div class="breeding-atlas">
              <article class="breeding-panel breeding-atlas__picker">
                <div class="breeding-panel__header">
                  <h3>Ancestry target</h3>
                  <p class="breeding-panel__description">Search for a pal to trace every parent route. Tap a card to focus its branch.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="atlasSearch" placeholder="Search pals" aria-label="Search ancestry pals">
                </div>
                <div class="pal-grid" id="atlasGrid"></div>
              </article>
              <article class="breeding-atlas__diagram" aria-live="polite">
                <header>
                  <h3 id="atlasDiagramTitle">Select a pal to view its tree</h3>
                  <p id="atlasDiagramCopy">Every combo expands into collapsible branches so side monitors and tablets stay readable.</p>
                </header>
                <div class="breeding-tree" id="breedingTree"></div>
                <p class="breeding-atlas__empty" id="breedingAtlasEmpty" hidden></p>
              </article>
            </div>
          </div>
          <div id="breedingPairs" class="breeding-mode" role="tabpanel" aria-labelledby="breedingTabPairs" aria-hidden="true" tabindex="-1">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent A</h3>
                  <p class="breeding-panel__description">Choose your first partner. Filter by pal name or elemental type.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent1Search" placeholder="Search pals" aria-label="Search parent A pals">
                </div>
                <div class="pal-grid" id="parent1Grid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent B</h3>
                  <p class="breeding-panel__description">Match a second pal to balance breeding power and passives.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="parent2Search" placeholder="Search pals" aria-label="Search parent B pals">
                </div>
                <div class="pal-grid" id="parent2Grid"></div>
              </article>
              <article class="breeding-result-card">
                <header>
                  <h3>Predicted egg</h3>
                  <p>We average breeding power and surface the closest baby match.</p>
                </header>
                <div class="breeding-result" id="breedingResult"></div>
              </article>
            </div>
          </div>
          <div id="breedingDiscover" class="breeding-mode" role="tabpanel" aria-labelledby="breedingTabDiscover" aria-hidden="true" tabindex="-1">
            <div class="breeding-panels">
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Desired offspring</h3>
                  <p class="breeding-panel__description">Search for the pal you want to hatch or browse the list below.</p>
                </div>
                <div class="pal-search">
                  <input type="search" id="babySearch" placeholder="Search pals" aria-label="Search desired pals">
                </div>
                <div class="pal-grid" id="babyGrid"></div>
              </article>
              <article class="breeding-panel">
                <div class="breeding-panel__header">
                  <h3>Parent recipes</h3>
                  <p class="breeding-panel__description">Tap any combo to auto-fill the pair lab and jump straight to predictions.</p>
                </div>
                <div class="breeding-combos" id="breedingCombos"></div>
              </article>
            </div>
          </div>
        </div>
      </section>
      <!-- Progress page -->
      <section id="progressPage" class="page">
        <header class="page-header">
          <h2>Adaptive Progress</h2>
        </header>
        <p>Monitor your adaptive journey at a glance. Palmate keeps your current stage, pinned guides, pal roster, and workshop research in sync so you always know what to tackle next.</p>
        <div class="progress-overview">
          <article class="progress-stage-card">
            <div class="progress-stage-card__content">
              <span class="progress-stage-card__badge"><i class="fa-solid fa-compass"></i> Adaptive stage</span>
              <h3 id="progressStageTitle">Loading stage…</h3>
              <p id="progressStageSubtitle">We’ll surface your current milestone as soon as the guide loads.</p>
            </div>
            <div class="progress-stage-card__meter">
              <span class="label" id="progressStageLabel">Adaptive completion</span>
              <div class="progress-stage-meter" id="progressStageMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" id="progressStageFill"></div>
              </div>
            </div>
            <div class="progress-stage-card__actions">
              <button type="button" class="btn" id="progressStageResume" disabled>Resume next step</button>
              <button type="button" class="btn btn--ghost" id="progressStagePlanner">Open planner</button>
            </div>
          </article>
          <article class="progress-stage-card">
            <div class="progress-stage-card__content">
              <span class="progress-stage-card__badge"><i class="fa-solid fa-layer-group"></i> Active queue</span>
              <h3>Tonight’s active guides</h3>
              <p id="progressQueueSubtitle">Pin guides from the planner to keep them here for instant access.</p>
            </div>
            <ul class="adaptive-queue" id="progressActiveQueue">
              <li class="adaptive-queue__item">
                <div class="adaptive-queue__meta">
                  <p class="adaptive-queue__title">Queue loading…</p>
                  <p class="adaptive-queue__stats">Add an adaptive guide from the planner to see it here.</p>
                </div>
              </li>
            </ul>
            <div class="progress-stage-card__actions">
              <button type="button" class="btn btn--ghost" id="progressQueueManage">Manage queue</button>
            </div>
          </article>
        </div>
        <div class="progress-grid">
          <article class="progress-card progress-card--hero">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-book-open-reader"></i></div>
              <div>
                <h3>Adaptive guide completion</h3>
                <p>Track required steps, boss victories, and story & optional quests from your curated route.</p>
              </div>
            </div>
            <div class="progress-meter" id="guideProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="guideProgress"></div>
            </div>
            <div class="progress-card__footer" style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
              <div style="flex:1;display:flex;flex-direction:column;gap:4px">
                <span id="guideProgressText" class="progress-text"></span>
                <span id="bossQuestBadge" class="progress-badge"></span>
              </div>
              <button class="btn" id="resetRouteProgress" type="button">Reset Guide Progress</button>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-paw"></i></div>
              <div>
                <h3>Pal squad registry</h3>
                <p>Mark pals as recruited to keep your adaptive roster accurate.</p>
              </div>
            </div>
            <div class="progress-meter" id="palsProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="palsProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="palsProgressText" class="progress-text"></span>
            </div>
          </article>
          <article class="progress-card">
            <div class="progress-card__header">
              <div class="progress-card__icon"><i class="fa-solid fa-screwdriver-wrench"></i></div>
              <div>
                <h3>Workshop momentum</h3>
                <p>Unlock inventions to keep pace with the adaptive route recommendations.</p>
              </div>
            </div>
            <div class="progress-meter" id="techProgressMeter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="meter-fill" id="techProgress"></div>
            </div>
            <div class="progress-card__footer">
              <span id="techProgressText" class="progress-text"></span>
            </div>
          </article>
        </div>
        <section id="progressRouteSection" class="progress-route card">
          <div class="progress-route__header">
            <div class="progress-route__intro">
              <span class="progress-route__eyebrow"><i class="fa-solid fa-route"></i> Adaptive tracker</span>
              <h3>Route intelligence &amp; boss timeline</h3>
              <p id="progressRouteLead">Review boss victories, story milestones, and tune your adaptive filters without leaving this dashboard.</p>
            </div>
            <div class="progress-route__actions">
              <button type="button" class="btn" data-route-action="toggle-optional">Hide Optional</button>
              <button type="button" class="btn" data-route-action="jump-next" data-step-id="">Jump to next required</button>
            </div>
          </div>
          <div class="progress-route__stats route-overview__stats">
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-list-check"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="required-title">Required steps</p>
                  <p class="route-overview__stat-value" data-route-role="required-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="required-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="required-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="required-note">Main path objectives</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="optional-title">Optional tasks</p>
                  <p class="route-overview__stat-value" data-route-role="optional-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="optional-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="optional-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="optional-note">Bonus cleanup and prep</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-chess-king"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="boss-title">Bosses defeated</p>
                  <p class="route-overview__stat-value" data-route-role="boss-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="boss-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="boss-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="boss-note">Campaign bosses defeated so far</p>
            </article>
            <article class="route-overview__stat">
              <div class="route-overview__stat-header">
                <span class="route-overview__stat-icon"><i class="fa-solid fa-scroll"></i></span>
                <div>
                  <p class="route-overview__stat-title" data-route-role="quest-title">Story & optional quests</p>
                  <p class="route-overview__stat-value" data-route-role="quest-count">0/0</p>
                </div>
              </div>
              <div class="route-overview__meter" data-route-role="quest-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
                <div class="fill" data-route-role="quest-fill"></div>
              </div>
              <p class="route-overview__stat-sub" data-route-role="quest-note">Story and optional quest progress</p>
            </article>
          </div>
          <p class="progress-route__next" data-route-role="next-callout"></p>
          <div class="progress-route__filters" data-route-role="filters"></div>
          <div class="progress-route__timeline" id="progressBossTimeline"></div>
        </section>
      </section>
      <!-- Glossary page -->
      <section id="glossaryPage" class="page">
        <header class="page-header">
          <h2>Glossary</h2>
        </header>
        <p>Browse every passive trait, active skill, element matchup and work task in one place. Use the quick links and search boxes below to jump right to what you need.</p>
        <div id="glossaryContent"></div>
      </section>
  </main>
  <!-- Modal for pal details -->
  <div id="modal">
    <div id="modalContent">
      <button id="modalClose">Close</button>
      <div id="modalBody"></div>
    </div>
  </div>
  <script>
    // Data variables
    let PALS = {};
    let ITEMS = {};
    let TECH = [];
    let TECH_LOOKUP = {};
    let TECH_PAGE_STATE = null;
    let SKILL_DETAILS = {};
    let PASSIVE_DETAILS = {};
    let ITEM_DETAILS = {};
    let PARTNER_SKILLS = [];
    let RANCH_PRODUCER_CACHE = null;
    let ITEM_KEY_LOOKUP = new Map();
    // Map of items to pals that drop them.  Populated after data load.
    let DROPS_MAP = {};
    // Map pal names to IDs for quick lookup when clicking breeding
    // combos.  Populated after data load.
    let PAL_NAME_TO_ID = {};
    let PAL_SLUG_TO_ID = {};
    // Persist breeding page selections between rebuilds (e.g. when switching modes)
    const BREEDING_SELECTION = { parent1Id: null, parent2Id: null, babyId: null, atlasId: null, mode: 'breedingAdvisor' };
    let currentBreedingPageController = null;
    let baseBreedingRefreshHandle = null;
    let baseBreedingRefreshUsingTimeout = false;
    let baseBreedingNeedsAnalysis = false;
    const BREEDING_ROUTE_STEP_IDS = ['ch2-tech-breeding-farm'];
    const BREEDING_DUPLICATE_LIMIT = 2;
    // Progress tracking
    let caught = JSON.parse(localStorage.getItem('caught') || '{}');
    let collected = JSON.parse(localStorage.getItem('collected') || '{}');
    let unlocked = JSON.parse(localStorage.getItem('unlocked') || '{}');
    let refreshPalList = null;
    const KID_MODE_STORAGE_KEY = 'palmate:kidMode';
    // Maximum stats for scaling radar chart
    // Maximum stats for scaling radar chart.  Speed is capped lower to avoid
    // overpowering the chart – the fastest pals reach around 1000.
    const maxStats = { hp: 150, attack: 150, defense: 145, speed: 1000, stamina: 350, support: 150, food: 9 };
    // Type to environment mapping
    const environmentMap = {
      'Fire': 'Volcano',
      'Ice': 'Snow',
      'Electric': 'Coast',
      'Water': 'River',
      'Grass': 'Forest',
      'Ground': 'Desert',
      'Dark': 'Swamp',
      'Dragon': 'Mountains',
      'Air': 'Highlands',
      'Neutral': 'Plains'
    };
    // Rarity to recommended sphere
    const raritySphere = {
      1: 'Pal Sphere',
      2: 'Mega Sphere',
      3: 'Giga Sphere',
      4: 'Hyper Sphere',
      5: 'Ultra Sphere',
      6: 'Legendary Sphere'
    };
    // Human-friendly rarity names for better readability on cards and details.
    const rarityNames = {
      1: 'Common',
      2: 'Uncommon',
      3: 'Rare',
      4: 'Epic',
      5: 'Legendary',
      6: 'Mythic'
    };
    // Sphere capture rates and descriptions (approximate for guidance)
    const sphereRates = {
      'Pal Sphere': { rate: 0.3, description: 'Good for beginners and low-level pals (Lv 1-15)' },
      'Mega Sphere': { rate: 0.45, description: 'Better success for mid-level pals (Lv 16-30)' },
      'Giga Sphere': { rate: 0.6, description: 'Ideal for stronger pals (Lv 31-45)' },
      'Hyper Sphere': { rate: 0.75, description: 'Very high success for tough pals (Lv 46-60)' },
      'Ultra Sphere': { rate: 0.85, description: 'Excellent for very tough pals (Lv 61-70)' },
      'Legendary Sphere': { rate: 1.0, description: 'Guaranteed catch for legendary pals (Lv 71+)' }
    };
    // Trait lists for guidance (simplified)
    const goodTraits = ['Diligent', 'Runner', 'Strong', 'Loyal'];
    const badTraits = ['Coward', 'Lazy', 'Gullible'];

    const PALWORLD_BASE_URL = 'https://palworld.gg';
    const WORK_TYPE_DETAILS = {
      handiwork: { label: 'Handiwork', kidLabel: 'Building crew', icon: '🛠️' },
      transporting: { label: 'Transporting', kidLabel: 'Hauling crew', icon: '📦' },
      gathering: { label: 'Gathering', kidLabel: 'Picker', icon: '🎒' },
      lumbering: { label: 'Lumbering', kidLabel: 'Woodcutter', icon: '🪓' },
      mining: { label: 'Mining', kidLabel: 'Ore team', icon: '⛏️' },
      watering: { label: 'Watering', kidLabel: 'Water team', icon: '💧' },
      planting: { label: 'Planting', kidLabel: 'Seed planter', icon: '🌱' },
      kindling: { label: 'Kindling', kidLabel: 'Fire starter', icon: '🔥' },
      generating_electricity: { label: 'Electricity', kidLabel: 'Power pals', icon: '⚡' },
      cooling: { label: 'Cooling', kidLabel: 'Chillers', icon: '❄️' },
      medicine: { label: 'Medicine', kidLabel: 'Healers', icon: '💊' },
      farming: { label: 'Ranching', kidLabel: 'Ranch pals', icon: '🐑' }
    };
    const RANCH_ITEM_LIBRARY = {
      pal_sphere: {
        key: 'pal_sphere',
        name: 'Pal Sphere',
        tags: ['sphere', 'early', 'universal'],
        priority: 120,
        producers: ['Vixy'],
        openUrl: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Sphere')}`,
        reasons: {
          sphere: {
            kid: 'Pal Spheres help you catch lots of pals without shopping trips.',
            grown: 'Passive Pal Sphere income keeps capture sprees rolling between tech pushes.'
          },
          default: {
            kid: 'Pal Spheres keep your catching tools stocked up.',
            grown: 'Keep Pal Spheres flowing so every recruitment sprint stays smooth.'
          }
        }
      },
      egg: {
        key: 'egg',
        name: 'Eggs',
        tags: ['cake', 'early'],
        priority: 100,
        reasons: {
          cake: {
            kid: 'Cake batter needs lots of eggs soon.',
            grown: 'Breeding Cakes demand dozens of Eggs—build the surplus early.'
          },
          default: {
            kid: 'Eggs cook into tasty stamina snacks.',
            grown: 'Eggs keep the cooking pot productive before wheat farms scale.'
          }
        }
      },
      milk: {
        key: 'milk',
        name: 'Milk',
        tags: ['cake'],
        priority: 95,
        reasons: {
          cake: {
            kid: 'Cake cream needs lots of milk.',
            grown: 'Cake and high-tier meals burn through Milk nonstop once breeding starts.'
          },
          default: {
            kid: 'Milk keeps the cooking pot stocked.',
            grown: 'Milk covers cooking buffs while you chase late-game recipes.'
          }
        }
      },
      honey: {
        key: 'honey',
        name: 'Honey',
        tags: ['cake'],
        priority: 98,
        reasons: {
          cake: {
            kid: 'Honey is the sticky part of Cake—make sure it never runs out.',
            grown: 'Honey is the classic Cake bottleneck; automate it before the breeding rush.'
          },
          default: {
            kid: 'Honey sweetens lots of late meals.',
            grown: 'Honey supports Cake plus medicine buffs later on.'
          }
        }
      },
      wool: {
        key: 'wool',
        name: 'Wool',
        tags: ['cloth', 'cold', 'early'],
        priority: 90,
        reasons: {
          cloth: {
            kid: 'Wool spins into cloth for armor and story quests.',
            grown: 'Cloth stockpiles gate Chapter 1 prep and early armor upgrades.'
          },
          cold: {
            kid: 'Warm outfits need wool when you hike into the snow.',
            grown: 'Cold-resist armor and late gear both lean on a deep Wool reserve.'
          },
          default: {
            kid: 'Wool keeps the tailor busy.',
            grown: 'Wool converts to Cloth, blankets, and winter gear.'
          }
        }
      },
      high_quality_pal_oil: {
        key: 'high_quality_pal_oil',
        name: 'High Quality Pal Oil',
        tags: ['oil', 'advanced'],
        priority: 70,
        reasons: {
          oil: {
            kid: 'Factory parts and Polymer eat lots of shiny oil.',
            grown: 'Polymer, firearms, and Production Lines guzzle High Quality Pal Oil.'
          },
          default: {
            kid: 'Oil helps late-game machines work.',
            grown: 'HQ Pal Oil keeps late factories and weapon benches humming.'
          }
        }
      },
      pal_fluids: {
        key: 'pal_fluids',
        name: 'Pal Fluids',
        tags: ['medicine', 'advanced'],
        priority: 60,
        reasons: {
          medicine: {
            kid: 'Medicine benches and hot springs sip Pal Fluids.',
            grown: 'Electric and advanced medicine benches plus Hot Springs consume Pal Fluids constantly.'
          },
          default: {
            kid: 'Pal Fluids help heal pals.',
            grown: 'Pal Fluids feed medicine production and luxury baths.'
          }
        }
      }
    };
    const RANCH_PRODUCER_OVERRIDES = [
      { key: 'pal_sphere', name: 'Pal Sphere', producers: ['Vixy'] }
    ];
    const WORK_KEY_ALIASES = {
      medicine_production: 'medicine',
      electricity: 'generating_electricity'
    };
    const BASE_TECH_KEYWORDS = ['base', 'ranch', 'plantation', 'farm', 'logging', 'pit', 'furnace', 'generator', 'mill', 'feed', 'palbox', 'cooler', 'monitoring', 'breeding', 'workbench', 'assembly', 'refinery', 'hot spring'];
    const BASE_TECH_THRESHOLDS = [
      { techLevel: 1, level: 1 },
      { techLevel: 4, level: 2 },
      { techLevel: 7, level: 3 },
      { techLevel: 10, level: 4 },
      { techLevel: 15, level: 5 },
      { techLevel: 20, level: 6 },
      { techLevel: 28, level: 7 },
      { techLevel: 36, level: 8 },
      { techLevel: 45, level: 9 },
      { techLevel: 55, level: 10 }
    ];
    const BASE_INTEL_ROTATION_INTERVAL = 12000;
    const MEDICINE_TECH_NAMES = [
      'Medieval Medicine Workbench',
      'Electric Medicine Workbench',
      'Advanced Medicine Workbench'
    ];
    const FURNACE_TECH_NAMES = ['Primitive Furnace', 'Improved Furnace', 'Electric Furnace', 'Gigantic Furnace'];
    const POWER_TECH_NAMES = ['Human-Powered Generator', 'Power Generator', 'Production Assembly Line'];
    const BASE_STAGE_OVERVIEWS = {
      ch0: {
        icon: '🛖',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kid: {
          title: 'Build the starter camp',
          lines: [
            'Place the Palbox and Primitive Workbench so helpers know where to work.',
            'Add a Feed Box early so Lamballs and Cattiva stay happy while you learn jobs.'
          ]
        },
        grown: {
          title: 'Anchor Base #1',
          lines: [
            'Palbox + Primitive Workbench unlock automation toggles and your first crafting loop.',
            'A Feed Box right away keeps stamina downtime low as you juggle early chores.'
          ]
        }
      },
      ch1: {
        icon: '🎯',
        kid: {
          title: 'Make Pal Spheres nonstop',
          lines: [
            'Catch a Vixy and let it live on the Ranch—it digs up Pal Spheres for free.',
            'Logging Sites and Stone Pits keep wood and rocks ready for sphere crafting.'
          ]
        },
        grown: {
          title: 'Sphere supply & early automation',
          lines: [
            'Ranch a Vixy early; its unique ranch output is Pal Spheres, perfect for the capture spike.',
            'Automate wood and stone so Crusher + workbenches never stall while you push Tech Lv 8.'
          ]
        }
      },
      ch2: {
        icon: '🍰',
        kid: {
          title: 'Bake Cake ingredients',
          lines: [
            'Build a Wheat Plantation, Mill, and Cooking Pot so batter is always ready.',
            'Catch Mozzarina for milk, Chikipi for eggs, and Beegarde for honey.'
          ]
        },
        grown: {
          title: 'Farm lines for Cake & ingots',
          lines: [
            'Primitive Furnace plus Wheat → Mill → Cooking Pot is the midgame backbone.',
            'Secure Mozzarina, Chikipi, and Beegarde so milk, eggs, and honey flow into Cakes.'
          ]
        }
      },
      ch3: {
        icon: '❄️',
        kid: {
          title: 'Keep food cold',
          lines: [
            'A Cooler Box keeps snacks fresh while you travel through the snow.',
            'Leave strong fire pals on the furnace so metal keeps cooking.'
          ]
        },
        grown: {
          title: 'Snow prep & smelting uptime',
          lines: [
            'Cooler Box coverage protects food during long northern expeditions.',
            'Stack high-level Kindling on furnaces so refined ingots stay ahead of tech unlocks.'
          ]
        }
      },
      ch4: {
        icon: '🗺️',
        kid: {
          title: 'Plan Base Three',
          lines: [
            'Pick a desert or ice cliff for coal and shiny quartz.',
            'Bring pals that can mine, haul, and cool things down.'
          ]
        },
        grown: {
          title: 'Chart the resource campus',
          lines: [
            'Scout a coal/quartz plateau for Base #3 once base level 15 unlocks.',
            'Reserve strong Mining, Transporting, and Cooling pals for the expansion site.'
          ]
        }
      },
      ch5: {
        icon: '🌋',
        kid: {
          title: 'Heat-proof the factory',
          lines: [
            'Fire pals handle furnaces while Water pals cool food in the volcano zone.',
            'Pack extra feed so workers recover fast after hot jobs.'
          ]
        },
        grown: {
          title: 'Volcano logistics',
          lines: [
            'Keep Heat-resistant pals on furnaces and move spare Water/Cooling pals onto fridges.',
            'Stockpile coal and refine ore nonstop so weapon upgrades stay on schedule.'
          ]
        }
      },
      ch6: {
        icon: '⚡',
        kid: {
          title: 'Power every station',
          lines: [
            'Strong Electric pals should live on generators so machines keep running.',
            'Have one healer ready for surprise damage.'
          ]
        },
        grown: {
          title: 'Generator & support focus',
          lines: [
            'Marcus & Faleris prep demands continuous power—assign resilient Electricity pals to every generator.',
            'Begin rotating a medicine specialist so revives and first aid are covered.'
          ]
        }
      },
      ch7: {
        icon: '🩺',
        kid: {
          title: 'Keep everyone healed',
          lines: [
            'Unlock the fancy medicine tables and let a gentle pal run them.',
            'Double-check that fridges stay cold for late-game cooking.'
          ]
        },
        grown: {
          title: 'Late-game clinic & cooling',
          lines: [
            'Shadowbeak runs demand medkits—rotate high Medicine pals onto the bench when you unlock it.',
            'Cooling + Electricity coverage keeps the endgame assembly lines from stalling.'
          ]
        }
      },
      ch8: {
        icon: '🌸',
        kid: {
          title: 'Sakurajima supplies',
          lines: [
            'Bring extra gardeners so new crops grow fast in the pink isles.',
            'Swap pals between bases so power and cooling stay strong.'
          ]
        },
        grown: {
          title: 'Selyne support loop',
          lines: [
            'Balance Electricity, Cooling, and Medicine so Sakurajima recipes finish while you raid the island.',
            'Stage extra honey and flour so Cake breeding chains never pause.'
          ]
        }
      },
      ch9: {
        icon: '🛡️',
        kid: {
          title: 'Feybreak finale prep',
          lines: [
            'Make sure generators, coolers, and ranch pals are all full so battles stay easy.',
            'Keep your strongest pals rested before big fights.'
          ]
        },
        grown: {
          title: 'Feybreak sustain',
          lines: [
            'Max out power, cooling, and medicine coverage so Bastigor attempts always start with fresh stocks.',
            'Rotate Artisan handiwork pals so endgame ammo and armor finish quickly.'
          ]
        }
      },
      default: {
        icon: '🛠️',
        kid: {
          title: 'Keep the base happy',
          lines: [
            'Make sure someone builds, someone cooks, and someone carries goodies.',
            'Swap pals between jobs if a meter drops low.'
          ]
        },
        grown: {
          title: 'Balance the roster',
          lines: [
            'Watch your coverage meters—shift pals toward weak jobs to keep automation humming.',
            'Rotate captures based on upcoming tech unlocks so nothing bottlenecks the route.'
          ]
        }
      }
    };
    const BASE_STEP_NOTE_OVERRIDES = {
      'ch0-base-foundation': {
        icon: '🪵',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Place the Palbox',
        grownTitle: 'Anchor your first base',
        kidLines: [
          'Drop the Palbox and Primitive Workbench so pals know where to work.',
          'This lets Palmate track jobs for the Base planner.'
        ],
        grownLines: [
          'Palbox + Primitive Workbench unlocks automation toggles and fast access to build menus.',
          'Log the unlock in Palmate so route detection stays accurate.'
        ]
      },
      'ch0-base-feedbox': {
        icon: '🥕',
        badge: { kid: 'Bonus', grown: 'Optional' },
        kidTitle: 'Set up the Feed Box',
        grownTitle: 'Automate feeding',
        kidLines: [
          'A Feed Box keeps Lamball and Cattiva fed while you adventure.',
          'It stops work breaks from hunger.'
        ],
        grownLines: [
          'Early Feed Box placement keeps stamina downtime low as you expand Base #1.',
          'Even though optional, it speeds every other job immediately.'
        ]
      },
      'ch1-base-alarm-monitor': {
        icon: '🔔',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Build the alert bell',
        grownTitle: 'Set up alert network',
        kidLines: [
          'An Alarm Bell and Monitoring Stand warn you if pals get sleepy or hungry.',
          'Check in when it rings so work keeps going.'
        ],
        grownLines: [
          'Alarm Bell now, Monitoring Stand at Tech Lv 15 keeps downtime visible even when you roam.',
          'Pair it with rested Transporting pals so deliveries keep moving.'
        ]
      },
      'ch1-base-resource-sites': {
        icon: '🏭',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Build wood & rock helpers',
        grownTitle: 'Automate logs and stone',
        kidLines: [
          'Logging Sites and Stone Pits mean pals haul wood and rocks all day.',
          'Put a Crusher nearby so ore turns into Paldium for Pal Spheres.'
        ],
        grownLines: [
          'Drop Logging Site + Stone Pit at Tech Lv 7, then add a Crusher at Lv 8.',
          'This fuels sphere crafting and furnace inputs while you chase Zoe.'
        ]
      },
      'ch1-base-hot-spring': {
        icon: '🛁',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Hot Spring break',
        grownTitle: 'Install the Hot Spring',
        kidLines: [
          'A Hot Spring helps pals rest fast when they get tired.',
          'Keep it near the work sites so breaks are quick.'
        ],
        grownLines: [
          'Hot Springs dramatically shorten rest cycles—place one between crafting and furnace rows.',
          'It offsets the workload spike once Crusher and furnaces come online.'
        ]
      },
      'ch2-base-furnace': {
        icon: '🔥',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Light the furnace',
        grownTitle: 'Staff the Primitive Furnace',
        kidLines: [
          'Build the Primitive Furnace and leave two fire pals to keep it hot.',
          'Ingots are needed for saddles and better tools.'
        ],
        grownLines: [
          'Primitive Furnace unlocks at Tech Lv 10—assign high Kindling pals immediately.',
          'Parallel furnaces prevent metal bottlenecks during the cake/flyer rush.'
        ]
      },
      'ch2-base-farm-line': {
        icon: '🌾',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Start the wheat line',
        grownTitle: 'Build the Cake chain',
        kidLines: [
          'Plant wheat, grind flour, and cook it so Cake batter is ready.',
          'Let Water pals splash plantations so crops grow fast.'
        ],
        grownLines: [
          'Wheat Plantation + Mill + Cooking Pot should sit in one loop with Watering pals on call.',
          'Keep flour ahead of honey to avoid the Cake bottleneck once breeding opens.'
        ]
      },
      'ch2-base-ranch': {
        icon: '🍯',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Ranch sweet treats',
        grownTitle: 'Assign ranch producers',
        kidLines: [
          'Give Chikipi, Mozzarina, and Beegarde ranch jobs for eggs, milk, and honey.',
          'Those goodies turn into Cake for baby pals.'
        ],
        grownLines: [
          'Chikipi (eggs), Mozzarina (milk), and Beegarde/Elizabee (honey) cover the Cake recipe.',
          'Stage storage near the Cooking Pot so ingredients stay topped off.'
        ]
      },
      'ch2-base-new-site': {
        icon: '🏞️',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Place Base Two',
        grownTitle: 'Establish the ore campus',
        kidLines: [
          'Hit base level 10 then drop Base Two near a cliff packed with ore.',
          'Fly back often to empty the boxes.'
        ],
        grownLines: [
          'Base Lv 10 unlock lets you settle the Desolate Church ridge or similar ore shelf.',
          'Anchor furnaces and storage there to supercharge metal throughput.'
        ]
      },
      'roster-mining': {
        icon: '⛏️',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Keep miners ready',
        grownTitle: 'Mining lineup',
        kidLines: [
          'Have two or three mining pals like Digtoise or Rushoar working ore.',
          'Swap in stronger pals later like Anubis.'
        ],
        grownLines: [
          'Maintain at least two Mining specialists (Digtoise, Rushoar, Anubis) at every base.',
          'Their ore feed powers furnaces, Crusher, and sphere crafting simultaneously.'
        ]
      },
      'roster-lumber': {
        icon: '🪓',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Wood team',
        grownTitle: 'Lumber coverage',
        kidLines: [
          'Two lumber pals like Tanzee or Eikthyrdeer keep planks coming.',
          'Wood fuels Pal Spheres and building upgrades.'
        ],
        grownLines: [
          'Assign two Lumbering pals (Tanzee, Eikthyrdeer, or Dinossom) so planks and beams never stall builds.',
          'Combine with Transporters to keep Logging Site outputs moving.'
        ]
      },
      'roster-transport': {
        icon: '🚚',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Hauling pals',
        grownTitle: 'Transport loop',
        kidLines: [
          'Use fliers like Vixy or Pengullet to move items fast.',
          'Vixy on the Ranch can also dig up bonus Pal Spheres.'
        ],
        grownLines: [
          'Keep two dedicated Transporting pals—Pengullet, Vixy, or Fenglope—to prevent crafting clogs.',
          'Bonus: Vixy ranch duty produces Pal Spheres while it isn’t hauling.'
        ]
      },
      'roster-kindling': {
        icon: '🔥',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Fire pals',
        grownTitle: 'Kindling core',
        kidLines: [
          'Foxparks and later Ragnahawk should stay on furnaces and ovens.',
          'They make metal bars super fast.'
        ],
        grownLines: [
          'Maintain two high-level Kindling pals—Foxparks, Arsox, Ragnahawk—to keep furnaces blazing.',
          'Metal throughput is the gate on weapons, armor, and Cake cookware.'
        ]
      },
      'roster-watering': {
        icon: '💧',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Water team',
        grownTitle: 'Water & cooling',
        kidLines: [
          'Pengullet or Fuack can water crops and chill fridges.',
          'Cold pals keep food from spoiling.'
        ],
        grownLines: [
          'At least two Watering/Cooling pals (Pengullet, Surfent, Jormuntide) keep plantations and fridges online.',
          'Balance them between Cake production and exploration prep.'
        ]
      },
      'roster-handiwork': {
        icon: '🛠️',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Crafting pals',
        grownTitle: 'Handiwork trio',
        kidLines: [
          'Have three builders with Handywork so stations finish quick.',
          'Traits like Artisan make them even faster.'
        ],
        grownLines: [
          'Run three Handiwork specialists (Artisan trait preferred) so benches, ammo, and armor queue smoothly.',
          'Rotate extras into training to chase perfect passives.'
        ]
      },
      'roster-ranch': {
        icon: '🐝',
        badge: { kid: 'Roster', grown: 'Roster' },
        kidTitle: 'Ranch crew',
        grownTitle: 'Ranch rotation',
        kidLines: [
          'Keep ranch pals like Chikipi, Mozzarina, and Beegarde working the pens.',
          'They make eggs, milk, and honey while you explore.'
        ],
        grownLines: [
          'Reserve one or two ranch slots for Cake staples plus specialty drops (Vixy for Pal Spheres, Wool pals for cloth).',
          'Swap outputs based on the tech you are chasing next.'
        ]
      },
      'ch3-base-cooler': {
        icon: '❄️',
        badge: { kid: 'Guide step', grown: 'Guide step' },
        kidTitle: 'Cool the snacks',
        grownTitle: 'Install Cooler Box',
        kidLines: [
          'Build a Cooler Box so meat and berries stay fresh in the snow.',
          'Keep a Water or Ice pal nearby to power it.'
        ],
        grownLines: [
          'Cooler Box prevents spoilage during long Lily expeditions—staff it with Cooling pals before you leave.',
          'Pair it with Wheat + Honey stores so Cake baking continues while you travel.'
        ]
      },
      'ch4-base-plan': {
        icon: '🧭',
        badge: { kid: 'Optional', grown: 'Optional' },
        kidTitle: 'Plan the next base',
        grownTitle: 'Sketch Base #3',
        kidLines: [
          'Draw where Base Three will go—desert coal or icy quartz spots are best.',
          'List which pals you need to move there.'
        ],
        grownLines: [
          'Scout a plateau with dense coal/quartz for Base #3 and note which pals will migrate.',
          'Queue transporters and miners to follow once the slot unlocks.'
        ]
      }
    };
    let baseIntelState = { notes: [], activeIndex: 0, rotationTimer: null };
    const BASE_LEVEL_CONFIG = [
      {
        level: 1,
        label: 'Starter Camp',
        slots: 5,
        preferredRarity: 2,
        defaultWeight: 0.25,
        focus: ['Handiwork', 'Lumbering', 'Transporting'],
        copy: {
          kid: 'Keep the first camp busy with helpers who build, haul and chop wood.',
          grown: 'Lean on quick builders, haulers and lumber crews to finish early structures.'
        },
        workWeights: {
          handiwork: 1.2,
          transporting: 1.0,
          gathering: 0.85,
          lumbering: 1.1,
          mining: 0.9,
          watering: 0.55,
          planting: 0.45,
          kindling: 0.65,
          generating_electricity: 0.25,
          cooling: 0.2,
          medicine: 0.15,
          farming: 0.5
        }
      },
      {
        level: 2,
        label: 'Settled Outpost',
        slots: 7,
        preferredRarity: 2,
        defaultWeight: 0.25,
        focus: ['Handiwork', 'Mining', 'Watering'],
        copy: {
          kid: 'Add pals who can mine rock and carry water so crafting never pauses.',
          grown: 'Expand stone, water and handiwork coverage to unlock stronger buildings.'
        },
        workWeights: {
          handiwork: 1.15,
          transporting: 0.95,
          gathering: 0.7,
          lumbering: 1.05,
          mining: 1.0,
          watering: 0.7,
          planting: 0.55,
          kindling: 0.7,
          generating_electricity: 0.3,
          cooling: 0.2,
          medicine: 0.15,
          farming: 0.55
        }
      },
      {
        level: 3,
        label: 'Growing Workshop',
        slots: 9,
        preferredRarity: 3,
        defaultWeight: 0.25,
        focus: ['Mining', 'Kindling', 'Watering'],
        copy: {
          kid: 'Fire pals and miners keep furnaces roaring while water pals feed farms.',
          grown: 'Balance ore, furnaces and early crops so metal tools arrive on schedule.'
        },
        workWeights: {
          handiwork: 1.1,
          transporting: 0.9,
          gathering: 0.65,
          lumbering: 1.0,
          mining: 1.1,
          watering: 0.75,
          planting: 0.6,
          kindling: 0.75,
          generating_electricity: 0.35,
          cooling: 0.25,
          medicine: 0.2,
          farming: 0.6
        }
      },
      {
        level: 4,
        label: 'Elemental Shift',
        slots: 11,
        preferredRarity: 3,
        defaultWeight: 0.25,
        focus: ['Kindling', 'Watering', 'Planting'],
        copy: {
          kid: 'Fire pals light furnaces while garden pals grow berries for food.',
          grown: 'Kindling and irrigation ramp up production for cooking pots and plantations.'
        },
        workWeights: {
          handiwork: 1.0,
          transporting: 0.85,
          gathering: 0.6,
          lumbering: 0.95,
          mining: 1.1,
          watering: 0.8,
          planting: 0.7,
          kindling: 0.85,
          generating_electricity: 0.45,
          cooling: 0.3,
          medicine: 0.25,
          farming: 0.65
        }
      },
      {
        level: 5,
        label: 'Production Hub',
        slots: 13,
        preferredRarity: 4,
        defaultWeight: 0.25,
        focus: ['Planting', 'Watering', 'Kindling'],
        copy: {
          kid: 'Big farms need pals to plant, water and cook lots of food.',
          grown: 'Stabilise plantations, ranching and furnaces to support long craft queues.'
        },
        workWeights: {
          handiwork: 0.95,
          transporting: 0.8,
          gathering: 0.55,
          lumbering: 0.9,
          mining: 1.0,
          watering: 0.95,
          planting: 0.85,
          kindling: 0.9,
          generating_electricity: 0.55,
          cooling: 0.35,
          medicine: 0.3,
          farming: 0.75
        }
      },
      {
        level: 6,
        label: 'Powered Base',
        slots: 15,
        preferredRarity: 4,
        defaultWeight: 0.25,
        focus: ['Kindling', 'Planting', 'Electricity'],
        copy: {
          kid: 'Electric pals join the team so machines and fridges can stay on.',
          grown: 'Introduce generators without losing momentum on crops, cooking and smelting.'
        },
        workWeights: {
          handiwork: 0.9,
          transporting: 0.8,
          gathering: 0.5,
          lumbering: 0.85,
          mining: 0.95,
          watering: 1.0,
          planting: 0.9,
          kindling: 1.0,
          generating_electricity: 0.7,
          cooling: 0.45,
          medicine: 0.35,
          farming: 0.8
        }
      },
      {
        level: 7,
        label: 'Industrial Yard',
        slots: 17,
        preferredRarity: 5,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Watering', 'Planting'],
        copy: {
          kid: 'Power pals, gardeners and farmers keep every station buzzing.',
          grown: 'Push automation with strong generators while maintaining crop uptime.'
        },
        workWeights: {
          handiwork: 0.85,
          transporting: 0.75,
          gathering: 0.45,
          lumbering: 0.8,
          mining: 0.95,
          watering: 1.0,
          planting: 0.95,
          kindling: 1.05,
          generating_electricity: 0.85,
          cooling: 0.55,
          medicine: 0.4,
          farming: 0.85
        }
      },
      {
        level: 8,
        label: 'Balanced Campus',
        slots: 19,
        preferredRarity: 5,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Planting', 'Cooling'],
        copy: {
          kid: 'Keep the farm happy and the fridges cold while power stays green.',
          grown: 'Manage cooling, generators and plantations to prep for late-game crafting.'
        },
        workWeights: {
          handiwork: 0.8,
          transporting: 0.75,
          gathering: 0.45,
          lumbering: 0.75,
          mining: 0.9,
          watering: 1.0,
          planting: 1.0,
          kindling: 1.05,
          generating_electricity: 0.95,
          cooling: 0.7,
          medicine: 0.55,
          farming: 0.9
        }
      },
      {
        level: 9,
        label: 'Advanced Facility',
        slots: 22,
        preferredRarity: 6,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Cooling', 'Medicine'],
        copy: {
          kid: 'Science pals join to heal friends and power fancy machines.',
          grown: 'Late-game tech leans on reliable energy, refrigeration and medical coverage.'
        },
        workWeights: {
          handiwork: 0.75,
          transporting: 0.7,
          gathering: 0.4,
          lumbering: 0.7,
          mining: 0.85,
          watering: 1.05,
          planting: 1.05,
          kindling: 1.1,
          generating_electricity: 1.05,
          cooling: 0.85,
          medicine: 0.7,
          farming: 0.95
        }
      },
      {
        level: 10,
        label: 'Prime Headquarters',
        slots: 25,
        preferredRarity: 6,
        defaultWeight: 0.25,
        focus: ['Electricity', 'Medicine', 'Ranching'],
        copy: {
          kid: 'Your dream base runs on power pals, healers and ranch hands.',
          grown: 'Cover every specialty—power grids, cooling, medicine and ranch outputs stay maxed.'
        },
        workWeights: {
          handiwork: 0.7,
          transporting: 0.7,
          gathering: 0.4,
          lumbering: 0.65,
          mining: 0.8,
          watering: 1.05,
          planting: 1.05,
          kindling: 1.1,
          generating_electricity: 1.15,
          cooling: 0.95,
          medicine: 0.85,
          farming: 1.0
        }
      }
    ];
    const BASE_PLANNER_STORAGE_KEY = 'palmate:basePlanner';
    const MAX_RANCH_ASSIGNMENT_COUNT = 6;
    let basePlannerState = loadBasePlannerState();
    let basePlannerElements = {};
    let MAX_WORK_LEVEL = 4;

    // Whether we’re in Kid Mode.  Kid Mode simplifies the UI by
    // enlarging fonts, hiding advanced stats and using shorter
    // explanations.  Remember the user’s previous choice so the
    // experience stays consistent between visits.
    const savedKidMode = localStorage.getItem(KID_MODE_STORAGE_KEY);
    let kidMode = savedKidMode === null ? true : savedKidMode === 'true';
    document.body.classList.toggle('kid-mode', kidMode);
    persistKidMode();

    const WORK_ROLE_COPY = {
      kindling: { kid: 'Fire helper', grown: 'Kindling' },
      watering: { kid: 'Watering', grown: 'Watering' },
      planting: { kid: 'Plant seeds', grown: 'Planting' },
      generating_electricity: { kid: 'Make power', grown: 'Generating Electricity' },
      transporting: { kid: 'Carry items', grown: 'Transporting' },
      handiwork: { kid: 'Crafting', grown: 'Handiwork' },
      gathering: { kid: 'Gathering', grown: 'Gathering' },
      lumbering: { kid: 'Chop wood', grown: 'Lumbering' },
      mining: { kid: 'Mining', grown: 'Mining' },
      medicine: { kid: 'Healing', grown: 'Medicine' },
      medicine_production: { kid: 'Brew medicine', grown: 'Medicine Production' },
      cooling: { kid: 'Cooling', grown: 'Cooling' },
      farming: { kid: 'Ranch helper', grown: 'Farming' }
    };

    function getWorkRoleLabel(role){
      const entry = WORK_ROLE_COPY[role];
      const fallback = niceName(role);
      if(entry){
        const label = kidMode ? entry.kid : entry.grown;
        return label || fallback;
      }
      return fallback;
    }

    // Descriptions for active skills.  Each entry maps the skill key
    // (as it appears in the data) to a human-friendly object with
    // damage, type (AoE, cone, single-target) and a brief description
    // gleaned from community knowledge and official guides.  When
    // unknown, we provide a generic description encouraging players to
    // experiment.  Feel free to extend this dictionary with more
    // abilities as you discover them.
    const defaultSkillsDictionary = {
      'rolly_poly': { name:'Roly Poly', damage:'Low', type:'Charge', description:'Curls into a ball and rolls after foes; be careful as you may become dizzy afterwards' },
      'air_cannon': { name:'Air Cannon', damage:'Moderate', type:'Projectile', description:'Fires compressed air that pushes enemies back in a line' },
      'power_shot': { name:'Power Shot', damage:'Moderate', type:'Projectile', description:'Charges up and fires a strong projectile at a single target' },
      'implode': { name:'Implode', damage:'Massive', type:'Area', description:'Self-destructs in a powerful explosion harming all nearby – the user faints afterwards' },
      'electric_ball': { name:'Electric Ball', damage:'High', type:'Projectile', description:'Launches a ball of lightning that zaps enemies on contact' },
      'dragon_burst': { name:'Dragon Burst', damage:'High', type:'Area', description:'Unleashes draconic energy in a burst around the user' },
      'fire_blast': { name:'Fire Blast', damage:'High', type:'Cone', description:'Breathes fire in a wide cone, burning anything in its path' },
      'leaf_dance': { name:'Leaf Dance', damage:'Moderate', type:'Area', description:'Summons swirling leaves that slice nearby enemies' },
      // Additional skills with descriptions derived from the Palworld Wiki【841863502450800†L124-L156】.  These give
      // players a better sense of each move’s effect.
      'acid_rain': { name:'Acid Rain', damage:'Moderate', type:'Area', description:'Creates acidic clouds that pour down rain on enemies' },
      'air_blade': { name:'Air Blade', damage:'Moderate', type:'Fan', description:'Sends out sharp blades of air in a fan shape' },
      'apocalypse': { name:'Apocalypse', damage:'High', type:'Area', description:'Generates several dark vortexes in the surrounding area' },
      'aqua_burst': { name:'Aqua Burst', damage:'High', type:'Projectile', description:'Creates a giant ball of water and hurls it at an enemy' },
      'aqua_gun': { name:'Aqua Gun', damage:'Low', type:'Projectile', description:'Hurls a ball of water straight at an enemy' },
      'beam_slicer': { name:'Beam Slicer', damage:'Very High', type:'Beam', description:'Mows down the frontal area with a dragon beam; the impacted area explodes shortly after' },
      'blast_cannon': { name:'Blast Cannon', damage:'High', type:'Projectile', description:'Fires an energy bullet imbued with dragon power that explodes on impact' },
      'blizzard_spike': { name:'Blizzard Spike', damage:'Very High', type:'Projectile', description:'Creates a giant lump of ice and hurls it; damages those in the surrounding area upon impact' },
      'bog_blast': { name:'Bog Blast', damage:'Low', type:'Projectile', description:'Hurls sticky mud at an enemy' },
      'bubble_blast': { name:'Bubble Blast', damage:'Moderate', type:'Homing', description:'Fires numerous bubbles that slowly pursue an enemy' },
      'circle_vine': { name:'Circle Vine', damage:'High', type:'Area', description:'Sprouts sharp roots in and around the enemy’s location' },
      'comet_strike': { name:'Comet Strike', damage:'High', type:'Area', description:'Drops a meteorite straight down, generating a shock wave around the impact area' },
      'cryst_breath': { name:'Cryst Breath', damage:'High', type:'Cone', description:'Enshrouds an enemy in a frigid blast of air, dealing continuous damage' },
      'dark_arrow': { name:'Dark Arrow', damage:'Moderate', type:'Homing', description:'Fires off dark energy that homes in on an enemy' },
      'dark_ball': { name:'Dark Ball', damage:'Low', type:'Homing', description:'Unleashes a sphere of darkness that slowly tracks down the enemy' },
      'dark_cannon': { name:'Dark Cannon', damage:'Moderate', type:'Projectile', description:'Fires off dark energy that homes in on an enemy' },
      'dark_laser': { name:'Dark Laser', damage:'Very High', type:'Beam', description:'Charges dark energy before blasting enemies with a powerful beam' },
      'diamond_rain': { name:'Diamond Rain', damage:'Very High', type:'Area', description:'Creates numerous lumps of ice that consecutively drop on a foe’s head' },
      'draconic_breath': { name:'Draconic Breath', damage:'Moderate', type:'Cone', description:'Exhales breath imbued with draconic energy, dealing continuous damage to those in front' },
      'dragon_cannon': { name:'Dragon Cannon', damage:'Low', type:'Projectile', description:'Hurls an energy ball imbued with draconic energy at an enemy' },
      'dragon_meteor': { name:'Dragon Meteor', damage:'Very High', type:'Area', description:'Calls down numerous small meteorites and launches them at an enemy' },
      'fire_ball': { name:'Fire Ball', damage:'Very High', type:'Projectile', description:'Creates a giant ball of flames and hurls it; it explodes over a wide area upon impact' },
      'flame_funnel': { name:'Flame Funnel', damage:'High', type:'Area', description:'Creates multiple spheres of fiery energy, from which countless fireballs shoot towards the enemy' },
      'flame_wall': { name:'Flame Wall', damage:'High', type:'Area', description:'Creates a wall of flames at the enemy’s location; the wall remains and deals damage over time' },
      'flare_arrow': { name:'Flare Arrow', damage:'Moderate', type:'Homing', description:'Fires three flaming arrows in succession that home in on an enemy' },
      'flare_storm': { name:'Flare Storm', damage:'Moderate', type:'Area', description:'Generates two flaming tornadoes on either side before launching them at an enemy' }
    };
    let skillsDictionary = { ...defaultSkillsDictionary };

    // Descriptions for passive traits.  Each entry summarises the
    // benefits or drawbacks of the trait.  We extracted a few from
    // community guides and added our own commentary for others.  Add
    // additional traits here as needed.  Traits not present here
    // will display a generic encouragement to experiment.
    const defaultTraitsDictionary = {
      'Swift': 'Increases movement speed by 30%, letting your pal dash around quickly',
      'Legend': 'Raises Attack and Defense by 20% and Movement Speed by 15%',
      'Lord of the Sea': 'Increases Water attack damage by 20%',
      'Runner': 'Boosts movement speed by 20%',
      'Diligent': 'Raises work efficiency, making jobs go 20% faster',
      'Strong': 'Increases attack damage by 20%',
      'Loyal': 'Improves Attack and Defense slightly (about 10%)',
      'Coward': 'Lowers Attack and Defense by 10%; this pal gets scared easily',
      'Lazy': 'Decreases work speed by 20%, making tasks take longer',
      'Gullible': 'More susceptible to negative status effects; be wary when battling'
    };
    let traitsDictionary = { ...defaultTraitsDictionary };

    // Mapping of environment names to highlight coordinates.  Each
    // environment corresponds to a circular highlight on the map.  The
    // x and y values represent the percentage offsets from the top-left
    // corner of the map image, while w and h represent the diameter
    // percentages of the highlight.  These were chosen manually to
    // approximate the Palworld regions and provide a more natural
    // spotlight compared to boxy overlays.
    const zonePositions = {
      'Volcano': { x: 68, y: 10, w: 30, h: 30 },
      'Snow': { x: 10, y: 10, w: 25, h: 25 },
      'Plains': { x: 40, y: 50, w: 35, h: 35 },
      'Forest': { x: 12, y: 55, w: 25, h: 25 },
      'Coast': { x: 78, y: 60, w: 25, h: 25 },
      'Desert': { x: 50, y: 65, w: 25, h: 25 },
      'Swamp': { x: 85, y: 45, w: 20, h: 20 },
      'Mountains': { x: 50, y: 20, w: 25, h: 25 },
      'Highlands': { x: 40, y: 5, w: 30, h: 20 },
      'River': { x: 5, y: 70, w: 25, h: 20 }
    };

    const DATA_SOURCES = [
      'data/palworld_complete_data_final.json',
      'data/palworld_complete_data_enhanced.json',
      'data/palworld_complete_data.json'
    ];
    const EMBEDDED_DATA_SCRIPT = 'data/palworld_complete_data_fallback.js';
    const ITEM_DETAILS_SOURCES = ['data/item_details.json'];
    const ITEM_DETAILS_FALLBACK_SCRIPT = 'data/item_details_fallback.js';
    const ITEM_DETAILS_GLOBAL = '__PALMATE_ITEM_DETAILS__';
    const PARTNER_SKILL_SOURCES = ['data/partner_skills.json'];
    let embeddedDataPromise = null;
    let itemDetailsEmbeddedPromise = null;

    async function loadEmbeddedDataset() {
      if (window.__PALMATE_EMBEDDED_DATA__) {
        return window.__PALMATE_EMBEDDED_DATA__;
      }
      if (!embeddedDataPromise) {
        embeddedDataPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = EMBEDDED_DATA_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window.__PALMATE_EMBEDDED_DATA__ || null);
          script.onerror = event => {
            console.warn('Unable to load embedded dataset script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await embeddedDataPromise;
      } catch (err) {
        console.warn('Embedded dataset loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsFallback() {
      if (window[ITEM_DETAILS_GLOBAL]) {
        return window[ITEM_DETAILS_GLOBAL];
      }
      if (!itemDetailsEmbeddedPromise) {
        itemDetailsEmbeddedPromise = new Promise(resolve => {
          const script = document.createElement('script');
          script.src = ITEM_DETAILS_FALLBACK_SCRIPT;
          script.async = true;
          script.onload = () => resolve(window[ITEM_DETAILS_GLOBAL] || null);
          script.onerror = event => {
            console.warn('Unable to load item detail fallback script.', event);
            resolve(null);
          };
          document.head.appendChild(script);
        });
      }
      try {
        return await itemDetailsEmbeddedPromise;
      } catch (err) {
        console.warn('Item detail fallback loader failed.', err);
        return null;
      }
    }
    async function loadItemDetailsDataset() {
      const loadErrors = [];
      for (const source of ITEM_DETAILS_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          return payload;
        } catch (error) {
          loadErrors.push({ source, error });
          console.warn(`Failed to load item details from ${source}`, error);
        }
      }
      return null;
    }
    async function loadItemDetails() {
      const dataset = await loadItemDetailsDataset();
      if (dataset) return dataset;
      const fallback = await loadItemDetailsFallback();
      if (fallback) return fallback;
      console.warn('Item detail dataset unavailable. Item cards will use minimal info.');
      return {};
    }
    async function loadPartnerSkillDataset() {
      for (const source of PARTNER_SKILL_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (Array.isArray(payload)) {
            return payload;
          }
          console.warn(`Partner skill payload from ${source} was not an array.`);
        } catch (err) {
          console.warn(`Failed to load partner skills from ${source}`, err);
        }
      }
      return [];
    }
    // Type icon mapping (relative file paths)
    const iconMap = {
      'Neutral': 'assets/icons/neutral.png',
      'Fire': 'assets/icons/fire.png',
      'Ice': 'assets/icons/ice.png',
      'Electric': 'assets/icons/electric.png',
      'Water': 'assets/icons/water.png',
      'Grass': 'assets/icons/grass.png',
      'Ground': 'assets/icons/ground.png',
      'Dark': 'assets/icons/dark.png',
      'Dragon': 'assets/icons/dragon.png',
      'Air': 'assets/icons/air.png'
    };

    // A handful of recently added pals still lack bundled artwork.  Rather than
    // shipping temporary binary placeholders (which broke our last build), keep
    // a small deny-list of missing files so we can fall back to type icons
    // without triggering console errors.
    const missingPalArt = new Set([
      'assets/pals/098_astegon.png',
      'assets/pals/130_ice_reptyro.png',
      'assets/pals/131_ice_kingpaca.png',
      'assets/pals/138_selyne.png',
      'assets/pals/139_croajiro.png',
      'assets/pals/140_dogen.png'
    ]);

    function getPrimaryType(pal) {
      if (!pal || !Array.isArray(pal.types)) return 'Neutral';
      const type = pal.types.find(entry => typeof entry === 'string' && entry.trim().length);
      return type || 'Neutral';
    }

    function getPalIconSource(pal) {
      const primary = getPrimaryType(pal);
      return iconMap[primary] || iconMap['Neutral'];
    }

    function getPalArtSource(pal) {
      if (!pal) return null;
      const candidate = pal.localImage;
      if (!candidate || missingPalArt.has(candidate)) {
        return null;
      }
      return candidate;
    }

    function getPalOnlineArtSource(pal) {
      if (!pal) return null;
      const remote = typeof pal.image === 'string' ? pal.image.trim() : '';
      if (!remote) return null;
      return remote;
    }

    function applyPalArtwork(img, pal, { alt } = {}) {
      if (!img) return;
      const sources = [];
      const localArt = getPalArtSource(pal);
      if (localArt) sources.push(localArt);
      const onlineArt = getPalOnlineArtSource(pal);
      if (onlineArt && !sources.includes(onlineArt)) {
        sources.push(onlineArt);
      }
      const iconFallback = getPalIconSource(pal);
      if (iconFallback && !sources.includes(iconFallback)) {
        sources.push(iconFallback);
      }
      let attemptIndex = 0;
      function tryNextSource() {
        while (attemptIndex < sources.length) {
          const candidate = sources[attemptIndex++];
          if (!candidate) continue;
          if (/^https?:/i.test(candidate)) {
            img.referrerPolicy = img.referrerPolicy || 'no-referrer';
          } else if (img.referrerPolicy) {
            img.removeAttribute('referrerpolicy');
          }
          img.src = candidate;
          return;
        }
        img.removeEventListener('error', handleError);
      }
      function handleError() {
        if (attemptIndex < sources.length) {
          tryNextSource();
        } else {
          img.removeEventListener('error', handleError);
        }
      }
      img.loading = img.loading || 'lazy';
      img.decoding = img.decoding || 'async';
      if (alt !== undefined) {
        img.alt = alt;
      } else if (!img.alt || img.alt === '') {
        img.alt = pal && pal.name ? `${pal.name} artwork` : 'Pal artwork';
      }
      img.addEventListener('error', handleError);
      tryNextSource();
    }

    // Audio cues for a more immersive UI.  Users can add their own sound files
    // (e.g. click.mp3, modal_open.mp3, modal_close.mp3) inside assets/sounds.
    const clickSound = new Audio('assets/sounds/click.mp3');
    const openSound = new Audio('assets/sounds/modal_open.mp3');
    const closeSound = new Audio('assets/sounds/modal_close.mp3');
    function playSound(sound) {
      // Gracefully handle missing audio files
      if (!sound || typeof sound.play !== 'function') return;
      try {
        sound.currentTime = 0;
        const result = sound.play();
        if (result && typeof result.catch === 'function') {
          result.catch(err => console.debug('Sound error', err));
        }
      } catch (err) {
        // Audio play can fail if files are missing or browser policy blocks it
        console.debug('Sound error', err);
      }
    }
    // Navigation handling: top nav bar.  Each .nav-item button
    // switches to its associated page when clicked.  After the
    // switch, we play a click sound.  On small screens the nav
    // collapses into a menu controlled by #navToggle.
    const navElement = document.getElementById('navbar');
    const navToggle = document.getElementById('navToggle');
    const navItems = Array.from(document.querySelectorAll('#navbar .nav-item'));
    const navMobileQuery = window.matchMedia ? window.matchMedia('(max-width: 720px)') : { matches: false };
    const navToggleIcon = navToggle ? navToggle.querySelector('i') : null;

    function setNavOpen(desired) {
      if (!navElement || !navToggle) return;
      const open = !!desired;
      navElement.dataset.open = open ? 'true' : 'false';
      navToggle.setAttribute('aria-expanded', open ? 'true' : 'false');
      navToggle.setAttribute('aria-label', open ? 'Close navigation menu' : 'Open navigation menu');
      if (navToggleIcon) {
        navToggleIcon.classList.toggle('fa-bars', !open);
        navToggleIcon.classList.toggle('fa-xmark', open);
      }
    }

    function collapseNavIfMobile() {
      if (navToggle && navMobileQuery.matches) {
        setNavOpen(false);
      }
    }

    setNavOpen(false);

    if (navToggle) {
      navToggle.addEventListener('click', () => {
        const isOpen = navElement?.dataset.open === 'true';
        setNavOpen(!isOpen);
      });
      document.addEventListener('click', event => {
        if (!navElement || navElement.dataset.open !== 'true' || !navMobileQuery.matches) return;
        if (!navElement.contains(event.target)) {
          setNavOpen(false);
        }
      });
      document.addEventListener('keydown', event => {
        if (event.key === 'Escape' && navElement?.dataset.open === 'true') {
          setNavOpen(false);
          navToggle.focus();
        }
      });
      const navBreakpointHandler = event => {
        if (!event.matches) {
          setNavOpen(false);
        }
      };
      if (typeof navMobileQuery.addEventListener === 'function') {
        navMobileQuery.addEventListener('change', navBreakpointHandler);
      } else if (typeof navMobileQuery.addListener === 'function') {
        navMobileQuery.addListener(navBreakpointHandler);
      }
    }

    navItems.forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.getAttribute('data-page');
        switchPage(target);
        playSound(clickSound);
        collapseNavIfMobile();
      });
    });

    navItems.forEach(btn => {
      if (btn.classList.contains('active')) {
        btn.setAttribute('aria-current', 'page');
      }
    });

    function refreshModeUI() {
      document.body.classList.toggle('kid-mode', kidMode);
      const toggleTitle = document.getElementById('modeToggle');
      const modeIcon = toggleTitle ? toggleTitle.querySelector('i') : null;
      if (toggleTitle && modeIcon) {
        if (kidMode) {
          modeIcon.classList.remove('fa-user-astronaut');
          modeIcon.classList.add('fa-child');
          toggleTitle.title = 'Switch to grown-up mode';
        } else {
          modeIcon.classList.remove('fa-child');
          modeIcon.classList.add('fa-user-astronaut');
          toggleTitle.title = 'Switch to kid mode';
        }
      }
      document.querySelectorAll('[data-mode-card]').forEach(card => {
        const mode = card.getAttribute('data-mode-card');
        const active = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        card.classList.toggle('active', !!active);
        const status = card.querySelector('.mode-card__status');
        if (status) {
          status.textContent = active
            ? (mode === 'kid' ? 'Kid Mode active' : 'Grown-up Mode active')
            : (mode === 'kid' ? 'Switch to Kid Mode' : 'Switch to Grown-up Mode');
        }
      });
      document.querySelectorAll('[data-mode-choice]').forEach(btn => {
        const mode = btn.getAttribute('data-mode-choice');
        const isActive = (mode === 'kid' && kidMode) || (mode === 'grown' && !kidMode);
        btn.disabled = isActive;
        if (isActive) {
          btn.setAttribute('aria-pressed', 'true');
        } else {
          btn.removeAttribute('aria-pressed');
        }
      });
    }

    function bindRouteActionButtons(){
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        if(btn.dataset.boundToggle) return;
        btn.dataset.boundToggle = 'true';
        btn.addEventListener('click', () => {
          routeHideOptional = !routeHideOptional;
          persistRoutePreferences();
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          refreshRouteIntelligenceUI({ skipActiveList: true });
          playSound(clickSound);
        });
      });
      document.querySelectorAll('[data-route-action="toggle-suggestions"]').forEach(btn => {
        if(btn.dataset.boundSuggestions) return;
        btn.dataset.boundSuggestions = 'true';
        btn.addEventListener('click', () => {
          routeSuggestionsCollapsed = !routeSuggestionsCollapsed;
          applyRouteSuggestionsCollapseState();
          persistRoutePreferences();
          playSound(clickSound);
        });
      });
      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        if(btn.dataset.boundJump) return;
        btn.dataset.boundJump = 'true';
        btn.addEventListener('click', () => {
          const queued = btn.dataset.stepId;
          const next = queued
            || (findNextRouteStep() || findNextRouteStep({ includeOptional: true }))?.step?.id
            || '';
          if(next){
            queueRouteFocus(next);
          }
          playSound(clickSound);
        });
      });
    }

    function updateRouteToggleButtons(){
      const label = routeOptionalToggleLabel(routeHideOptional);
      const pressed = routeHideOptional ? 'true' : 'false';
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        btn.textContent = label;
        btn.setAttribute('aria-pressed', pressed);
      });
    }

    function rebuildModeAwarePages() {
      buildPalPage();
      buildItemPage();
      buildTechPage();
      buildBasePage();
      buildBreedingPage();
      buildGlossaryPage();
      renderRouteGuide();
      buildHomePage();
      buildProgressPage();
      updateProgressUI();
    }

    function persistKidMode() {
      try {
        localStorage.setItem(KID_MODE_STORAGE_KEY, kidMode ? 'true' : 'false');
      } catch (err) {
        console.warn('Failed to save kid mode preference', err);
      }
    }

    function setKidMode(value, { rebuild = true } = {}) {
      const desired = !!value;
      if (kidMode === desired) {
        persistKidMode();
        refreshModeUI();
        if (rebuild) {
          rebuildModeAwarePages();
        }
        return;
      }
      kidMode = desired;
      persistKidMode();
      refreshModeUI();
      if (rebuild) {
        rebuildModeAwarePages();
      }
    }

    // Mode toggle button: switch between kid and grown-up modes.  The
    // icon and tooltip change based on the current mode.  We also
    // rebuild pages so their copy matches the selected experience.
    document.getElementById('modeToggle').addEventListener('click', () => {
      setKidMode(!kidMode);
      playSound(clickSound);
    });
    refreshModeUI();
    function switchPage(page) {
      // Hide all pages and show the selected page.  Our pages are
      // <section> elements with IDs like palsPage, itemsPage, etc.
      document.querySelectorAll('.page').forEach(section => section.classList.remove('active'));
      const activePage = document.getElementById(page + 'Page');
      if (activePage) activePage.classList.add('active');
      // Update navigation item active state
      navItems.forEach(btn => {
        const isActive = btn.getAttribute('data-page') === page;
        btn.classList.toggle('active', isActive);
        if (isActive) {
          btn.setAttribute('aria-current', 'page');
        } else {
          btn.removeAttribute('aria-current');
        }
      });
      collapseNavIfMobile();
    }
    // Modal controls
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modalBody');
    document.getElementById('modalClose').addEventListener('click', closeModal);
    modal.addEventListener('click', event => {
      if (event.target === modal) {
        closeModal();
      }
    });
    // Track resize handlers registered by the map modal so they can be
    // removed when the dialog closes.  Without this cleanup we would leak
    // listeners as the player opens multiple guide entries.
    let mapResizeCleanup = null;
    function openModal() {
      modal.classList.add('active');
      playSound(openSound);
    }
    function closeModal() {
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      modal.classList.remove('active');
      modalBody.innerHTML = '';
      playSound(closeSound);
    }
    const PALWORLD_PAL_SLUG_OVERRIDES = {
      // Reserved for pals whose Palworld.gg slug does not match the default slugification.
    };
    const PALWORLD_ITEM_SLUG_OVERRIDES = {
      // Reserved for items whose Palworld.gg slug does not match their key.
    };
    const ROUTE_GLOSSARY_SUMMARIES = {
      'lifmunk-effigy': {
        title: 'Lifmunk Effigy',
        kid: [
          'Tiny glowing statues hidden all over Palworld.',
          'Feed them to the Statue of Power to make catching pals easier.'
        ],
        grown: [
          'Collectible statues that grant Capture Power when offered at a Statue of Power.',
          'Always grab them on sight; the bonus stacks and makes catching high-level pals easier.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Lifmunk Effigy')}`,
        note: 'Peek at Palworld.gg without losing your place in the route.'
      },
      'skill-fruit': {
        title: 'Skill Fruit',
        kid: [
          'Special fruit that lets a pal learn a new move.',
          'Find them in dungeons or treasure chests and save the ones you like.'
        ],
        grown: [
          'Consumable items that instantly teach the move printed on the fruit.',
          'Best sourced from dungeons; stash rare elements until you know which pal will use them.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Skill Fruit')}`,
        note: 'Palmate keeps this move info handy so you can stay on track.'
      },
      'pal-essence-condenser': {
        title: 'Pal Essence Condenser',
        kid: [
          'A special machine that eats extra pals to give your favorite buddy shiny stars.',
          'Those stars make their partner skill stronger and can even help with base jobs.'
        ],
        grown: [
          'Consumes 4, 16, 32 and 64 duplicates (116 total) to raise a partner skill to level 5.',
          'Each star boosts base stats and the 4★ upgrade grants +1 to every work suitability.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Essence Condenser')}`,
        note: 'Palmate keeps condensation tips nearby so you never lose the route context.'
      },
      'pal-condensation': {
        title: 'Pal Condensation',
        kid: [
          'Feeding the condenser pals makes partner moves power up one star at a time.',
          'Four stars also give that buddy better job levels back at base.'
        ],
        grown: [
          'Every condenser star increases partner skill level by one (to Lv.5) while adding base stat boosts.',
          'Damage-focused mounts scale hard with these ranks—watch for mount tags that boost player and pal damage.'
        ],
        url: `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent('Pal Essence Condenser')}`,
        note: 'Review condensation effects without leaving your tower or route notes.'
      }
    };
    // Palworld's in-game coordinates are not symmetrical on the X/Y axes.
    // The community map hosted at palworld.gg converts in-game positions to a
    // 256x256 tile space. Replicating that transform keeps our static map
    // markers aligned regardless of screen size or aspect ratio.
    // Palworld world coordinates convert to Leaflet tile space using a 7.8125 scale
    // factor with an origin offset of 128. This mirrors the transformation used by
    // palworld.gg so that static map markers align with the community map tiles.
    const MAP_SCALE = 7.8125;
    const MAP_OFFSET = 128;
    const MAP_LAT_BOUNDS = { min: -256, max: 0 };
    const MAP_LNG_BOUNDS = { min: 0, max: 256 };
    function clampToRange(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }
    function worldCoordsToPercent(coords) {
      if (!Array.isArray(coords) || coords.length < 2) {
        return { left: 50, top: 50 };
      }
      const [rawX, rawY] = coords.map(Number);
      const lng = clampToRange((rawX / MAP_SCALE) + MAP_OFFSET, MAP_LNG_BOUNDS.min, MAP_LNG_BOUNDS.max);
      const lat = clampToRange((rawY / MAP_SCALE) - MAP_OFFSET, MAP_LAT_BOUNDS.min, MAP_LAT_BOUNDS.max);
      const lngSpan = MAP_LNG_BOUNDS.max - MAP_LNG_BOUNDS.min;
      const latSpan = MAP_LAT_BOUNDS.max - MAP_LAT_BOUNDS.min;
      if (!lngSpan || !latSpan) {
        return { left: 50, top: 50 };
      }
      return {
        left: ((lng - MAP_LNG_BOUNDS.min) / lngSpan) * 100,
        top: ((MAP_LAT_BOUNDS.max - lat) / latSpan) * 100
      };
    }
    function mapDescriptionLines(info) {
      if (!info) return [];
      if (kidMode && Array.isArray(info.kid) && info.kid.length) {
        return info.kid;
      }
      if (!kidMode && Array.isArray(info.grown) && info.grown.length) {
        return info.grown;
      }
      if (info.note) {
        return [info.note];
      }
      return [];
    }
    function openRouteMapModal(mapInfo = {}, fallbackUrl) {
      const entrance = mapInfo.entrance || null;
      const entranceCoords = Array.isArray(mapInfo.entranceCoords)
        ? mapInfo.entranceCoords
        : (entrance && Array.isArray(entrance.coords) ? entrance.coords : null);
      const coords = entranceCoords || (Array.isArray(mapInfo.coords) ? mapInfo.coords : null);
      if (!coords) {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
        return;
      }
      if (typeof mapResizeCleanup === 'function') {
        mapResizeCleanup();
        mapResizeCleanup = null;
      }
      const { left, top } = worldCoordsToPercent(coords);
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'map-modal';
      const heading = document.createElement('h3');
      heading.textContent = mapInfo.title || 'Route location';
      wrap.appendChild(heading);
      const meta = document.createElement('p');
      meta.className = 'map-modal-note';
      const metaBits = [];
      if (mapInfo.region) metaBits.push(mapInfo.region);
      const primaryLabel = entrance && entrance.label ? entrance.label : (mapInfo.coordsLabel || 'Entrance');
      metaBits.push(`${primaryLabel}: (${coords[0]}, ${coords[1]})`);
      if (!entranceCoords && Array.isArray(mapInfo.coords) && mapInfo.coords.length >= 2) {
        metaBits.push(`Location: (${mapInfo.coords[0]}, ${mapInfo.coords[1]})`);
      }
      meta.textContent = metaBits.join(' • ');
      wrap.appendChild(meta);
      const details = [
        ...mapDescriptionLines(mapInfo),
        ...mapDescriptionLines(entrance)
      ];
      if (details.length) {
        const detailsWrap = document.createElement('div');
        detailsWrap.className = 'map-modal-details';
        details.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          detailsWrap.appendChild(p);
        });
        wrap.appendChild(detailsWrap);
      }
      const canvas = document.createElement('div');
      canvas.className = 'map-modal-canvas';
      const mapImage = document.createElement('img');
      mapImage.src = 'assets/images/palworld-full-map-2.webp';
      const mapAltTitle = entrance && entrance.label
        ? `${entrance.label} for ${mapInfo.title || 'the selected encounter'}`
        : (mapInfo.title ? `${mapInfo.title} location on the Palworld map` : 'Palworld map showing the selected route location');
      mapImage.alt = mapAltTitle;
      canvas.appendChild(mapImage);
      const marker = document.createElement('div');
      marker.className = 'map-marker';
      marker.style.left = `${left}%`;
      marker.style.top = `${top}%`;
      const markerLabel = (entrance && entrance.label) || mapInfo.label || mapInfo.title;
      if (markerLabel) {
        const label = document.createElement('span');
        label.className = 'map-marker-label';
        label.textContent = markerLabel;
        marker.appendChild(label);
      }
      canvas.appendChild(marker);
      mapResizeCleanup = null;
      wrap.appendChild(canvas);
      const actions = document.createElement('div');
      actions.className = 'badges';
      actions.style.marginTop = '4px';
      const openBtn = document.createElement('button');
      openBtn.type = 'button';
      openBtn.className = 'modal-action-btn';
      openBtn.textContent = 'Open interactive map';
      openBtn.addEventListener('click', () => {
        window.open(mapInfo.url || fallbackUrl || `${PALWORLD_BASE_URL}/map`, '_blank', 'noopener');
      });
      actions.appendChild(openBtn);
      wrap.appendChild(actions);
      modalBody.appendChild(wrap);
      openModal();
    }
    function openTowerMap(link) {
      if (!link) return;
      const info = link.map ? { ...link.map } : {};
      if (!info.url && link.url) {
        info.url = link.url;
      }
      if (!info.title) {
        info.title = niceName(link.id || 'Tower');
      }
      openRouteMapModal(info, link.url);
    }
    function slugifyForPalworld(text) {
      if (!text) return '';
      return text
        .toLowerCase()
        .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
        .replace(/&/g, ' and ')
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }
    function humaniseItemKey(key) {
      if (!key) return '';
      return key
        .split('_')
        .filter(Boolean)
        .map(part => part.charAt(0).toUpperCase() + part.slice(1))
        .join(' ');
    }

    function normalizeItemLookupKey(value) {
      if (value == null) return '';
      return String(value).trim().toLowerCase();
    }

    function registerItemAlias(alias, key) {
      const normalized = normalizeItemLookupKey(alias);
      if (!normalized || !key) return;
      const variants = new Set([normalized]);
      const collapsed = normalized.replace(/[\s_-]+/g, ' ').trim();
      if (collapsed) {
        variants.add(collapsed);
        variants.add(collapsed.replace(/\s+/g, '-'));
        variants.add(collapsed.replace(/\s+/g, '_'));
      }
      variants.forEach(variant => {
        if (!variant) return;
        if (!ITEM_KEY_LOOKUP.has(variant)) {
          ITEM_KEY_LOOKUP.set(variant, key);
        }
      });
    }

    function rebuildItemLookup() {
      ITEM_KEY_LOOKUP = new Map();
      const keys = new Set([
        ...Object.keys(ITEMS || {}),
        ...Object.keys(ITEM_DETAILS || {})
      ]);
      keys.forEach(key => {
        if (!key) return;
        registerItemAlias(key, key);
        const friendly = humaniseItemKey(key);
        registerItemAlias(friendly, key);
        const slug = slugifyForPalworld(friendly);
        if (slug) registerItemAlias(slug, key);
        const item = ITEMS?.[key];
        if (item?.name) registerItemAlias(item.name, key);
        const detail = ITEM_DETAILS?.[key];
        if (detail?.name) registerItemAlias(detail.name, key);
        if (Array.isArray(detail?.aliases)) {
          detail.aliases.forEach(alias => registerItemAlias(alias, key));
        }
      });
    }

    function lookupItemKey(value) {
      if (!value) return null;
      const normalized = normalizeItemLookupKey(value);
      if (!normalized) return null;
      if (ITEM_KEY_LOOKUP.has(normalized)) {
        return ITEM_KEY_LOOKUP.get(normalized);
      }
      const collapsed = normalized.replace(/[\s_-]+/g, ' ').trim();
      if (collapsed) {
        if (ITEM_KEY_LOOKUP.has(collapsed)) {
          return ITEM_KEY_LOOKUP.get(collapsed);
        }
        const hyphenated = collapsed.replace(/\s+/g, '-');
        if (ITEM_KEY_LOOKUP.has(hyphenated)) {
          return ITEM_KEY_LOOKUP.get(hyphenated);
        }
        const underscored = collapsed.replace(/\s+/g, '_');
        if (ITEM_KEY_LOOKUP.has(underscored)) {
          return ITEM_KEY_LOOKUP.get(underscored);
        }
      }
      const slug = slugifyForPalworld(value);
      if (slug) {
        const slugKey = normalizeItemLookupKey(slug);
        if (ITEM_KEY_LOOKUP.has(slugKey)) {
          return ITEM_KEY_LOOKUP.get(slugKey);
        }
      }
      return null;
    }

    function resolveItemKeyFromLink(link) {
      if (!link || typeof link !== 'object') return null;
      const candidates = [];
      if (link.id != null) candidates.push(link.id);
      if (link.slug != null) candidates.push(link.slug);
      if (link.name != null) candidates.push(link.name);
      if (link.title != null) candidates.push(link.title);
      for (const candidate of candidates) {
        const resolved = lookupItemKey(candidate);
        if (resolved) return resolved;
      }
      return null;
    }
    function canonicalizeRanchPalName(name) {
      return name ? String(name).trim().toLowerCase() : '';
    }
    function deriveRanchReasonForEntry(entry, stageTags) {
      if (!entry) return { kid: '', grown: '' };
      const reasons = entry.reasons || {};
      const tags = Array.isArray(entry.tags) ? entry.tags : [];
      if (stageTags && typeof stageTags.has === 'function') {
        for (const tag of tags) {
          if (stageTags.has(tag) && reasons[tag]) {
            return reasons[tag];
          }
        }
      }
      return reasons.default || { kid: '', grown: '' };
    }
    function composeDefaultRanchReason(itemName) {
      const label = itemName ? String(itemName).toLowerCase() : 'your focus item';
      return {
        kid: `Keep ${label} coming from the Ranch.`,
        grown: `Maintain a steady flow of ${label}.`
      };
    }
    function composeDefaultRanchActions(palName, itemName) {
      const label = itemName ? String(itemName).toLowerCase() : 'your focus item';
      if (palName) {
        return {
          kid: `Let ${palName} work the Ranch so ${label} stacks up.`,
          grown: `Assign ${palName} to produce ${label} automatically.`
        };
      }
      return {
        kid: `Keep ${label} flowing from the Ranch.`,
        grown: `Schedule ranch pals to maintain ${label} production.`
      };
    }
    function findRanchLibraryEntry(itemKey) {
      if (!itemKey) return null;
      if (RANCH_ITEM_LIBRARY && RANCH_ITEM_LIBRARY[itemKey]) {
        return RANCH_ITEM_LIBRARY[itemKey];
      }
      return Object.values(RANCH_ITEM_LIBRARY || {}).find(entry => entry && entry.key === itemKey) || null;
    }
    function invalidateRanchProducerCache() {
      RANCH_PRODUCER_CACHE = null;
    }
    function applyRanchProducerOverrides() {
      if (!Array.isArray(RANCH_PRODUCER_OVERRIDES)) return;
      RANCH_PRODUCER_OVERRIDES.forEach(entry => {
        if (!entry || !entry.key) return;
        const key = String(entry.key);
        const producers = Array.isArray(entry.producers) ? entry.producers.filter(Boolean) : [];
        const detail = ITEM_DETAILS[key] || {};
        const item = ITEMS && ITEMS[key] ? ITEMS[key] : null;
        const merged = new Set([
          ...(Array.isArray(detail.ranchProducers) ? detail.ranchProducers : []),
          ...(item && Array.isArray(item.ranchProducers) ? item.ranchProducers : []),
          ...producers
        ].map(name => String(name).trim()).filter(Boolean));
        if (!ITEM_DETAILS[key]) {
          ITEM_DETAILS[key] = { name: entry.name || humaniseItemKey(key) };
        }
        ITEM_DETAILS[key].ranchProducers = Array.from(merged);
        if (ITEMS && item) {
          ITEMS[key] = { ...item, ranchProducers: Array.from(merged) };
        }
        const libEntry = findRanchLibraryEntry(key);
        if (libEntry) {
          const libMerged = new Set([...(libEntry.producers || []), ...merged]);
          libEntry.producers = Array.from(libMerged);
        }
      });
      invalidateRanchProducerCache();
    }
    function getRanchProducerCatalog() {
      if (RANCH_PRODUCER_CACHE) {
        return RANCH_PRODUCER_CACHE;
      }
      const map = new Map();
      const ensureEntry = (itemKey, name) => {
        if (!itemKey) return null;
        const key = String(itemKey);
        if (!map.has(key)) {
          map.set(key, {
            itemKey: key,
            name: name || humaniseItemKey(key),
            producers: new Set(),
            libraryEntry: findRanchLibraryEntry(key)
          });
        } else if (name && !map.get(key).name) {
          map.get(key).name = name;
        }
        return map.get(key);
      };
      const register = (itemKey, name, producers) => {
        if (!itemKey) return;
        const record = ensureEntry(itemKey, name);
        if (!record) return;
        (Array.isArray(producers) ? producers : []).forEach(value => {
          if (!value) return;
          record.producers.add(String(value));
        });
      };
      Object.values(RANCH_ITEM_LIBRARY || {}).forEach(entry => {
        if (!entry) return;
        register(entry.key || entry.itemKey, entry.name, entry.producers);
      });
      Object.entries(ITEM_DETAILS || {}).forEach(([key, detail]) => {
        if (!detail) return;
        register(key, detail.name, detail.ranchProducers);
      });
      Object.entries(ITEMS || {}).forEach(([key, item]) => {
        if (!item) return;
        register(key, item.name, item.ranchProducers);
      });
      RANCH_PRODUCER_OVERRIDES.forEach(entry => {
        if (!entry) return;
        register(entry.key, entry.name, entry.producers);
      });
      const catalog = Array.from(map.values())
        .filter(entry => entry.producers.size)
        .map(entry => ({
          itemKey: entry.itemKey,
          name: entry.name || humaniseItemKey(entry.itemKey),
          producers: Array.from(entry.producers).sort((a, b) => a.localeCompare(b)),
          libraryEntry: entry.libraryEntry || findRanchLibraryEntry(entry.itemKey)
        }))
        .sort((a, b) => a.name.localeCompare(b.name));
      RANCH_PRODUCER_CACHE = catalog;
      return catalog;
    }
    function createManualRanchRecommendation(option, stageTags) {
      if (!option) return null;
      const libraryEntry = option.libraryEntry || findRanchLibraryEntry(option.itemKey);
      const reason = deriveRanchReasonForEntry(libraryEntry, stageTags);
      const defaults = composeDefaultRanchReason(option.name);
      const producers = Array.isArray(option.producers) ? option.producers.slice() : [];
      const caughtProducers = producers.filter(name => isPalCaughtByName(name));
      const missingProducers = producers.filter(name => !isPalCaughtByName(name));
      const hasDetail = !!(ITEM_DETAILS && ITEM_DETAILS[option.itemKey]) || !!(ITEMS && ITEMS[option.itemKey]);
      return {
        key: option.itemKey,
        itemKey: option.itemKey,
        name: option.name,
        reasonKid: reason?.kid || defaults.kid,
        reasonGrown: reason?.grown || defaults.grown,
        actionKid: libraryEntry?.actionKid || '',
        actionGrown: libraryEntry?.actionGrown || '',
        producers,
        caughtProducers,
        missingProducers,
        hasDetail,
        openUrl: libraryEntry?.openUrl || null
      };
    }
    function buildRanchRosterSection({ plan, assignments, kidMode }) {
      const catalog = getRanchProducerCatalog();
      if (!catalog.length) return null;
      const stageTags = plan?.stageTags instanceof Set
        ? new Set(Array.from(plan.stageTags))
        : new Set(Array.isArray(plan?.stageTags) ? plan.stageTags : []);
      const recommendedKeys = new Set((plan?.recommendations || []).map(rec => rec.itemKey));
      const assignmentLookup = new Map();
      (assignments || []).forEach(entry => {
        if (!entry) return;
        const itemKey = entry.itemKey || '';
        const palKey = canonicalizeRanchPalName(entry.palName);
        assignmentLookup.set(`${itemKey}|${palKey}`, entry);
      });
      const rows = catalog.map(option => {
        const producers = option.producers.map(name => {
          const canonical = canonicalizeRanchPalName(name);
          const assignmentKey = `${option.itemKey || ''}|${canonical}`;
          const assignment = assignmentLookup.get(assignmentKey) || null;
          const pal = findPalByName(name);
          const isCaught = isPalCaughtByName(name);
          const assignedCount = assignment ? Math.max(1, assignment.count || 1) : 0;
          return {
            name,
            pal,
            isCaught,
            isAssigned: !!assignment,
            assignedCount
          };
        });
        const caught = producers.filter(entry => entry.isCaught);
        if (!caught.length) return null;
        const recommendation = createManualRanchRecommendation(option, stageTags);
        const totalAssigned = producers.reduce((sum, entry) => sum + Math.max(0, entry.assignedCount || 0), 0);
        return {
          option,
          producers,
          caught,
          recommendation,
          totalAssigned,
          hasAssignment: totalAssigned > 0,
          isRecommended: recommendedKeys.has(option.itemKey)
        };
      }).filter(Boolean);
      if (!rows.length) return null;
      rows.sort((a, b) => {
        if (a.isRecommended !== b.isRecommended) {
          return a.isRecommended ? -1 : 1;
        }
        if (a.hasAssignment !== b.hasAssignment) {
          return a.hasAssignment ? -1 : 1;
        }
        if (b.totalAssigned !== a.totalAssigned) {
          return b.totalAssigned - a.totalAssigned;
        }
        return a.option.name.localeCompare(b.option.name);
      });
      const container = document.createElement('div');
      container.className = 'ranch-roster';
      const title = document.createElement('h4');
      title.className = 'ranch-roster__title';
      title.textContent = kidMode ? 'Your ranch pals' : 'Roster ranch options';
      container.appendChild(title);
      const intro = document.createElement('p');
      intro.className = 'ranch-roster__intro';
      intro.textContent = kidMode
        ? 'Tap a pal below to add them to the Ranch plan.'
        : 'Assign any captured ranch producer directly from your roster.';
      container.appendChild(intro);
      const list = document.createElement('div');
      list.className = 'ranch-roster__list';
      rows.forEach(row => {
        const card = document.createElement('div');
        card.className = 'ranch-roster-option';
        if (row.hasAssignment) card.classList.add('is-active');
        const header = document.createElement('div');
        header.className = 'ranch-roster-option__header';
        const name = document.createElement('span');
        name.className = 'ranch-roster-option__name';
        name.textContent = row.option.name;
        header.appendChild(name);
        if (row.isRecommended || row.hasAssignment) {
          const badge = document.createElement('span');
          badge.className = 'ranch-roster-option__badge';
          if (row.isRecommended && row.hasAssignment) {
            badge.textContent = kidMode ? 'Suggested & reserved' : 'Suggested • reserved';
          } else if (row.isRecommended) {
            badge.textContent = kidMode ? 'Suggested focus' : 'Suggested';
          } else {
            badge.textContent = kidMode
              ? `Reserved: ${row.totalAssigned}`
              : `Reserved slots: ${row.totalAssigned}`;
          }
          header.appendChild(badge);
        } else if (row.totalAssigned) {
          const badge = document.createElement('span');
          badge.className = 'ranch-roster-option__badge';
          badge.textContent = kidMode
            ? `Reserved: ${row.totalAssigned}`
            : `Reserved slots: ${row.totalAssigned}`;
          header.appendChild(badge);
        }
        card.appendChild(header);
        if (row.recommendation) {
          const reason = document.createElement('p');
          reason.className = 'ranch-roster-option__reason';
          const reasonText = kidMode ? row.recommendation.reasonKid : row.recommendation.reasonGrown;
          reason.textContent = reasonText || (kidMode
            ? `Keep ${row.option.name.toLowerCase()} coming from the Ranch.`
            : `Maintain ${row.option.name.toLowerCase()} production automatically.`);
          card.appendChild(reason);
        }
        const palList = document.createElement('div');
        palList.className = 'ranch-roster-option__pal-list';
        row.caught.forEach(producer => {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'ranch-roster-option__pal';
          if (producer.isAssigned) button.classList.add('is-selected');
          if (producer.isAssigned && producer.assignedCount > 1) {
            button.textContent = `${producer.name} ×${producer.assignedCount}`;
          } else if (producer.isAssigned) {
            button.textContent = `${producer.name} ✓`;
          } else {
            button.textContent = producer.name;
          }
          button.addEventListener('click', event => {
            event.stopPropagation();
            setRanchAssignmentFromRecommendation(row.recommendation, { palName: producer.name });
          });
          palList.appendChild(button);
        });
        card.appendChild(palList);
        list.appendChild(card);
      });
      container.appendChild(list);
      return container;
    }
    function clampRanchAssignmentCount(raw) {
      const numeric = Number(raw);
      if (!Number.isFinite(numeric)) {
        return 1;
      }
      return clampToRange(Math.round(numeric), 1, MAX_RANCH_ASSIGNMENT_COUNT || 1);
    }
    function normalizeRanchAssignmentEntry(raw) {
      if (!raw || typeof raw !== 'object') return null;
      const itemKey = raw.itemKey ? String(raw.itemKey) : null;
      const itemName = raw.itemName ? String(raw.itemName) : '';
      const palName = raw.palName ? String(raw.palName) : '';
      const palId = raw.palId != null && raw.palId !== '' && Number.isFinite(Number(raw.palId))
        ? Number(raw.palId)
        : null;
      return {
        itemKey,
        itemName,
        palId,
        palName,
        reasonKid: raw.reasonKid ? String(raw.reasonKid) : '',
        reasonGrown: raw.reasonGrown ? String(raw.reasonGrown) : '',
        actionKid: raw.actionKid ? String(raw.actionKid) : '',
        actionGrown: raw.actionGrown ? String(raw.actionGrown) : '',
        noteKid: raw.noteKid ? String(raw.noteKid) : '',
        noteGrown: raw.noteGrown ? String(raw.noteGrown) : '',
        timestamp: Number.isFinite(Number(raw.timestamp)) ? Number(raw.timestamp) : Date.now(),
        count: clampRanchAssignmentCount(raw.count || 1)
      };
    }
    function normalizeRanchAssignment(raw) {
      return normalizeRanchAssignmentEntry(raw);
    }
    function normalizeRanchAssignments(raw) {
      if (!raw) return [];
      const source = Array.isArray(raw) ? raw : [raw];
      const normalized = source.map(entry => normalizeRanchAssignmentEntry(entry)).filter(Boolean);
      const seen = new Set();
      return normalized.filter(entry => {
        const key = `${entry.itemKey || ''}|${canonicalizeRanchPalName(entry.palName)}`;
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
    }
    function loadBasePlannerState() {
      const defaults = { mode: 'auto', manualLevel: 1, ranchAssignments: [] };
      try {
        const stored = localStorage.getItem(BASE_PLANNER_STORAGE_KEY);
        if (!stored) {
          return { ...defaults };
        }
        const parsed = JSON.parse(stored);
        if (!parsed || typeof parsed !== 'object') {
          return { ...defaults };
        }
        const mode = parsed.mode === 'manual' ? 'manual' : 'auto';
        const levelRaw = Number(parsed.manualLevel);
        const manualLevel = clampToRange(Number.isFinite(levelRaw) ? Math.round(levelRaw) : 1, 1, BASE_LEVEL_CONFIG.length || 1);
        const assignments = normalizeRanchAssignments(parsed.ranchAssignments);
        if (!assignments.length && parsed.ranchAssignment) {
          const legacy = normalizeRanchAssignmentEntry(parsed.ranchAssignment);
          if (legacy) assignments.push(legacy);
        }
        return { mode, manualLevel, ranchAssignments: assignments };
      } catch (err) {
        console.warn('Failed to load base planner state', err);
        return { ...defaults };
      }
    }
    function persistBasePlannerState() {
      try {
        localStorage.setItem(BASE_PLANNER_STORAGE_KEY, JSON.stringify(basePlannerState));
      } catch (err) {
        console.warn('Failed to persist base planner state', err);
      }
    }
    function canonicalWorkKey(key) {
      if (!key) return null;
      const normalized = String(key).toLowerCase();
      return WORK_KEY_ALIASES[normalized] || normalized;
    }
    function getWorkTypeDetail(key) {
      const canonical = canonicalWorkKey(key);
      return WORK_TYPE_DETAILS[canonical] || { label: humaniseItemKey(canonical || key || 'Work'), kidLabel: humaniseItemKey(canonical || key || 'Work'), icon: '⭐' };
    }
    function priorityDescriptor(weight) {
      if (weight >= 1.1) {
        return { kid: 'Mega important job', grown: 'Critical priority' };
      }
      if (weight >= 0.95) {
        return { kid: 'Very important job', grown: 'High priority' };
      }
      if (weight >= 0.75) {
        return { kid: 'Helpful job', grown: 'Support priority' };
      }
      if (weight >= 0.5) {
        return { kid: 'Nice to have', grown: 'Supplemental focus' };
      }
      return { kid: 'Bonus coverage', grown: 'Low priority' };
    }
    function coverageDescriptor(weight, totalLevel, config, highestWeight) {
      const slots = Math.max(1, config?.slots || 1);
      const maxWork = Math.max(1, MAX_WORK_LEVEL);
      const normalized = totalLevel > 0 ? totalLevel / (slots * maxWork) : 0;
      const priorityFactor = highestWeight > 0 ? weight / highestWeight : 1;
      const effective = normalized * (0.6 + 0.4 * priorityFactor);
      if (totalLevel <= 0) {
        return { kid: 'Add a pal here', grown: 'No coverage yet', percent: 0 };
      }
      if (effective >= 0.75) {
        return { kid: 'Crew ready', grown: 'Excellent coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      if (effective >= 0.5) {
        return { kid: 'Strong', grown: 'Strong coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      if (effective >= 0.3) {
        return { kid: 'Okay', grown: 'Light coverage', percent: Math.min(100, Math.round(normalized * 100)) };
      }
      return { kid: 'Needs helpers', grown: 'Needs attention', percent: Math.min(100, Math.round(normalized * 100)) };
    }
    function gatherUpcomingRouteSteps(limit = 8, { includeOptional = true } = {}) {
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const upcoming = [];
      for (const chapter of chapters) {
        if (!chapter) continue;
        const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
        for (const step of steps) {
          if (!step) continue;
          if (!includeOptional && step.optional) continue;
          if (routeState && routeState[step.id]) continue;
          upcoming.push({ chapter, step });
          if (upcoming.length >= limit) {
            return upcoming;
          }
        }
      }
      return upcoming;
    }
    function computeRanchPlan({ stageSnapshot, limit = 5 } = {}) {
      const plan = {
        recommendations: [],
        summaryKid: '',
        summaryGrown: '',
        hasRanch: isTechUnlocked('Ranch'),
        stageTags: new Set()
      };
      const stageId = stageSnapshot?.stageId || null;
      const stageIndex = typeof stageSnapshot?.stageIndex === 'number' ? stageSnapshot.stageIndex : -1;
      const tags = plan.stageTags;
      if (stageIndex <= 1) tags.add('early');
      if (stageIndex <= 4) tags.add('sphere');
      if (stageIndex >= 2) tags.add('mid');
      if (stageIndex >= 3) tags.add('cold');
      if (stageIndex >= 4) tags.add('advanced');
      if (stageId === 'ch1') tags.add('cloth');
      if (stageId === 'ch2') tags.add('cake');
      if (stageId === 'ch3') tags.add('cold');
      if (stageId && /^ch\d+/i.test(stageId)) {
        const numeric = Number(stageId.replace(/[^0-9]/g, ''));
        if (Number.isFinite(numeric) && numeric >= 4) tags.add('oil');
      }
      const upcomingSteps = gatherUpcomingRouteSteps(12);
      const addTagsFromText = raw => {
        if (!raw) return;
        const text = String(raw).toLowerCase();
        if (text.includes('cake') || text.includes('breeding farm') || text.includes('bake')) tags.add('cake');
        if (text.includes('cloth') || text.includes('wool') || text.includes('tailor')) tags.add('cloth');
        if (text.includes('snow') || text.includes('cold') || text.includes('freez') || text.includes('tundra')) tags.add('cold');
        if (text.includes('polymer') || text.includes('assembly line') || text.includes('factory') || text.includes('assault rifle')) tags.add('oil');
        if (text.includes('medicine') || text.includes('medical') || text.includes('hot spring')) tags.add('medicine');
        if (text.includes('ranch')) tags.add('cake');
      };
      upcomingSteps.forEach(entry => addTagsFromText(entry?.step?.text));
      (stageSnapshot?.pendingBaseSteps || []).forEach(entry => addTagsFromText(entry?.step?.text));
      if (stageSnapshot?.nextStep) addTagsFromText(stageSnapshot.nextStep.text);
      tags.add('sphere');
      const unique = arr => Array.from(new Set((arr || []).map(item => String(item || '').trim()).filter(Boolean)));
      const candidates = Object.values(RANCH_ITEM_LIBRARY || {})
        .filter(entry => {
          const entryTags = Array.isArray(entry.tags) ? entry.tags : [];
          if (!entryTags.length && !entry.always) return false;
          return entryTags.some(tag => tags.has(tag)) || entry.always;
        })
        .sort((a, b) => (b.priority || 0) - (a.priority || 0));
      const maxItems = Math.max(1, Number.isFinite(limit) ? Math.round(limit) : 5);
      candidates.slice(0, maxItems).forEach(entry => {
        const detail = (ITEM_DETAILS && ITEM_DETAILS[entry.key]) || (ITEMS && ITEMS[entry.key]) || {};
        const name = entry.name || detail.name || humaniseItemKey(entry.key || 'Item');
        const producers = unique(entry.producers || detail.ranchProducers || (ITEMS && ITEMS[entry.key]?.ranchProducers));
        if (!producers.length) return;
        const caughtProducers = producers.filter(name => isPalCaughtByName(name));
        const missingProducers = producers.filter(name => !isPalCaughtByName(name));
        const reason = deriveRanchReasonForEntry(entry, tags);
        const targetName = name.toLowerCase();
        const caughtLabelKid = caughtProducers.slice(0, 2).join(' and ');
        const caughtLabelGrown = caughtProducers.join(', ');
        const prospectKid = missingProducers.slice(0, 2).join(' or ') || producers.slice(0, 2).join(' or ');
        const prospectGrown = missingProducers.join(', ') || producers.join(', ');
        const actionKid = caughtProducers.length
          ? `Let ${caughtLabelKid} stay on the Ranch so ${targetName} piles up.`
          : `Catch ${prospectKid || 'new pals'} so the Ranch makes ${targetName}.`;
        const actionGrown = caughtProducers.length
          ? `Assign ${caughtProducers[0]} to the Ranch to keep ${targetName} flowing.`
          : `Recruit ${prospectGrown || 'ranch producers'} to automate ${targetName}.`;
        const hasDetail = !!((ITEM_DETAILS && ITEM_DETAILS[entry.key]) || (ITEMS && ITEMS[entry.key]));
        plan.recommendations.push({
          key: entry.key,
          itemKey: entry.key,
          name,
          reasonKid: reason.kid || '',
          reasonGrown: reason.grown || '',
          actionKid,
          actionGrown,
          producers,
          caughtProducers,
          missingProducers,
          hasDetail,
          openUrl: entry.openUrl || null
        });
      });
      const names = plan.recommendations.map(rec => rec.name).slice(0, 4);
      if (names.length) {
        const kidJoin = names.slice(0, 3).join(' & ');
        const grownJoin = names.join(' • ');
        if (plan.hasRanch) {
          plan.summaryKid = `Focus: ${kidJoin}`;
          plan.summaryGrown = `Focus outputs: ${grownJoin}`;
        } else {
          plan.summaryKid = `Plan ahead: ${kidJoin}`;
          plan.summaryGrown = `Plan ahead: ${grownJoin}`;
        }
      } else {
        plan.summaryKid = plan.hasRanch
          ? 'Choose a ranch item to chase next.'
          : 'Unlock the Ranch to start planning outputs.';
        plan.summaryGrown = plan.hasRanch
          ? 'Choose the next ranch output to pursue.'
          : 'Unlock the Ranch to start planning outputs.';
      }
      return plan;
    }
    function pickPreferredRanchProducer(rec, { palName } = {}) {
      if (!rec) return { name: '', pal: null, isCaught: false };
      const names = Array.isArray(rec.producers) ? rec.producers : [];
      if (palName) {
        const match = names.find(name => String(name).toLowerCase() === String(palName).toLowerCase());
        if (match) {
          const pal = findPalByName(match);
          return { name: match, pal, isCaught: pal ? !!caught[pal.id] : isPalCaughtByName(match) };
        }
      }
      const candidates = names.map(name => {
        const pal = findPalByName(name);
        return { name, pal, isCaught: pal ? !!caught[pal.id] : isPalCaughtByName(name) };
      });
      const caughtCandidate = candidates.find(entry => entry.pal && entry.isCaught);
      if (caughtCandidate) return caughtCandidate;
      const withData = candidates.find(entry => entry.pal);
      if (withData) return withData;
      if (names.length) {
        return { name: names[0], pal: findPalByName(names[0]) || null, isCaught: isPalCaughtByName(names[0]) };
      }
      return { name: '', pal: null, isCaught: false };
    }
    function getRanchAssignments() {
      if (!basePlannerState || !Array.isArray(basePlannerState.ranchAssignments)) {
        return [];
      }
      return basePlannerState.ranchAssignments
        .map(entry => normalizeRanchAssignmentEntry(entry))
        .filter(Boolean);
    }
    function findRanchAssignmentIndex(assignments, target) {
      if (!target) return -1;
      const itemKey = target.itemKey ? String(target.itemKey) : null;
      const palName = canonicalizeRanchPalName(target.palName);
      return assignments.findIndex(entry => {
        if ((entry.itemKey || null) !== itemKey) return false;
        return canonicalizeRanchPalName(entry.palName) === palName;
      });
    }
    function updateRanchAssignments(assignments) {
      const normalized = normalizeRanchAssignments(assignments);
      basePlannerState.ranchAssignments = normalized;
      persistBasePlannerState();
    }
    function resolveRanchAssignments({ plan } = {}) {
      const stored = getRanchAssignments();
      if (!stored.length) return [];
      const recommendations = Array.isArray(plan?.recommendations) ? plan.recommendations : [];
      const resolved = stored.map(entry => {
        if (!entry) return null;
        let pal = null;
        if (entry.palId != null && PALS && PALS[entry.palId]) {
          pal = PALS[entry.palId];
        }
        if (!pal && entry.palName) {
          pal = findPalByName(entry.palName);
        }
        const recommendation = recommendations.find(rec => rec.itemKey === entry.itemKey) || null;
        const reasonKid = recommendation?.reasonKid || entry.reasonKid;
        const reasonGrown = recommendation?.reasonGrown || entry.reasonGrown;
        const actionKid = recommendation?.actionKid || entry.actionKid;
        const actionGrown = recommendation?.actionGrown || entry.actionGrown;
        const noteKid = entry.noteKid || (entry.palName
          ? `${entry.palName} works the Ranch for ${entry.itemName || 'your focus item'}.`
          : `Ranch focus: ${entry.itemName || 'planned output'}.`);
        const noteGrown = entry.noteGrown || (entry.palName
          ? `${entry.palName} assigned to the Ranch for ${entry.itemName || 'the planned output'}.`
          : `Ranch focus: ${entry.itemName || 'planned output'}.`);
        return {
          ...entry,
          pal,
          recommendation,
          reasonKid,
          reasonGrown,
          actionKid,
          actionGrown,
          noteKid,
          noteGrown,
          isCaught: pal ? !!caught[pal.id] : (entry.palName ? isPalCaughtByName(entry.palName) : false)
        };
      }).filter(Boolean);
      resolved.sort((a, b) => (a.timestamp || 0) - (b.timestamp || 0));
      return resolved;
    }
    function clearAllRanchAssignments() {
      if (!basePlannerState.ranchAssignments || !basePlannerState.ranchAssignments.length) {
        basePlannerState.ranchAssignments = [];
        updateBasePlanner();
        return;
      }
      basePlannerState.ranchAssignments = [];
      persistBasePlannerState();
      updateBasePlanner();
    }
    function removeRanchAssignment(target) {
      if (!target) return;
      const assignments = getRanchAssignments();
      const index = findRanchAssignmentIndex(assignments, target);
      if (index === -1) return;
      assignments.splice(index, 1);
      updateRanchAssignments(assignments);
      updateBasePlanner();
    }
    function adjustRanchAssignmentCount(target, delta) {
      if (!target || !delta) return;
      const assignments = getRanchAssignments();
      const index = findRanchAssignmentIndex(assignments, target);
      if (index === -1) return;
      const current = assignments[index];
      const nextCount = clampRanchAssignmentCount((current.count || 1) + delta);
      if (nextCount <= 0) {
        assignments.splice(index, 1);
      } else {
        assignments[index] = { ...current, count: nextCount, timestamp: Date.now() };
      }
      updateRanchAssignments(assignments);
      updateBasePlanner();
    }
    function setRanchAssignmentFromRecommendation(rec, { palName, amount = 1 } = {}) {
      if (!rec) return;
      const preferred = pickPreferredRanchProducer(rec, { palName });
      const pal = preferred.pal;
      const palDisplay = preferred.name || (pal ? pal.name : '');
      if (!palDisplay) return;
      const itemName = rec.name || humaniseItemKey(rec.itemKey || rec.key || 'Ranch Output');
      const lowerOutput = itemName ? itemName.toLowerCase() : 'your ranch output';
      const noteKid = palDisplay
        ? `${palDisplay} keeps ${lowerOutput} flowing on the Ranch.`
        : `Ranch focus: ${lowerOutput}.`;
      const noteGrown = palDisplay
        ? `${palDisplay} is scheduled on the Ranch for ${lowerOutput}.`
        : `Ranch focus: ${lowerOutput}.`;
      const reasonFallback = composeDefaultRanchReason(itemName);
      const actionFallback = composeDefaultRanchActions(palDisplay, itemName);
      const entry = normalizeRanchAssignmentEntry({
        itemKey: rec.itemKey || rec.key || null,
        itemName,
        palId: pal ? pal.id : null,
        palName: palDisplay,
        reasonKid: rec.reasonKid || reasonFallback.kid,
        reasonGrown: rec.reasonGrown || reasonFallback.grown,
        actionKid: rec.actionKid || actionFallback.kid,
        actionGrown: rec.actionGrown || actionFallback.grown,
        noteKid,
        noteGrown,
        count: Math.max(1, amount),
        timestamp: Date.now()
      });
      const assignments = getRanchAssignments();
      const index = findRanchAssignmentIndex(assignments, entry);
      if (index >= 0) {
        const current = assignments[index];
        const nextCount = clampRanchAssignmentCount((current.count || 1) + Math.max(1, amount));
        assignments[index] = { ...current, ...entry, count: nextCount, timestamp: Date.now() };
      } else {
        assignments.push({ ...entry });
      }
      updateRanchAssignments(assignments);
      updateBasePlanner();
    }
    function selectRanchAssignmentPal(rec, palName) {
      if (!rec || !palName) return;
      const itemKey = rec.itemKey || rec.key || null;
      const assignments = getRanchAssignments();
      let preservedCount = 1;
      const filtered = assignments.filter(entry => {
        if ((entry.itemKey || null) !== itemKey) return true;
        if (canonicalizeRanchPalName(entry.palName) === canonicalizeRanchPalName(palName)) {
          preservedCount = entry.count || preservedCount;
        }
        return false;
      });
      const preferred = pickPreferredRanchProducer(rec, { palName });
      const pal = preferred.pal;
      const palDisplay = preferred.name || palName;
      const itemName = rec.name || humaniseItemKey(itemKey || 'Ranch Output');
      const lowerOutput = itemName ? itemName.toLowerCase() : 'your ranch output';
      const reasonFallback = composeDefaultRanchReason(itemName);
      const actionFallback = composeDefaultRanchActions(palDisplay, itemName);
      const entry = normalizeRanchAssignmentEntry({
        itemKey,
        itemName,
        palId: pal ? pal.id : null,
        palName: palDisplay,
        reasonKid: rec.reasonKid || reasonFallback.kid,
        reasonGrown: rec.reasonGrown || reasonFallback.grown,
        actionKid: rec.actionKid || actionFallback.kid,
        actionGrown: rec.actionGrown || actionFallback.grown,
        noteKid: `${palDisplay} keeps ${lowerOutput} flowing on the Ranch.`,
        noteGrown: `${palDisplay} is scheduled on the Ranch for ${lowerOutput}.`,
        count: preservedCount,
        timestamp: Date.now()
      });
      filtered.push(entry);
      updateRanchAssignments(filtered);
      updateBasePlanner();
    }
    function isBaseRelatedTech(item) {
      if (!item) return false;
      const fields = [item.category, item.group, item.name];
      return fields.some(field => {
        if (!field) return false;
        const value = String(field).toLowerCase();
        return BASE_TECH_KEYWORDS.some(keyword => value.includes(keyword));
      });
    }
    function deriveBaseLevelFromTech(techLevel) {
      if (!Array.isArray(BASE_TECH_THRESHOLDS) || !BASE_TECH_THRESHOLDS.length) {
        return 1;
      }
      let derived = 1;
      BASE_TECH_THRESHOLDS.forEach(threshold => {
        if (techLevel >= threshold.techLevel) {
          derived = threshold.level;
        }
      });
      return clampToRange(derived, 1, BASE_LEVEL_CONFIG.length || 1);
    }
    function calculateAutoBaseLevelDetail() {
      let highestTechLevel = 0;
      let highestItem = null;
      let unlockCount = 0;
      (Array.isArray(TECH) ? TECH : []).forEach(levelEntry => {
        const tierLevel = Number(levelEntry?.level) || 0;
        (levelEntry?.items || []).forEach(item => {
          if (!item || !item.name) return;
          if (!isBaseRelatedTech(item)) return;
          if (unlocked[item.name]) {
            unlockCount += 1;
            if (tierLevel > highestTechLevel) {
              highestTechLevel = tierLevel;
              highestItem = { name: item.name, techLevel: tierLevel };
            }
          }
        });
      });
      const level = deriveBaseLevelFromTech(highestTechLevel);
      return { level, highestTechLevel, highestItem, unlockCount };
    }
    function isTechUnlocked(name) {
      if (!name) return false;
      if (unlocked && unlocked[name]) return true;
      const normalized = String(name).toLowerCase();
      return Object.keys(unlocked || {}).some(key => {
        return unlocked[key] && typeof key === 'string' && key.toLowerCase() === normalized;
      });
    }
    function hasAnyTechUnlocked(names) {
      if (!Array.isArray(names)) return false;
      return names.some(name => isTechUnlocked(name));
    }
    function readRouteStateSnapshot() {
      if (typeof routeState !== 'undefined' && routeState && Object.keys(routeState).length) {
        return routeState;
      }
      const storageKey = typeof ROUTE_STORAGE_KEY !== 'undefined' ? ROUTE_STORAGE_KEY : 'palmarathon:route:v1';
      try {
        const stored = localStorage.getItem(storageKey);
        if (!stored) return {};
        const parsed = JSON.parse(stored);
        return parsed && typeof parsed === 'object' ? parsed : {};
      } catch (err) {
        console.warn('Failed to read route state snapshot', err);
        return {};
      }
    }
    function isBreedingUnlocked() {
      if (isTechUnlocked('Breeding Farm')) return true;
      const snapshot = readRouteStateSnapshot();
      return BREEDING_ROUTE_STEP_IDS.some(stepId => snapshot && snapshot[stepId]);
    }
    function findPalByName(name) {
      if (!name) return null;
      const id = PAL_NAME_TO_ID && Object.prototype.hasOwnProperty.call(PAL_NAME_TO_ID, name)
        ? PAL_NAME_TO_ID[name]
        : null;
      if (id != null && PALS && PALS[id]) {
        return PALS[id];
      }
      return Object.values(PALS || {}).find(pal => pal && pal.name === name) || null;
    }
    function isPalCaughtByName(name) {
      const pal = findPalByName(name);
      if (!pal) return false;
      return !!caught[pal.id];
    }
    function palsThatDropItem(itemKey) {
      if (!itemKey) return [];
      const needle = String(itemKey).toLowerCase();
      return Object.values(PALS || {}).filter(pal => {
        return Array.isArray(pal?.drops) && pal.drops.some(drop => String(drop || '').toLowerCase() === needle);
      });
    }
    function collectPendingBaseSteps({ includeOptional = true } = {}) {
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const pending = [];
      chapters.forEach((chapter, chapterIndex) => {
        (chapter?.steps || []).forEach(step => {
          if (!step || step.category !== 'Base') return;
          if (!includeOptional && step.optional) return;
          if (routeState && routeState[step.id]) return;
          pending.push({ chapter, step, chapterIndex });
        });
      });
      pending.sort((a, b) => {
        if (a.chapterIndex !== b.chapterIndex) {
          return a.chapterIndex - b.chapterIndex;
        }
        const optionalA = !!a.step?.optional;
        const optionalB = !!b.step?.optional;
        if (optionalA !== optionalB) {
          return optionalA ? 1 : -1;
        }
        return 0;
      });
      return pending;
    }
    function determineGuideStageSnapshot() {
      const pendingBaseSteps = collectPendingBaseSteps();
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      if (!chapters.length) {
        return {
          stageId: null,
          stageIndex: -1,
          stageTitleKid: '',
          stageTitleGrown: '',
          progressPercent: null,
          pendingBaseSteps,
          nextStep: null
        };
      }
      const nextRoute = findNextRouteStep ? findNextRouteStep({ includeOptional: false }) : null;
      let activeChapter = nextRoute?.chapter || null;
      if (!activeChapter) {
        activeChapter = chapters[chapters.length - 1];
      }
      const stageId = activeChapter?.id || null;
      const stageIndex = chapters.findIndex(chapter => chapter && (chapter === activeChapter || chapter.id === stageId));
      const stageTitleKid = activeChapter ? (activeChapter.titleKid || activeChapter.title || '') : '';
      const stageTitleGrown = activeChapter ? (activeChapter.title || activeChapter.titleKid || '') : '';
      const progress = typeof calculateGuideProgressSummary === 'function' ? calculateGuideProgressSummary() : null;
      const progressPercent = progress ? progress.percent : null;
      return {
        stageId,
        stageIndex,
        stageTitleKid,
        stageTitleGrown,
        progressPercent,
        pendingBaseSteps,
        nextStep: nextRoute?.step || null
      };
    }
    function createStageOverviewNote(stageSnapshot) {
      const stageId = stageSnapshot?.stageId;
      const overview = (stageId && BASE_STAGE_OVERVIEWS[stageId]) || BASE_STAGE_OVERVIEWS.default;
      if (!overview) return null;
      const badgeConfig = overview.badge || null;
      const kidLines = Array.isArray(overview.kid?.lines) && overview.kid.lines.length
        ? overview.kid.lines.slice()
        : [stageSnapshot?.stageTitleKid || 'Keep your base balanced.'];
      const grownLines = Array.isArray(overview.grown?.lines) && overview.grown.lines.length
        ? overview.grown.lines.slice()
        : [stageSnapshot?.stageTitleGrown || 'Keep your base balanced.'];
      if (stageId === 'ch1') {
        if (isPalCaughtByName('Vixy')) {
          if (kidLines.length) kidLines[0] = 'Let Vixy live on the Ranch so it digs Pal Spheres while you explore.';
          kidLines.push('Keep wood and stone pals busy so the Crusher never stops.');
          if (grownLines.length) grownLines[0] = 'Park Vixy on the Ranch for passive Pal Sphere income and keep Crusher fed.';
          grownLines.push('Balance Transporting coverage so logging and stone outputs stay clear.');
        }
      }
      if (stageId === 'ch2') {
        const honeyReady = palsThatDropItem('honey').some(pal => caught && caught[pal.id]);
        if (honeyReady) {
          kidLines.push('Check the honey chest often so Cakes never pause.');
          grownLines.push('With honey secured, ensure flour and milk stay ahead of egg demand.');
        }
      }
      return {
        id: `base-stage-${stageId || 'default'}`,
        icon: overview.icon || '🛠️',
        badge: badgeConfig
          ? { kid: badgeConfig.kid || badgeConfig.grown || '', grown: badgeConfig.grown || badgeConfig.kid || '' }
          : null,
        kid: {
          title: overview.kid?.title || stageSnapshot?.stageTitleKid || 'Base focus',
          lines: kidLines
        },
        grown: {
          title: overview.grown?.title || stageSnapshot?.stageTitleGrown || 'Base focus',
          lines: grownLines
        }
      };
    }
    function createBaseStepNote(entry) {
      if (!entry || !entry.step) return null;
      const { step } = entry;
      const override = BASE_STEP_NOTE_OVERRIDES[step.id] || {};
      const badgeConfig = override.badge || (step.optional ? { kid: 'Bonus', grown: 'Optional' } : { kid: 'Guide step', grown: 'Guide step' });
      const kidLines = Array.isArray(override.kidLines) && override.kidLines.length
        ? override.kidLines.slice()
        : [(step.textKid || step.text || '').trim()].filter(Boolean);
      const grownLines = Array.isArray(override.grownLines) && override.grownLines.length
        ? override.grownLines.slice()
        : [(step.textAdult || step.text || step.textKid || '').trim()].filter(Boolean);
      const note = {
        id: `base-step-${step.id}`,
        icon: override.icon || '📋',
        badge: badgeConfig
          ? { kid: badgeConfig.kid || badgeConfig.grown || '', grown: badgeConfig.grown || badgeConfig.kid || '' }
          : null,
        kid: {
          title: override.kidTitle || step.textKid || step.text || 'Base reminder',
          lines: kidLines
        },
        grown: {
          title: override.grownTitle || step.textAdult || step.text || 'Base reminder',
          lines: grownLines
        }
      };
      if (step.optional) {
        note.kid.footer = 'Optional step';
        note.grown.footer = 'Optional checklist item';
      }
      return note;
    }
    function suggestPalsForWork(key, { crew, baseConfig, stageSnapshot } = {}) {
      const result = { kid: [], grown: [] };
      const seen = new Set();
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      const stageIndex = typeof snapshot?.stageIndex === 'number' && snapshot.stageIndex >= 0 ? snapshot.stageIndex : 0;
      let config = baseConfig;
      if (!config) {
        const autoInfo = calculateAutoBaseLevelDetail();
        const manualLevel = clampToRange(
          Number.isFinite(basePlannerState?.manualLevel) ? Math.round(basePlannerState.manualLevel) : autoInfo.level,
          1,
          BASE_LEVEL_CONFIG.length || 1
        );
        const activeLevel = basePlannerState?.mode === 'manual' ? manualLevel : autoInfo.level;
        config = getBaseLevelConfig(activeLevel);
      }
      const preferredRarity = Number(config?.preferredRarity);
      const rarityBaseline = Number.isFinite(preferredRarity) ? preferredRarity : 2;
      const rarityCap = Math.max(1, rarityBaseline + Math.max(0, Math.floor(stageIndex / 2)));
      const priceCap = 1800 + stageIndex * 1400;
      const STARTER_SPAWN_KEYWORDS = ['plains', 'forest', 'coast', 'plateau', 'grass', 'field', 'hill', 'valley', 'beach', 'lake'];
      const MID_SPAWN_KEYWORDS = ['desert', 'marsh', 'swamp', 'canyon', 'highland', 'mountain'];
      const LATE_SPAWN_KEYWORDS = ['volcano', 'tundra', 'snow', 'ice', 'ruins', 'abyss', 'sanctuary', 'dungeon', 'frost'];
      const evaluateAccessibility = pal => {
        const rarity = Number(pal?.rarity) || 0;
        const price = Number(pal?.price) || 0;
        const areas = Array.isArray(pal?.spawnAreas) ? pal.spawnAreas : [];
        const normalizedAreas = areas.map(area => String(area || '').toLowerCase());
        const hasStarterArea = normalizedAreas.some(area => STARTER_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        const hasMidArea = normalizedAreas.some(area => MID_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        const hasLateArea = normalizedAreas.some(area => LATE_SPAWN_KEYWORDS.some(keyword => area.includes(keyword)));
        let spawnPenalty = 1.5;
        if (!normalizedAreas.length) {
          spawnPenalty = 2;
        } else if (hasStarterArea) {
          spawnPenalty = 0;
        } else if (hasLateArea) {
          spawnPenalty = stageIndex >= 4 ? 1.5 : 4;
        } else if (hasMidArea) {
          spawnPenalty = stageIndex >= 2 ? 1.2 : 2.6;
        } else {
          spawnPenalty = 1.2;
        }
        const rarityPenalty = Math.max(0, rarity - rarityCap);
        const pricePenalty = priceCap > 0 ? Math.max(0, price - priceCap) / priceCap : 0;
        const accessible =
          rarity <= rarityCap &&
          (price === 0 || price <= priceCap) &&
          (spawnPenalty <= 2 || stageIndex >= 3);
        const accessibilityScore = rarityPenalty * 6 + pricePenalty * 4 + spawnPenalty + (accessible ? 0 : 15);
        return { accessible, accessibilityScore };
      };
      if (crew && Array.isArray(crew.selections)) {
        crew.selections.forEach(entry => {
          if (!entry || !entry.pal) return;
          if (!Array.isArray(entry.contributions)) return;
          if (!entry.contributions.some(contribution => contribution.key === key)) return;
          const name = entry.pal.name;
          if (!name || seen.has(name)) return;
          if (!entry.isCaught && result.kid.length < 2) {
            result.kid.push(name);
            seen.add(name);
            return;
          }
          if (entry.isCaught && result.grown.length < 2) {
            result.grown.push(name);
            seen.add(name);
          }
        });
      }
      if (result.kid.length < 2 || result.grown.length < 2) {
        const dataset = Object.values(PALS || {})
          .filter(pal => pal?.work && Number(pal.work[key]) > 0)
          .map(pal => {
            const { accessible, accessibilityScore } = evaluateAccessibility(pal);
            return {
              pal,
              accessible,
              accessibilityScore,
              workLevel: Number(pal.work[key]) || 0
            };
          })
          .sort((a, b) => {
            if (b.workLevel !== a.workLevel) return b.workLevel - a.workLevel;
            if (a.accessible !== b.accessible) return a.accessible ? -1 : 1;
            if (a.accessibilityScore !== b.accessibilityScore) return a.accessibilityScore - b.accessibilityScore;
            const rarityDiff = (a.pal.rarity || 0) - (b.pal.rarity || 0);
            if (rarityDiff !== 0) return rarityDiff;
            const priceDiff = (a.pal.price || 0) - (b.pal.price || 0);
            if (priceDiff !== 0) return priceDiff;
            return a.pal.name.localeCompare(b.pal.name);
          });
        dataset.forEach(entry => {
          const pal = entry.pal;
          if (!pal?.name || seen.has(pal.name)) return;
          if (result.kid.length < 2) {
            result.kid.push(pal.name);
          }
          if (result.grown.length < 2) {
            result.grown.push(pal.name);
          }
          seen.add(pal.name);
        });
      }
      if (!result.grown.length) {
        result.grown = result.kid.slice();
      }
      if (!result.kid.length) {
        result.kid = result.grown.slice();
      }
      return result;
    }
    function calculateEffectiveWorkWeights(config, context = {}) {
      const baseWeights = config?.workWeights || {};
      const weights = {};
      Object.keys(baseWeights).forEach(key => {
        weights[key] = baseWeights[key];
      });
      const defaultWeight = config?.defaultWeight != null ? config.defaultWeight : 0.2;
      const stageSnapshot = context.stageSnapshot || determineGuideStageSnapshot();
      const stageIndex = typeof stageSnapshot?.stageIndex === 'number' ? stageSnapshot.stageIndex : null;
      if (!hasAnyTechUnlocked(MEDICINE_TECH_NAMES)) {
        if (weights.medicine != null) {
          weights.medicine = Math.min(weights.medicine, defaultWeight * 0.6);
        } else {
          weights.medicine = defaultWeight * 0.5;
        }
      }
      if (hasAnyTechUnlocked(FURNACE_TECH_NAMES)) {
        const baseKindling = weights.kindling != null ? weights.kindling : defaultWeight;
        weights.kindling = Math.max(baseKindling, baseKindling + 0.15);
        const baseMining = weights.mining != null ? weights.mining : defaultWeight;
        weights.mining = Math.max(baseMining, baseMining + 0.05);
        const baseTransport = weights.transporting != null ? weights.transporting : defaultWeight;
        weights.transporting = Math.max(baseTransport, baseTransport + 0.05);
      }
      if (stageIndex != null && stageIndex >= 2) {
        const baseFarming = weights.farming != null ? weights.farming : defaultWeight;
        weights.farming = Math.max(baseFarming, baseFarming + 0.1);
        const basePlanting = weights.planting != null ? weights.planting : defaultWeight;
        weights.planting = Math.max(basePlanting, basePlanting + 0.05);
        const baseWatering = weights.watering != null ? weights.watering : defaultWeight;
        weights.watering = Math.max(baseWatering, baseWatering + 0.05);
      }
      if (hasAnyTechUnlocked(POWER_TECH_NAMES)) {
        const basePower = weights.generating_electricity != null ? weights.generating_electricity : defaultWeight;
        weights.generating_electricity = Math.max(basePower, basePower + 0.08);
      }
      return weights;
    }
    function generateCoverageNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      if (!crew || !crew.coverage) return notes;
      const entries = Object.entries(weights || config?.workWeights || {})
        .filter(([, weight]) => weight && weight > 0)
        .sort((a, b) => b[1] - a[1]);
      if (!entries.length) return notes;
      const highestWeight = entries[0][1];
      const threshold = (config?.defaultWeight != null ? config.defaultWeight : 0.2) * 1.5;
      const gaps = entries
        .map(([key, weight]) => {
          const total = crew.coverage[key] || 0;
          const descriptor = coverageDescriptor(weight, total, config, highestWeight);
          return { key, weight, descriptor };
        })
        .filter(entry => entry.descriptor.percent < 55 && entry.weight >= threshold);
      gaps.sort((a, b) => {
        if (a.descriptor.percent !== b.descriptor.percent) {
          return a.descriptor.percent - b.descriptor.percent;
        }
        return b.weight - a.weight;
      });
      const ranchPlan = computeRanchPlan({ stageSnapshot, limit: kidMode ? 3 : 4 });
      let ranchNoteAdded = false;
      gaps.slice(0, 2).forEach(entry => {
        const canonical = canonicalWorkKey(entry.key);
        if (canonical === 'farming') {
          if (ranchNoteAdded) return;
          ranchNoteAdded = true;
          const focusKid = ranchPlan.recommendations.map(rec => rec.name).slice(0, kidMode ? 2 : 3).join(' & ');
          const focusGrown = ranchPlan.recommendations.map(rec => rec.name).slice(0, 3).join(' • ');
          const primary = ranchPlan.recommendations[0] || null;
          const secondary = ranchPlan.recommendations[1] || null;
          const kidLines = [];
          if (focusKid) {
            kidLines.push(ranchPlan.hasRanch
              ? `Ranch focus: ${focusKid}.`
              : `Plan for ${focusKid} when the Ranch is ready.`);
          } else if (!ranchPlan.hasRanch) {
            kidLines.push('Unlock the Ranch to start making special items.');
          }
          if (primary?.reasonKid) kidLines.push(primary.reasonKid);
          if (primary?.actionKid) kidLines.push(primary.actionKid);
          if (secondary && !secondary.caughtProducers.length) {
            kidLines.push(secondary.actionKid);
          }
          if (!kidLines.length) {
            kidLines.push('Assign a pal to the Ranch to begin passive production.');
          }
          const grownLines = [];
          if (focusGrown) {
            grownLines.push(ranchPlan.hasRanch
              ? `Target outputs: ${focusGrown}.`
              : `Queue these outputs post-Ranch: ${focusGrown}.`);
          } else if (!ranchPlan.hasRanch) {
            grownLines.push('Unlock the Ranch to add passive item production.');
          }
          if (primary?.reasonGrown) grownLines.push(primary.reasonGrown);
          if (primary?.actionGrown) grownLines.push(primary.actionGrown);
          if (secondary && secondary.missingProducers.length) {
            grownLines.push(`Recruit ${secondary.missingProducers.join(', ')} to unlock ${secondary.name.toLowerCase()}.`);
          }
          if (!grownLines.length) {
            grownLines.push('Review ranch slots and assign producers for upcoming recipes.');
          }
          notes.push({
            id: 'coverage-ranch-plan',
            icon: '🐑',
            badge: { kid: 'Ranch', grown: 'Ranch' },
            kid: {
              title: 'Ranch plan',
              lines: kidLines
            },
            grown: {
              title: 'Ranch focus',
              lines: grownLines
            }
          });
          return;
        }
        const detail = getWorkTypeDetail(entry.key);
        const helperNames = suggestPalsForWork(entry.key, { crew, baseConfig: config, stageSnapshot });
        const kidTargets = helperNames.kid.slice(0, 2);
        const grownTargets = helperNames.grown.slice(0, 2);
        const kidLines = [
          `We need more ${detail.kidLabel || detail.label.toLowerCase()} helpers (${Math.round(entry.descriptor.percent)}% filled).`
        ];
        if (kidTargets.length) {
          kidLines.push(`Try ${kidTargets.join(' or ')}.`);
        } else {
          kidLines.push('Open the pal list to find workers with this job.');
        }
        kidLines.push('Switch pals around until this meter turns green.');
        const grownLines = [
          `${detail.label} coverage is ${Math.round(entry.descriptor.percent)}%.`,
          grownTargets.length
            ? `Recruit or reassign ${grownTargets.join(' or ')}.`
            : 'Review your pal list for strong specialists to cover this role.',
          'Balancing this job keeps automation from stalling.'
        ];
        notes.push({
          id: `coverage-${entry.key}`,
          icon: detail.icon || '⭐',
          badge: { kid: 'Coverage', grown: 'Coverage' },
          kid: {
            title: `${detail.kidLabel || detail.label} boost`,
            lines: kidLines
          },
          grown: {
            title: `${detail.label} priority`,
            lines: grownLines
          }
        });
      });
      return notes;
    }
    function generateCatchNotes(crew) {
      const notes = [];
      if (!crew || !Array.isArray(crew.selections)) return notes;
      const missing = crew.selections.filter(entry => entry && entry.pal && !entry.isCaught);
      missing.sort((a, b) => {
        if (b.score !== a.score) return b.score - a.score;
        return b.rawScore - a.rawScore;
      });
      missing.slice(0, 3).forEach(entry => {
        const pal = entry.pal;
        const contributions = Array.isArray(entry.contributions) ? entry.contributions : [];
        const top = contributions.slice(0, 2);
        const kidHighlights = top.map(contribution => {
          const detail = getWorkTypeDetail(contribution.key);
          return `${detail.kidLabel || detail.label} ${workLevelLabel(contribution.level)}`;
        });
        const grownHighlights = top.map(contribution => {
          const detail = getWorkTypeDetail(contribution.key);
          return `${detail.label} Lv ${contribution.level}`;
        });
        const habitats = Array.isArray(pal.spawnAreas) && pal.spawnAreas.length
          ? pal.spawnAreas.slice(0, 2).join(', ')
          : '';
        const rarityLabel = rarityNames[pal.rarity] || '';
        const sphere = raritySphere[pal.rarity] || 'Pal Sphere';
        const kidLines = [
          kidHighlights.length ? `${pal.name} brings ${kidHighlights.join(' & ')}.` : `${pal.name} helps with lots of jobs.`,
          habitats ? `Look in ${habitats}.` : 'Check the map page to see where it lives.',
          `Try a ${sphere}.`
        ];
        const grownLines = [
          `${pal.name} covers ${grownHighlights.join(', ') || 'important roles'}${rarityLabel ? ` (${rarityLabel})` : ''}.`,
          habitats ? `Spawns: ${habitats}.` : 'Use the map tab or modal to confirm spawn points.',
          `Suggested sphere: ${sphere}.`
        ];
        notes.push({
          id: `target-${pal.id}`,
          icon: '🎯',
          badge: { kid: 'Next catch', grown: 'Next catch' },
          kid: {
            title: `Catch ${pal.name}`,
            lines: kidLines
          },
          grown: {
            title: `Recruit ${pal.name}`,
            lines: grownLines
          }
        });
      });
      return notes;
    }
    function generateTechPriorityNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      const medicineUnlocked = hasAnyTechUnlocked(MEDICINE_TECH_NAMES);
      if (!medicineUnlocked && (weights?.medicine || 0) > (config?.defaultWeight || 0.2) * 0.5) {
        notes.push({
          id: 'tech-medicine',
          icon: '💊',
          badge: { kid: 'Heads-up', grown: 'Heads-up' },
          kid: {
            title: 'Medicine comes later',
            lines: [
              'No doctor table is unlocked yet, so it is okay if healer pals rest for now.',
              'Focus on builders, haulers, and fire pals until the medicine bench is ready.'
            ]
          },
          grown: {
            title: 'Delay medicine coverage',
            lines: [
              'Medicine benches are not unlocked, so Palmate deprioritises specialist healers.',
              'Revisit once the Medieval Medicine Workbench (or better) is marked unlocked.'
            ]
          }
        });
      }
      const honeyCandidates = palsThatDropItem('honey');
      const hasHoneyPal = honeyCandidates.some(pal => caught && caught[pal.id]);
      const hasRanch = isTechUnlocked('Ranch');
      if (hasRanch && !hasHoneyPal && (stageSnapshot?.stageIndex ?? 0) >= 1) {
        const honeyNames = honeyCandidates.map(pal => pal.name).filter(Boolean);
        const preview = honeyNames.slice(0, 2).join(' or ') || 'Beegarde';
        notes.push({
          id: 'tech-honey',
          icon: '🍯',
          badge: { kid: 'Cake prep', grown: 'Cake prep' },
          kid: {
            title: 'Catch a honey pal',
            lines: [
              `We still need honey for Cakes. Try to catch ${preview} soon.`,
              'Give them a Ranch slot so honey flows while you explore.'
            ]
          },
          grown: {
            title: 'Secure honey production',
            lines: [
              `Cakes hinge on honey—target ${preview} and park them on the Ranch.`,
              'Pair with Mozzarina (milk) and Chikipi (eggs) to complete the recipe pipeline.'
            ]
          }
        });
      }
      const furnaceUnlocked = hasAnyTechUnlocked(FURNACE_TECH_NAMES);
      if (furnaceUnlocked) {
        const kindlingCoverage = crew?.coverage?.kindling || 0;
        const expected = Math.max(1, crew?.slotCount || 1) * Math.max(1, MAX_WORK_LEVEL);
        if (kindlingCoverage < expected * 0.6) {
          const helpers = suggestPalsForWork('kindling', { crew, baseConfig: config, stageSnapshot });
          const kidTargets = helpers.kid.slice(0, 2).join(' or ') || 'strong fire pals';
          const grownTargets = helpers.grown.slice(0, 2).join(' or ') || 'dedicated Kindling specialists';
          notes.push({
            id: 'tech-kindling',
            icon: '🔥',
            badge: { kid: 'Smelting', grown: 'Smelting' },
            kid: {
              title: 'More fire pals',
              lines: [
                `Furnaces love fire pals. Add ${kidTargets} to keep metal bars cooking.`,
                'More flames mean faster saddles, weapons, and Cake cookware.'
              ]
            },
            grown: {
              title: 'Boost kindling uptime',
              lines: [
                `Kindling coverage is light—recruit ${grownTargets} so furnaces never idle.`,
                'Parallel smelters prevent bottlenecks during the midgame tech rush.'
              ]
            }
          });
        }
      }
      return notes;
    }
    function generateBaseIntelNotes({ config, crew, weights, stageSnapshot }) {
      const notes = [];
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      const queue = new Set();
      const addNote = note => {
        if (!note || !note.id || queue.has(note.id)) return;
        queue.add(note.id);
        notes.push(note);
      };
      const pending = snapshot.pendingBaseSteps || [];
      const prioritizedStep = pending.find(entry => {
        if (snapshot.stageIndex != null && entry.chapterIndex > snapshot.stageIndex + 1) return false;
        return true;
      }) || pending[0];
      if (prioritizedStep) {
        addNote(createBaseStepNote(prioritizedStep));
      } else {
        addNote(createStageOverviewNote(snapshot));
      }
      generateCoverageNotes({ config, crew, weights, stageSnapshot: snapshot }).forEach(addNote);
      generateCatchNotes(crew).forEach(addNote);
      generateTechPriorityNotes({ config, crew, weights, stageSnapshot: snapshot }).forEach(addNote);
      const ranchAssignments = Array.isArray(crew?.ranchAssignments) ? crew.ranchAssignments : [];
      if (ranchAssignments.length) {
        const kidLines = [];
        const grownLines = [];
        ranchAssignments.slice(0, 3).forEach(assignment => {
          const count = Math.max(1, assignment.count || 1);
          const itemName = assignment.itemName || 'your focus item';
          const palName = assignment.palName || (kidMode ? 'Ranch helper' : 'Reserved pal');
          const kidCount = count > 1 ? ` ×${count}` : '';
          const grownCount = count > 1 ? ` ×${count}` : '';
          kidLines.push(`${palName}${kidCount} keeps ${itemName.toLowerCase()} flowing.`);
          const grownDetail = assignment.actionGrown || assignment.reasonGrown || `${palName}${grownCount} reserved for ${itemName.toLowerCase()}.`;
          grownLines.push(grownDetail);
        });
        if (ranchAssignments.length > 3) {
          const extra = ranchAssignments.length - 3;
          kidLines.push(`+${extra} more ranch plan${extra === 1 ? '' : 's'} saved below.`);
          grownLines.push(extra === 1 ? 'One more ranch output queued—scroll for details.' : `${extra} additional ranch outputs queued—review the list below.`);
        }
        addNote({
          id: 'ranch-assignment-plan',
          icon: '🐑',
          badge: { kid: 'Ranch', grown: 'Ranch' },
          kid: {
            title: 'Ranch crew locked in',
            lines: kidLines.length ? kidLines : ['Keep a pal on the Ranch so items pile up.']
          },
          grown: {
            title: 'Ranch plan active',
            lines: grownLines.length ? grownLines : ['Reserve one worker on the Ranch and rebalance the crew.']
          }
        });
      }
      if (!notes.length) {
        addNote(createStageOverviewNote(snapshot));
      }
      return notes.slice(0, 6);
    }
    function renderBaseIntelNotes(notes, activeIndex, { stageSnapshot } = {}) {
      const elements = basePlannerElements || {};
      if (elements.intelStage) {
        const label = kidMode
          ? (stageSnapshot?.stageTitleKid || 'Follow the guide')
          : (stageSnapshot?.stageTitleGrown || 'Follow the route guide');
        const badgeText = typeof stageSnapshot?.progressPercent === 'number'
          ? `${stageSnapshot.progressPercent}% ${kidMode ? 'done' : 'complete'}`
          : '';
        const parts = [];
        parts.push(`<span>${escapeHTML(label)}</span>`);
        if (badgeText) {
          parts.push(`<span class="base-intel-stage__badge">${escapeHTML(badgeText)}</span>`);
        }
        elements.intelStage.innerHTML = parts.join(' ');
      }
      if (elements.intelMeta) {
        const total = notes.length;
        if (total > 1) {
          elements.intelMeta.textContent = kidMode
            ? `Palmate shows ${total} tips. They swap every ${Math.round(BASE_INTEL_ROTATION_INTERVAL / 1000)} seconds.`
            : `${total} rotating notes — auto-advance every ${Math.round(BASE_INTEL_ROTATION_INTERVAL / 1000)}s.`;
        } else if (total === 1) {
          elements.intelMeta.textContent = kidMode
            ? 'Palmate found one big tip for your base.'
            : 'Palmate found a key insight for your base.';
        } else {
          elements.intelMeta.textContent = kidMode
            ? 'Mark guide steps and unlock tech so Palmate can share base tips.'
            : 'Track guide progress and unlocked tech to unlock tailored base insights.';
        }
      }
      const container = elements.intelNotes;
      if (!container) return;
      container.innerHTML = '';
      if (!notes.length) {
        const empty = document.createElement('div');
        empty.className = 'base-note base-note--active';
        const body = document.createElement('p');
        body.className = 'base-note__body';
        body.textContent = kidMode
          ? 'Palmate needs more info. Check off guide steps and mark pals as caught to unlock tips!'
          : 'Palmate needs more data. Update your guide steps and captured pals to unlock insights.';
        empty.appendChild(body);
        container.appendChild(empty);
        return;
      }
      notes.forEach((note, index) => {
        const card = document.createElement('article');
        card.className = `base-note${index === activeIndex ? ' base-note--active' : ''}`;
        const header = document.createElement('div');
        header.className = 'base-note__header';
        const icon = document.createElement('div');
        icon.className = 'base-note__icon';
        icon.textContent = note.icon || '⭐';
        header.appendChild(icon);
        const title = document.createElement('h4');
        title.className = 'base-note__title';
        const variant = kidMode ? note.kid : note.grown;
        title.textContent = variant?.title || (kidMode ? 'Base tip' : 'Base insight');
        header.appendChild(title);
        card.appendChild(header);
        const badge = note.badge && (kidMode ? note.badge.kid : note.badge.grown);
        if (badge) {
          const badgeEl = document.createElement('span');
          badgeEl.className = 'base-note__badge';
          badgeEl.textContent = badge;
          card.appendChild(badgeEl);
        }
        (variant?.lines || []).forEach(line => {
          if (!line) return;
          const body = document.createElement('p');
          body.className = 'base-note__body';
          body.textContent = line;
          card.appendChild(body);
        });
        if (variant?.footer) {
          const footer = document.createElement('div');
          footer.className = 'base-note__footer';
          footer.textContent = variant.footer;
          card.appendChild(footer);
        }
        container.appendChild(card);
      });
    }
    function restartBaseIntelTimer() {
      if (baseIntelState.rotationTimer) {
        clearInterval(baseIntelState.rotationTimer);
        baseIntelState.rotationTimer = null;
      }
      if (!baseIntelState.notes || baseIntelState.notes.length <= 1) {
        return;
      }
      baseIntelState.rotationTimer = setInterval(() => {
        rotateBaseIntel(1);
      }, BASE_INTEL_ROTATION_INTERVAL);
    }
    function rotateBaseIntel(step = 1, { userInitiated = false } = {}) {
      const notes = baseIntelState.notes || [];
      if (!notes.length) return;
      const total = notes.length;
      baseIntelState.activeIndex = (baseIntelState.activeIndex + step + total) % total;
      renderBaseIntelNotes(notes, baseIntelState.activeIndex, { stageSnapshot: baseIntelState.stageSnapshot });
      if (userInitiated) {
        restartBaseIntelTimer();
      }
    }
    function updateBaseIntel(config, crew, { weights, stageSnapshot } = {}) {
      const snapshot = stageSnapshot || determineGuideStageSnapshot();
      baseIntelState.stageSnapshot = snapshot;
      const previous = baseIntelState.notes && baseIntelState.notes[baseIntelState.activeIndex];
      const previousId = previous?.id || null;
      const notes = generateBaseIntelNotes({ config, crew, weights, stageSnapshot: snapshot });
      baseIntelState.notes = notes;
      if (previousId) {
        const idx = notes.findIndex(note => note.id === previousId);
        baseIntelState.activeIndex = idx >= 0 ? idx : 0;
      } else {
        baseIntelState.activeIndex = 0;
      }
      renderBaseIntelNotes(notes, baseIntelState.activeIndex, { stageSnapshot: snapshot });
      restartBaseIntelTimer();
    }
    function getBaseLevelConfig(level) {
      if (!Array.isArray(BASE_LEVEL_CONFIG) || !BASE_LEVEL_CONFIG.length) return null;
      return BASE_LEVEL_CONFIG.find(cfg => cfg.level === level) || BASE_LEVEL_CONFIG[BASE_LEVEL_CONFIG.length - 1];
    }
    function computeMaxWorkLevel() {
      let max = 0;
      Object.values(PALS || {}).forEach(pal => {
        const work = pal?.work || {};
        Object.values(work).forEach(value => {
          if (typeof value === 'number' && value > max) {
            max = value;
          }
        });
      });
      return max || 4;
    }
    function workLevelLabel(level) {
      const numeric = Number(level) || 0;
      return `Lv ${numeric}`;
    }
    function buildBasePage() {
      const page = document.getElementById('basePage');
      if (!page) return;
      const introText = kidMode
        ? 'Palmate watches your tech unlocks and pals to build a dream crew for your base.'
        : 'Palmate analyses unlocked tech, captured pals, and work priorities to recommend an optimal base roster.';
      page.innerHTML = `
        <header class="page-header">
          <h2>${kidMode ? 'Base Crew' : 'Base Planner'}</h2>
        </header>
        <p class="page-intro">${introText}</p>
        <div class="base-planner-layout">
          <article class="base-card base-card--intel">
            <div class="base-card__header base-card__header--intel">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Base intel' : 'Base intel'}</h3>
                <p class="base-card__meta" id="baseIntelMeta"></p>
              </div>
              <div class="base-intel__controls">
                <button type="button" class="base-intel__shuffle" id="baseIntelShuffle">${kidMode ? 'Next tip' : 'Shuffle tips'}</button>
                <span class="base-intel__hint">${kidMode ? 'Palmate swaps tips every 20 seconds.' : 'Tips auto-rotate every 20 seconds.'}</span>
              </div>
            </div>
            <div class="base-intel__context">
              <div class="base-intel-stage" id="baseIntelStage"></div>
            </div>
            <div class="base-intel-notes" id="baseIntelNotes"></div>
          </article>
          <article class="base-card base-card--level">
            <div class="base-card__header">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Track your base level' : 'Track your base level'}</h3>
                <p class="base-card__meta" id="baseLevelCopy"></p>
              </div>
              <span class="base-card__badge" id="baseModeBadge"></span>
            </div>
            <div class="base-level-summary">
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Auto level' : 'Detected level'}</span>
                <span class="base-level-summary__value" id="baseDetectedLevel">1</span>
              </div>
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Manual level' : 'Manual level'}</span>
                <span class="base-level-summary__value" id="baseManualValue">1</span>
              </div>
              <div class="base-level-summary__item">
                <span class="base-level-summary__label">${kidMode ? 'Crew slots' : 'Slots available'}</span>
                <span class="base-level-summary__value" id="baseSlotCount">5</span>
              </div>
            </div>
            <label for="baseLevelInput">${kidMode ? 'Slide to match your base level.' : 'Use the slider when you want to override the detected level.'}</label>
            <input type="range" min="1" max="${BASE_LEVEL_CONFIG.length}" value="${basePlannerState.manualLevel}" id="baseLevelInput" class="base-level-slider">
            <div class="base-level-controls">
              <button type="button" class="base-toggle" id="baseManualToggle" aria-pressed="${basePlannerState.mode === 'manual'}">${kidMode ? 'Manual level' : 'Manual control'}: ${basePlannerState.mode === 'manual' ? (kidMode ? 'On' : 'On') : (kidMode ? 'Off' : 'Off')}</button>
              <button type="button" class="base-toggle" id="baseUseDetected">${kidMode ? 'Use detected level' : 'Use detected level'}</button>
            </div>
            <p class="base-card__hint" id="baseLevelHint"></p>
            <p class="base-card__meta" id="baseFocusText"></p>
            <ul class="base-priority-list" id="basePriorityList"></ul>
          </article>
          <article class="base-card base-card--crew">
            <div class="base-card__header">
              <div>
                <h3 class="base-card__title">${kidMode ? 'Suggested pals' : 'Suggested crew'}</h3>
                <p class="base-card__meta" id="baseCrewMeta"></p>
              </div>
              <span class="base-card__badge" id="baseActiveBadge"></span>
            </div>
            <div class="base-slot-grid" id="baseSlotsGrid"></div>
            <div>
              <h4 class="base-card__title" style="font-size:1rem;">${kidMode ? 'Coverage check' : 'Work coverage check'}</h4>
            </div>
            <div class="base-coverage-grid" id="baseCoverageGrid"></div>
          </article>
        </div>
      `;
      basePlannerElements = {
        page,
        slider: page.querySelector('#baseLevelInput'),
        manualToggle: page.querySelector('#baseManualToggle'),
        useDetected: page.querySelector('#baseUseDetected'),
        detectedValue: page.querySelector('#baseDetectedLevel'),
        manualValue: page.querySelector('#baseManualValue'),
        slotCount: page.querySelector('#baseSlotCount'),
        levelHint: page.querySelector('#baseLevelHint'),
        priorityList: page.querySelector('#basePriorityList'),
        slotsGrid: page.querySelector('#baseSlotsGrid'),
        coverageGrid: page.querySelector('#baseCoverageGrid'),
        focusText: page.querySelector('#baseFocusText'),
        levelCopy: page.querySelector('#baseLevelCopy'),
        crewMeta: page.querySelector('#baseCrewMeta'),
        modeBadge: page.querySelector('#baseModeBadge'),
        activeBadge: page.querySelector('#baseActiveBadge'),
        intelNotes: page.querySelector('#baseIntelNotes'),
        intelMeta: page.querySelector('#baseIntelMeta'),
        intelStage: page.querySelector('#baseIntelStage'),
        intelShuffle: page.querySelector('#baseIntelShuffle')
      };
      if (baseIntelState.rotationTimer) {
        clearInterval(baseIntelState.rotationTimer);
        baseIntelState.rotationTimer = null;
      }
      if (basePlannerElements.slider) {
        basePlannerElements.slider.max = String(BASE_LEVEL_CONFIG.length);
        basePlannerElements.slider.addEventListener('input', event => {
          const raw = Number(event.target.value);
          const value = clampToRange(Number.isFinite(raw) ? Math.round(raw) : 1, 1, BASE_LEVEL_CONFIG.length || 1);
          basePlannerState.manualLevel = value;
          basePlannerState.mode = 'manual';
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.manualToggle) {
        basePlannerElements.manualToggle.addEventListener('click', () => {
          if (basePlannerState.mode === 'manual') {
            basePlannerState.mode = 'auto';
          } else {
            const sliderValue = basePlannerElements.slider ? Number(basePlannerElements.slider.value) : NaN;
            const fallback = calculateAutoBaseLevelDetail().level;
            basePlannerState.manualLevel = clampToRange(Number.isFinite(sliderValue) ? Math.round(sliderValue) : fallback, 1, BASE_LEVEL_CONFIG.length || 1);
            basePlannerState.mode = 'manual';
          }
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.useDetected) {
        basePlannerElements.useDetected.addEventListener('click', () => {
          const autoInfo = calculateAutoBaseLevelDetail();
          basePlannerState.manualLevel = autoInfo.level;
          basePlannerState.mode = 'auto';
          persistBasePlannerState();
          updateBasePlanner();
        });
      }
      if (basePlannerElements.intelShuffle) {
        basePlannerElements.intelShuffle.addEventListener('click', () => {
          rotateBaseIntel(1, { userInitiated: true });
        });
      }
      updateBasePlanner();
    }
    function updateBasePlanner() {
      const elements = basePlannerElements || {};
      if (!elements.slider || !BASE_LEVEL_CONFIG.length) return;
      const autoInfo = calculateAutoBaseLevelDetail();
      const clampedManual = clampToRange(basePlannerState.manualLevel || autoInfo.level || 1, 1, BASE_LEVEL_CONFIG.length || 1);
      if (basePlannerState.manualLevel !== clampedManual) {
        basePlannerState.manualLevel = clampedManual;
        persistBasePlannerState();
      }
      const useManual = basePlannerState.mode === 'manual';
      const activeLevel = useManual ? basePlannerState.manualLevel : autoInfo.level;
      const config = getBaseLevelConfig(activeLevel);
      if (!config) return;
      const stageSnapshot = determineGuideStageSnapshot();
      const weights = calculateEffectiveWorkWeights(config, { stageSnapshot, activeLevel, autoInfo });
      const ranchPlan = computeRanchPlan({ stageSnapshot, limit: kidMode ? 3 : 4 });
      const resolvedRanchAssignments = resolveRanchAssignments({ plan: ranchPlan });
      const sliderValue = useManual ? basePlannerState.manualLevel : autoInfo.level;
      elements.slider.value = String(sliderValue);
      elements.slider.disabled = !useManual;
      if (elements.slider.disabled) {
        elements.slider.setAttribute('aria-disabled', 'true');
      } else {
        elements.slider.removeAttribute('aria-disabled');
      }
      if (elements.manualValue) {
        elements.manualValue.textContent = String(sliderValue);
      }
      if (elements.detectedValue) {
        elements.detectedValue.textContent = String(autoInfo.level || 1);
      }
      if (elements.slotCount) {
        elements.slotCount.textContent = String(config.slots);
      }
      if (elements.modeBadge) {
        elements.modeBadge.textContent = useManual
          ? (kidMode ? 'Manual' : 'Manual override')
          : (kidMode ? 'Auto detect' : 'Auto detect');
      }
      if (elements.activeBadge) {
        elements.activeBadge.textContent = `Lv ${activeLevel}`;
      }
      if (elements.levelCopy) {
        elements.levelCopy.textContent = kidMode ? (config.copy?.kid || '') : (config.copy?.grown || '');
      }
      if (elements.focusText) {
        const focusNames = Array.isArray(config.focus)
          ? config.focus.map(key => {
              const detail = getWorkTypeDetail(key);
              return kidMode ? (detail.kidLabel || detail.label) : detail.label;
            }).filter(Boolean)
          : [];
        elements.focusText.textContent = focusNames.length
          ? `${kidMode ? 'Focus:' : 'Priority focus:'} ${focusNames.join(kidMode ? ', ' : ' • ')}`
          : '';
      }
      if (elements.manualToggle) {
        elements.manualToggle.setAttribute('aria-pressed', useManual ? 'true' : 'false');
        elements.manualToggle.textContent = `${kidMode ? 'Manual level' : 'Manual control'}: ${useManual ? (kidMode ? 'On' : 'On') : (kidMode ? 'Off' : 'Off')}`;
      }
      if (elements.useDetected) {
        elements.useDetected.disabled = !useManual && autoInfo.level === basePlannerState.manualLevel;
      }
      if (elements.levelHint) {
        const hints = [];
        if (useManual) {
          hints.push(kidMode ? 'Manual mode is on. Match the slider to your real base level.' : 'Manual override active. Use the slider to match your in-game base level.');
        } else if (autoInfo.highestItem) {
          hints.push(kidMode
            ? `Detected level from ${autoInfo.highestItem.name} (Tech Lv ${autoInfo.highestItem.techLevel}).`
            : `Detected from ${autoInfo.highestItem.name} at Tech Lv ${autoInfo.highestItem.techLevel}.`);
        } else {
          hints.push(kidMode ? 'No base unlocks marked yet, so we start at Level 1.' : 'No base-focused tech marked unlocked yet. Defaulting to Level 1.');
        }
        if (!useManual && autoInfo.highestItem) {
          hints.push(kidMode ? 'Switch to manual if your camp is ahead.' : 'Toggle manual control if your base has progressed further.');
        }
        elements.levelHint.textContent = hints.join(' ');
      }
      if (elements.priorityList) {
        elements.priorityList.innerHTML = '';
        const entries = Object.entries(weights || {})
          .filter(([, weight]) => weight && weight > 0)
          .sort((a, b) => b[1] - a[1]);
        const limit = kidMode ? Math.min(entries.length, 5) : entries.length;
        entries.slice(0, limit).forEach(([key, weight]) => {
          const detail = getWorkTypeDetail(key);
          const item = document.createElement('li');
          item.className = 'base-priority-item';
          const icon = document.createElement('span');
          icon.className = 'base-priority-item__icon';
          icon.textContent = detail.icon || '⭐';
          item.appendChild(icon);
          const content = document.createElement('div');
          content.className = 'base-priority-item__content';
          const label = document.createElement('span');
          label.className = 'base-priority-item__label';
          label.textContent = kidMode ? (detail.kidLabel || detail.label) : detail.label;
          content.appendChild(label);
          const note = document.createElement('p');
          note.className = 'base-priority-item__note';
          const descriptor = priorityDescriptor(weight);
          note.textContent = kidMode ? descriptor.kid : descriptor.grown;
          content.appendChild(note);
          item.appendChild(content);
          elements.priorityList.appendChild(item);
        });
      }
      const crew = recommendBaseCrew(config, { stageSnapshot, weightsOverride: weights, ranchAssignments: resolvedRanchAssignments });
      updateBaseIntel(config, crew, { weights, stageSnapshot });
      if (elements.slotsGrid) {
        elements.slotsGrid.innerHTML = '';
        for (let slotIndex = 0; slotIndex < config.slots; slotIndex += 1) {
          const entry = crew.selections[slotIndex];
          if (entry && entry.pal) {
            const card = document.createElement('article');
            card.className = 'base-slot-card';
            card.dataset.palId = entry.pal.id || '';
            if (entry.assignmentType === 'ranch' || (entry.assignment && entry.assignment.type === 'ranch')) {
              card.classList.add('base-slot-card--ranch');
            }
            const header = document.createElement('div');
            header.className = 'base-slot-card__header';
            const slotLabel = document.createElement('span');
            slotLabel.className = 'base-slot-card__slot';
            slotLabel.textContent = `${kidMode ? 'Slot' : 'Slot'} ${slotIndex + 1}`;
            header.appendChild(slotLabel);
            const status = document.createElement('span');
            status.className = `base-slot-card__status ${entry.isCaught ? 'base-slot-card__status--caught' : 'base-slot-card__status--missing'}`;
            status.textContent = entry.isCaught ? (kidMode ? 'Caught' : 'Caught') : (kidMode ? 'Catch next' : 'Not caught');
            header.appendChild(status);
            if (entry.assignment && entry.assignment.type === 'ranch') {
              const badge = document.createElement('span');
              badge.className = 'base-slot-card__assignment';
              const copyTotal = Math.max(1, entry.assignment.count || 1);
              badge.textContent = kidMode
                ? `Ranch pal${copyTotal > 1 ? ` ×${copyTotal}` : ''}`
                : `Ranch pal${copyTotal > 1 ? ` ×${copyTotal}` : ''}`;
              header.appendChild(badge);
            }
            card.appendChild(header);
            const palInfo = document.createElement('div');
            palInfo.className = 'base-slot-card__pal';
            const portrait = document.createElement('img');
            portrait.className = 'base-slot-card__portrait';
            applyPalArtwork(portrait, entry.pal, { alt: `${entry.pal.name || 'Pal'} portrait` });
            palInfo.appendChild(portrait);
            const infoWrap = document.createElement('div');
            infoWrap.className = 'base-slot-card__info';
            const nameEl = document.createElement('h4');
            nameEl.className = 'base-slot-card__name';
            nameEl.textContent = entry.pal.name || 'Pal';
            infoWrap.appendChild(nameEl);
            const types = Array.isArray(entry.pal.types) ? entry.pal.types : [];
            if (types.length) {
              const typesWrap = document.createElement('div');
              typesWrap.className = 'base-slot-card__types';
              types.forEach(type => {
                const icon = document.createElement('img');
                icon.src = iconMap[type] || iconMap['Neutral'];
                icon.alt = `${type} icon`;
                typesWrap.appendChild(icon);
              });
              infoWrap.appendChild(typesWrap);
            }
            palInfo.appendChild(infoWrap);
            card.appendChild(palInfo);
            const workList = document.createElement('ul');
            workList.className = 'base-slot-card__work';
            entry.contributions.slice(0, kidMode ? 2 : 3).forEach(contribution => {
              const detail = getWorkTypeDetail(contribution.key);
              const item = document.createElement('li');
              item.innerHTML = `<span>${detail.icon || '⭐'}</span><span>${kidMode ? (detail.kidLabel || detail.label) : detail.label} ${workLevelLabel(contribution.level)}</span>`;
              workList.appendChild(item);
            });
            card.appendChild(workList);
            const note = document.createElement('p');
            note.className = 'base-slot-card__note';
            if (entry.assignment && entry.assignment.type === 'ranch') {
              const noteTextKid = entry.assignment.noteKid || entry.assignment.actionKid || `Keep ${entry.pal.name} on the Ranch.`;
              const noteTextGrown = entry.assignment.noteGrown || entry.assignment.actionGrown || `Reserve ${entry.pal.name} for ranch output.`;
              const copyIndex = (entry.assignment.copyIndex ?? 0) + 1;
              const copyTotal = Math.max(1, entry.assignment.count || 1);
              const suffix = copyTotal > 1
                ? kidMode
                  ? ` (Helper ${copyIndex} of ${copyTotal})`
                  : ` (Slot ${copyIndex} of ${copyTotal})`
                : '';
              note.textContent = (kidMode ? noteTextKid : noteTextGrown) + suffix;
            } else if (entry.note) {
              note.textContent = entry.note;
            } else {
              const highlights = entry.contributions.slice(0, 2).map(contribution => {
                const detail = getWorkTypeDetail(contribution.key);
                const label = kidMode ? (detail.kidLabel || detail.label) : detail.label;
                return `${label} ${workLevelLabel(contribution.level)}`;
              });
              note.textContent = highlights.length
                ? (kidMode ? `Great at ${highlights.join(' & ')}` : `Highlights: ${highlights.join(' • ')}`)
                : (kidMode ? 'Flexible helper' : 'General support');
            }
            card.appendChild(note);
            const actions = document.createElement('div');
            actions.className = 'base-slot-card__actions';
            const viewButton = document.createElement('button');
            viewButton.type = 'button';
            viewButton.className = 'base-slot-card__action base-slot-card__action--primary';
            viewButton.textContent = kidMode ? 'View pal' : 'Open details';
            viewButton.addEventListener('click', event => {
              event.stopPropagation();
              showPalDetail(entry.pal.id);
            });
            actions.appendChild(viewButton);
            const toggleButton = document.createElement('button');
            toggleButton.type = 'button';
            toggleButton.className = 'base-slot-card__action';
            toggleButton.textContent = entry.isCaught
              ? (kidMode ? 'Mark not caught' : 'Mark as not caught')
              : (kidMode ? 'Mark caught' : 'Mark as caught');
            toggleButton.addEventListener('click', event => {
              event.stopPropagation();
              setPalCaught(entry.pal.id, !entry.isCaught);
            });
            actions.appendChild(toggleButton);
            card.appendChild(actions);
            elements.slotsGrid.appendChild(card);
          } else {
            const placeholder = document.createElement('article');
            placeholder.className = 'base-slot-card';
            const header = document.createElement('div');
            header.className = 'base-slot-card__header';
            const slotLabel = document.createElement('span');
            slotLabel.className = 'base-slot-card__slot';
            slotLabel.textContent = `${kidMode ? 'Slot' : 'Slot'} ${slotIndex + 1}`;
            header.appendChild(slotLabel);
            const status = document.createElement('span');
            status.className = 'base-slot-card__status';
            status.textContent = kidMode ? 'Open slot' : 'Open slot';
            header.appendChild(status);
            placeholder.appendChild(header);
            const empty = document.createElement('div');
            empty.className = 'base-slot-card__empty';
            empty.textContent = kidMode
              ? 'Catch another helper to fill this job.'
              : 'Catch or recruit another worker to fill this assignment.';
            placeholder.appendChild(empty);
            elements.slotsGrid.appendChild(placeholder);
          }
        }
      }
      if (elements.crewMeta) {
        const filled = Math.min(crew.selections.length, config.slots);
        const capturedCount = crew.capturedCount || 0;
        const suggestionCount = Math.max(0, filled - capturedCount);
        const reservedSlots = Array.isArray(crew.ranchAssignments)
          ? crew.ranchAssignments.reduce((sum, assignment) => sum + Math.max(1, assignment.count || 1), 0)
          : 0;
        if (config.slots) {
          const baseSummary = kidMode
            ? `Palmate filled ${filled} of ${config.slots} slots.`
            : `Recommended crew covers ${filled} of ${config.slots} slots.`;
          let detailSummary = '';
          if (!filled) {
            detailSummary = kidMode
              ? 'Catch pals to start filling your camp.'
              : 'Mark captured pals to start building your roster.';
          } else if (kidMode) {
            detailSummary = suggestionCount
              ? `${capturedCount} from your crew, ${suggestionCount} to catch next.`
              : `${capturedCount} from your crew ready to work.`;
            if (reservedSlots) {
              detailSummary += ` Ranch pals saved: ${reservedSlots}.`;
            }
          } else {
            const capturedLabel = `${capturedCount} slot${capturedCount === 1 ? '' : 's'} use captured pals`;
            detailSummary = suggestionCount
              ? `${capturedLabel}; ${suggestionCount} new recruit${suggestionCount === 1 ? '' : 's'} suggested.`
              : `${capturedLabel}.`;
            if (reservedSlots) {
              detailSummary += ` Ranch reserves: ${reservedSlots} slot${reservedSlots === 1 ? '' : 's'}.`;
            }
          }
          elements.crewMeta.textContent = `${baseSummary} ${detailSummary}`.trim();
        } else {
          elements.crewMeta.textContent = '';
        }
      }
      if (elements.coverageGrid) {
        elements.coverageGrid.innerHTML = '';
        const weightEntries = Object.entries(weights || {})
          .filter(([, weight]) => weight && weight > 0)
          .sort((a, b) => b[1] - a[1]);
        const highestWeight = weightEntries.length ? weightEntries[0][1] : 1;
        if (resolvedRanchAssignments.length) {
          const summary = document.createElement('div');
          summary.className = 'base-coverage-item base-coverage-item--ranch';
          const header = document.createElement('div');
          header.className = 'base-coverage-item__header';
          const title = document.createElement('span');
          title.className = 'base-coverage-item__title';
          title.innerHTML = `🐑 <span>${kidMode ? 'Ranch focus' : 'Ranch plan'}</span>`;
          header.appendChild(title);
          const reservedTotal = resolvedRanchAssignments.reduce((sum, assignment) => sum + Math.max(1, assignment.count || 1), 0);
          const status = document.createElement('span');
          status.className = 'base-coverage-item__status';
          status.textContent = kidMode
            ? `Helpers reserved: ${reservedTotal}`
            : `Reserved slots: ${reservedTotal}`;
          header.appendChild(status);
          summary.appendChild(header);
          const list = document.createElement('div');
          list.className = 'ranch-assignment-list';
          resolvedRanchAssignments.forEach(assignment => {
            const entry = document.createElement('article');
            entry.className = 'ranch-assignment-entry';
            const entryHeader = document.createElement('div');
            entryHeader.className = 'ranch-assignment-entry__header';
            const entryTitle = document.createElement('h4');
            entryTitle.className = 'ranch-assignment-entry__title';
            entryTitle.textContent = assignment.itemName || humaniseItemKey(assignment.itemKey || 'Ranch output');
            entryHeader.appendChild(entryTitle);
            const countBadge = document.createElement('span');
            countBadge.className = 'ranch-assignment-entry__count';
            countBadge.textContent = `×${Math.max(1, assignment.count || 1)}`;
            entryHeader.appendChild(countBadge);
            entry.appendChild(entryHeader);
            const palLine = document.createElement('p');
            palLine.className = 'ranch-assignment-entry__pal';
            palLine.textContent = assignment.palName
              ? `${assignment.palName}${assignment.isCaught ? '' : kidMode ? ' (catch me!)' : ' (uncaught)'}`
              : kidMode
                ? 'Choose a pal to keep on the Ranch.'
                : 'Select a pal to reserve on the Ranch.';
            entry.appendChild(palLine);
            const reasonText = kidMode
              ? assignment.reasonKid || assignment.reasonGrown
              : assignment.reasonGrown || assignment.reasonKid;
            if (reasonText) {
              const reason = document.createElement('p');
              reason.className = 'ranch-assignment-entry__reason';
              reason.textContent = reasonText;
              entry.appendChild(reason);
            }
            const actionText = kidMode
              ? assignment.actionKid || assignment.actionGrown
              : assignment.actionGrown || assignment.actionKid;
            if (actionText) {
              const action = document.createElement('p');
              action.className = 'ranch-assignment-entry__action';
              action.textContent = actionText;
              entry.appendChild(action);
            }
            const controls = document.createElement('div');
            controls.className = 'ranch-assignment-entry__controls';
            const decrement = document.createElement('button');
            decrement.type = 'button';
            decrement.className = 'ranch-assignment-entry__control';
            decrement.textContent = '−';
            decrement.setAttribute('aria-label', kidMode ? 'Remove one helper' : 'Remove one reserved slot');
            decrement.addEventListener('click', event => {
              event.stopPropagation();
              adjustRanchAssignmentCount(assignment, -1);
            });
            controls.appendChild(decrement);
            const increment = document.createElement('button');
            increment.type = 'button';
            increment.className = 'ranch-assignment-entry__control';
            increment.textContent = '+';
            increment.setAttribute('aria-label', kidMode ? 'Add another helper' : 'Reserve another slot');
            if (Math.max(1, assignment.count || 1) >= MAX_RANCH_ASSIGNMENT_COUNT) {
              increment.disabled = true;
            }
            increment.addEventListener('click', event => {
              event.stopPropagation();
              adjustRanchAssignmentCount(assignment, 1);
            });
            controls.appendChild(increment);
            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = 'ranch-assignment-entry__remove';
            removeBtn.textContent = kidMode ? 'Remove' : 'Remove';
            removeBtn.addEventListener('click', event => {
              event.stopPropagation();
              removeRanchAssignment(assignment);
            });
            controls.appendChild(removeBtn);
            entry.appendChild(controls);
            list.appendChild(entry);
          });
          summary.appendChild(list);
          const footer = document.createElement('div');
          footer.className = 'ranch-assignment-entry__footer';
          const clearBtn = document.createElement('button');
          clearBtn.type = 'button';
          clearBtn.className = 'ranch-assignment-summary__clear';
          clearBtn.textContent = kidMode ? 'Clear ranch plan' : 'Clear all assignments';
          clearBtn.addEventListener('click', event => {
            event.stopPropagation();
            clearAllRanchAssignments();
          });
          footer.appendChild(clearBtn);
          const availableRecs = ranchPlan.recommendations.filter(rec => !resolvedRanchAssignments.some(assignment => assignment.itemKey === rec.itemKey));
          if (availableRecs.length) {
            const quickAdd = document.createElement('button');
            quickAdd.type = 'button';
            quickAdd.className = 'ranch-assignment-summary__quick';
            quickAdd.textContent = kidMode ? 'Add recommended pals' : 'Add recommended output';
            quickAdd.addEventListener('click', event => {
              event.stopPropagation();
              availableRecs.slice(0, kidMode ? 1 : 2).forEach(rec => setRanchAssignmentFromRecommendation(rec));
            });
            footer.appendChild(quickAdd);
          }
          if (footer.children.length) {
            summary.appendChild(footer);
          }
          elements.coverageGrid.appendChild(summary);
        }
        weightEntries.forEach(([key, weight]) => {
          const detail = getWorkTypeDetail(key);
          const canonical = canonicalWorkKey(key);
          const item = document.createElement('div');
          item.className = 'base-coverage-item';
          const header = document.createElement('div');
          header.className = 'base-coverage-item__header';
          const title = document.createElement('span');
          title.className = 'base-coverage-item__title';
          title.innerHTML = `${detail.icon || '⭐'} <span>${kidMode ? (detail.kidLabel || detail.label) : detail.label}</span>`;
          header.appendChild(title);
          const status = document.createElement('span');
          status.className = 'base-coverage-item__status';
          if (canonical === 'farming') {
            status.textContent = kidMode ? ranchPlan.summaryKid : ranchPlan.summaryGrown;
            header.appendChild(status);
            item.appendChild(header);
            const list = document.createElement('div');
            list.className = 'ranch-suggestion-list';
            if (ranchPlan.recommendations.length) {
              ranchPlan.recommendations.forEach(rec => {
                const suggestion = document.createElement('div');
                suggestion.className = 'ranch-suggestion';
                const matchingAssignments = resolvedRanchAssignments.filter(assignment => assignment.itemKey === rec.itemKey);
                if (matchingAssignments.length) {
                  suggestion.classList.add('ranch-suggestion--active');
                }
                const suggestionHeader = document.createElement('div');
                suggestionHeader.className = 'ranch-suggestion__header';
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'ranch-suggestion__item';
                button.textContent = rec.name;
                if (rec.hasDetail) {
                  button.dataset.itemKey = rec.itemKey;
                  button.addEventListener('click', event => {
                    event.stopPropagation();
                    openItemDetail(rec.itemKey);
                  });
                } else if (rec.openUrl) {
                  button.addEventListener('click', event => {
                    event.stopPropagation();
                    window.open(rec.openUrl, '_blank', 'noopener');
                  });
                } else {
                  button.disabled = true;
                }
                suggestionHeader.appendChild(button);
                const reasonText = kidMode ? rec.reasonKid : rec.reasonGrown;
                if (reasonText) {
                  const reason = document.createElement('span');
                  reason.className = 'ranch-suggestion__reason';
                  reason.textContent = reasonText;
                  suggestionHeader.appendChild(reason);
                }
                const assignmentTotal = matchingAssignments.reduce((sum, entry) => sum + Math.max(1, entry.count || 1), 0);
                if (assignmentTotal) {
                  const badge = document.createElement('span');
                  badge.className = 'ranch-suggestion__badge';
                  badge.textContent = kidMode
                    ? `Reserved: ${assignmentTotal}`
                    : `Reserved slots: ${assignmentTotal}`;
                  suggestionHeader.appendChild(badge);
                }
                suggestion.appendChild(suggestionHeader);
                const action = document.createElement('p');
                action.className = 'ranch-suggestion__action';
                action.textContent = kidMode ? rec.actionKid : rec.actionGrown;
                suggestion.appendChild(action);
                const statusLine = document.createElement('p');
                statusLine.className = 'ranch-suggestion__status';
                if (rec.caughtProducers.length) {
                  statusLine.textContent = kidMode
                    ? `Ready pals: ${rec.caughtProducers.slice(0, 3).join(' & ')}.`
                    : `Ready producers: ${rec.caughtProducers.join(', ')}.`;
                } else if (rec.missingProducers.length) {
                  statusLine.textContent = kidMode
                    ? `Catch ${rec.missingProducers.slice(0, 3).join(' or ')} to start.`
                    : `Recruit ${rec.missingProducers.join(', ')} to unlock ${rec.name.toLowerCase()}.`;
                } else {
                  statusLine.textContent = kidMode
                    ? 'Choose a ranch pal to begin production.'
                    : 'Select a ranch hand to begin production.';
                }
                suggestion.appendChild(statusLine);
                const controls = document.createElement('div');
                controls.className = 'ranch-suggestion__controls';
                const preferred = pickPreferredRanchProducer(rec);
                const assignBtn = document.createElement('button');
                assignBtn.type = 'button';
                assignBtn.className = 'ranch-suggestion__assign';
                assignBtn.textContent = assignmentTotal
                  ? (kidMode ? 'Add another helper' : 'Add another slot')
                  : (kidMode
                      ? `Use ${preferred.name || 'this pal'}`
                      : `Assign ${preferred.name || 'recommended pal'}`);
                assignBtn.setAttribute('aria-pressed', assignmentTotal ? 'true' : 'false');
                assignBtn.addEventListener('click', event => {
                  event.stopPropagation();
                  setRanchAssignmentFromRecommendation(rec);
                });
                controls.appendChild(assignBtn);
                if (Array.isArray(rec.producers) && rec.producers.length) {
                  const producerList = document.createElement('div');
                  producerList.className = 'ranch-suggestion__producer-list';
                  const label = document.createElement('span');
                  label.className = 'ranch-suggestion__producer-label';
                  label.textContent = kidMode ? 'Pick pal:' : 'Choose ranch hand:';
                  producerList.appendChild(label);
                  rec.producers.forEach(name => {
                    const palButton = document.createElement('button');
                    palButton.type = 'button';
                    palButton.className = 'ranch-suggestion__producer';
                    const isPalCaught = isPalCaughtByName(name);
                    palButton.textContent = isPalCaught ? `${name} ✓` : name;
                    if (matchingAssignments.some(assignment => assignment.palName && assignment.palName.toLowerCase() === name.toLowerCase())) {
                      palButton.classList.add('is-selected');
                    }
                    palButton.addEventListener('click', event => {
                      event.stopPropagation();
                      selectRanchAssignmentPal(rec, name);
                    });
                    producerList.appendChild(palButton);
                  });
                  controls.appendChild(producerList);
                }
                suggestion.appendChild(controls);
                list.appendChild(suggestion);
              });
            } else {
              const empty = document.createElement('p');
              empty.className = 'ranch-suggestion__action';
              empty.textContent = kidMode
                ? 'Unlock the Ranch to start planning outputs.'
                : 'Unlock the Ranch to start planning outputs.';
              list.appendChild(empty);
            }
            item.appendChild(list);
            const rosterSection = buildRanchRosterSection({
              plan: ranchPlan,
              assignments: resolvedRanchAssignments,
              kidMode
            });
            if (rosterSection) {
              item.appendChild(rosterSection);
            }
            elements.coverageGrid.appendChild(item);
            return;
          }
          const total = crew.coverage[key] || 0;
          const descriptor = coverageDescriptor(weight, total, config, highestWeight);
          status.textContent = kidMode ? descriptor.kid : descriptor.grown;
          header.appendChild(status);
          item.appendChild(header);
          const meter = document.createElement('div');
          meter.className = 'base-coverage-meter';
          const fill = document.createElement('div');
          fill.className = 'base-coverage-meter__fill';
          const percent = Math.max(0, Math.min(100, descriptor.percent));
          fill.style.width = `${percent}%`;
          meter.appendChild(fill);
          item.appendChild(meter);
          elements.coverageGrid.appendChild(item);
        });
      }
    }
    function recommendBaseCrew(config, options = {}) {
      const slotCount = config?.slots || 0;
      if (!slotCount) {
        return { selections: [], coverage: {}, slotCount: 0, capturedCount: 0 };
      }
      const weights = options.weightsOverride
        ? { ...options.weightsOverride }
        : calculateEffectiveWorkWeights(config, options);
      const defaultWeight = config?.defaultWeight != null ? config.defaultWeight : 0.2;
      const available = Object.values(PALS || {}).filter(pal => {
        if (!pal || !pal.work) return false;
        return Object.values(pal.work).some(value => Number(value) > 0);
      });
      const coverage = {};
      const selections = [];
      const used = new Map();
      const addSelection = (candidate, { updateCoverage = true } = {}) => {
        if (!candidate || !candidate.pal) return;
        selections.push(candidate);
        if (candidate.pal && candidate.pal.id != null) {
          const palId = candidate.pal.id;
          used.set(palId, (used.get(palId) || 0) + 1);
        }
        if (updateCoverage && Array.isArray(candidate.contributions)) {
          candidate.contributions.forEach(entry => {
            coverage[entry.key] = (coverage[entry.key] || 0) + entry.level;
          });
        }
      };
      const activeRanchAssignments = Array.isArray(options.ranchAssignments)
        ? options.ranchAssignments.map(entry => ({ ...entry }))
        : [];
      activeRanchAssignments.forEach(assignment => {
        if (!assignment || selections.length >= slotCount) return;
        let pal = assignment.pal || null;
        if (!pal && assignment.palId != null && PALS && PALS[assignment.palId]) {
          pal = PALS[assignment.palId];
        }
        if (!pal && assignment.palName) {
          pal = findPalByName(assignment.palName);
        }
        if (!pal) return;
        let evaluation = scorePalForBase(pal, weights, {}, config, defaultWeight);
        if (!evaluation) {
          const workEntries = Object.entries(pal.work || {});
          const maxLevel = Math.max(1, MAX_WORK_LEVEL);
          const fallbackContributions = workEntries
            .map(([key, value]) => {
              const level = Number(value) || 0;
              if (!level) return null;
              const canonical = canonicalWorkKey(key);
              if (!canonical) return null;
              const weight = Object.prototype.hasOwnProperty.call(weights, canonical)
                ? weights[canonical]
                : defaultWeight;
              if (!weight) return null;
              const normalizedLevel = level / maxLevel;
              const baseContribution = weight * normalizedLevel;
              return {
                key: canonical,
                level,
                weight,
                baseContribution,
                contributionScore: baseContribution
              };
            })
            .filter(Boolean)
            .sort((a, b) => {
              if (b.contributionScore !== a.contributionScore) {
                return b.contributionScore - a.contributionScore;
              }
              return b.level - a.level;
            });
          evaluation = {
            score: 0,
            rawScore: 0,
            contributions: fallbackContributions,
            isCaught: !!caught[pal.id]
          };
        }
        const count = Math.max(1, assignment.count || 1);
        for (let copyIndex = 0; copyIndex < count && selections.length < slotCount; copyIndex += 1) {
          const contributions = Array.isArray(evaluation.contributions)
            ? evaluation.contributions.map(entry => ({ ...entry }))
            : [];
          const assignmentInfo = {
            ...assignment,
            pal,
            type: 'ranch',
            copyIndex,
            count,
            isCaught: assignment.isCaught != null ? assignment.isCaught : !!caught[pal.id]
          };
          const candidate = {
            pal,
            score: evaluation.score,
            rawScore: evaluation.rawScore,
            contributions,
            isCaught: assignmentInfo.isCaught,
            assignment: assignmentInfo,
            assignmentType: 'ranch'
          };
          addSelection(candidate, { updateCoverage: false });
        }
      });
      const pickBestFromPool = (pool, { coverageAware = true } = {}) => {
        let best = null;
        pool.forEach(pal => {
          if (!pal || used.has(pal.id)) return;
          const evaluation = scorePalForBase(pal, weights, coverageAware ? coverage : {}, config, defaultWeight);
          if (!evaluation) return;
          if (!best || evaluation.score > best.score || (evaluation.score === best.score && evaluation.rawScore > best.rawScore)) {
            best = { pal, ...evaluation };
          }
        });
        return best;
      };
      const fillFromPool = pool => {
        if (!Array.isArray(pool) || !pool.length) return;
        while (selections.length < slotCount) {
          const candidate = pickBestFromPool(pool);
          if (!candidate) break;
          addSelection(candidate);
        }
      };
      const caughtPool = available.filter(pal => pal && caught[pal.id] && !used.has(pal.id));
      const suggestionPool = available.filter(pal => pal && !caught[pal.id] && !used.has(pal.id));
      fillFromPool(caughtPool);
      fillFromPool(suggestionPool);
      if (selections.length < slotCount) {
        const remainder = available.filter(pal => pal && !used.has(pal.id));
        const fallback = remainder
          .map(pal => {
            const evaluation = scorePalForBase(pal, weights, {}, config, defaultWeight);
            if (!evaluation) return null;
            return { pal, ...evaluation };
          })
          .filter(Boolean)
          .sort((a, b) => {
            if (b.rawScore !== a.rawScore) {
              return b.rawScore - a.rawScore;
            }
            return (b.pal?.rarity || 0) - (a.pal?.rarity || 0);
          });
        while (selections.length < slotCount && fallback.length) {
          const next = fallback.shift();
          addSelection(next);
        }
      }
      const capturedCount = selections.filter(entry => entry && entry.isCaught).length;
      return { selections, coverage, slotCount, capturedCount, weights, ranchAssignments: activeRanchAssignments };
    }
    function scorePalForBase(pal, weights, coverage, config, defaultWeight) {
      if (!pal || !pal.work) return null;
      const contributions = [];
      let rawScore = 0;
      let score = 0;
      const coverageMap = coverage || {};
      const maxLevel = Math.max(1, MAX_WORK_LEVEL);
      const workEntries = Object.entries(pal.work || {});
      workEntries.forEach(([key, value]) => {
        const level = Number(value) || 0;
        if (!level) return;
        const canonical = canonicalWorkKey(key);
        if (!canonical) return;
        const weight = Object.prototype.hasOwnProperty.call(weights, canonical)
          ? weights[canonical]
          : defaultWeight;
        if (!weight) return;
        const normalizedLevel = level / maxLevel;
        const baseContribution = weight * normalizedLevel;
        rawScore += baseContribution;
        const existing = coverageMap[canonical] || 0;
        const coverageFactor = 1 / (1 + existing);
        const contributionScore = baseContribution * (1 + coverageFactor);
        score += contributionScore;
        contributions.push({ key: canonical, level, weight, baseContribution, contributionScore });
      });
      if (!contributions.length) return null;
      contributions.sort((a, b) => {
        if (b.contributionScore !== a.contributionScore) {
          return b.contributionScore - a.contributionScore;
        }
        return b.level - a.level;
      });
      const isCaught = !!caught[pal.id];
      if (isCaught) {
        score += 0.6;
      } else {
        score -= 0.15;
      }
      const preferred = config?.preferredRarity || 6;
      const rarity = pal?.rarity || 0;
      if (rarity && rarity > preferred) {
        const penalty = (rarity - preferred) * 0.35;
        score -= penalty;
        rawScore -= penalty * 0.6;
      }
      score += contributions.length * 0.05;
      return { score, rawScore, contributions, isCaught };
    }
    function openPalworldEmbed({ heading, url, fallbackUrl, note, summaryHtml }) {
      modalBody.innerHTML = '';
      const wrap = document.createElement('div');
      wrap.className = 'external-embed';
      const actions = document.createElement('div');
      actions.className = 'embed-actions';
      const titleEl = document.createElement('h3');
      titleEl.textContent = heading;
      actions.appendChild(titleEl);
      if (url) {
        const link = document.createElement('a');
        link.href = url;
        link.target = '_blank';
        link.rel = 'noopener';
        link.className = 'embed-link';
        link.textContent = 'Open in new tab';
        actions.appendChild(link);
      }
      wrap.appendChild(actions);
      const noteEl = document.createElement('p');
      noteEl.className = 'embed-note';
      noteEl.textContent = note || 'This view pulls live details from Palworld.gg while keeping your progress tracker close at hand.';
      wrap.appendChild(noteEl);
      if (summaryHtml) {
        const summary = document.createElement('div');
        summary.className = 'embed-summary';
        summary.innerHTML = summaryHtml;
        wrap.appendChild(summary);
      }
      if (url) {
        const frame = document.createElement('iframe');
        frame.src = url;
        frame.title = heading;
        frame.loading = 'lazy';
        frame.referrerPolicy = 'no-referrer-when-downgrade';
        frame.className = 'embed-frame';
        wrap.appendChild(frame);
      }
      const fallback = document.createElement('p');
      fallback.className = 'embed-fallback';
      const fallbackLink = document.createElement('a');
      fallbackLink.href = fallbackUrl || url || PALWORLD_BASE_URL;
      fallbackLink.target = '_blank';
      fallbackLink.rel = 'noopener';
      fallbackLink.textContent = 'Open on Palworld.gg';
      fallback.appendChild(document.createTextNode('If the page does not load, '));
      fallback.appendChild(fallbackLink);
      fallback.appendChild(document.createTextNode('.'));
      wrap.appendChild(fallback);
      modalBody.appendChild(wrap);
      openModal();
      return wrap;
    }
    async function loadDatasetSequentially() {
      const isFileProtocol = window.location.protocol === 'file:';
      if (isFileProtocol) {
        const embeddedPayload = await loadEmbeddedDataset();
        if (embeddedPayload) {
          return { payload: embeddedPayload, source: 'embedded fallback dataset' };
        }
        console.warn('File protocol detected but embedded dataset fallback was unavailable. Continuing with fetch attempts.');
      }
      const loadErrors = [];
      for (const source of DATA_SOURCES) {
        try {
          const response = await fetch(source);
          if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
          }
          const payload = await response.json();
          if (!payload || typeof payload !== 'object') {
            throw new Error('Invalid JSON payload');
          }
          if (!payload.pals || !payload.items || !payload.tech) {
            console.warn(`Dataset ${source} missing required keys. Skipping.`);
            continue;
          }
          return { payload, source };
        } catch (err) {
          loadErrors.push({ source, error: err });
          console.warn(`Failed to load dataset ${source}`, err);
        }
      }
      const embeddedFallback = await loadEmbeddedDataset();
      if (embeddedFallback) {
        return { payload: embeddedFallback, source: 'embedded fallback dataset' };
      }
      const errorSummary = loadErrors.length
        ? loadErrors.map(entry => {
            const reason = entry.error && entry.error.message ? entry.error.message : entry.error;
            return `${entry.source} (${reason})`;
          }).join('; ')
        : '';
      const summarySuffix = errorSummary ? ` ${errorSummary}` : '';
      throw new Error(`Unable to load any dataset from the data folder.${summarySuffix}`);
    }

    (async function initialisePalmate() {
      try {
        const { payload, source } = await loadDatasetSequentially();
        console.info(`Palmate data source: ${source}`);
        // Data is namespaced under pals, items and tech plus extra sections
        PALS = payload.pals || {};
        ITEMS = payload.items || {};
        TECH = payload.tech || [];
        rebuildTechLookup();
        SKILL_DETAILS = payload.skillsDetails || {};
        PASSIVE_DETAILS = payload.passiveDetails || {};
        ITEM_DETAILS = await loadItemDetails();
        applyRanchProducerOverrides();
        rebuildItemLookup();
        PARTNER_SKILLS = await loadPartnerSkillDataset();
        // Build name‑to‑ID lookup map
        PAL_NAME_TO_ID = {};
        PAL_SLUG_TO_ID = {};
        Object.values(PALS).forEach(p => {
          PAL_NAME_TO_ID[p.name] = p.id;
          const slug = slugifyForPalworld(p.name);
          if(slug) PAL_SLUG_TO_ID[slug] = p.id;
        });
        // Build a global map of item drops for quick lookup
        DROPS_MAP = {};
        Object.values(PALS).forEach(pal => {
          (pal.drops || []).forEach(item => {
            if (!DROPS_MAP[item]) DROPS_MAP[item] = [];
            DROPS_MAP[item].push(pal.name);
          });
        });
        MAX_WORK_LEVEL = computeMaxWorkLevel();
        // Build pages
        buildPalPage();
        buildItemPage();
        buildTechPage();
        buildBasePage();
        buildBreedingPage();
        buildHomePage();
        renderRouteGuide();
        // Synchronise skills and traits dictionaries with the loaded data.
        // Override the static dictionaries with entries from the JSON file.
        skillsDictionary = { ...defaultSkillsDictionary };
        if (SKILL_DETAILS && Object.keys(SKILL_DETAILS).length) {
          const normalizedSkills = {};
          Object.entries(SKILL_DETAILS).forEach(([key, info = {}]) => {
            const normalizedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
            normalizedSkills[normalizedKey] = {
              name: (info.name || key).replace(/_/g, ' '),
              damage: info.power ? `Power ${info.power}` : (info.damage || 'Unknown'),
              type: info.element || info.type || 'Unknown',
              description: info.description || 'No description available.'
            };
          });
          skillsDictionary = { ...defaultSkillsDictionary, ...normalizedSkills };
        }
        traitsDictionary = { ...defaultTraitsDictionary };
        if (PASSIVE_DETAILS && Object.keys(PASSIVE_DETAILS).length) {
          traitsDictionary = { ...defaultTraitsDictionary, ...PASSIVE_DETAILS };
        }
        buildGlossaryPage();
        buildMapPage();
        buildProgressPage();
        updateProgressUI();
      } catch (err) {
        console.error(err);
        const reason = err && err.message ? ` (${err.message})` : '';
        const extraHelp = window.location.protocol === 'file:'
          ? ' Launching a local web server or regenerating data/palworld_complete_data_fallback.js usually resolves file:// restrictions.'
          : ' Please confirm that the data folder is deployed with the site.';
        document.body.insertAdjacentHTML('beforeend', `<p style="color:red">Failed to load data${reason}.${extraHelp}</p>`);
      }
    })();
    // Build pal page
    function buildPalPage() {
      const list = document.getElementById('palsList');
      const search = document.getElementById('palSearch');
      const filtersContainer = document.getElementById('palFilters');
      const statusGroup = filtersContainer ? filtersContainer.querySelector('[data-filter-group="status"]') : null;
      const workGroup = filtersContainer ? filtersContainer.querySelector('[data-filter-group="work"]') : null;
      const summaryEl = document.getElementById('palFilterSummary');
      const resetBtn = document.getElementById('palFilterReset');
      if (!list || !search) return;
      const filterState = {
        search: '',
        status: 'all',
        work: new Set()
      };
      const statusOptions = [
        { key: 'all', kid: 'All pals', grown: 'All pals' },
        { key: 'caught', kid: 'Caught pals', grown: 'Caught pals' },
        { key: 'missing', kid: 'Need to catch', grown: 'Missing pals' }
      ];
      const workRoleStats = (() => {
        const stats = {};
        Object.values(PALS || {}).forEach(pal => {
          Object.entries(pal.work || {}).forEach(([role, level]) => {
            if (level) {
              stats[role] = (stats[role] || 0) + 1;
            }
          });
        });
        return stats;
      })();
      if (filtersContainer) {
        const statusLabel = document.getElementById('palFilterStatusLabel');
        const workLabel = document.getElementById('palFilterWorkLabel');
        if (statusLabel) {
          statusLabel.textContent = kidMode ? 'Crew status' : 'Collection status';
        }
        if (workLabel) {
          workLabel.textContent = kidMode ? 'Work helpers' : 'Work roles';
        }
        if (resetBtn) {
          resetBtn.textContent = kidMode ? 'Clear filters' : 'Reset filters';
        }
      }
      if (statusGroup) {
        statusGroup.innerHTML = '';
        statusOptions.forEach(option => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'chip pal-filter-chip';
          btn.dataset.status = option.key;
          btn.setAttribute('aria-pressed', 'false');
          statusGroup.appendChild(btn);
        });
        statusGroup.addEventListener('click', event => {
          const btn = event.target.closest('button[data-status]');
          if (!btn) return;
          const key = btn.dataset.status;
          if (!key) return;
          if (filterState.status === key && key !== 'all') {
            filterState.status = 'all';
          } else {
            filterState.status = key;
          }
          render();
        });
      }
      if (workGroup) {
        workGroup.innerHTML = '';
        Object.keys(workRoleStats)
          .sort((a, b) => getWorkRoleLabel(a).localeCompare(getWorkRoleLabel(b), undefined, { sensitivity: 'base' }))
          .forEach(role => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'chip pal-filter-chip';
            btn.dataset.role = role;
            btn.setAttribute('aria-pressed', 'false');
            workGroup.appendChild(btn);
          });
        workGroup.addEventListener('click', event => {
          const btn = event.target.closest('button[data-role]');
          if (!btn) return;
          const role = btn.dataset.role;
          if (!role) return;
          if (filterState.work.has(role)) {
            filterState.work.delete(role);
          } else {
            filterState.work.add(role);
          }
          render();
        });
      }
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          filterState.status = 'all';
          filterState.work.clear();
          filterState.search = '';
          search.value = '';
          render();
          if (typeof search.focus === 'function') {
            try {
              search.focus({ preventScroll: true });
            } catch (err) {
              search.focus();
            }
          }
        });
      }
      function statusLabel(key) {
        const entry = statusOptions.find(option => option.key === key);
        if (!entry) return kidMode ? 'All pals' : 'All pals';
        return kidMode ? entry.kid : entry.grown;
      }
      function buildSearchHaystack(pal) {
        const parts = [pal.name];
        if (Array.isArray(pal.types)) parts.push(...pal.types);
        if (Array.isArray(pal.drops)) parts.push(...pal.drops);
        if (Array.isArray(pal.passives)) parts.push(...pal.passives);
        if (Array.isArray(pal.spawnAreas)) parts.push(...pal.spawnAreas);
        Object.entries(pal.work || {}).forEach(([role, level]) => {
          if (level) {
            parts.push(role);
            parts.push(getWorkRoleLabel(role));
          }
        });
        return parts.join(' ').toLowerCase();
      }
      function createWorkBadges(pal) {
        const entries = Object.entries(pal.work || {})
          .filter(([, level]) => level)
          .sort((a, b) => (b[1] || 0) - (a[1] || 0))
          .slice(0, 3);
        if (!entries.length) return '';
        return entries.map(([role, level]) => {
          const label = getWorkRoleLabel(role);
          const highlight = filterState.work.size && filterState.work.has(role) ? ' pal-work-badge--active' : '';
          return `<span class='pal-work-badge${highlight}' data-role='${escapeHTML(role)}'><span class='pal-work-badge__label'>${escapeHTML(label)}</span><span class='pal-work-badge__level'>Lv ${escapeHTML(String(level))}</span></span>`;
        }).join('');
      }
      function updateStatusChips(totals) {
        if (!statusGroup) return;
        statusGroup.querySelectorAll('button[data-status]').forEach(btn => {
          const key = btn.dataset.status;
          const label = statusLabel(key);
          const count = key === 'all'
            ? totals.total
            : key === 'caught'
              ? totals.caught
              : totals.missing;
          btn.innerHTML = `<span class="pal-filter-chip__label">${escapeHTML(label)}</span><span class="pal-filter-chip__count">${count}</span>`;
          const active = filterState.status === key;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
          btn.classList.toggle('pal-filter-chip--active', active);
          btn.setAttribute('aria-label', `${label}: ${count} pals`);
        });
      }
      function updateWorkChips() {
        if (!workGroup) return;
        workGroup.querySelectorAll('button[data-role]').forEach(btn => {
          const role = btn.dataset.role;
          const label = getWorkRoleLabel(role);
          const count = workRoleStats[role] || 0;
          const active = filterState.work.has(role);
          btn.innerHTML = `<span class="pal-filter-chip__label">${escapeHTML(label)}</span><span class="pal-filter-chip__count">${count}</span>`;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
          btn.classList.toggle('pal-filter-chip--active', active);
          btn.setAttribute('aria-label', `${label}: ${count} pals`);
        });
      }
      function render() {
        const palsArray = Object.values(PALS || {});
        const totals = {
          total: palsArray.length,
          caught: palsArray.filter(p => caught[p.id]).length
        };
        totals.missing = totals.total - totals.caught;
        updateStatusChips(totals);
        updateWorkChips();
        const normalizedSearch = filterState.search.trim().toLowerCase();
        const results = palsArray
          .slice()
          .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }))
          .filter(pal => {
            if (filterState.status === 'caught' && !caught[pal.id]) return false;
            if (filterState.status === 'missing' && caught[pal.id]) return false;
            if (filterState.work.size) {
              const palWork = pal.work || {};
              let matchesWork = false;
              for (const role of filterState.work) {
                if (palWork[role]) {
                  matchesWork = true;
                  break;
                }
              }
              if (!matchesWork) return false;
            }
            if (normalizedSearch) {
              const haystack = buildSearchHaystack(pal);
              if (!haystack.includes(normalizedSearch)) return false;
            }
            return true;
          });
        list.innerHTML = '';
        if (summaryEl) {
          const count = results.length;
          if (!totals.total) {
            summaryEl.textContent = kidMode ? 'Pal data loading…' : 'Pal data loading…';
          } else if (count === totals.total && !normalizedSearch && filterState.status === 'all' && !filterState.work.size) {
            summaryEl.textContent = kidMode
              ? `Showing all ${count} pals.`
              : `Showing all ${count} pals.`;
          } else {
            summaryEl.textContent = kidMode
              ? `Showing ${count} pal${count === 1 ? '' : 's'}.`
              : `Showing ${count} of ${totals.total} pals.`;
          }
        }
        if (!results.length) {
          const empty = document.createElement('p');
          empty.className = 'empty-state pal-list-empty';
          empty.textContent = kidMode
            ? 'No pals match those filters yet.'
            : 'No pals match your filters yet.';
          list.appendChild(empty);
          return;
        }
        const fragment = document.createDocumentFragment();
        results.forEach(pal => {
          const card = document.createElement('div');
          card.className = 'pal-card';
          const types = Array.isArray(pal.types) ? pal.types : [];
          const typeIcons = types.map(t => {
            const safe = escapeHTML(t);
            const icon = iconMap[t] || iconMap['Neutral'];
            return `<img src='${icon}' alt='${safe} icon' style='width:20px;height:20px;margin-right:2px;'>`;
          }).join('');
          const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
          let rarityLabel = rarityNames[rarity] || '';
          let starIcons = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          if (kidMode) {
            rarityLabel = '';
            starIcons = '';
          }
          const workBadges = createWorkBadges(pal);
          card.innerHTML = `
            <img alt="">
            <div class="name">${escapeHTML(pal.name)}</div>
            <div class="badge">${typeIcons}</div>
            ${workBadges ? `<div class="work">${workBadges}</div>` : ''}
            <div class="rarity"><span class="stars">${starIcons}</span> <span class="label">${escapeHTML(rarityLabel)}</span></div>
            <button class="catch-btn ${caught[pal.id] ? 'caught' : ''}">${caught[pal.id] ? 'Caught' : 'Catch'}</button>
          `;
          const portrait = card.querySelector('img');
          applyPalArtwork(portrait, pal, { alt: `${pal.name} portrait` });
          card.dataset.palId = pal.id;
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            showPalDetail(pal.id);
          });
          const btn = card.querySelector('button');
          btn.dataset.palId = pal.id;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            setPalCaught(pal.id);
          });
          fragment.appendChild(card);
        });
        list.appendChild(fragment);
      }
      filterState.search = search.value || '';
      search.addEventListener('input', () => {
        filterState.search = search.value;
        render();
      });
      render();
      refreshPalList = render;
    }
    function syncPalButtons(palId) {
      if (palId === undefined || palId === null) return;
      document.querySelectorAll(`.catch-btn[data-pal-id="${palId}"]`).forEach(btn => {
        const state = !!caught[palId];
        btn.classList.toggle('caught', state);
        btn.textContent = state ? 'Caught' : 'Catch';
      });
    }
    function setPalCaught(palId, value, { silent = false, skipAutoComplete = false, deferProgressUpdate = false } = {}) {
      if (palId === undefined || palId === null) return null;
      const current = !!caught[palId];
      const desired = value == null ? !current : !!value;
      if (current === desired) {
        syncPalButtons(palId);
        if (deferProgressUpdate) {
          requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
        }
        return desired;
      }
      caught[palId] = desired;
      try {
        localStorage.setItem('caught', JSON.stringify(caught));
      } catch (err) {
        console.warn('Failed to save caught pals', err);
      }
      syncPalButtons(palId);
      if (!skipAutoComplete) {
        autoCompleteRouteStepsForPal(palId);
      }
      requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
      if (!deferProgressUpdate) {
        updateProgressUI();
      }
      if (typeof refreshPalList === 'function') {
        refreshPalList();
      }
      if (!silent) {
        playSound(clickSound);
      }
      return desired;
    }
    function syncTechButtons(techKey, techName) {
      if (!techKey) return;
      document.querySelectorAll(`.unlock-btn[data-tech-key="${techKey}"]`).forEach(btn => {
        const lookupName = btn.dataset.techName || techName;
        const state = lookupName ? !!unlocked[lookupName] : false;
        btn.classList.toggle('unlocked', state);
        btn.textContent = state ? 'Unlocked' : 'Unlock';
        btn.setAttribute('aria-pressed', state ? 'true' : 'false');
        const card = btn.closest('.tech-card');
        if (card) {
          card.classList.toggle('tech-card--unlocked', state);
          const status = card.querySelector('[data-tech-status]');
          if (status) {
            status.textContent = formatTechStatusText(state);
            status.classList.toggle('tech-card__status--unlocked', state);
          }
        }
        const modal = btn.closest('.tech-modal');
        if (modal) {
          const status = modal.querySelector('[data-tech-status]');
          if (status) {
            status.textContent = formatTechStatusText(state);
            status.classList.toggle('tech-modal__status--unlocked', state);
          }
        }
      });
    }
    function setTechUnlocked(techName, value, { techKey, silent = false, skipAutoComplete = false, deferProgressUpdate = false } = {}) {
      if (!techName) return null;
      const current = !!unlocked[techName];
      const desired = value == null ? !current : !!value;
      if (current === desired) {
        if (techKey) syncTechButtons(techKey, techName);
        if (deferProgressUpdate) {
          requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
        }
        return desired;
      }
      unlocked[techName] = desired;
      try {
        localStorage.setItem('unlocked', JSON.stringify(unlocked));
      } catch (err) {
        console.warn('Failed to save unlocked tech', err);
      }
      if (techKey) syncTechButtons(techKey, techName);
      if (!skipAutoComplete) {
        autoCompleteRouteStepsForTech(techKey, techName);
      }
      requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
      if (!deferProgressUpdate) {
        updateProgressUI();
      }
      if (!silent) {
        playSound(clickSound);
      }
      return desired;
    }
    function updateItemCollectionButtons(itemKey) {
      document.querySelectorAll(`.item-card button.collect-btn[data-item-key="${itemKey}"]`).forEach(btn => {
        const state = !!collected[itemKey];
        btn.classList.toggle('collected', state);
        btn.textContent = state ? 'Collected' : 'Collect';
      });
    }
    // Show pal details in a modal by embedding the Palworld.gg page
    // alongside quick progress hints and a shortcut back to the map.
    function showPalDetail(id) {
      const pal = PALS[id];
      if (!pal) return;
      const slug = PALWORLD_PAL_SLUG_OVERRIDES[pal.name] || slugifyForPalworld(pal.name);
      const palUrl = slug ? `${PALWORLD_BASE_URL}/pal/${slug}` : `${PALWORLD_BASE_URL}/pals`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/pals?search=${encodeURIComponent(pal.name)}`;
      const habitats = pal.spawnAreas && pal.spawnAreas.length
        ? pal.spawnAreas.join(', ')
        : (environmentMap[pal.types && pal.types[0]] || 'Unknown');
      const sphere = raritySphere[pal.rarity] || 'Pal Sphere';
      const sphereInfo = sphereRates[sphere];
      const caughtStatus = caught[pal.id];
      const summaryLines = [];
      if (kidMode) {
        summaryLines.push(`<strong>Status:</strong> ${caughtStatus ? 'We caught this pal!' : 'Still looking for this pal.'}`);
        if (habitats && habitats !== 'Unknown') {
          summaryLines.push(`<strong>Where it lives:</strong> ${habitats}`);
        }
        summaryLines.push(`<strong>Catch tip:</strong> Try a ${sphere}.`);
      } else {
        summaryLines.push(`<strong>Tracking:</strong> ${caughtStatus ? 'Caught' : 'Not caught yet'}`);
        if (habitats) {
          summaryLines.push(`<strong>Habitats:</strong> ${habitats}`);
        }
        if (sphereInfo) {
          summaryLines.push(`<strong>Suggested Sphere:</strong> ${sphere} (${Math.round(sphereInfo.rate * 100)}% base) – ${sphereInfo.description}`);
        }
      }
      summaryLines.push(`<button type="button" class="open-map-button modal-action-btn">Open Map</button>`);
      const summaryHtml = summaryLines.map(line => `<p>${line}</p>`).join('');
      const note = kidMode
        ? 'We show the Palworld.gg page here so you can read about this pal without leaving your guide.'
        : 'Palworld.gg has the most complete breakdowns. Enjoy them in-place while Palmate keeps tracking your progress.';
      const wrap = openPalworldEmbed({
        heading: `${pal.name} – Palworld.gg`,
        url: palUrl,
        fallbackUrl,
        note,
        summaryHtml
      });
      const mapButton = wrap.querySelector('.open-map-button');
      if (mapButton) {
        mapButton.addEventListener('click', (event) => {
          event.preventDefault();
          closeModal();
          switchPage('map');
        });
      }
    }
    window.viewPal = function(identifier){
      if(identifier === undefined || identifier === null) return;
      if(typeof identifier === 'number'){
        showPalDetail(identifier);
        return;
      }
      const normalized = String(identifier).toLowerCase();
      const slugId = PAL_SLUG_TO_ID[normalized];
      if(slugId){
        showPalDetail(slugId);
        return;
      }
      const byName = PAL_NAME_TO_ID[capitalize(normalized)];
      if(byName){
        showPalDetail(byName);
        return;
      }
      focusSearch(identifier, { target: 'pals' });
    };
    // Build items page
    function buildItemPage() {
      const list = document.getElementById('itemsList');
      const search = document.getElementById('itemSearch');
      // Compute which pals drop each item
      const dropsMap = {};
      Object.values(PALS).forEach(pal => {
        (pal.drops || []).forEach(item => {
          if (!dropsMap[item]) dropsMap[item] = [];
          dropsMap[item].push(pal.name);
        });
      });
      const allItemKeys = Array.from(new Set([
        ...Object.keys(ITEMS || {}),
        ...Object.keys(ITEM_DETAILS || {})
      ])).sort((a, b) => niceName(a).localeCompare(niceName(b)));
      function render(filter = '') {
        list.innerHTML = '';
        const term = filter.trim().toLowerCase();
        allItemKeys.forEach(itemKey => {
          const detail = ITEM_DETAILS[itemKey] || {};
          const baseInfo = ITEMS[itemKey] || {};
          const displayName = detail.name || niceName(itemKey);
          const ranchProducers = Array.isArray(detail.ranchProducers)
            ? detail.ranchProducers
            : (Array.isArray(baseInfo.ranchProducers) ? baseInfo.ranchProducers : []);
          const searchable = [
            itemKey,
            displayName,
            detail.type,
            baseInfo.category,
            ...(ranchProducers || [])
          ].filter(Boolean).join(' ').toLowerCase();
          if (term && !searchable.includes(term)) return;

          const card = document.createElement('div');
          card.className = 'item-card';
          card.dataset.itemKey = itemKey;

          const art = document.createElement('div');
          art.className = 'item-card-art';
          const usePlaceholder = () => {
            if (!art.querySelector('.item-card-placeholder')) {
              const placeholder = document.createElement('div');
              placeholder.className = 'item-card-placeholder';
              placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
              art.appendChild(placeholder);
            }
          };
          const imageUrl = detail.image || baseInfo.image || null;
          if (imageUrl) {
            const img = document.createElement('img');
            img.loading = 'lazy';
            img.decoding = 'async';
            img.alt = `${displayName} icon`;
            img.referrerPolicy = 'no-referrer';
            img.src = imageUrl;
            img.onerror = () => {
              img.remove();
              usePlaceholder();
            };
            art.appendChild(img);
          }
          if (!art.hasChildNodes()) {
            usePlaceholder();
          }
          card.appendChild(art);

          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = displayName;
          card.appendChild(nameEl);

          const category = detail.type || baseInfo.category || 'Misc';
          const categoryEl = document.createElement('div');
          categoryEl.className = 'category';
          categoryEl.textContent = category;
          card.appendChild(categoryEl);

          const dropNames = dropsMap[itemKey] || [];
          const dropsEl = document.createElement('div');
          dropsEl.className = 'drops';
          dropsEl.textContent = `Dropped by: ${dropNames.length ? dropNames.join(', ') : 'None recorded'}`;
          card.appendChild(dropsEl);

          const ranchEl = document.createElement('div');
          ranchEl.className = 'ranch';
          if (ranchProducers.length) {
            ranchEl.textContent = `Ranch pals: ${ranchProducers.join(', ')}`;
          } else {
            ranchEl.textContent = 'Ranch pals: None recorded';
            ranchEl.classList.add('ranch--empty');
          }
          card.appendChild(ranchEl);

          const btn = document.createElement('button');
          btn.className = `collect-btn ${collected[itemKey] ? 'collected' : ''}`;
          btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
          btn.dataset.itemKey = itemKey;
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            collected[itemKey] = !collected[itemKey];
            localStorage.setItem('collected', JSON.stringify(collected));
            btn.classList.toggle('collected', collected[itemKey]);
            btn.textContent = collected[itemKey] ? 'Collected' : 'Collect';
            requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
            updateProgressUI();
          });
          card.appendChild(btn);

          // Clicking the card opens the item details modal.  Exclude button clicks.
          card.addEventListener('click', (e) => {
            if (e.target.tagName.toLowerCase() === 'button') return;
            openItemDetail(itemKey);
          });
          list.appendChild(card);
        });
      }
      search.addEventListener('input', () => render(search.value));
      render();
    }
    function getTechBranchLabel(item) {
      if (!item) return 'Technology';
      if (item.isAncient) return 'Ancient Technology';
      return item.branch || 'Technology';
    }
    function normaliseTechMaterialQuantity(value) {
      if (typeof value === 'number') return Number.isFinite(value) && value >= 0 ? value : null;
      if (value === null || value === undefined) return null;
      const parsed = Number(value);
      return Number.isFinite(parsed) && parsed >= 0 ? parsed : null;
    }
    function resolveMaterialDetail(name) {
      if (!name) return { key: null, detail: null };
      if (!ITEM_DETAILS || typeof ITEM_DETAILS !== 'object') {
        return { key: null, detail: null };
      }
      const key = lookupItemKey(name);
      if (key && ITEM_DETAILS[key]) {
        return { key, detail: ITEM_DETAILS[key] };
      }
      return { key: null, detail: null };
    }
    function deriveMaterialIcon(entry, detail) {
      if (entry.icon && typeof entry.icon === 'string' && entry.icon.trim()) {
        return entry.icon.trim();
      }
      if (detail?.icon && typeof detail.icon === 'string' && detail.icon.trim()) {
        return detail.icon.trim();
      }
      if (detail?.image && typeof detail.image === 'string' && detail.image.trim()) {
        return detail.image.trim();
      }
      if (Array.isArray(detail?.icons)) {
        const icon = detail.icons.find(src => typeof src === 'string' && src.trim());
        if (icon) return icon.trim();
      }
      if (Array.isArray(detail?.images)) {
        const img = detail.images.find(src => typeof src === 'string' && src.trim());
        if (img) return img.trim();
      }
      return null;
    }
    function enrichTechMaterial(entry) {
      if (!entry || !entry.name) return null;
      const { key, detail } = resolveMaterialDetail(entry.name);
      const displayName = detail?.name || entry.name;
      const slug = key || detail?.slug || slugifyForPalworld(displayName) || slugifyForPalworld(entry.name);
      const quantity = normaliseTechMaterialQuantity(entry.quantity);
      const icon = deriveMaterialIcon(entry, detail);
      return {
        name: displayName,
        quantity,
        icon,
        slug: slug || null,
        key: key || null,
        originalName: entry.name
      };
    }
    function computeTechMaterials(item) {
      if (!item) return [];
      const directMaterials = item.materials && typeof item.materials === 'object' && item.materials !== null
        ? Object.entries(item.materials)
            .map(([name, qty]) => {
              const label = name ? String(name).trim() : '';
              if (!label) return null;
              return {
                name: label,
                quantity: normaliseTechMaterialQuantity(qty)
              };
            })
            .filter(Boolean)
        : [];
      if (directMaterials.length) {
        return directMaterials.map(enrichTechMaterial).filter(Boolean);
      }
      const detailKey = resolveItemKeyFromLink({ id: item.id, slug: item.id, name: item.name });
      const detail = detailKey && ITEM_DETAILS ? ITEM_DETAILS[detailKey] : null;
      if (!detail || !Array.isArray(detail.recipe)) {
        return [];
      }
      const recipeEntries = detail.recipe
        .map(ingredient => {
          if (!ingredient || typeof ingredient !== 'object') return null;
          const name = typeof ingredient.name === 'string' ? ingredient.name.trim() : '';
          if (!name) return null;
          const quantity = normaliseTechMaterialQuantity(ingredient.quantity);
          const icon = typeof ingredient.icon === 'string' && ingredient.icon.trim() ? ingredient.icon.trim() : null;
          return { name, quantity, icon };
        })
        .filter(Boolean);
      return recipeEntries.map(enrichTechMaterial).filter(Boolean);
    }
    function isGenericTechDescription(text) {
      if (typeof text !== 'string') return true;
      const normalised = text.trim().toLowerCase();
      if (!normalised) return true;
      return normalised.startsWith('unlocks the')
        || normalised.startsWith('unlock the')
        || normalised.startsWith('unlocks ')
        || normalised.startsWith('unlock ');
    }
    function buildDefaultTechDescription(item, { kid = false } = {}) {
      const name = item?.name || 'this unlock';
      const group = String(item?.group || '').toLowerCase();
      const category = String(item?.category || '').toLowerCase();
      const ancient = !!item?.isAncient;
      if (category.includes('base') || group.includes('structure') || group.includes('building')) {
        return kid ? `Adds the ${name} building to your base.` : `Adds the ${name} structure to your base build menu.`;
      }
      if (category.includes('weapon')) {
        return kid ? `Lets you craft the ${name} weapon.` : `Unlocks crafting for the ${name} weapon.`;
      }
      if (category.includes('armor') || category.includes('gear') || group.includes('armor')) {
        return kid ? `Lets you make the ${name} gear to wear.` : `Unlocks the ${name} gear recipe.`;
      }
      if (category.includes('vehicle') || group.includes('mount')) {
        return kid ? `Lets you ride with the ${name}.` : `Unlocks the ${name} mount blueprint.`;
      }
      if (ancient) {
        return kid ? `Restores the ancient ${name} so you can use it again.` : `Restores the ancient ${name} blueprint.`;
      }
      return kid ? `Lets you make ${name}.` : `Unlocks crafting for ${name}.`;
    }
    function computeTechDescriptions(item) {
      const raw = typeof item?.description === 'string' ? item.description.trim() : '';
      const grown = raw && !isGenericTechDescription(raw)
        ? raw
        : buildDefaultTechDescription(item, { kid: false });
      const kidCopy = raw && !isGenericTechDescription(raw)
        ? raw.replace(/\bUnlocks\b/gi, 'Lets')
        : buildDefaultTechDescription(item, { kid: true });
      return {
        grown,
        kid: kidCopy || grown
      };
    }
    function createTechMaterialChip(material) {
      if (!material || !material.name) return null;
      const displayName = material.name;
      const slug = material.slug || material.key || slugifyForPalworld(displayName);
      const payload = {
        type: 'item',
        id: material.key || slug || displayName,
        slug: slug || undefined,
        name: displayName
      };
      const quantity = typeof material.quantity === 'number' && Number.isFinite(material.quantity)
        ? material.quantity
        : null;
      const quantityLabel = quantity !== null ? `×${quantity}` : '×?';
      const ariaQuantity = quantity !== null ? `quantity ${quantity}` : 'quantity unknown';
      const link = document.createElement('a');
      link.href = '#';
      link.className = 'chip link tech-material-chip link--with-thumb';
      link.dataset.linkType = 'item';
      link.dataset.link = JSON.stringify(payload);
      link.setAttribute('role', 'button');
      link.setAttribute('aria-label', `${displayName}, ${ariaQuantity}`);
      const thumb = document.createElement('span');
      thumb.className = 'chip__thumb';
      const iconSrc = material.icon && typeof material.icon === 'string' ? material.icon.trim() : '';
      if (iconSrc) {
        const img = document.createElement('img');
        img.src = iconSrc;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = '';
        img.referrerPolicy = 'no-referrer';
        img.onerror = () => {
          img.remove();
          thumb.classList.add('tech-material-chip__thumb--placeholder');
          thumb.textContent = '⚙️';
        };
        thumb.appendChild(img);
      } else {
        thumb.classList.add('tech-material-chip__thumb--placeholder');
        thumb.textContent = '⚙️';
      }
      link.appendChild(thumb);
      const body = document.createElement('span');
      body.className = 'chip__body';
      const label = document.createElement('span');
      label.className = 'chip__label';
      label.textContent = displayName;
      body.appendChild(label);
      const qty = document.createElement('span');
      qty.className = 'chip__meta';
      qty.textContent = quantityLabel;
      body.appendChild(qty);
      link.appendChild(body);
      link.addEventListener('click', event => {
        event.preventDefault();
        event.stopPropagation();
        navigateLink(payload);
      });
      return link;
    }
    function formatTechCost(item, { kid = false, short = false } = {}) {
      if (!item || typeof item.techPoints !== 'number') {
        return kid ? 'Cost unknown' : 'Cost unknown';
      }
      const points = item.techPoints;
      if (points === 0) {
        return kid ? 'Free unlock' : 'Free unlock';
      }
      const isAncient = !!item.isAncient;
      if (short) {
        return `${points} ${isAncient ? 'AP' : 'TP'}`;
      }
      return `${points} ${isAncient ? 'Ancient Points' : 'Tech Points'}`;
    }
    function formatTechStatusText(isUnlocked) {
      return isUnlocked
        ? (kidMode ? 'Already built!' : 'Unlocked')
        : (kidMode ? 'Still locked' : 'Locked');
    }
    // Build technology tree page
    function buildTechPage() {
      const list = document.getElementById('techList');
      if (!list) return;
      list.innerHTML = '';
      const rawLevels = Array.isArray(TECH) ? TECH.filter(Boolean) : [];
      if (!rawLevels.length) {
        const empty = document.createElement('p');
        empty.className = 'tech-results__empty';
        empty.textContent = kidMode
          ? 'Technology data is still loading. Check back soon!'
          : 'Technology data is still loading.';
        list.appendChild(empty);
        return;
      }
      const categoryMap = new Map();
      const branchCounts = { all: 0, technology: 0, ancient: 0 };
      function registerCategory(label) {
        if (!label) return null;
        const slug = slugifyForPalworld(String(label));
        if (!slug) return null;
        const existing = categoryMap.get(slug);
        if (existing) {
          existing.count += 1;
        } else {
          categoryMap.set(slug, { slug, label: String(label), count: 1 });
        }
        return slug;
      }
      const levelEntries = rawLevels.map(level => {
        const levelNumber = typeof level?.level === 'number' ? level.level : null;
        const items = Array.isArray(level?.items) ? level.items.filter(item => item && item.name) : [];
        const entries = items.map(item => {
          const branch = item.isAncient ? 'ancient' : 'technology';
          branchCounts.all += 1;
          branchCounts[branch] = (branchCounts[branch] || 0) + 1;
          const categories = new Set();
          const primaryCategory = registerCategory(item.category);
          if (primaryCategory) categories.add(primaryCategory);
          if (item.group && item.group !== item.category) {
            const groupSlug = registerCategory(item.group);
            if (groupSlug) categories.add(groupSlug);
          }
          const materials = computeTechMaterials(item);
          const materialText = materials.map(entry => entry.name.toLowerCase()).join(' ');
          const searchBits = [
            item.name,
            item.description,
            item.category,
            item.group,
            materialText
          ].filter(Boolean);
          const searchText = searchBits.join(' ').toLowerCase();
          const slugBase = item.id || item.name;
          const slug = slugifyForPalworld(String(slugBase));
          const points = typeof item.techPoints === 'number' ? item.techPoints : null;
          return {
            level,
            levelNumber,
            item,
            slug: slug || slugifyForPalworld(item.name),
            branch,
            branchLabel: getTechBranchLabel(item),
            categories,
            materials,
            searchText,
            points
          };
        });
        return {
          level,
          levelNumber,
          entries
        };
      }).filter(entry => entry.levelNumber !== null || entry.entries.length);
      levelEntries.sort((a, b) => (a.levelNumber || 0) - (b.levelNumber || 0));
      if (!levelEntries.length) {
        const empty = document.createElement('p');
        empty.className = 'tech-results__empty';
        empty.textContent = kidMode
          ? 'Technology data is still loading. Check back soon!'
          : 'Technology data is still loading.';
        list.appendChild(empty);
        return;
      }
      const categories = Array.from(categoryMap.values()).sort((a, b) => a.label.localeCompare(b.label));
      const filterState = TECH_PAGE_STATE || (TECH_PAGE_STATE = {
        query: '',
        queryRaw: '',
        branch: 'all',
        category: 'all',
        status: 'all',
        sort: 'level-asc'
      });
      if (typeof filterState.queryRaw !== 'string') {
        filterState.queryRaw = filterState.query || '';
      }
      if (typeof filterState.query !== 'string') {
        filterState.query = filterState.queryRaw.toLowerCase();
      } else {
        filterState.query = filterState.query.toLowerCase();
      }
      if (!filterState.sort) {
        filterState.sort = 'level-asc';
      }
      const controls = document.createElement('section');
      controls.className = 'tech-controls';
      list.appendChild(controls);
      const topRow = document.createElement('div');
      topRow.className = 'tech-controls__row';
      controls.appendChild(topRow);
      const searchWrap = document.createElement('div');
      searchWrap.className = 'tech-search';
      const searchInput = document.createElement('input');
      searchInput.type = 'search';
      searchInput.placeholder = kidMode
        ? 'Search for blueprints or gadgets'
        : 'Search by name, category, or materials';
      searchInput.setAttribute('aria-label', kidMode ? 'Search technology unlocks' : 'Search technology');
      searchInput.value = filterState.queryRaw || '';
      searchWrap.appendChild(searchInput);
      const searchIcon = document.createElement('i');
      searchIcon.className = 'fa-solid fa-magnifying-glass';
      searchWrap.appendChild(searchIcon);
      topRow.appendChild(searchWrap);
      const branchWrap = document.createElement('div');
      branchWrap.className = 'tech-filter';
      const branchLabel = document.createElement('span');
      branchLabel.className = 'tech-filter__label';
      branchLabel.textContent = kidMode ? 'Show' : 'Branch';
      branchWrap.appendChild(branchLabel);
      const branchGroup = document.createElement('div');
      branchGroup.className = 'tech-pills';
      branchWrap.appendChild(branchGroup);
      const branchButtons = [];
      const branchOptions = [
        { key: 'all', label: kidMode ? 'All Tech' : 'All', count: branchCounts.all },
        { key: 'technology', label: kidMode ? 'Tech' : 'Technology', count: branchCounts.technology },
        { key: 'ancient', label: kidMode ? 'Ancient' : 'Ancient', count: branchCounts.ancient }
      ];
      branchOptions.forEach(option => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tech-pill';
        btn.dataset.value = option.key;
        btn.textContent = option.count ? `${option.label} (${option.count})` : option.label;
        if (filterState.branch === option.key) {
          btn.classList.add('active');
        }
        btn.addEventListener('click', () => {
          if (filterState.branch === option.key) return;
          filterState.branch = option.key;
          branchButtons.forEach(b => b.classList.toggle('active', b.dataset.value === filterState.branch));
          updateResetState();
          renderLevels();
        });
        branchButtons.push(btn);
        branchGroup.appendChild(btn);
      });
      topRow.appendChild(branchWrap);
      const summary = document.createElement('p');
      summary.className = 'tech-summary';
      controls.appendChild(summary);
      const filterRow = document.createElement('div');
      filterRow.className = 'tech-controls__row';
      controls.appendChild(filterRow);
      const categoryWrap = document.createElement('div');
      categoryWrap.className = 'tech-filter';
      const categoryLabel = document.createElement('span');
      categoryLabel.className = 'tech-filter__label';
      categoryLabel.textContent = kidMode ? 'Category' : 'Category';
      categoryWrap.appendChild(categoryLabel);
      const categorySelect = document.createElement('select');
      categorySelect.className = 'tech-select';
      const defaultCategory = document.createElement('option');
      defaultCategory.value = 'all';
      defaultCategory.textContent = kidMode ? 'All categories' : 'All categories';
      categorySelect.appendChild(defaultCategory);
      categories.forEach(cat => {
        const option = document.createElement('option');
        option.value = cat.slug;
        option.textContent = `${cat.label} (${cat.count})`;
        categorySelect.appendChild(option);
      });
      if (!categoryMap.has(filterState.category)) {
        filterState.category = 'all';
      }
      categorySelect.value = filterState.category || 'all';
      categorySelect.addEventListener('change', () => {
        filterState.category = categorySelect.value || 'all';
        updateResetState();
        renderLevels();
      });
      categoryWrap.appendChild(categorySelect);
      filterRow.appendChild(categoryWrap);
      const statusWrap = document.createElement('div');
      statusWrap.className = 'tech-filter';
      const statusLabel = document.createElement('span');
      statusLabel.className = 'tech-filter__label';
      statusLabel.textContent = kidMode ? 'Progress' : 'Status';
      statusWrap.appendChild(statusLabel);
      const statusGroup = document.createElement('div');
      statusGroup.className = 'tech-pills';
      statusWrap.appendChild(statusGroup);
      const statusButtons = [];
      const statusOptions = [
        { key: 'all', label: kidMode ? 'All' : 'All' },
        { key: 'locked', label: kidMode ? 'Locked' : 'Locked' },
        { key: 'unlocked', label: kidMode ? 'Unlocked' : 'Unlocked' }
      ];
      statusOptions.forEach(option => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'tech-pill';
        btn.dataset.value = option.key;
        btn.textContent = option.label;
        if (filterState.status === option.key) {
          btn.classList.add('active');
        }
        btn.addEventListener('click', () => {
          if (filterState.status === option.key) return;
          filterState.status = option.key;
          statusButtons.forEach(b => b.classList.toggle('active', b.dataset.value === filterState.status));
          updateResetState();
          renderLevels();
        });
        statusButtons.push(btn);
        statusGroup.appendChild(btn);
      });
      filterRow.appendChild(statusWrap);
      const sortWrap = document.createElement('div');
      sortWrap.className = 'tech-filter';
      const sortLabel = document.createElement('span');
      sortLabel.className = 'tech-filter__label';
      sortLabel.textContent = kidMode ? 'Sort by' : 'Sort by';
      sortWrap.appendChild(sortLabel);
      const sortSelect = document.createElement('select');
      sortSelect.className = 'tech-select';
      const sortOptions = kidMode
        ? [
            { value: 'level-asc', label: 'Lowest level first' },
            { value: 'level-desc', label: 'Highest level first' },
            { value: 'name-asc', label: 'Name A → Z' },
            { value: 'name-desc', label: 'Name Z → A' },
            { value: 'points-asc', label: 'Cheapest first' },
            { value: 'points-desc', label: 'Most expensive' }
          ]
        : [
            { value: 'level-asc', label: 'Tech level ↑' },
            { value: 'level-desc', label: 'Tech level ↓' },
            { value: 'name-asc', label: 'Name A → Z' },
            { value: 'name-desc', label: 'Name Z → A' },
            { value: 'points-asc', label: 'Cost low → high' },
            { value: 'points-desc', label: 'Cost high → low' }
          ];
      sortOptions.forEach(option => {
        const opt = document.createElement('option');
        opt.value = option.value;
        opt.textContent = option.label;
        sortSelect.appendChild(opt);
      });
      if (!sortOptions.some(option => option.value === filterState.sort)) {
        filterState.sort = 'level-asc';
      }
      sortSelect.value = filterState.sort;
      sortSelect.addEventListener('change', () => {
        filterState.sort = sortSelect.value || 'level-asc';
        updateResetState();
        renderLevels();
      });
      sortWrap.appendChild(sortSelect);
      filterRow.appendChild(sortWrap);
      const resetBtn = document.createElement('button');
      resetBtn.type = 'button';
      resetBtn.className = 'tech-reset-btn';
      resetBtn.textContent = kidMode ? 'Reset filters' : 'Reset filters';
      resetBtn.addEventListener('click', () => {
        filterState.query = '';
        filterState.queryRaw = '';
        filterState.branch = 'all';
        filterState.category = 'all';
        filterState.status = 'all';
        filterState.sort = 'level-asc';
        searchInput.value = '';
        branchButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.value === 'all'));
        statusButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.value === 'all'));
        categorySelect.value = 'all';
        sortSelect.value = 'level-asc';
        updateResetState();
        renderLevels();
      });
      filterRow.appendChild(resetBtn);
      const results = document.createElement('div');
      results.className = 'tech-results';
      list.appendChild(results);
      function hasActiveFilters() {
        return !!(filterState.query && filterState.query.length)
          || filterState.branch !== 'all'
          || filterState.category !== 'all'
          || filterState.status !== 'all';
      }
      function matchesFilter(entry) {
        if (!entry || !entry.item) return false;
        if (filterState.branch !== 'all' && entry.branch !== filterState.branch) return false;
        if (filterState.category !== 'all' && !entry.categories.has(filterState.category)) return false;
        const isUnlocked = !!unlocked[entry.item.name];
        if (filterState.status === 'locked' && isUnlocked) return false;
        if (filterState.status === 'unlocked' && !isUnlocked) return false;
        if (filterState.query) {
          if (!entry.searchText.includes(filterState.query)) return false;
        }
        return true;
      }
      function sortEntries(entries) {
        const sortMode = filterState.sort || 'level-asc';
        if (sortMode === 'name-asc' || sortMode === 'name-desc') {
          return entries.slice().sort((a, b) => {
            const nameA = a.item.name || '';
            const nameB = b.item.name || '';
            return sortMode === 'name-asc' ? nameA.localeCompare(nameB) : nameB.localeCompare(nameA);
          });
        }
        if (sortMode === 'points-asc' || sortMode === 'points-desc') {
          return entries.slice().sort((a, b) => {
            const aVal = typeof a.points === 'number' ? a.points : (sortMode === 'points-desc' ? -Infinity : Infinity);
            const bVal = typeof b.points === 'number' ? b.points : (sortMode === 'points-desc' ? -Infinity : Infinity);
            if (aVal === bVal) {
              return (a.item.name || '').localeCompare(b.item.name || '');
            }
            return sortMode === 'points-asc' ? aVal - bVal : bVal - aVal;
          });
        }
        return entries.slice();
      }
      function createTechCard(entry) {
        if (!entry || !entry.item || !entry.item.name) return null;
        const { item, slug, materials } = entry;
        const techKey = item.id || slug;
        const card = document.createElement('article');
        card.className = 'tech-card';
        if (techKey) {
          card.id = `tech-${techKey}`;
          card.dataset.techKey = techKey;
          card.tabIndex = 0;
          card.setAttribute('role', 'group');
          card.setAttribute('aria-roledescription', kidMode ? 'Tech card' : 'Technology card');
          card.dataset.clickable = 'true';
        }
        card.dataset.branch = entry.branch;
        const isUnlocked = !!unlocked[item.name];
        if (isUnlocked) {
          card.classList.add('tech-card--unlocked');
        }
        const art = document.createElement('div');
        art.className = 'tech-card__art';
        if (item.image) {
          const img = document.createElement('img');
          img.loading = 'lazy';
          img.decoding = 'async';
          img.alt = `${item.name} image`;
          img.referrerPolicy = 'no-referrer';
          img.src = item.image;
          img.onerror = () => {
            img.remove();
            art.classList.add('tech-card__art--fallback');
            const icon = document.createElement('i');
            icon.className = 'fa-solid fa-gears';
            art.appendChild(icon);
          };
          art.appendChild(img);
        } else {
          art.classList.add('tech-card__art--fallback');
          const icon = document.createElement('i');
          icon.className = 'fa-solid fa-gears';
          art.appendChild(icon);
        }
        card.appendChild(art);
        const info = document.createElement('div');
        info.className = 'tech-card__info';
        const headerRow = document.createElement('div');
        headerRow.className = 'tech-card__meta';
        const nameEl = document.createElement('h5');
        nameEl.className = 'tech-card__name';
        nameEl.textContent = item.name;
        headerRow.appendChild(nameEl);
        const costBadge = document.createElement('span');
        costBadge.className = 'tech-card__cost';
        costBadge.textContent = formatTechCost(item, { kid: kidMode, short: true });
        headerRow.appendChild(costBadge);
        info.appendChild(headerRow);
        const chips = document.createElement('div');
        chips.className = 'tech-card__chips';
        const chipLabels = new Set();
        if (item.category) chipLabels.add(item.category);
        if (item.group && item.group !== item.category) chipLabels.add(item.group);
        chipLabels.forEach(label => {
          const chip = document.createElement('span');
          chip.className = 'tech-chip';
          chip.textContent = label;
          chips.appendChild(chip);
        });
        if (chipLabels.size) {
          info.appendChild(chips);
        }
        const descriptions = computeTechDescriptions(item);
        const description = document.createElement('p');
        description.className = 'tech-card__description';
        description.textContent = kidMode ? descriptions.kid : descriptions.grown;
        info.appendChild(description);
        if (materials.length) {
          const materialList = document.createElement('ul');
          materialList.className = 'tech-card__materials';
          materials.forEach(material => {
            const chip = createTechMaterialChip(material);
            if (!chip) return;
            const li = document.createElement('li');
            li.appendChild(chip);
            materialList.appendChild(li);
          });
          if (materialList.children.length) {
            info.appendChild(materialList);
          } else {
            const note = document.createElement('p');
            note.className = 'tech-card__note';
            note.textContent = kidMode
              ? 'No ingredients needed for this unlock.'
              : 'No crafting ingredients required for this unlock.';
            info.appendChild(note);
          }
        } else {
          const note = document.createElement('p');
          note.className = 'tech-card__note';
          note.textContent = kidMode
            ? 'No ingredients needed for this unlock.'
            : 'No crafting ingredients required for this unlock.';
          info.appendChild(note);
        }
        const footer = document.createElement('div');
        footer.className = 'tech-card__footer';
        const status = document.createElement('span');
        status.className = 'tech-card__status';
        if (isUnlocked) {
          status.classList.add('tech-card__status--unlocked');
        }
        if (techKey) {
          status.dataset.techStatus = techKey;
        }
        status.textContent = formatTechStatusText(isUnlocked);
        footer.appendChild(status);
        const unlockBtn = document.createElement('button');
        unlockBtn.type = 'button';
        unlockBtn.className = 'unlock-btn';
        if (isUnlocked) {
          unlockBtn.classList.add('unlocked');
        }
        if (techKey) {
          unlockBtn.dataset.techKey = techKey;
        }
        unlockBtn.dataset.techName = item.name;
        unlockBtn.setAttribute('aria-pressed', isUnlocked ? 'true' : 'false');
        unlockBtn.textContent = isUnlocked ? 'Unlocked' : 'Unlock';
        unlockBtn.addEventListener('click', event => {
          event.stopPropagation();
          const newState = setTechUnlocked(item.name, !unlocked[item.name], { techKey });
          unlockBtn.classList.toggle('unlocked', newState);
          unlockBtn.textContent = newState ? 'Unlocked' : 'Unlock';
          unlockBtn.setAttribute('aria-pressed', newState ? 'true' : 'false');
          status.textContent = formatTechStatusText(newState);
          status.classList.toggle('tech-card__status--unlocked', newState);
        });
        footer.appendChild(unlockBtn);
        info.appendChild(footer);
        card.appendChild(info);
        if (techKey) {
          card.addEventListener('click', () => {
            showTechDetail(techKey);
          });
          card.addEventListener('keydown', event => {
            if (event.key === 'Enter' || event.key === ' ' || event.key === 'Spacebar') {
              event.preventDefault();
              showTechDetail(techKey);
            }
          });
        }
        return card;
      }
      function updateResetState() {
        const isDefault = !(filterState.query && filterState.query.length)
          && filterState.branch === 'all'
          && filterState.category === 'all'
          && filterState.status === 'all'
          && (filterState.sort === 'level-asc' || !filterState.sort);
        resetBtn.disabled = isDefault;
      }
      function updateSummary(total, levelCount, filtersActive, hasResults) {
        if (!summary) return;
        if (!hasResults) {
          summary.textContent = filtersActive
            ? (kidMode ? 'No blueprints match those filters yet.' : 'No technology matches the current filters.')
            : (kidMode ? 'Technology data is still loading.' : 'Technology data is still loading.');
          return;
        }
        const unlockWord = total === 1 ? 'unlock' : 'unlocks';
        const levelWord = levelCount === 1 ? 'level' : 'levels';
        summary.textContent = kidMode
          ? `Showing ${total} ${unlockWord} across ${levelCount} tech ${levelWord}.`
          : `Showing ${total} ${unlockWord} across ${levelCount} tech ${levelWord}.`;
      }
      function renderLevels() {
        results.innerHTML = '';
        const filtersActive = hasActiveFilters();
        const sortMode = filterState.sort || 'level-asc';
        const orderedLevels = sortMode === 'level-desc'
          ? levelEntries.slice().sort((a, b) => (b.levelNumber || 0) - (a.levelNumber || 0))
          : levelEntries.slice();
        let totalMatches = 0;
        let levelsRendered = 0;
        let renderedAny = false;
        orderedLevels.forEach(levelEntry => {
          const filteredEntries = levelEntry.entries.filter(matchesFilter);
          const hasMatches = filteredEntries.length > 0;
          if (!hasMatches && filtersActive) {
            return;
          }
          const showTechColumn = filterState.branch !== 'ancient';
          const showAncientColumn = filterState.branch !== 'technology';
          const standardEntries = sortEntries(filteredEntries.filter(entry => entry.branch === 'technology'));
          const ancientEntries = sortEntries(filteredEntries.filter(entry => entry.branch === 'ancient'));
          const section = document.createElement('article');
          section.className = 'tech-level-card';
          const header = document.createElement('header');
          header.className = 'tech-level-header';
          const number = document.createElement('div');
          number.className = 'tech-level-number';
          const label = document.createElement('span');
          label.textContent = kidMode ? 'Level' : 'Level';
          number.appendChild(label);
          const value = document.createElement('strong');
          value.textContent = levelEntry.levelNumber != null ? String(levelEntry.levelNumber) : '?';
          number.appendChild(value);
          header.appendChild(number);
          const summaryParts = [];
          if (showTechColumn && standardEntries.length) {
            summaryParts.push(
              kidMode
                ? `${standardEntries.length} tech gadget${standardEntries.length === 1 ? '' : 's'}`
                : `${standardEntries.length} tech unlock${standardEntries.length === 1 ? '' : 's'}`
            );
          }
          if (showAncientColumn && ancientEntries.length) {
            summaryParts.push(
              kidMode
                ? `${ancientEntries.length} ancient relic${ancientEntries.length === 1 ? '' : 's'}`
                : `${ancientEntries.length} ancient unlock${ancientEntries.length === 1 ? '' : 's'}`
            );
          }
          const summaryText = summaryParts.length
            ? summaryParts.join(' • ')
            : filtersActive
              ? (kidMode ? 'No matches at this level.' : 'No matching unlocks at this level.')
              : (kidMode ? 'No blueprints at this level yet.' : 'No unlocks available at this level.');
          const summaryEl = document.createElement('p');
          summaryEl.className = 'tech-level-summary';
          summaryEl.textContent = summaryText;
          header.appendChild(summaryEl);
          section.appendChild(header);
          const columns = document.createElement('div');
          columns.className = 'tech-columns';
          const columnDefs = [];
          if (showTechColumn) {
            columnDefs.push({
              key: 'tech',
              heading: kidMode ? 'Technology' : 'Technology',
              entries: standardEntries,
              emptyText: filtersActive
                ? (kidMode ? 'Nothing here matches your filters.' : 'No matching technology unlocks.')
                : (kidMode ? 'No tech unlocks at this level.' : 'No new technology unlocks.')
            });
          }
          if (showAncientColumn) {
            columnDefs.push({
              key: 'ancient',
              heading: kidMode ? 'Ancient Tech' : 'Ancient Technology',
              entries: ancientEntries,
              emptyText: filtersActive
                ? (kidMode ? 'No ancient relics in this filter.' : 'No matching ancient unlocks.')
                : (kidMode ? 'No ancient relics at this level.' : 'No ancient tech at this level.')
            });
          }
          columnDefs.forEach(columnInfo => {
            const column = document.createElement('div');
            column.className = `tech-column tech-column--${columnInfo.key}`;
            const heading = document.createElement('h4');
            heading.textContent = columnInfo.heading;
            column.appendChild(heading);
            if (!columnInfo.entries.length) {
              const empty = document.createElement('p');
              empty.className = 'tech-empty';
              empty.textContent = columnInfo.emptyText;
              column.appendChild(empty);
            } else {
              const grid = document.createElement('div');
              grid.className = 'tech-card-grid';
              columnInfo.entries.forEach(entry => {
                const card = createTechCard(entry);
                if (card) grid.appendChild(card);
              });
              column.appendChild(grid);
            }
            columns.appendChild(column);
          });
          section.appendChild(columns);
          results.appendChild(section);
          renderedAny = true;
          levelsRendered += 1;
          totalMatches += filteredEntries.length;
        });
        if (!renderedAny) {
          const empty = document.createElement('div');
          empty.className = 'tech-results__empty';
          empty.textContent = filtersActive
            ? (kidMode ? 'No blueprints match those filters yet.' : 'No technology matches the current filters.')
            : (kidMode ? 'Technology data is still loading. Check back soon!' : 'Technology data is still loading.');
          results.appendChild(empty);
          updateSummary(0, 0, filtersActive, false);
          applyQueuedTechFocus();
          return;
        }
        updateSummary(totalMatches, levelsRendered, filtersActive, true);
        applyQueuedTechFocus();
      }
      searchInput.addEventListener('input', event => {
        const value = event.target.value || '';
        filterState.queryRaw = value;
        filterState.query = value.trim().toLowerCase();
        updateResetState();
        renderLevels();
      });
      updateResetState();
      renderLevels();
    }

    function queueTechFocus(key){
      if(!key){
        pendingTechFocus = null;
        return;
      }
      pendingTechFocus = key;
      setTimeout(applyQueuedTechFocus, 0);
    }

    function applyQueuedTechFocus(){
      if(!pendingTechFocus) return;
      const techCard = document.getElementById(`tech-${pendingTechFocus}`);
      if(!techCard) return;
      pendingTechFocus = null;
      requestAnimationFrame(() => {
        techCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
        pulse(techCard);
      });
    }
    // Build breeding page
    const BREEDING_ANALYSIS_CACHE = {
      recipeMap: null,
      partnerLookup: null,
      palsSorted: null
    };
    function buildBreedingRecipeMap() {
      const map = {};
      Object.values(PALS || {}).forEach(pal => {
        const combos = Array.isArray(pal.breedingCombos) ? pal.breedingCombos : [];
        map[pal.id] = combos.map(pair => {
          if (!Array.isArray(pair) || pair.length < 2) {
            return { parents: [null, null], names: pair || [], pals: [null, null] };
          }
          const [leftName, rightName] = pair;
          const leftPal = findPalByName(leftName);
          const rightPal = findPalByName(rightName);
          return {
            parents: [leftPal ? leftPal.id : null, rightPal ? rightPal.id : null],
            names: [leftName, rightName],
            pals: [leftPal, rightPal]
          };
        });
      });
      return map;
    }
    function buildPartnerSkillLookup() {
      const lookup = {};
      const skills = Array.isArray(PARTNER_SKILLS) ? PARTNER_SKILLS : [];
      skills.forEach(skill => {
        const categories = Array.isArray(skill.categories) ? skill.categories.map(cat => String(cat)) : [];
        const normalized = new Set();
        let mountLabel = null;
        categories.forEach(cat => {
          const lower = cat.toLowerCase();
          if (lower.includes('combat')) normalized.add('combat');
          if (lower.includes('utility')) normalized.add('utility');
          if (lower.includes('farming')) normalized.add('farming');
          if (lower.startsWith('mount')) {
            normalized.add('mount');
            mountLabel = mountLabel || cat;
            if (lower.includes('flying')) normalized.add('mount-flying');
            if (lower.includes('glider')) normalized.add('mount-glider');
            if (lower.includes('swimmer')) normalized.add('mount-swimmer');
            if (lower.includes('ridden')) normalized.add('mount-ridden');
          }
        });
        const description = typeof skill.description === 'string' ? skill.description : '';
        const descLower = description.toLowerCase();
        const modifiesPlayerDamage = descLower.includes('player') && (descLower.includes('damage') || descLower.includes('attack'));
        const modifiesPalDamage = descLower.includes('pal') && descLower.includes('damage');
        const modifiesAnyDamage = descLower.includes('damage') || descLower.includes('attack');
        const speedBoost = descLower.includes('speed') && descLower.includes('mount');
        const workBoost = descLower.includes('work') || descLower.includes('carry') || descLower.includes('weight');
        const dropBoost = descLower.includes('drop') || descLower.includes('harvest');
        (Array.isArray(skill.pals) ? skill.pals : []).forEach(name => {
          const pal = findPalByName(name);
          if (!pal) return;
          lookup[pal.id] = {
            skill,
            categories,
            normalized,
            mountLabel,
            description,
            descLower,
            modifiesAnyDamage,
            modifiesPlayerDamage,
            modifiesPalDamage,
            speedBoost,
            workBoost,
            dropBoost
          };
        });
      });
      return lookup;
    }
    function computeBreedingGraph(recipes) {
      const caughtIds = new Set();
      Object.entries(caught || {}).forEach(([id, value]) => {
        if (!value) return;
        const numeric = Number(id);
        if (!Number.isNaN(numeric)) {
          caughtIds.add(numeric);
        }
      });
      const depths = new Map();
      const sources = new Map();
      caughtIds.forEach(id => depths.set(id, 0));
      let progressed = true;
      while (progressed) {
        progressed = false;
        Object.values(PALS || {}).forEach(pal => {
          const combos = recipes[pal.id] || [];
          combos.forEach(recipe => {
            if (!recipe || !Array.isArray(recipe.parents)) return;
            if (!recipe.parents.every(parentId => parentId != null && depths.has(parentId))) return;
            const parentDepths = recipe.parents.map(parentId => depths.get(parentId) || 0);
            const candidateDepth = Math.max(...parentDepths) + 1;
            if (!depths.has(pal.id) || candidateDepth < depths.get(pal.id)) {
              depths.set(pal.id, candidateDepth);
              sources.set(pal.id, recipe);
              progressed = true;
            }
          });
        });
      }
      return {
        depths,
        sources,
        reachable: new Set(depths.keys()),
        caughtIds
      };
    }
    function getBreedingAnalysis({ refresh = false } = {}) {
      if (refresh || !BREEDING_ANALYSIS_CACHE.recipeMap) {
        BREEDING_ANALYSIS_CACHE.recipeMap = buildBreedingRecipeMap();
      }
      if (refresh || !BREEDING_ANALYSIS_CACHE.partnerLookup) {
        BREEDING_ANALYSIS_CACHE.partnerLookup = buildPartnerSkillLookup();
      }
      if (refresh || !BREEDING_ANALYSIS_CACHE.palsSorted) {
        BREEDING_ANALYSIS_CACHE.palsSorted = Object.values(PALS || {}).sort((a, b) => a.name.localeCompare(b.name));
      }
      const graph = computeBreedingGraph(BREEDING_ANALYSIS_CACHE.recipeMap);
      return {
        recipeMap: BREEDING_ANALYSIS_CACHE.recipeMap,
        partnerLookup: BREEDING_ANALYSIS_CACHE.partnerLookup,
        palsSorted: BREEDING_ANALYSIS_CACHE.palsSorted,
        depths: graph.depths,
        sources: graph.sources,
        reachable: graph.reachable,
        caughtIds: graph.caughtIds
      };
    }
    function getBreedingPartnerInfo(analysis, pal) {
      if (!analysis || !pal) return null;
      return analysis.partnerLookup[pal.id] || null;
    }
    function getBreedingPreferredRecipe(analysis, palId) {
      if (!analysis) return null;
      if (analysis.sources.has(palId)) {
        return analysis.sources.get(palId);
      }
      const options = analysis.recipeMap[palId] || [];
      const valid = options.find(entry => Array.isArray(entry.parents) && entry.parents.every(id => id != null));
      return valid || options[0] || null;
    }
    function formatBreedingDepthLabel(analysis, palId, { kidMode = false } = {}) {
      if (!analysis) return kidMode ? 'Catch in the wild' : 'Catch in the wild';
      const depth = analysis.depths.get(palId);
      if (depth == null) return kidMode ? 'Catch in the wild' : 'Catch in the wild';
      if (depth === 0) {
        return kidMode ? 'Already in your camp' : 'Already caught';
      }
      const suffix = depth > 1 ? 's' : '';
      return kidMode ? `${depth} breeding step${suffix}` : `${depth} breeding step${suffix}`;
    }
    function summarizeWorkRoles(pal) {
      const work = pal?.work || {};
      const entries = Object.entries(work).filter(([, level]) => level > 0);
      entries.sort((a, b) => b[1] - a[1]);
      return entries.slice(0, 3).map(([role, level]) => {
        const label = getWorkRoleLabel(role);
        return `${label}: Lv${level}`;
      });
    }
    function computeBreedingCombatScore(pal, partnerInfo) {
      if (!pal) return -Infinity;
      const stats = pal.stats || {};
      let score = (stats.attack || 0) * 1.6 + (stats.defense || 0) * 0.8 + (stats.hp || 0) * 0.6 + (stats.speed || 0) * 0.3;
      score += (pal.rarity || 0) * 30;
      if (partnerInfo?.normalized?.has('combat')) score += 120;
      if (partnerInfo?.modifiesAnyDamage) score += 60;
      if (partnerInfo?.modifiesPlayerDamage) score += 30;
      if (partnerInfo?.modifiesPalDamage) score += 30;
      return score;
    }
    function computeBreedingWorkerScore(pal, partnerInfo) {
      if (!pal) return -Infinity;
      const work = pal.work || {};
      const levels = Object.values(work).filter(level => level > 0);
      if (!levels.length) return -Infinity;
      let score = levels.reduce((total, level) => total + (level * level * 12), 0);
      score += Math.max(...levels) * 30;
      if (partnerInfo?.workBoost) score += 80;
      if (partnerInfo?.dropBoost) score += 25;
      return score;
    }
    function computeBreedingMountScore(pal, partnerInfo) {
      if (!pal) return -Infinity;
      if (!partnerInfo || !partnerInfo.normalized?.has('mount')) return -Infinity;
      const stats = pal.stats || {};
      let score = (stats.speed || 0) * 0.5 + (pal.rarity || 0) * 25;
      if (partnerInfo.normalized.has('mount-flying')) score += 180;
      if (partnerInfo.normalized.has('mount-glider')) score += 120;
      if (partnerInfo.normalized.has('mount-swimmer')) score += 90;
      if (partnerInfo.speedBoost) score += 140;
      return score;
    }
    function computeBreedingCollectionScore(analysis, pal) {
      if (!pal) return -Infinity;
      const rarity = pal.rarity || 0;
      const price = pal.price || 0;
      let score = rarity * 120 + price / 80;
      const depth = analysis?.depths?.get(pal.id);
      if (depth != null && depth > 0) {
        score += (6 - Math.min(depth, 6)) * 25;
      }
      if (!caught[pal.id]) {
        score += 180;
      }
      return score;
    }
    function generateBreedingAdvisorSuggestions({ kidMode = false, refresh = false } = {}) {
      const analysis = getBreedingAnalysis({ refresh });
      const formatSteps = palId => formatBreedingDepthLabel(analysis, palId, { kidMode });
      const reachableIds = Array.from(analysis.reachable);
      const newIds = reachableIds.filter(id => !analysis.caughtIds.has(id));
      const used = new Set();
      const suggestions = [];
      const configs = [
        {
          key: 'combat',
          icon: 'fa-crosshairs',
          eyebrowKid: 'Battle pick',
          eyebrowGrown: 'Combat focus',
          titleKid: 'Power pal',
          titleGrown: 'Combat ace',
          scoring: (pal, partnerInfo) => computeBreedingCombatScore(pal, partnerInfo),
          buildSubtitle: (pal, partnerInfo) => kidMode
            ? `Breed ${pal.name} to help with tough fights.`
            : `${pal.name} offers your biggest immediate damage spike.`,
          buildHighlights: (pal, partnerInfo) => {
            const stats = pal.stats || {};
            const lines = [
              kidMode ? `Attack ~${Math.round(stats.attack || 0)}` : `Attack ${Math.round(stats.attack || 0)}`,
              kidMode ? `Defense ~${Math.round(stats.defense || 0)}` : `Defense ${Math.round(stats.defense || 0)}`
            ];
            if (partnerInfo?.skill?.name) {
              lines.push(kidMode ? `Skill: ${partnerInfo.skill.name}` : `Partner skill • ${partnerInfo.skill.name}`);
            }
            return lines.filter(Boolean);
          },
          buildNote: pal => {
            const depthText = formatSteps(pal.id).toLowerCase();
            return kidMode
              ? `${pal.name} is your strongest fighter in ${depthText}.`
              : `${pal.name} is the highest attack hatch reachable in ${depthText}.`;
          }
        },
        {
          key: 'worker',
          icon: 'fa-helmet-safety',
          eyebrowKid: 'Base boost',
          eyebrowGrown: 'Base planner',
          titleKid: 'Work hero',
          titleGrown: 'Base specialist',
          scoring: (pal, partnerInfo) => computeBreedingWorkerScore(pal, partnerInfo),
          buildSubtitle: pal => kidMode
            ? `${pal.name} speeds up jobs at base.`
            : `${pal.name} shores up critical work roles you are missing.`,
          buildHighlights: (pal, partnerInfo) => {
            const highlights = summarizeWorkRoles(pal);
            if (partnerInfo?.skill?.name) {
              highlights.push(kidMode ? `Skill: ${partnerInfo.skill.name}` : `Partner skill • ${partnerInfo.skill.name}`);
            }
            return highlights;
          },
          buildNote: pal => {
            const roles = summarizeWorkRoles(pal).join(', ');
            return kidMode
              ? `${pal.name} keeps your base humming (${roles}).`
              : `${pal.name} unlocks better productivity (${roles}).`;
          }
        },
        {
          key: 'mount',
          icon: 'fa-feather-pointed',
          eyebrowKid: 'Travel pick',
          eyebrowGrown: 'Mobility upgrade',
          titleKid: 'Speedy ride',
          titleGrown: 'Mount upgrade',
          scoring: (pal, partnerInfo) => computeBreedingMountScore(pal, partnerInfo),
          buildSubtitle: (pal, partnerInfo) => {
            const mountLabel = partnerInfo?.mountLabel || (kidMode ? 'Ride skill' : 'Ride skill');
            return kidMode
              ? `${pal.name} lets you ${mountLabel.toLowerCase()}.`
              : `${pal.name} is the best ${mountLabel.toLowerCase()} you can hatch right now.`;
          },
          buildHighlights: (pal, partnerInfo) => {
            const stats = pal.stats || {};
            const lines = [kidMode ? `Speed ~${Math.round(stats.speed || 0)}` : `Speed ${Math.round(stats.speed || 0)}`];
            if (partnerInfo?.skill?.name) {
              lines.push(kidMode ? `Skill: ${partnerInfo.skill.name}` : `Partner skill • ${partnerInfo.skill.name}`);
            }
            return lines;
          },
          buildNote: pal => kidMode
            ? `${pal.name} keeps travel fast so you can explore more.`
            : `${pal.name} is the cleanest mobility upgrade available from breeding.`
        },
        {
          key: 'collection',
          icon: 'fa-layer-group',
          eyebrowKid: 'New friend',
          eyebrowGrown: 'Collection target',
          titleKid: 'New friend',
          titleGrown: 'Collection highlight',
          scoring: pal => computeBreedingCollectionScore(analysis, pal),
          buildSubtitle: pal => kidMode
            ? `${pal.name} fills a new slot in your Paldeck.`
            : `${pal.name} plugs a rare gap in your Paldeck.`,
          buildHighlights: pal => {
            const depthText = formatSteps(pal.id);
            const lines = [depthText];
            if (pal.price) {
              lines.push(kidMode ? `${pal.price.toLocaleString()} gold value` : `${pal.price.toLocaleString()} gold value`);
            }
            return lines;
          },
          buildNote: pal => kidMode
            ? `Hatching ${pal.name} gets you closer to a full Paldeck.`
            : `${pal.name} is a prestige hatch that nudges your deck toward completion.`
        }
      ];
      function pickCandidate(scoringFn) {
        let best = null;
        let bestScore = -Infinity;
        const evaluate = ids => {
          ids.forEach(id => {
            if (used.has(id)) return;
            const pal = PALS[id];
            if (!pal) return;
            const partnerInfo = getBreedingPartnerInfo(analysis, pal);
            const score = scoringFn(pal, partnerInfo, analysis);
            if (score > bestScore) {
              bestScore = score;
              best = { pal, partnerInfo, recipe: getBreedingPreferredRecipe(analysis, id) };
            }
          });
        };
        evaluate(newIds);
        if (!best) evaluate(reachableIds);
        if (!best) evaluate(analysis.palsSorted.map(p => p.id));
        return best;
      }
      configs.forEach(config => {
        const entry = pickCandidate(config.scoring);
        if (!entry) return;
        used.add(entry.pal.id);
        const eyebrow = kidMode ? config.eyebrowKid : config.eyebrowGrown;
        const title = kidMode ? config.titleKid : config.titleGrown;
        const subtitle = config.buildSubtitle(entry.pal, entry.partnerInfo);
        const highlights = config.buildHighlights(entry.pal, entry.partnerInfo).filter(Boolean);
        const note = config.buildNote(entry.pal, entry.partnerInfo);
        suggestions.push({
          configKey: config.key,
          icon: config.icon,
          eyebrow,
          title,
          subtitle,
          highlights,
          note,
          pal: entry.pal,
          partnerInfo: entry.partnerInfo,
          recipe: entry.recipe,
          depthLabel: formatSteps(entry.pal.id),
          recipeParents: entry.recipe && Array.isArray(entry.recipe.parents) ? entry.recipe.parents : [],
          recipeNames: entry.recipe && Array.isArray(entry.recipe.names) ? entry.recipe.names : []
        });
      });
      return { analysis, suggestions };
    }
    function buildBreedingPage() {
      const parent1Grid = document.getElementById('parent1Grid');
      const parent2Grid = document.getElementById('parent2Grid');
      const babyGrid = document.getElementById('babyGrid');
      const result = document.getElementById('breedingResult');
      const combosContainer = document.getElementById('breedingCombos');
      const parent1Search = document.getElementById('parent1Search');
      const parent2Search = document.getElementById('parent2Search');
      const babySearch = document.getElementById('babySearch');
      const advisorGrid = document.getElementById('breedingAdvisorGrid');
      const advisorEmpty = document.getElementById('breedingAdvisorEmpty');
      const advisorTitle = document.getElementById('breedingAdvisorTitle');
      const advisorCopy = document.getElementById('breedingAdvisorCopy');
      const atlasGrid = document.getElementById('atlasGrid');
      const atlasSearch = document.getElementById('atlasSearch');
      const atlasDiagram = document.getElementById('breedingTree');
      const atlasEmpty = document.getElementById('breedingAtlasEmpty');
      const modeButtons = Array.from(document.querySelectorAll('.breeding-tab'));
      const modes = Array.from(document.querySelectorAll('.breeding-mode'));
      if (!parent1Grid || !parent2Grid || !babyGrid || !result || !combosContainer || !parent1Search || !parent2Search || !babySearch || !advisorGrid || !advisorEmpty || !advisorTitle || !advisorCopy || !atlasGrid || !atlasSearch || !atlasDiagram || !atlasEmpty) {
        return;
      }
      let analysis = getBreedingAnalysis({ refresh: true });
      let palsSorted = analysis.palsSorted;
      let formatSteps = palId => formatBreedingDepthLabel(analysis, palId, { kidMode });

      let parentState = {
        parent1: BREEDING_SELECTION.parent1Id ? PALS[BREEDING_SELECTION.parent1Id] : null,
        parent2: BREEDING_SELECTION.parent2Id ? PALS[BREEDING_SELECTION.parent2Id] : null
      };
      let selectedBaby = BREEDING_SELECTION.babyId ? PALS[BREEDING_SELECTION.babyId] : null;
      let selectedAtlas = BREEDING_SELECTION.atlasId ? PALS[BREEDING_SELECTION.atlasId] : null;
      if (!parentState.parent1) parentState.parent1 = null;
      if (!parentState.parent2) parentState.parent2 = null;
      if (!selectedBaby) selectedBaby = null;
      if (!selectedAtlas) selectedAtlas = null;

      function updateBreedingSelection() {
        BREEDING_SELECTION.parent1Id = parentState.parent1 ? parentState.parent1.id : null;
        BREEDING_SELECTION.parent2Id = parentState.parent2 ? parentState.parent2.id : null;
        BREEDING_SELECTION.babyId = selectedBaby ? selectedBaby.id : null;
        BREEDING_SELECTION.atlasId = selectedAtlas ? selectedAtlas.id : null;
      }

      function makeEmptyMessage(text) {
        const msg = document.createElement('p');
        msg.className = 'empty-state';
        msg.textContent = text;
        return msg;
      }

      function createPalCard(pal, options = {}) {
        const { compact = true, selectable = true, selected = false } = options;
        const card = document.createElement('div');
        card.classList.add('pal-card');
        if (compact) card.classList.add('compact');
        if (selectable) card.classList.add('selectable');
        else card.classList.add('static');
        if (selected) card.classList.add('selected');
        const img = document.createElement('img');
        applyPalArtwork(img, pal);
        card.appendChild(img);
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = pal.name;
        card.appendChild(name);
        const badge = document.createElement('div');
        badge.className = 'badge';
        if (Array.isArray(pal.types) && pal.types.length) {
          pal.types.forEach(type => {
            const icon = document.createElement('img');
            icon.src = iconMap[type] || iconMap['Neutral'];
            icon.alt = `${type} icon`;
            badge.appendChild(icon);
          });
        } else {
          const span = document.createElement('span');
          span.textContent = 'Unknown';
          badge.appendChild(span);
        }
        card.appendChild(badge);
        if (pal && typeof pal.id !== 'undefined') {
          const caughtStatus = document.createElement('div');
          const isCaught = !!caught[pal.id];
          caughtStatus.className = 'caught-status';
          caughtStatus.dataset.caught = isCaught ? 'true' : 'false';
          caughtStatus.textContent = isCaught
            ? (kidMode ? 'We caught it!' : 'Caught')
            : (kidMode ? 'Need this pal' : 'Not caught yet');
          card.appendChild(caughtStatus);
        }
        const rarityEl = document.createElement('div');
        rarityEl.className = 'rarity';
        const starSpan = document.createElement('span');
        starSpan.className = 'stars';
        const labelSpan = document.createElement('span');
        labelSpan.className = 'label';
        const rarity = Math.max(1, Math.min(pal.rarity || 0, 6));
        if (!kidMode) {
          starSpan.innerHTML = Array(rarity).fill('<i class="fa-solid fa-star"></i>').join('');
          labelSpan.textContent = rarityNames[rarity] || '';
        }
        rarityEl.appendChild(starSpan);
        rarityEl.appendChild(labelSpan);
        card.appendChild(rarityEl);
        return card;
      }

      function createPalChip(pal, fallbackName, options = {}) {
        const { condensed = false, role = null, meta = null } = options;
        const chip = document.createElement('div');
        chip.className = 'breeding-chip';
        if (condensed) chip.classList.add('breeding-chip--condensed');
        if (role) chip.classList.add(`breeding-chip--${role}`);
        const art = document.createElement('div');
        art.className = 'breeding-chip__art';
        if (pal) {
          const img = document.createElement('img');
          applyPalArtwork(img, pal, { alt: `${pal.name} portrait` });
          art.appendChild(img);
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'breeding-chip__placeholder';
          placeholder.textContent = '?';
          art.appendChild(placeholder);
        }
        chip.appendChild(art);
        const body = document.createElement('div');
        body.className = 'breeding-chip__body';
        const label = document.createElement('span');
        label.className = 'breeding-chip__label';
        label.textContent = pal ? pal.name : (fallbackName || (kidMode ? 'Unknown pal' : 'Unknown pal'));
        body.appendChild(label);
        const metaText = meta != null ? meta : (pal && Array.isArray(pal.types) && pal.types.length ? pal.types.join(' / ') : '');
        if (metaText) {
          const metaSpan = document.createElement('span');
          metaSpan.className = 'breeding-chip__meta';
          metaSpan.textContent = metaText;
          body.appendChild(metaSpan);
        }
        chip.appendChild(body);
        return chip;
      }

      function createComboCard(pal, fallbackName) {
        return createPalChip(pal, fallbackName, {
          condensed: true,
          role: pal ? 'parent' : null,
          meta: pal ? formatSteps(pal.id) : ''
        });
      }
      function getPartnerInfo(pal) {
        return getBreedingPartnerInfo(analysis, pal);
      }

      function getPreferredRecipe(palId) {
        return getBreedingPreferredRecipe(analysis, palId);
      }

      function buildHighlights(lines) {
        const list = document.createElement('ul');
        list.className = 'advisor-card__highlights';
        lines.forEach(entry => {
          if (!entry) return;
          const li = document.createElement('li');
          if (typeof entry === 'string') {
            li.textContent = entry;
          } else {
            li.textContent = kidMode ? entry.kid : entry.grown;
          }
          list.appendChild(li);
        });
        return list;
      }

      function buildAdvisorCard(entry) {
        const pal = entry.pal;
        const partnerInfo = entry.partnerInfo;
        const recipe = entry.recipe;
        const card = document.createElement('article');
        card.className = 'advisor-card';
        card.setAttribute('role', 'listitem');

        const header = document.createElement('header');
        header.className = 'advisor-card__header';
        const titleBlock = document.createElement('div');
        titleBlock.className = 'advisor-card__titleblock';
        const eyebrow = document.createElement('span');
        eyebrow.className = 'advisor-card__eyebrow';
        eyebrow.textContent = entry.eyebrow;
        titleBlock.appendChild(eyebrow);
        const title = document.createElement('h4');
        title.className = 'advisor-card__title';
        title.textContent = entry.title;
        titleBlock.appendChild(title);
        const subtitle = document.createElement('p');
        subtitle.className = 'advisor-card__subtitle';
        subtitle.textContent = entry.subtitle;
        titleBlock.appendChild(subtitle);
        header.appendChild(titleBlock);
        const iconWrap = document.createElement('div');
        iconWrap.className = 'advisor-card__icon';
        const icon = document.createElement('i');
        icon.className = `fa-solid ${entry.icon}`;
        iconWrap.appendChild(icon);
        header.appendChild(iconWrap);
        card.appendChild(header);

        const badges = document.createElement('div');
        badges.className = 'advisor-card__badges';
        const rarityName = rarityNames[Math.max(1, Math.min(pal.rarity || 0, 6))] || (kidMode ? 'Unknown' : 'Unknown');
        const rarityBadge = document.createElement('span');
        rarityBadge.className = 'advisor-card__badge';
        rarityBadge.textContent = rarityName;
        badges.appendChild(rarityBadge);
        const typeBadge = document.createElement('span');
        typeBadge.className = 'advisor-card__badge';
        typeBadge.textContent = Array.isArray(pal.types) && pal.types.length ? pal.types.join(' / ') : 'Unknown';
        badges.appendChild(typeBadge);
        const stepBadge = document.createElement('span');
        stepBadge.className = 'advisor-card__badge';
        stepBadge.textContent = formatSteps(pal.id);
        badges.appendChild(stepBadge);
        card.appendChild(badges);

        const palWrap = document.createElement('div');
        palWrap.className = 'advisor-card__pal';
        palWrap.appendChild(createPalCard(pal, { compact: false, selectable: false }));
        card.appendChild(palWrap);

        card.appendChild(buildHighlights(entry.highlights || []));

        const actions = document.createElement('div');
        actions.className = 'advisor-card__actions';
        const parentIds = Array.isArray(entry.recipeParents) && entry.recipeParents.every(id => id != null)
          ? entry.recipeParents
          : (recipe && Array.isArray(recipe.parents) && recipe.parents.every(id => id != null) ? recipe.parents : null);
        if (parentIds) {
          const planBtn = document.createElement('button');
          planBtn.type = 'button';
          planBtn.className = 'advisor-card__action';
          planBtn.textContent = kidMode ? 'Queue this combo' : 'Queue this combo';
          planBtn.addEventListener('click', () => {
            const [leftId, rightId] = parentIds;
            parentState.parent1 = leftId != null ? PALS[leftId] : null;
            parentState.parent2 = rightId != null ? PALS[rightId] : null;
            selectedBaby = pal;
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
            renderBabyGrid();
            showCombos();
            switchBreedingMode('breedingPairs');
            playSound(clickSound);
          });
          actions.appendChild(planBtn);
        }
        const atlasBtn = document.createElement('button');
        atlasBtn.type = 'button';
        atlasBtn.className = 'advisor-card__action';
        atlasBtn.textContent = kidMode ? 'View tree' : 'Open in atlas';
        atlasBtn.addEventListener('click', () => {
          selectedAtlas = pal;
          updateBreedingSelection();
          atlasSearch.value = '';
          renderAtlasGrid();
          renderAtlasDiagram();
          switchBreedingMode('breedingAtlas');
          playSound(clickSound);
        });
        actions.appendChild(atlasBtn);
        card.appendChild(actions);

        const note = document.createElement('p');
        note.className = 'advisor-card__note';
        note.textContent = entry.note;
        card.appendChild(note);

        return card;
      }

      function renderAdvisor({ refreshAnalysis = false } = {}) {
        advisorGrid.innerHTML = '';
        advisorEmpty.hidden = true;
        advisorTitle.textContent = kidMode ? 'Advisor queue' : 'Advisor queue';
        advisorCopy.textContent = kidMode
          ? 'We look at pals you can hatch and pick the smartest next ones.'
          : 'We analyse your roster, reachable offspring, and partner skills to queue intelligent breeding targets.';

        if (!isBreedingUnlocked()) {
          advisorEmpty.hidden = false;
          advisorEmpty.textContent = kidMode
            ? 'Unlock the Breeding Farm to see suggested pals and parents.'
            : 'Unlock the Breeding Farm to surface personalised breeding recommendations.';
          return;
        }

        const { analysis: latestAnalysis, suggestions } = generateBreedingAdvisorSuggestions({ kidMode, refresh: refreshAnalysis });
        analysis = latestAnalysis;
        palsSorted = analysis.palsSorted;
        formatSteps = palId => formatBreedingDepthLabel(analysis, palId, { kidMode });

        if (!suggestions.length) {
          advisorEmpty.hidden = false;
          advisorEmpty.textContent = kidMode
            ? 'Mark pals as caught so we can suggest the next hatch.'
            : 'Mark pals as caught to unlock tailored breeding advice.';
          return;
        }

        suggestions.forEach(entry => {
          advisorGrid.appendChild(buildAdvisorCard(entry));
        });
      }

      const MAX_ATLAS_DEPTH = 4;

      function renderAtlasGrid() {
        atlasGrid.innerHTML = '';
        if (!palsSorted.length) {
          atlasGrid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        let matches = filterPals(atlasSearch.value);
        if (selectedAtlas && !matches.some(p => p.id === selectedAtlas.id)) {
          matches = [selectedAtlas, ...matches];
        }
        if (!matches.length) {
          atlasGrid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'Try a different pal search.'));
          return;
        }
        matches.forEach(pal => {
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: selectedAtlas && selectedAtlas.id === pal.id
          });
          card.addEventListener('click', () => {
            if (selectedAtlas && selectedAtlas.id === pal.id) {
              selectedAtlas = null;
            } else {
              selectedAtlas = pal;
            }
            updateBreedingSelection();
            renderAtlasGrid();
            renderAtlasDiagram();
            playSound(clickSound);
          });
          atlasGrid.appendChild(card);
        });
      }

      function createAtlasFocus(pal) {
        const focus = document.createElement('div');
        focus.className = 'breeding-tree__focus';
        const heading = document.createElement('h4');
        heading.textContent = pal.name;
        focus.appendChild(heading);
        const meta = document.createElement('div');
        meta.className = 'breeding-tree__meta';
        const rarityLabel = rarityNames[Math.max(1, Math.min(pal.rarity || 0, 6))] || (kidMode ? 'Unknown rarity' : 'Unknown rarity');
        const raritySpan = document.createElement('span');
        raritySpan.textContent = rarityLabel;
        meta.appendChild(raritySpan);
        const stepsSpan = document.createElement('span');
        stepsSpan.textContent = formatSteps(pal.id);
        meta.appendChild(stepsSpan);
        if (Array.isArray(pal.types) && pal.types.length) {
          const typeSpan = document.createElement('span');
          typeSpan.textContent = pal.types.join(' / ');
          meta.appendChild(typeSpan);
        }
        focus.appendChild(meta);
        focus.appendChild(
          createPalChip(pal, pal.name, {
            role: 'child',
            meta: formatSteps(pal.id)
          })
        );
        return focus;
      }

      function buildAtlasBranches(pal, depth, visited) {
        const combos = (analysis?.recipeMap?.[pal.id]) || [];
        if (!combos.length) return null;
        const fragment = document.createDocumentFragment();
        combos.forEach((recipe, index) => {
          const branch = document.createElement('details');
          branch.className = 'breeding-branch';
          if (depth <= 0 && index === 0) branch.open = true;
          const summary = document.createElement('summary');
          const marker = document.createElement('div');
          marker.className = 'breeding-branch__marker';
          marker.textContent = String(index + 1);
          summary.appendChild(marker);
          const label = document.createElement('div');
          label.className = 'breeding-branch__summary';
          const flow = document.createElement('div');
          flow.className = 'breeding-branch__summary-flow';
          const leftName = recipe.names?.[0] || 'Unknown';
          const rightName = recipe.names?.[1] || 'Unknown';
          const leftPal = recipe.pals?.[0] || null;
          const rightPal = recipe.pals?.[1] || null;
          flow.appendChild(
            createPalChip(leftPal, leftName, {
              condensed: true,
              role: 'parent',
              meta: leftPal ? formatSteps(leftPal.id) : ''
            })
          );
          const plus = document.createElement('span');
          plus.className = 'breeding-branch__summary-arrow';
          plus.textContent = '+';
          flow.appendChild(plus);
          flow.appendChild(
            createPalChip(rightPal, rightName, {
              condensed: true,
              role: 'parent',
              meta: rightPal ? formatSteps(rightPal.id) : ''
            })
          );
          label.appendChild(flow);
          const resultRow = document.createElement('div');
          resultRow.className = 'breeding-branch__summary-result';
          const arrow = document.createElement('span');
          arrow.className = 'breeding-branch__summary-arrow';
          arrow.textContent = '↓';
          resultRow.appendChild(arrow);
          resultRow.appendChild(
            createPalChip(pal, pal.name, {
              condensed: true,
              role: 'child',
              meta: formatSteps(pal.id)
            })
          );
          label.appendChild(resultRow);
          summary.appendChild(label);
          summary.setAttribute(
            'aria-label',
            kidMode
              ? `${leftName} plus ${rightName} makes ${pal.name}`
              : `${leftName} and ${rightName} produce ${pal.name}`
          );
          branch.appendChild(summary);
          const pairWrap = document.createElement('div');
          pairWrap.className = 'breeding-branch__layout';
          branch.appendChild(pairWrap);
          const pyramid = document.createElement('div');
          pyramid.className = 'breeding-branch__pyramid';
          const childChip = createPalChip(pal, pal.name, {
            role: 'child',
            meta: formatSteps(pal.id)
          });
          pyramid.appendChild(childChip);
          const connector = document.createElement('div');
          connector.className = 'breeding-branch__connector';
          pyramid.appendChild(connector);
          const summaryChips = document.createElement('div');
          summaryChips.className = 'breeding-branch__summary-chips';
          (recipe.names || []).forEach((name, idx) => {
            if (idx > 0) {
              const join = document.createElement('span');
              join.className = 'breeding-branch__summary-arrow';
              join.textContent = '+';
              summaryChips.appendChild(join);
            }
            const parentPal = recipe.pals?.[idx] || null;
            summaryChips.appendChild(
              createPalChip(parentPal, name || 'Unknown parent', {
                condensed: true,
                role: 'parent',
                meta: parentPal ? formatSteps(parentPal.id) : ''
              })
            );
          });
          pyramid.appendChild(summaryChips);
          pairWrap.appendChild(pyramid);
          const parentGrid = document.createElement('div');
          parentGrid.className = 'breeding-branch__parent-grid';
          pairWrap.appendChild(parentGrid);
          (recipe.names || []).forEach((name, idx) => {
            const parentPal = recipe.pals?.[idx] || null;
            const parentWrap = document.createElement('div');
            parentWrap.className = 'breeding-branch__parent';
            if (parentPal) {
              const card = createPalCard(parentPal, {
                compact: false,
                selectable: true,
                selected: selectedAtlas && selectedAtlas.id === parentPal.id
              });
              card.addEventListener('click', () => {
                selectedAtlas = parentPal;
                updateBreedingSelection();
                atlasSearch.value = '';
                renderAtlasGrid();
                renderAtlasDiagram();
                playSound(clickSound);
              });
              parentWrap.appendChild(card);
              const status = document.createElement('p');
              status.className = 'breeding-branch__notice';
              status.textContent = formatSteps(parentPal.id);
              parentWrap.appendChild(status);
              if (visited.has(parentPal.id)) {
                const loop = document.createElement('p');
                loop.className = 'breeding-branch__notice';
                loop.textContent = kidMode
                  ? 'Loop spotted—stop here.'
                  : 'Loop detected in breeding chain; stopping recursion.';
                parentWrap.appendChild(loop);
              } else if (depth + 1 >= MAX_ATLAS_DEPTH) {
                const truncated = document.createElement('p');
                truncated.className = 'breeding-branch__notice';
                truncated.textContent = kidMode
                  ? 'Tree trimmed for space.'
                  : 'Further ancestry hidden for readability—expand via atlas search.';
                parentWrap.appendChild(truncated);
              } else {
                const nextVisited = new Set(visited);
                nextVisited.add(parentPal.id);
                const childBranches = buildAtlasBranches(parentPal, depth + 1, nextVisited);
                if (childBranches) {
                  const childWrap = document.createElement('div');
                  childWrap.className = 'breeding-branch__children';
                  childWrap.appendChild(childBranches);
                  parentWrap.appendChild(childWrap);
                }
              }
            } else {
              parentWrap.appendChild(
                createPalChip(null, name || 'Unknown parent', {
                  condensed: true
                })
              );
              const missing = document.createElement('p');
              missing.className = 'breeding-branch__notice';
              missing.textContent = kidMode
                ? 'Parent info missing.'
                : 'Parent data unavailable in current dataset.';
              parentWrap.appendChild(missing);
            }
            parentGrid.appendChild(parentWrap);
          });
          fragment.appendChild(branch);
        });
        return fragment;
      }

      function renderAtlasDiagram() {
        atlasDiagram.innerHTML = '';
        atlasEmpty.hidden = true;
        if (!selectedAtlas) {
          atlasEmpty.hidden = false;
          atlasEmpty.textContent = kidMode
            ? 'Pick a pal on the left to see their family tree.'
            : 'Select a pal to trace every breeding route that produces it.';
          return;
        }
        atlasDiagram.appendChild(createAtlasFocus(selectedAtlas));
        const branchesWrap = document.createElement('div');
        branchesWrap.className = 'breeding-tree__branches';
        const branchFragment = buildAtlasBranches(selectedAtlas, 0, new Set([selectedAtlas.id]));
        if (branchFragment) {
          branchesWrap.appendChild(branchFragment);
        } else {
          const note = document.createElement('p');
          note.className = 'breeding-branch__notice';
          note.textContent = kidMode
            ? 'No breeding recipes recorded yet.'
            : 'We do not have breeding recipes for this pal yet.';
          branchesWrap.appendChild(note);
        }
        atlasDiagram.appendChild(branchesWrap);
      }

      function filterPals(term) {
        const normalized = (term || '').trim().toLowerCase();
        if (!normalized) return palsSorted.slice();
        return palsSorted.filter(pal => {
          const nameMatch = pal.name.toLowerCase().includes(normalized);
          const typeMatch = Array.isArray(pal.types) && pal.types.some(type => type && type.toLowerCase().includes(normalized));
          return nameMatch || typeMatch;
        });
      }

      function renderParentGrid(slot) {
        const grid = slot === 'parent1' ? parent1Grid : parent2Grid;
        const searchTerm = slot === 'parent1' ? parent1Search.value : parent2Search.value;
        grid.innerHTML = '';
        if (!palsSorted.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        const selected = slot === 'parent1' ? parentState.parent1 : parentState.parent2;
        let matches = filterPals(searchTerm);
        if (selected && !matches.some(p => p.id === selected.id)) {
          matches = [selected, ...matches];
        }
        if (!matches.length) {
          grid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'No pals match your search yet.'));
          return;
        }
        matches.forEach(pal => {
          const isSelected = selected && selected.id === pal.id;
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: isSelected
          });
          card.addEventListener('click', () => {
            const alreadySelected = slot === 'parent1'
              ? parentState.parent1 && parentState.parent1.id === pal.id
              : parentState.parent2 && parentState.parent2.id === pal.id;
            if (slot === 'parent1') {
              parentState.parent1 = alreadySelected ? null : pal;
            } else {
              parentState.parent2 = alreadySelected ? null : pal;
            }
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
          });
          grid.appendChild(card);
        });
      }

      function updateParentGrids() {
        renderParentGrid('parent1');
        renderParentGrid('parent2');
      }

      function renderBabyGrid() {
        babyGrid.innerHTML = '';
        if (!palsSorted.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'Loading pals…' : 'Breeding data is still loading.'));
          return;
        }
        let matches = filterPals(babySearch.value);
        if (selectedBaby && !matches.some(p => p.id === selectedBaby.id)) {
          matches = [selectedBaby, ...matches];
        }
        if (!matches.length) {
          babyGrid.appendChild(makeEmptyMessage(kidMode ? 'No pals match that search.' : 'Try a different pal search.'));
          return;
        }
        matches.forEach(pal => {
          const card = createPalCard(pal, {
            compact: true,
            selectable: true,
            selected: selectedBaby && selectedBaby.id === pal.id
          });
          card.addEventListener('click', () => {
            if (selectedBaby && selectedBaby.id === pal.id) {
              selectedBaby = null;
            } else {
              selectedBaby = pal;
            }
            updateBreedingSelection();
            renderBabyGrid();
            showCombos();
          });
          babyGrid.appendChild(card);
        });
      }

      function showCombos() {
        combosContainer.innerHTML = '';
        if (!selectedBaby) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'Pick a pal above to see recipes.' : 'Select a pal to see which parents can produce it.'));
          return;
        }
        const header = document.createElement('div');
        header.className = 'breeding-baby-header';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? `Make ${selectedBaby.name}` : `Parent combos for ${selectedBaby.name}`;
        header.appendChild(heading);
        header.appendChild(
          createPalChip(selectedBaby, selectedBaby.name, {
            role: 'child',
            meta: formatSteps(selectedBaby.id)
          })
        );
        combosContainer.appendChild(header);
        const combos = Array.isArray(analysis?.recipeMap?.[selectedBaby.id])
          ? analysis.recipeMap[selectedBaby.id]
          : [];
        if (!combos.length) {
          combosContainer.appendChild(makeEmptyMessage(kidMode ? 'No combos known yet.' : 'We do not have recorded breeding pairs for this pal yet.'));
          return;
        }
        combos.forEach(recipe => {
          const names = Array.isArray(recipe?.names) ? recipe.names : [];
          if (!names.length) return;
          const parents = Array.isArray(recipe?.parents) ? recipe.parents : [];
          const pals = Array.isArray(recipe?.pals) ? recipe.pals : [];
          const [leftId, rightId] = parents;
          const leftPal = pals[0] || (leftId != null ? PALS[leftId] : null);
          const rightPal = pals[1] || (rightId != null ? PALS[rightId] : null);
          const leftName = names[0] || (leftPal ? leftPal.name : 'Unknown');
          const rightName = names[1] || (rightPal ? rightPal.name : 'Unknown');
          const canActivate = parents.length >= 2 && parents.every(id => id != null);
          const row = document.createElement('div');
          row.className = 'breeding-combo';
          if (canActivate) {
            row.setAttribute('role', 'button');
            row.tabIndex = 0;
            row.setAttribute(
              'aria-label',
              kidMode
                ? `Use ${leftName} and ${rightName} together`
                : `Breed ${leftName} with ${rightName} to hatch ${selectedBaby.name}`
            );
          } else {
            row.classList.add('breeding-combo--disabled');
            row.setAttribute('aria-disabled', 'true');
          }
          const activateCombo = () => {
            if (!canActivate) return;
            if (leftPal) parentState.parent1 = leftPal;
            if (rightPal) parentState.parent2 = rightPal;
            updateBreedingSelection();
            updateParentGrids();
            updateResult();
            switchBreedingMode('breedingPairs');
            playSound(clickSound);
          };
          row.appendChild(createComboCard(leftPal, leftName));
          const plus = document.createElement('div');
          plus.className = 'combo-arrow';
          plus.textContent = '+';
          row.appendChild(plus);
          row.appendChild(createComboCard(rightPal, rightName));
          const arrow = document.createElement('div');
          arrow.className = 'combo-arrow';
          arrow.textContent = '→';
          row.appendChild(arrow);
          row.appendChild(
            createPalChip(selectedBaby, selectedBaby.name, {
              role: 'child',
              meta: formatSteps(selectedBaby.id)
            })
          );
          if (canActivate) {
            row.addEventListener('click', activateCombo);
            row.addEventListener('keydown', event => {
              if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                activateCombo();
              }
            });
          }
          combosContainer.appendChild(row);
        });
      }

      function findPredictedBaby() {
        if (!parentState.parent1 || !parentState.parent2) return null;
        const power1 = parentState.parent1.breeding && typeof parentState.parent1.breeding.power === 'number'
          ? parentState.parent1.breeding.power
          : 0;
        const power2 = parentState.parent2.breeding && typeof parentState.parent2.breeding.power === 'number'
          ? parentState.parent2.breeding.power
          : 0;
        const avgPower = Math.floor((power1 + power2) / 2);
        let closest = null;
        let diff = Infinity;
        Object.values(PALS).forEach(p => {
          const power = p.breeding && typeof p.breeding.power === 'number' ? p.breeding.power : 0;
          const delta = Math.abs(power - avgPower);
          if (delta < diff) {
            diff = delta;
            closest = p;
          }
        });
        return { baby: closest, avgPower };
      }

      function updateResult() {
        result.innerHTML = '';
        if (!parentState.parent1 || !parentState.parent2) {
          result.appendChild(makeEmptyMessage(kidMode ? 'Pick two pals to guess the baby.' : 'Select two parents to see the likely offspring.'));
          return;
        }
        const prediction = findPredictedBaby();
        const baby = prediction ? prediction.baby : null;
        const avgPower = prediction ? prediction.avgPower : 0;
        const flow = document.createElement('div');
        flow.className = 'breeding-flow';
        flow.appendChild(
          createPalChip(parentState.parent1, parentState.parent1?.name, {
            role: 'parent',
            meta: parentState.parent1 ? formatSteps(parentState.parent1.id) : ''
          })
        );
        const plus = document.createElement('div');
        plus.className = 'combo-arrow';
        plus.textContent = '+';
        flow.appendChild(plus);
        flow.appendChild(
          createPalChip(parentState.parent2, parentState.parent2?.name, {
            role: 'parent',
            meta: parentState.parent2 ? formatSteps(parentState.parent2.id) : ''
          })
        );
        const arrow = document.createElement('div');
        arrow.className = 'combo-arrow';
        arrow.textContent = '→';
        flow.appendChild(arrow);
        if (baby) {
          flow.appendChild(
            createPalChip(baby, baby.name, {
              role: 'child',
              meta: formatSteps(baby.id)
            })
          );
        } else {
          const placeholder = document.createElement('div');
          placeholder.classList.add('empty-state');
          placeholder.textContent = kidMode ? 'Unknown baby' : 'No matching baby yet';
          flow.appendChild(placeholder);
        }
        result.appendChild(flow);
        const tip = document.createElement('p');
        tip.className = 'breeding-tip';
        if (baby) {
          const babyPower = baby && baby.breeding && typeof baby.breeding.power === 'number' ? baby.breeding.power : 'Unknown';
          tip.innerHTML = kidMode
            ? `This pair is most likely to make <strong>${baby.name}</strong>. Pop a Cake into the box before you leave.`
            : `The parents average to breeding power ${avgPower}. That lines up closest with <strong>${baby.name}</strong> (Power ${babyPower}). Drop a Cake in the box to start incubation.`;
          result.appendChild(tip);
          const combosBtn = document.createElement('button');
          combosBtn.type = 'button';
          combosBtn.className = 'breeding-combo-link';
          combosBtn.textContent = kidMode ? 'Show how to make this pal' : 'See breeding combinations';
          combosBtn.addEventListener('click', () => {
            if (!baby) return;
            selectedBaby = baby;
            updateBreedingSelection();
            babySearch.value = '';
            renderBabyGrid();
            showCombos();
            switchBreedingMode('breedingDiscover');
            playSound(clickSound);
          });
          result.appendChild(combosBtn);
        } else {
          tip.textContent = kidMode ? 'We do not know the baby for this pair yet.' : 'We could not find a pal that matches this breeding power. Try another combination!';
          result.appendChild(tip);
        }
      }

      function switchBreedingMode(targetId) {
        modes.forEach(mode => {
          const isActive = mode.id === targetId;
          mode.classList.toggle('active', isActive);
          mode.setAttribute('aria-hidden', isActive ? 'false' : 'true');
          mode.setAttribute('tabindex', isActive ? '0' : '-1');
        });
        modeButtons.forEach(btn => {
          const isActive = btn.dataset.target === targetId;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
          btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
        BREEDING_SELECTION.mode = targetId;
      }

      const savedMode = BREEDING_SELECTION.mode || 'breedingAdvisor';
      const availableModes = modes.map(mode => mode.id);
      const initialMode = availableModes.includes(savedMode) ? savedMode : 'breedingAdvisor';

      modeButtons.forEach(btn => {
        btn.onclick = () => {
          const target = btn.dataset.target;
          switchBreedingMode(target);
          playSound(clickSound);
        };
      });

      parent1Search.oninput = () => renderParentGrid('parent1');
      parent2Search.oninput = () => renderParentGrid('parent2');
      babySearch.oninput = () => renderBabyGrid();
      atlasSearch.oninput = () => renderAtlasGrid();

      const refreshBreedingViews = ({ refreshAnalysis = false } = {}) => {
        renderAdvisor({ refreshAnalysis });
        updateParentGrids();
        renderBabyGrid();
        showCombos();
        updateResult();
        renderAtlasGrid();
        renderAtlasDiagram();
        updateBreedingSelection();
      };

      currentBreedingPageController = {
        refresh: refreshBreedingViews
      };

      refreshBreedingViews({ refreshAnalysis: true });
      switchBreedingMode(initialMode);
    }

    // Home page builder.  Highlights adaptive guidance, quick status,
    // and provides rapid jumps into the planner or progress dashboard.
    function buildHomePage() {
      const home = document.getElementById('homeCards');
      if (!home) return;
      home.innerHTML = '';

      function createModeCard(mode) {
        const card = document.createElement('article');
        card.className = 'mode-card';
        card.dataset.modeCard = mode;

        const status = document.createElement('span');
        status.className = 'mode-card__status';
        status.textContent = mode === 'kid' ? 'Kid mode' : 'Grown-up mode';
        card.appendChild(status);

        const title = document.createElement('h3');
        title.textContent = mode === 'kid' ? 'Kid Mode' : 'Grown-up Mode';
        card.appendChild(title);

        const desc = document.createElement('p');
        desc.textContent = mode === 'kid'
          ? 'Friendly wording, brighter cues, and extra encouragement for younger Trainers.'
          : 'Full strategy notes, numbers, and context for planners and veteran captains.';
        card.appendChild(desc);

        const features = document.createElement('ul');
        features.className = 'mode-card__features';
        const featureLines = mode === 'kid'
          ? [
              'Simple story language for every guide step.',
              'Large buttons with gentle colours and icons.',
              'Positive reminders instead of intimidating jargon.'
            ]
          : [
              'Detailed boss prep, resistances, and combat notes.',
              'Full material lists and supporting sub-routes.',
              'Context for breeding, tech rushes, and co-op splits.'
            ];
        featureLines.forEach(line => {
          const li = document.createElement('li');
          li.textContent = line;
          features.appendChild(li);
        });
        card.appendChild(features);

        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'btn btn--ghost mode-card__button';
        button.dataset.modeChoice = mode;
        button.textContent = mode === 'kid' ? 'Switch to Kid Mode' : 'Switch to Grown-up Mode';
        button.addEventListener('click', () => {
          const desired = mode === 'kid';
          const requiresRebuild = kidMode !== desired;
          setKidMode(desired, { rebuild: requiresRebuild });
          playSound(clickSound);
          switchPage('home');
        });
        card.appendChild(button);

        return card;
      }

      function createProgressCard(type) {
        const card = document.createElement('article');
        card.className = 'home-progress-card';

        const header = document.createElement('div');
        header.className = 'home-progress-card__header';
        const iconWrap = document.createElement('div');
        iconWrap.className = 'home-progress-card__icon';
        const icon = document.createElement('i');
        icon.className = 'fa-solid fa-compass';
        iconWrap.appendChild(icon);
        header.appendChild(iconWrap);

        const headerText = document.createElement('div');
        const title = document.createElement('h3');
        const subtitle = document.createElement('p');

        headerText.appendChild(title);
        headerText.appendChild(subtitle);
        header.appendChild(headerText);
        card.appendChild(header);

        const meter = document.createElement('div');
        meter.className = 'home-progress-meter';
        meter.setAttribute('role', 'progressbar');
        meter.setAttribute('aria-valuemin', '0');
        meter.setAttribute('aria-valuemax', '100');
        meter.setAttribute('aria-valuenow', '0');
        const fill = document.createElement('div');
        fill.className = 'fill';
        const progressText = document.createElement('div');
        progressText.className = 'home-progress-text';
        progressText.setAttribute('aria-live', 'polite');
        const nextButton = document.createElement('button');
        nextButton.type = 'button';
        nextButton.className = 'home-progress-link home-progress-next';
        nextButton.disabled = true;
        const actions = document.createElement('div');
        actions.className = 'home-progress-actions';
        const actionBtn = document.createElement('button');
        actionBtn.type = 'button';
        actionBtn.className = 'btn';

        if (type === 'route') {
          icon.className = 'fa-solid fa-map-location-dot';
          title.textContent = kidMode ? 'Adaptive Route Guide' : 'Adaptive Route Guide';
          subtitle.textContent = kidMode
            ? 'Track main chapters, boss wins, and story quests together.'
            : 'Monitor required steps, boss clears, and story & optional quests before the system lines up your next priority.';
          meter.id = 'homeRouteProgressMeter';
          meter.setAttribute('aria-label', 'Route guide progress');
          fill.id = 'homeRouteProgressBar';
          progressText.id = 'homeRouteProgressText';
          nextButton.id = 'homeRouteNextStep';
          nextButton.textContent = kidMode ? 'Loading next guide step…' : 'Loading next guide step…';
          nextButton.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open the guide' : 'Open route guide';
          actionBtn.addEventListener('click', () => {
            const stepId = nextButton.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
        } else if (type === 'pals') {
          icon.className = 'fa-solid fa-paw';
          title.textContent = kidMode ? 'Pal Squad Tracker' : 'Pal collection';
          subtitle.textContent = kidMode
            ? 'Mark pals as caught and celebrate new friends.'
            : 'See how many pals you have registered so far.';
          meter.id = 'homePalsProgressMeter';
          meter.setAttribute('aria-label', 'Pal collection progress');
          fill.id = 'homePalsProgressBar';
          progressText.id = 'homePalsProgressText';
          nextButton.id = 'homePalsNext';
          nextButton.textContent = kidMode ? 'Loading pal reminder…' : 'Loading pal reminder…';
          nextButton.addEventListener('click', () => {
            const palId = nextButton.dataset.palId;
            if (palId && PALS[palId]) {
              showPalDetail(palId);
            } else {
              switchPage('pals');
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open pal list' : 'Go to pal tracker';
          actionBtn.addEventListener('click', () => {
            switchPage('pals');
            playSound(clickSound);
          });
        } else if (type === 'tech') {
          icon.className = 'fa-solid fa-screwdriver-wrench';
          title.textContent = kidMode ? 'Workshop Technology' : 'Technology progress';
          subtitle.textContent = kidMode
            ? 'Peek at what inventions are still locked.'
            : 'Review how many blueprints remain.';
          meter.id = 'homeTechProgressMeter';
          meter.setAttribute('aria-label', 'Technology progress');
          fill.id = 'homeTechProgressBar';
          progressText.id = 'homeTechProgressText';
          nextButton.id = 'homeTechNext';
          nextButton.textContent = kidMode ? 'Loading tech reminder…' : 'Loading tech reminder…';
          nextButton.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
          actionBtn.textContent = kidMode ? 'Open tech tree' : 'View tech tree';
          actionBtn.addEventListener('click', () => {
            const techKey = nextButton.dataset.techKey;
            switchPage('tech');
            if (techKey) {
              queueTechFocus(techKey);
            }
            playSound(clickSound);
          });
        } else {
          card.classList.add('home-progress-card--queue');
          icon.className = 'fa-solid fa-layer-group';
          title.textContent = kidMode ? 'Tonight’s queue' : 'Adaptive queue';
          subtitle.textContent = kidMode
            ? 'Pin adventures from the planner to keep them front and centre.'
            : 'Pinned adaptive guides stay here for quick hops back in.';
          const list = document.createElement('ul');
          list.className = 'adaptive-queue';
          list.id = 'homeActiveQueue';
          const placeholder = document.createElement('li');
          placeholder.className = 'adaptive-queue__item';
          const placeholderMeta = document.createElement('div');
          placeholderMeta.className = 'adaptive-queue__meta';
          const placeholderTitle = document.createElement('p');
          placeholderTitle.className = 'adaptive-queue__title';
          placeholderTitle.textContent = kidMode ? 'Queue loading…' : 'Queue loading…';
          const placeholderStats = document.createElement('p');
          placeholderStats.className = 'adaptive-queue__stats';
          placeholderStats.textContent = kidMode
            ? 'Add an adventure from the planner to see it here.'
            : 'Pick a guide in the planner and it will appear here.';
          placeholderMeta.appendChild(placeholderTitle);
          placeholderMeta.appendChild(placeholderStats);
          placeholder.appendChild(placeholderMeta);
          list.appendChild(placeholder);
          card.appendChild(list);
          const manageBtn = document.createElement('button');
          manageBtn.type = 'button';
          manageBtn.className = 'adaptive-queue__cta';
          manageBtn.textContent = kidMode ? 'Manage queue' : 'Manage queue';
          manageBtn.addEventListener('click', () => {
            switchPage('route');
            playSound(clickSound);
          });
          card.appendChild(manageBtn);
          return card;
        }

        meter.appendChild(fill);
        card.appendChild(meter);
        progressText.textContent = kidMode ? 'Loading progress…' : 'Loading progress…';
        card.appendChild(progressText);
        nextButton.disabled = true;
        card.appendChild(nextButton);
        actions.appendChild(actionBtn);
        card.appendChild(actions);
        return card;
      }

      const hero = document.createElement('section');
      hero.className = 'home-section home-hero';
      const intro = document.createElement('div');
      intro.className = 'home-hero__intro';
      const eyebrow = document.createElement('span');
      eyebrow.className = 'home-hero__eyebrow';
      eyebrow.innerHTML = '<i class="fa-solid fa-wand-magic-sparkles"></i> Adaptive guide';
      intro.appendChild(eyebrow);
      const headline = document.createElement('h3');
      headline.id = 'homeAdaptiveHeadline';
      headline.textContent = kidMode ? 'Loading your adaptive plan…' : 'Loading your adaptive plan…';
      intro.appendChild(headline);
      const subhead = document.createElement('p');
      subhead.id = 'homeAdaptiveSubhead';
      subhead.textContent = kidMode
        ? 'Palmate is lining up the perfect adventures for tonight. Once your data loads, we’ll highlight the next big step.'
        : 'Palmate is warming up your adaptive queue. We’ll summarise your current stage and next objective in a moment.';
      intro.appendChild(subhead);
      const actions = document.createElement('div');
      actions.className = 'home-hero__actions';
      const plannerBtn = document.createElement('button');
      plannerBtn.type = 'button';
      plannerBtn.className = 'btn';
      plannerBtn.textContent = kidMode ? 'Open adaptive planner' : 'Open adaptive planner';
      plannerBtn.addEventListener('click', () => {
        switchPage('route');
        playSound(clickSound);
      });
      const progressBtn = document.createElement('button');
      progressBtn.type = 'button';
      progressBtn.className = 'btn btn--ghost';
      progressBtn.textContent = kidMode ? 'View progress dashboard' : 'View progress dashboard';
      progressBtn.addEventListener('click', () => {
        switchPage('progress');
        playSound(clickSound);
      });
      actions.appendChild(plannerBtn);
      actions.appendChild(progressBtn);
      intro.appendChild(actions);
      hero.appendChild(intro);
      const modeWrap = document.createElement('div');
      modeWrap.className = 'home-hero__mode';
      const modeLabel = document.createElement('span');
      modeLabel.className = 'home-hero__mode-label';
      modeLabel.textContent = kidMode
        ? 'How should Palmate speak to you?'
        : 'Choose your presentation style';
      const modeToggle = document.createElement('div');
      modeToggle.className = 'mode-toggle';
      modeToggle.appendChild(createModeCard('kid'));
      modeToggle.appendChild(createModeCard('grown'));
      modeWrap.appendChild(modeLabel);
      modeWrap.appendChild(modeToggle);
      hero.appendChild(modeWrap);

      const panel = document.createElement('div');
      panel.className = 'home-hero__panel';
      const focusCard = document.createElement('article');
      focusCard.className = 'home-focus-card';
      const focusBadge = document.createElement('span');
      focusBadge.className = 'home-focus-card__badge';
      focusBadge.innerHTML = '<i class="fa-solid fa-route"></i> Next priority';
      const focusTitle = document.createElement('h4');
      focusTitle.id = 'homeHeroFocusTitle';
      focusTitle.textContent = kidMode ? 'We are charting your next step…' : 'Preparing your next objective…';
      const focusCopy = document.createElement('p');
      focusCopy.id = 'homeHeroFocusCopy';
      focusCopy.textContent = kidMode
        ? 'As soon as the adaptive guide loads we will highlight the next big milestone.'
        : 'Once the adaptive data is ready, you’ll see the upcoming milestone and context here.';
      const focusMeter = document.createElement('div');
      focusMeter.className = 'home-focus-meter';
      focusMeter.id = 'homeHeroFocusMeter';
      focusMeter.setAttribute('role', 'progressbar');
      focusMeter.setAttribute('aria-valuemin', '0');
      focusMeter.setAttribute('aria-valuemax', '100');
      focusMeter.setAttribute('aria-valuenow', '0');
      const focusFill = document.createElement('div');
      focusFill.className = 'fill';
      focusFill.id = 'homeHeroFocusFill';
      focusMeter.appendChild(focusFill);
      const focusActions = document.createElement('div');
      focusActions.className = 'home-focus-actions';
      const resumeBtn = document.createElement('button');
      resumeBtn.type = 'button';
      resumeBtn.className = 'btn';
      resumeBtn.id = 'homeHeroResume';
      resumeBtn.textContent = kidMode ? 'Resume next step' : 'Resume next step';
      resumeBtn.disabled = true;
      resumeBtn.addEventListener('click', () => {
        const stepId = resumeBtn.dataset.stepId;
        switchPage('route');
        if (stepId) {
          queueRouteFocus(stepId);
        }
        playSound(clickSound);
      });
      focusActions.appendChild(resumeBtn);
      focusCard.appendChild(focusBadge);
      focusCard.appendChild(focusTitle);
      focusCard.appendChild(focusCopy);
      focusCard.appendChild(focusMeter);
      focusCard.appendChild(focusActions);
      panel.appendChild(focusCard);
      hero.appendChild(panel);
      home.appendChild(hero);

      const progressSection = document.createElement('section');
      progressSection.className = 'home-section home-progress';
      const progressHeader = document.createElement('div');
      progressHeader.className = 'home-section-header';
      progressHeader.innerHTML = kidMode
        ? '<h3>Your adaptive status</h3><p>Peek at your route progress, active queue, pal roster, and workshop research in one glance.</p>'
        : '<h3>Adaptive status overview</h3><p>Track route milestones, pinned guides, pal collection, and technology momentum before you dive back in.</p>';
      progressSection.appendChild(progressHeader);
      const progressGrid = document.createElement('div');
      progressGrid.className = 'home-progress-grid';
      ['route', 'queue', 'pals', 'tech'].forEach(type => {
        progressGrid.appendChild(createProgressCard(type));
      });
      progressSection.appendChild(progressGrid);
      home.appendChild(progressSection);

      const breedingSection = document.createElement('section');
      breedingSection.className = 'home-section home-breeding';
      const breedingHeader = document.createElement('div');
      breedingHeader.className = 'home-section-header';
      breedingHeader.innerHTML = kidMode
        ? '<h3>Breeding intelligence</h3><p>Unlock smarter egg plans, parent reminders, and quick jumps once the farm is live.</p>'
        : '<h3>Adaptive breeding intelligence</h3><p>Surface smart hatch targets, parent readiness, and shortcuts into the advisor.</p>';
      breedingSection.appendChild(breedingHeader);

      const breedingCard = document.createElement('article');
      breedingCard.className = 'home-breeding-card';
      breedingCard.id = 'homeBreedingIntel';
      breedingCard.dataset.state = 'loading';

      const breedingCardHeader = document.createElement('div');
      breedingCardHeader.className = 'home-breeding-card__header';
      const breedingIconWrap = document.createElement('div');
      breedingIconWrap.className = 'home-breeding-card__icon';
      const breedingIcon = document.createElement('i');
      breedingIcon.className = 'fa-solid fa-egg';
      breedingIconWrap.appendChild(breedingIcon);
      breedingCardHeader.appendChild(breedingIconWrap);
      const breedingHeaderText = document.createElement('div');
      const breedingTitle = document.createElement('h3');
      breedingTitle.className = 'home-breeding-card__title';
      breedingTitle.textContent = kidMode ? 'Smart egg planner' : 'Smart egg planner';
      const breedingSubtitle = document.createElement('p');
      breedingSubtitle.className = 'home-breeding-card__subtitle';
      breedingSubtitle.textContent = kidMode
        ? 'We track your pals and tech to highlight the best hatch targets and parents.'
        : 'Palmate analyses unlocks, caught pals, and partner skills to shortlist high-value hatches.';
      breedingHeaderText.appendChild(breedingTitle);
      breedingHeaderText.appendChild(breedingSubtitle);
      breedingCardHeader.appendChild(breedingHeaderText);
      breedingCard.appendChild(breedingCardHeader);

      const breedingStatus = document.createElement('p');
      breedingStatus.id = 'homeBreedingStatus';
      breedingStatus.className = 'home-breeding-status';
      breedingStatus.textContent = kidMode
        ? 'Checking breeding unlocks…'
        : 'Analysing breeding readiness…';
      breedingCard.appendChild(breedingStatus);

      const breedingList = document.createElement('ul');
      breedingList.id = 'homeBreedingList';
      breedingList.className = 'home-breeding-list';
      breedingCard.appendChild(breedingList);

      const breedingActions = document.createElement('div');
      breedingActions.className = 'home-breeding-actions';
      const breedingPlanBtn = document.createElement('button');
      breedingPlanBtn.type = 'button';
      breedingPlanBtn.className = 'btn';
      breedingPlanBtn.id = 'homeBreedingPlan';
      breedingPlanBtn.disabled = true;
      breedingPlanBtn.textContent = kidMode ? 'Plan this egg' : 'Plan recommended combo';
      breedingActions.appendChild(breedingPlanBtn);
      const breedingAtlasBtn = document.createElement('button');
      breedingAtlasBtn.type = 'button';
      breedingAtlasBtn.className = 'btn btn--ghost';
      breedingAtlasBtn.id = 'homeBreedingAtlas';
      breedingAtlasBtn.disabled = true;
      breedingAtlasBtn.textContent = kidMode ? 'View family tree' : 'View ancestry tree';
      breedingActions.appendChild(breedingAtlasBtn);
      const breedingAdvisorBtn = document.createElement('button');
      breedingAdvisorBtn.type = 'button';
      breedingAdvisorBtn.className = 'home-progress-link';
      breedingAdvisorBtn.id = 'homeBreedingAdvisor';
      breedingAdvisorBtn.textContent = kidMode ? 'Open breeding advisor' : 'Open breeding advisor';
      breedingActions.appendChild(breedingAdvisorBtn);
      const breedingUnlockBtn = document.createElement('button');
      breedingUnlockBtn.type = 'button';
      breedingUnlockBtn.className = 'btn';
      breedingUnlockBtn.id = 'homeBreedingUnlock';
      breedingUnlockBtn.hidden = true;
      breedingUnlockBtn.textContent = kidMode ? 'See unlock step' : 'Jump to unlock step';
      breedingActions.appendChild(breedingUnlockBtn);
      breedingCard.appendChild(breedingActions);

      breedingSection.appendChild(breedingCard);
      home.appendChild(breedingSection);

      const spotlight = document.createElement('section');
      spotlight.className = 'home-section home-spotlight';
      const spotlightHeader = document.createElement('div');
      spotlightHeader.className = 'home-section-header';
      spotlightHeader.innerHTML = kidMode
        ? '<h3>Pal spotlight</h3><p>Here’s a pal to chase next based on your adaptive progress.</p>'
        : '<h3>Pal spotlight</h3><p>Adaptive reminders surface the pal that advances your current goals.</p>';
      spotlight.appendChild(spotlightHeader);
      const spotlightBtn = document.createElement('button');
      spotlightBtn.type = 'button';
      spotlightBtn.className = 'home-spotlight-card';
      spotlightBtn.id = 'homePalSpotlight';
      spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Loading pal…</span><span class="home-spotlight-card__meta">We’ll suggest a buddy soon.</span></div>';
      spotlightBtn.addEventListener('click', () => {
        const palId = spotlightBtn.dataset.palId;
        if (palId && PALS[palId]) {
          showPalDetail(palId);
        } else {
          switchPage('pals');
        }
        playSound(clickSound);
      });
      spotlight.appendChild(spotlightBtn);
      home.appendChild(spotlight);

      refreshModeUI();
      updateHomeBreedingIntel({ refresh: true });
    }

    function updateHomeBreedingIntel({ refresh = false } = {}) {
      const card = document.getElementById('homeBreedingIntel');
      const statusEl = document.getElementById('homeBreedingStatus');
      const listEl = document.getElementById('homeBreedingList');
      const planBtn = document.getElementById('homeBreedingPlan');
      const atlasBtn = document.getElementById('homeBreedingAtlas');
      const advisorBtn = document.getElementById('homeBreedingAdvisor');
      const unlockBtn = document.getElementById('homeBreedingUnlock');
      if (!card || !statusEl || !listEl) return;

      const visibleButtons = [planBtn, atlasBtn];
      visibleButtons.forEach(btn => {
        if (!btn) return;
        btn.hidden = false;
        btn.disabled = true;
        btn.onclick = null;
      });
      if (advisorBtn) {
        advisorBtn.disabled = false;
        advisorBtn.onclick = () => {
          BREEDING_SELECTION.parent1Id = null;
          BREEDING_SELECTION.parent2Id = null;
          BREEDING_SELECTION.babyId = null;
          BREEDING_SELECTION.atlasId = null;
          BREEDING_SELECTION.mode = 'breedingAdvisor';
          buildBreedingPage();
          switchPage('breeding');
          playSound(clickSound);
        };
      }
      if (unlockBtn) {
        unlockBtn.hidden = true;
        unlockBtn.disabled = false;
        unlockBtn.onclick = null;
      }
      listEl.innerHTML = '';

      const formatNameList = names => {
        const clean = Array.isArray(names) ? names.filter(Boolean) : [];
        if (!clean.length) return '';
        if (clean.length === 1) return clean[0];
        if (clean.length === 2) {
          return kidMode ? `${clean[0]} and ${clean[1]}` : `${clean[0]} & ${clean[1]}`;
        }
        const head = clean.slice(0, -1);
        const tail = clean[clean.length - 1];
        const joiner = kidMode ? ' and ' : ', and ';
        return `${head.join(', ')}${joiner}${tail}`;
      };

      const describeParentStatus = (entry, { verbose = false } = {}) => {
        const parentNames = Array.isArray(entry?.recipeNames) ? entry.recipeNames.filter(Boolean) : [];
        const parentIds = Array.isArray(entry?.recipeParents) ? entry.recipeParents : [];
        if (!parentNames.length) {
          return kidMode
            ? (verbose ? 'We are still learning the parents.' : 'Parents unknown')
            : (verbose ? 'Parent data is still being sourced.' : 'Parent data missing');
        }
        let hasUnknown = false;
        const statuses = parentNames.map((name, idx) => {
          const parentId = parentIds[idx];
          if (parentId == null) {
            hasUnknown = true;
            return { name, caught: false, known: false };
          }
          return { name, caught: !!caught[parentId], known: true };
        });
        if (hasUnknown) {
          return kidMode
            ? (verbose ? 'Parent intel is incomplete right now.' : 'Parents incomplete')
            : (verbose ? 'Parent intel is incomplete in the current dataset.' : 'Parents incomplete');
        }
        const missing = statuses.filter(entry => !entry.caught);
        if (!missing.length) {
          return kidMode
            ? (verbose ? 'Parents ready in your camp.' : 'Parents ready')
            : (verbose ? 'Both parents are already caught and ready to pair.' : 'Parents ready');
        }
        const missingNames = missing.map(entry => entry.name);
        const list = formatNameList(missingNames);
        if (verbose) {
          if (missing.length === statuses.length) {
            return kidMode
              ? `Catch ${list} to start hatching.`
              : `Catch ${list} before you queue this hatch.`;
          }
          return kidMode
            ? `Still need ${list} before you can hatch.`
            : `You still need ${list} before this combo is ready.`;
        }
        if (missing.length === statuses.length) {
          return kidMode ? `Need ${list}` : `Missing ${list}`;
        }
        return kidMode ? `Need ${list}` : `Missing ${list}`;
      };

      if (!isBreedingUnlocked()) {
        card.dataset.state = 'locked';
        statusEl.textContent = kidMode
          ? 'Build the Breeding Farm to unlock smart egg tips.'
          : 'Construct the Breeding Farm to unlock personalised breeding intelligence.';
        visibleButtons.forEach(btn => {
          if (btn) btn.hidden = true;
        });
        if (advisorBtn) advisorBtn.disabled = true;
        if (unlockBtn) {
          unlockBtn.hidden = false;
          unlockBtn.onclick = () => {
            const targetStep = BREEDING_ROUTE_STEP_IDS.find(id => id);
            switchPage('route');
            if (targetStep) {
              queueRouteFocus(targetStep);
            }
            playSound(clickSound);
          };
        }
        return;
      }

      const { suggestions } = generateBreedingAdvisorSuggestions({ kidMode, refresh });
      if (!suggestions.length) {
        card.dataset.state = 'empty';
        statusEl.textContent = kidMode
          ? 'Mark pals as caught so we can line up egg combos.'
          : 'Mark more pals as caught to surface actionable breeding combos.';
        visibleButtons.forEach(btn => {
          if (btn) btn.hidden = true;
        });
        return;
      }

      card.dataset.state = 'ready';
      const top = suggestions[0];
      statusEl.textContent = kidMode
        ? `Next hatch: ${top.pal.name}. ${describeParentStatus(top, { verbose: true })}`
        : `Priority hatch: ${top.pal.name}. ${describeParentStatus(top, { verbose: true })}`;

      suggestions.slice(0, 3).forEach((entry, index) => {
        const item = document.createElement('li');
        item.className = 'home-breeding-item';

        const title = document.createElement('div');
        title.className = 'home-breeding-item__title';
        title.textContent = `${index + 1}. ${entry.pal.name}`;
        item.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'home-breeding-item__meta';

        const stepsSpan = document.createElement('span');
        const stepsIcon = document.createElement('i');
        stepsIcon.className = 'fa-solid fa-diagram-project';
        stepsIcon.setAttribute('aria-hidden', 'true');
        stepsSpan.appendChild(stepsIcon);
        stepsSpan.appendChild(document.createTextNode(` ${entry.depthLabel}`));
        meta.appendChild(stepsSpan);

        const parentSpan = document.createElement('span');
        const parentIcon = document.createElement('i');
        parentIcon.className = 'fa-solid fa-people-arrows';
        parentIcon.setAttribute('aria-hidden', 'true');
        parentSpan.appendChild(parentIcon);
        parentSpan.appendChild(document.createTextNode(` ${describeParentStatus(entry)}`));
        meta.appendChild(parentSpan);

        item.appendChild(meta);

        const noteText = entry.note || entry.subtitle;
        if (noteText) {
          const note = document.createElement('p');
          note.className = 'home-breeding-item__note';
          note.textContent = noteText;
          item.appendChild(note);
        }
        listEl.appendChild(item);
      });

      if (planBtn) {
        const parentIds = Array.isArray(top.recipeParents) ? top.recipeParents : [];
        const hasParents = parentIds.length >= 2 && parentIds.every(id => id != null);
        planBtn.hidden = false;
        planBtn.disabled = !hasParents;
        if (hasParents) {
          planBtn.onclick = () => {
            BREEDING_SELECTION.parent1Id = parentIds[0];
            BREEDING_SELECTION.parent2Id = parentIds[1];
            BREEDING_SELECTION.babyId = top.pal.id;
            BREEDING_SELECTION.atlasId = top.pal.id;
            BREEDING_SELECTION.mode = 'breedingPairs';
            buildBreedingPage();
            switchPage('breeding');
            playSound(clickSound);
          };
        }
      }
      if (atlasBtn) {
        atlasBtn.hidden = false;
        atlasBtn.disabled = false;
        atlasBtn.onclick = () => {
          BREEDING_SELECTION.parent1Id = null;
          BREEDING_SELECTION.parent2Id = null;
          BREEDING_SELECTION.babyId = top.pal.id;
          BREEDING_SELECTION.atlasId = top.pal.id;
          BREEDING_SELECTION.mode = 'breedingAtlas';
          buildBreedingPage();
          switchPage('breeding');
          playSound(clickSound);
        };
      }
    }

  function runBaseBreedingRefresh() {
    const refreshAnalysis = baseBreedingNeedsAnalysis;
    baseBreedingNeedsAnalysis = false;
    updateBasePlanner();
    updateHomeBreedingIntel({ refresh: refreshAnalysis });
    if (currentBreedingPageController && typeof currentBreedingPageController.refresh === 'function') {
      currentBreedingPageController.refresh({ refreshAnalysis });
    }
  }

  function finishBaseBreedingRefresh() {
    baseBreedingRefreshHandle = null;
    baseBreedingRefreshUsingTimeout = false;
    runBaseBreedingRefresh();
  }

  function requestBaseBreedingRefresh({ refreshBreedingAnalysis = false, immediate = false } = {}) {
    if (refreshBreedingAnalysis) {
      baseBreedingNeedsAnalysis = true;
    }
    if (immediate) {
      if (baseBreedingRefreshHandle != null) {
        if (baseBreedingRefreshUsingTimeout) {
          clearTimeout(baseBreedingRefreshHandle);
        } else if (typeof cancelAnimationFrame === 'function') {
          cancelAnimationFrame(baseBreedingRefreshHandle);
        }
        baseBreedingRefreshHandle = null;
        baseBreedingRefreshUsingTimeout = false;
      }
      runBaseBreedingRefresh();
      return;
    }
    if (baseBreedingRefreshHandle != null) {
      return;
    }
    if (typeof requestAnimationFrame === 'function') {
      baseBreedingRefreshHandle = requestAnimationFrame(() => {
        finishBaseBreedingRefresh();
      });
      baseBreedingRefreshUsingTimeout = false;
    } else {
      baseBreedingRefreshUsingTimeout = true;
      baseBreedingRefreshHandle = setTimeout(() => {
        finishBaseBreedingRefresh();
      }, 16);
    }
  }

    const ROUTE_STORAGE_KEY = 'palmarathon:route:v1';
    const ROUTE_PREFS_KEY = 'palmarathon:route:prefs:v1';
    const ROUTE_CONTEXT_KEY = 'palmarathon:route:context:v1';
    const DEFAULT_ROUTE_CONTEXT = {
      declaredLevel: null,
      hardcore: false,
      coop: false,
      availableTimeMinutes: null,
      goals: [],
      resourceGaps: []
    };
    let routeGuideData = null;
    let routeState = loadRouteState();
    const initialRoutePrefs = loadRoutePreferences();
    let routeHideOptional = !!initialRoutePrefs.hideOptional;
    let routeHiddenCategories = new Set(Array.isArray(initialRoutePrefs.hiddenCategories)
      ? initialRoutePrefs.hiddenCategories
          .map(value => routeCategorySlug(value, { strict: true }))
          .filter(Boolean)
      : []);
    let routeContext = loadRouteContext();
    let routeGoalDrawerOpen = false;
    let routeOverviewCollapsed = initialRoutePrefs.overviewCollapsed != null
      ? !!initialRoutePrefs.overviewCollapsed
      : true;
    let routeSuggestionsCollapsed = initialRoutePrefs.suggestionsCollapsed != null
      ? !!initialRoutePrefs.suggestionsCollapsed
      : true;
    let guideCatalogSearchTerm = '';
    let guideCatalogGroupFilter = 'all';
    let guideCatalogCategoryFilter = 'all';
    let routeLibraryListAbort = null;
    let guideCatalogListAbort = null;
    let pendingRouteFocus = null;
    let pendingTechFocus = null;
    const ROUTE_ART_IMAGE = 'assets/images/palworld-full-map-2.webp';
    const ROUTE_LIBRARY_DEFAULT_LIMIT = Number.POSITIVE_INFINITY;
    const ROUTE_PREVIEW_STEP_LIMIT = 8;
    const ROUTE_THEME_ART_SOURCES = {
      generic: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/058bd87dc17a7179e07c446aa64d0574ca43ab9d/header.jpg?t=1759163961',
      pal: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_f81b7c4f20be3b99f76a1415c4cdb9b444c99b97.1920x1080.jpg?t=1759163961',
      tech: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_0c8cbc20442b948c91b02d9e1b41bf0638a07c08.1920x1080.jpg?t=1759163961',
      item: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_06e27c15c7b4b10233c937b887cf6a6925c83009.1920x1080.jpg?t=1759163961',
      boss: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_a9fa84f0c21bc536f00925ab4586e8c4f587c2b7.1920x1080.jpg?t=1759163961',
      npc: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_b3cea7c9f04a67d784d4c6a0c157a11d6268b189.1920x1080.jpg?t=1759163961',
      travel: ROUTE_ART_IMAGE,
      map: ROUTE_ART_IMAGE,
      mainStory: 'assets/images/routes/main-story-constellation.svg'
    };
    const ROUTE_VISUAL_THEMES = {
      pal: { image: ROUTE_THEME_ART_SOURCES.pal, overlay: 'rgba(119, 141, 169, 0.58)', accent: '#9bd4ff', icon: 'fa-paw', position: 'center 40%' },
      tech: { image: ROUTE_THEME_ART_SOURCES.tech, overlay: 'rgba(42, 157, 143, 0.58)', accent: '#72e5c4', icon: 'fa-microchip', position: 'center 48%' },
      item: { image: ROUTE_THEME_ART_SOURCES.item, overlay: 'rgba(255, 196, 77, 0.6)', accent: '#ffd166', icon: 'fa-sack', position: 'center 52%' },
      boss: { image: ROUTE_THEME_ART_SOURCES.boss, overlay: 'rgba(126, 87, 255, 0.62)', accent: '#d1b8ff', icon: 'fa-chess-king', position: 'center 18%' },
      map: { image: ROUTE_THEME_ART_SOURCES.map, overlay: 'rgba(118, 206, 255, 0.6)', accent: '#6fe7ff', icon: 'fa-map-location-dot', position: 'center 32%' },
      npc: { image: ROUTE_THEME_ART_SOURCES.npc, overlay: 'rgba(236, 72, 153, 0.5)', accent: '#f9a8d4', icon: 'fa-user-astronaut', position: 'center 45%' },
      generic: { image: ROUTE_THEME_ART_SOURCES.generic, overlay: 'rgba(148, 187, 233, 0.55)', accent: '#9bd4ff', icon: 'fa-route', position: 'center 40%' }
    };
    const GUIDE_CATALOG_THEME_MAP = {
      missions: { overlay: ROUTE_VISUAL_THEMES.map.overlay, accent: ROUTE_VISUAL_THEMES.map.accent, icon: 'fa-map-signs', position: ROUTE_VISUAL_THEMES.map.position },
      resources: { overlay: ROUTE_VISUAL_THEMES.item.overlay, accent: ROUTE_VISUAL_THEMES.item.accent, icon: 'fa-seedling', position: ROUTE_VISUAL_THEMES.item.position },
      capturing: { overlay: ROUTE_VISUAL_THEMES.pal.overlay, accent: ROUTE_VISUAL_THEMES.pal.accent, icon: 'fa-paw', position: ROUTE_VISUAL_THEMES.pal.position },
      'base-building': { overlay: ROUTE_VISUAL_THEMES.item.overlay, accent: '#ffe8a3', icon: 'fa-hammer', position: ROUTE_VISUAL_THEMES.item.position },
      'base-management': { overlay: ROUTE_VISUAL_THEMES.tech.overlay, accent: ROUTE_VISUAL_THEMES.tech.accent, icon: 'fa-gears', position: ROUTE_VISUAL_THEMES.tech.position },
      technology: { overlay: ROUTE_VISUAL_THEMES.tech.overlay, accent: ROUTE_VISUAL_THEMES.tech.accent, icon: ROUTE_VISUAL_THEMES.tech.icon, position: ROUTE_VISUAL_THEMES.tech.position },
      npcs: { overlay: ROUTE_VISUAL_THEMES.npc.overlay, accent: ROUTE_VISUAL_THEMES.npc.accent, icon: ROUTE_VISUAL_THEMES.npc.icon, position: ROUTE_VISUAL_THEMES.npc.position },
      bosses: { overlay: ROUTE_VISUAL_THEMES.boss.overlay, accent: ROUTE_VISUAL_THEMES.boss.accent, icon: ROUTE_VISUAL_THEMES.boss.icon, position: ROUTE_VISUAL_THEMES.boss.position },
      exploration: { overlay: ROUTE_VISUAL_THEMES.map.overlay, accent: ROUTE_VISUAL_THEMES.map.accent, icon: 'fa-compass', position: ROUTE_VISUAL_THEMES.map.position },
      generic: { overlay: ROUTE_VISUAL_THEMES.generic.overlay, accent: ROUTE_VISUAL_THEMES.generic.accent, icon: ROUTE_VISUAL_THEMES.generic.icon, position: ROUTE_VISUAL_THEMES.generic.position }
    };
    const GUIDE_CATALOG_GROUP_LEVEL_MAP = {
      'getting-started-core-missions': { min: 1, max: 12 },
      'pals-capture': { min: 5, max: 30 },
      'resources-crafting': { min: 10, max: 35 },
      'technology-crafting-tools': { min: 15, max: 40 },
      'base-building-management': { min: 10, max: 30 },
      'combat-boss-guides': { min: 20, max: 60 },
      'exploration-maps-dungeons': { min: 15, max: 45 },
      'breeding-eggs': { min: 20, max: 45 },
      'stats-mechanics': { min: 1, max: 60 },
      'special-updates-events': { min: 1, max: 60 },
      'multiplayer-pvp': { min: 10, max: 60 },
      'social-community': { min: 1, max: 40 }
    };
    const GUIDE_CATALOG_GROUP_TIME_MAP = {
      'getting-started-core-missions': 20,
      'pals-capture': 25,
      'resources-crafting': 30,
      'technology-crafting-tools': 35,
      'base-building-management': 28,
      'combat-boss-guides': 40,
      'exploration-maps-dungeons': 32,
      'breeding-eggs': 34,
      'stats-mechanics': 18,
      'special-updates-events': 22,
      'multiplayer-pvp': 26,
      'social-community': 18
    };
    const GUIDE_CATALOG_GROUP_RISK_MAP = {
      'getting-started-core-missions': 'low',
      'pals-capture': 'medium',
      'resources-crafting': 'medium',
      'technology-crafting-tools': 'medium',
      'base-building-management': 'low',
      'combat-boss-guides': 'high',
      'exploration-maps-dungeons': 'medium',
      'breeding-eggs': 'medium',
      'stats-mechanics': 'low',
      'special-updates-events': 'medium',
      'multiplayer-pvp': 'high',
      'social-community': 'low'
    };
    const GUIDE_CATALOG_CATEGORY_ROUTE_MAP = {
      breeding: 'breeding',
      resources: 'resources',
      'base-building': 'automation',
      'base-management': 'automation',
      crafting: 'tech',
      technology: 'tech',
      boss: 'bosses',
      combat: 'bosses',
      palpedia: 'capture-index',
      capturing: 'capture-index',
      missions: 'progression',
      mechanics: 'misc',
      exploration: 'progression',
      dungeon: 'bosses',
      update: 'misc',
      social: 'misc',
      multiplayer: 'misc',
      event: 'misc',
      economy: 'resources',
      pvp: 'bosses',
      stats: 'misc'
    };
    const GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP = {
      breeding: 'breed',
      resources: 'gather',
      'base-building': 'build',
      'base-management': 'build',
      crafting: 'craft',
      technology: 'craft',
      boss: 'fight',
      combat: 'fight',
      palpedia: 'capture',
      capturing: 'capture',
      missions: 'quest',
      mechanics: 'prepare',
      exploration: 'explore',
      dungeon: 'explore',
      update: 'prepare',
      social: 'talk',
      multiplayer: 'talk',
      event: 'quest',
      economy: 'gather',
      pvp: 'fight'
    };
    const PAL_TYPE_VISUALS = {
      Fire: { overlay: 'rgba(255, 138, 101, 0.6)', accent: '#ffb199' },
      Water: { overlay: 'rgba(80, 176, 255, 0.6)', accent: '#75c8ff' },
      Grass: { overlay: 'rgba(105, 228, 166, 0.6)', accent: '#8ff0b5' },
      Electric: { overlay: 'rgba(255, 221, 89, 0.55)', accent: '#ffe066' },
      Ice: { overlay: 'rgba(125, 206, 235, 0.6)', accent: '#b5e8ff' },
      Ground: { overlay: 'rgba(216, 180, 160, 0.58)', accent: '#f2c8a2' },
      Dark: { overlay: 'rgba(136, 84, 208, 0.6)', accent: '#d0a3ff' },
      Dragon: { overlay: 'rgba(142, 178, 255, 0.6)', accent: '#a7c9ff' },
      Air: { overlay: 'rgba(173, 216, 230, 0.55)', accent: '#c8f1ff' },
      Neutral: { overlay: ROUTE_VISUAL_THEMES.pal.overlay, accent: ROUTE_VISUAL_THEMES.pal.accent }
    };
    const ROUTE_ART_LIBRARY = {
      boss: { ...ROUTE_VISUAL_THEMES.boss },
      tower: { ...ROUTE_VISUAL_THEMES.boss },
      'tower-boss': { ...ROUTE_VISUAL_THEMES.boss, overlay: 'rgba(155, 107, 255, 0.6)', icon: 'fa-chess-knight', position: 'center 28%' },
      dungeon: { ...ROUTE_VISUAL_THEMES.boss, overlay: 'rgba(148, 87, 235, 0.62)', icon: 'fa-skull', position: 'center 32%' },
      raid: { ...ROUTE_VISUAL_THEMES.boss, overlay: 'rgba(236, 72, 153, 0.6)', accent: '#f9a8d4', icon: 'fa-users', position: 'center 40%' },
      farming: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(42, 157, 143, 0.6)', accent: '#8ff0b5', icon: 'fa-seedling', position: 'center 62%' },
      gather: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(42, 157, 143, 0.6)', accent: '#8ff0b5', icon: 'fa-seedling', position: 'center 62%' },
      'resource-gathering': { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(74, 201, 155, 0.55)', accent: '#9ff2c5', icon: 'fa-seedling', position: 'center 60%' },
      resource: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(74, 201, 155, 0.55)', accent: '#9ff2c5', icon: 'fa-seedling', position: 'center 60%' },
      capture: { ...ROUTE_VISUAL_THEMES.pal, overlay: 'rgba(255, 170, 102, 0.6)', accent: '#ffd6a5', icon: 'fa-paw', position: 'center 58%' },
      breeding: { ...ROUTE_VISUAL_THEMES.pal, overlay: 'rgba(249, 168, 212, 0.55)', accent: '#ffbde6', icon: 'fa-egg', position: 'center 56%' },
      egg: { ...ROUTE_VISUAL_THEMES.pal, overlay: 'rgba(249, 168, 212, 0.55)', accent: '#ffbde6', icon: 'fa-egg', position: 'center 56%' },
      hatch: { ...ROUTE_VISUAL_THEMES.pal, overlay: 'rgba(249, 168, 212, 0.55)', accent: '#ffbde6', icon: 'fa-egg', position: 'center 56%' },
      combat: { ...ROUTE_VISUAL_THEMES.boss, overlay: 'rgba(255, 107, 107, 0.58)', accent: '#ffb4b4', icon: 'fa-crosshairs', position: 'center 34%' },
      exploration: { ...ROUTE_VISUAL_THEMES.map },
      progression: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(118, 206, 255, 0.58)', accent: '#8dd9ff', icon: 'fa-compass', position: 'center 44%' },
      core: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(118, 206, 255, 0.58)', accent: '#8dd9ff', icon: 'fa-compass', position: 'center 44%' },
      campaign: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(118, 206, 255, 0.58)', accent: '#8dd9ff', icon: 'fa-map-signs', position: 'center 44%' },
      'quest-main-story-early': { image: ROUTE_THEME_ART_SOURCES.mainStory, overlay: 'rgba(12, 22, 64, 0.78)', accent: '#facc15', icon: 'fa-dragon', position: 'center 36%' },
      support: { ...ROUTE_VISUAL_THEMES.tech, overlay: 'rgba(120, 180, 255, 0.55)', accent: '#a7c5ff', icon: 'fa-toolbox', position: 'center 52%' },
      starter: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(148, 210, 189, 0.55)', accent: '#a5f2d5', icon: 'fa-seedling', position: 'center 46%' },
      'early-game': { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(148, 210, 189, 0.55)', accent: '#a5f2d5', icon: 'fa-seedling', position: 'center 46%' },
      'mid-game': { ...ROUTE_VISUAL_THEMES.tech, overlay: 'rgba(255, 196, 77, 0.55)', accent: '#ffd166', icon: 'fa-chart-line', position: 'center 48%' },
      'late-game': { ...ROUTE_VISUAL_THEMES.boss, overlay: 'rgba(185, 109, 255, 0.6)', accent: '#deb7ff', icon: 'fa-trophy', position: 'center 30%' },
      travel: { ...ROUTE_VISUAL_THEMES.map, image: ROUTE_THEME_ART_SOURCES.travel },
      'fast-travel': { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(123, 201, 255, 0.55)', accent: '#9fd8ff', icon: 'fa-location-arrow', position: 'center 48%' },
      craft: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(255, 214, 102, 0.58)', accent: '#ffe599', icon: 'fa-hammer', position: 'center 44%' },
      base: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(90, 126, 255, 0.58)', accent: '#b8c3ff', icon: 'fa-house-flag', position: 'center 66%' },
      'base-building': { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(90, 126, 255, 0.58)', accent: '#b8c3ff', icon: 'fa-house-flag', position: 'center 66%' },
      'base-management': { ...ROUTE_VISUAL_THEMES.tech, overlay: 'rgba(90, 126, 255, 0.5)', accent: '#b8c3ff', icon: 'fa-gears', position: 'center 52%' },
      mount: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(255, 196, 77, 0.55)', accent: '#ffd166', icon: 'fa-horse', position: 'center 58%' },
      saddle: { ...ROUTE_VISUAL_THEMES.map, overlay: 'rgba(255, 196, 77, 0.55)', accent: '#ffd166', icon: 'fa-horse', position: 'center 58%' },
      ore: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(147, 197, 253, 0.55)', accent: '#b4d7ff', icon: 'fa-gem', position: 'center 62%' },
      ingot: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(255, 214, 102, 0.52)', accent: '#ffe59f', icon: 'fa-cubes', position: 'center 60%' },
      quartz: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(185, 220, 255, 0.58)', accent: '#e0f0ff', icon: 'fa-gem', position: 'center 62%' },
      paldium: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(120, 180, 255, 0.58)', accent: '#9ed0ff', icon: 'fa-bolt', position: 'center 58%' },
      coal: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(255, 138, 101, 0.55)', accent: '#ffb199', icon: 'fa-fire', position: 'center 60%' },
      lumber: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(148, 210, 189, 0.6)', accent: '#a5f2d5', icon: 'fa-tree', position: 'center 62%' },
      medicine: { ...ROUTE_VISUAL_THEMES.tech, overlay: 'rgba(72, 187, 255, 0.55)', accent: '#8edbff', icon: 'fa-kit-medical', position: 'center 52%' },
      healing: { ...ROUTE_VISUAL_THEMES.tech, overlay: 'rgba(72, 187, 255, 0.55)', accent: '#8edbff', icon: 'fa-kit-medical', position: 'center 52%' },
      technology: { ...ROUTE_VISUAL_THEMES.tech },
      research: { ...ROUTE_VISUAL_THEMES.tech },
      automation: { ...ROUTE_VISUAL_THEMES.item, overlay: 'rgba(90, 126, 255, 0.52)', accent: '#b8c3ff', icon: 'fa-gears', position: 'center 56%' },
      misc: { ...ROUTE_VISUAL_THEMES.generic }
    };
    const ROUTE_ART_ALIASES = {
      'main-story': 'quest-main-story-early',
      'main-story-progression': 'quest-main-story-early',
      'story-progression': 'quest-main-story-early',
      'quest-main-story': 'quest-main-story-early',
      automation: 'automation',
      'base-management': 'base-management',
      'base-building': 'base',
      base: 'base',
      campaign: 'campaign',
      capture: 'capture',
      'capture-index': 'capture',
      capturing: 'capture',
      tame: 'capture',
      taming: 'capture',
      craft: 'craft',
      crafting: 'craft',
      gather: 'gather',
      gathering: 'gather',
      resource: 'resource',
      resources: 'resource',
      progression: 'progression',
      core: 'core',
      campaignmain: 'campaign',
      mounts: 'mount',
      mount: 'mount',
      saddle: 'saddle',
      tech: 'technology',
      technology: 'technology',
      support: 'support',
      misc: 'misc',
      general: 'misc',
      utility: 'support',
      boss: 'boss',
      bosses: 'boss'
    };
    const ROUTE_ART_VARIANTS = [
      { image: ROUTE_THEME_ART_SOURCES.generic, overlay: 'rgba(148, 187, 233, 0.55)', accent: '#9bd4ff', icon: 'fa-route', position: 'center 40%' },
      { image: ROUTE_THEME_ART_SOURCES.item, overlay: 'rgba(255, 123, 123, 0.52)', accent: '#ffb3c1', icon: 'fa-fire', position: 'center 64%' },
      { image: ROUTE_THEME_ART_SOURCES.pal, overlay: 'rgba(92, 225, 230, 0.52)', accent: '#bde7f8', icon: 'fa-compass', position: 'center 28%' },
      { image: ROUTE_THEME_ART_SOURCES.tech, overlay: 'rgba(255, 196, 77, 0.5)', accent: '#ffd6a5', icon: 'fa-sun', position: 'center 52%' },
      { image: ROUTE_THEME_ART_SOURCES.map, overlay: 'rgba(118, 206, 255, 0.5)', accent: '#8dd9ff', icon: 'fa-compass', position: 'center 42%' },
      { image: ROUTE_THEME_ART_SOURCES.boss, overlay: 'rgba(185, 109, 255, 0.58)', accent: '#deb7ff', icon: 'fa-chess-knight', position: 'center 32%' },
      { image: ROUTE_THEME_ART_SOURCES.npc, overlay: 'rgba(249, 168, 212, 0.5)', accent: '#f9a8d4', icon: 'fa-user-astronaut', position: 'center 46%' },
      { image: ROUTE_THEME_ART_SOURCES.travel, overlay: 'rgba(255, 196, 77, 0.5)', accent: '#ffd166', icon: 'fa-map-location-dot', position: 'center 52%' }
    ];
    const NPC_ART_LIBRARY = {
      zoe: ROUTE_THEME_ART_SOURCES.npc,
      lily: ROUTE_THEME_ART_SOURCES.npc,
      marcus: ROUTE_THEME_ART_SOURCES.npc,
      victor: ROUTE_THEME_ART_SOURCES.npc,
      lydia: ROUTE_THEME_ART_SOURCES.npc,
      johanna: ROUTE_THEME_ART_SOURCES.npc,
      sigurd: ROUTE_THEME_ART_SOURCES.npc,
      abel: ROUTE_THEME_ART_SOURCES.npc,
      eliza: ROUTE_THEME_ART_SOURCES.npc,
      investigator: ROUTE_THEME_ART_SOURCES.npc
    };
    const ROUTE_CARD_BACKDROP_FALLBACKS = {
      hero: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/058bd87dc17a7179e07c446aa64d0574ca43ab9d/header.jpg?t=1759163961',
        overlay: 'rgba(10, 22, 36, 0.78)',
        position: 'center 40%'
      },
      active: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_f81b7c4f20be3b99f76a1415c4cdb9b444c99b97.1920x1080.jpg?t=1759163961',
        overlay: 'rgba(8, 20, 34, 0.8)',
        position: 'center 55%'
      },
      suggestions: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_a9fa84f0c21bc536f00925ab4586e8c4f587c2b7.1920x1080.jpg?t=1759163961',
        overlay: 'rgba(12, 26, 44, 0.82)',
        position: 'center 48%'
      },
      recommendations: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_b3cea7c9f04a67d784d4c6a0c157a11d6268b189.1920x1080.jpg?t=1759163961',
        overlay: 'rgba(8, 18, 34, 0.84)',
        position: 'center 52%'
      },
      library: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_06e27c15c7b4b10233c937b887cf6a6925c83009.1920x1080.jpg?t=1759163961',
        overlay: 'rgba(10, 24, 40, 0.86)',
        position: 'center 58%'
      },
      catalog: {
        image: 'https://shared.akamai.steamstatic.com/store_item_assets/steam/apps/1623730/ss_0c8cbc20442b948c91b02d9e1b41bf0638a07c08.1920x1080.jpg?t=1759163961',
        overlay: 'rgba(12, 30, 46, 0.88)',
        position: 'center 50%'
      }
    };
    const ROUTE_GOAL_ICON_MAP = {
      'base-building': { icon: 'fa-house-flag' },
      'capture': { icon: 'fa-paw' },
      'resource-gathering': { icon: 'fa-seedling' },
      'boss': { icon: 'fa-chess-rook' },
      'tower': { icon: 'fa-chess-rook' },
      'exploration': { icon: 'fa-compass' },
      'travel': { icon: 'fa-road' },
      'crafting': { icon: 'fa-hammer' },
      'tech': { icon: 'fa-gears' },
      'combat': { icon: 'fa-swords' },
      'mount': { icon: 'fa-horse' }
    };
    const ROUTE_DEFAULT_GOAL_ICON = 'fa-route';
    const ROUTE_PLAYSTYLE_LABELS = {
      boss: { kid: 'Boss battles', grown: 'Boss hunts' },
      tower: { kid: 'Boss battles', grown: 'Boss hunts' },
      resource: { kid: 'Resource runs', grown: 'Resource farming' },
      capture: { kid: 'Capture pals', grown: 'Capture & taming' },
      base: { kid: 'Build the base', grown: 'Base building' },
      craft: { kid: 'Crafting time', grown: 'Crafting & tech' },
      explore: { kid: 'Explore & travel', grown: 'Exploration' },
      support: { kid: 'Support prep', grown: 'Support route' },
      core: { kid: 'Main adventure', grown: 'Core progression' },
      adventure: { kid: 'Adventure mix', grown: 'Balanced adventure' }
    };
    const ROUTE_SUGGESTION_CHIP_LABELS = {
      pal: { kid: 'Pal spotlight', grown: 'Pal focus' },
      item: { kid: 'Loot haul', grown: 'Resource focus' },
      tech: { kid: 'New invention', grown: 'Tech unlock' },
      boss: { kid: 'Boss battle', grown: 'Boss encounter' },
      map: { kid: 'Explore zone', grown: 'Exploration' },
      npc: { kid: 'NPC quest', grown: 'NPC storyline' },
      capture: { kid: 'Capture pals', grown: 'Capture run' },
      farming: { kid: 'Gather loot', grown: 'Resource farming' },
      gather: { kid: 'Gather loot', grown: 'Resource farming' },
      travel: { kid: 'Travel time', grown: 'Travel route' },
      craft: { kid: 'Craft items', grown: 'Crafting focus' },
      base: { kid: 'Base project', grown: 'Base project' },
      generic: { kid: 'Adventure mix', grown: 'Adaptive pick' }
    };
    const DEFAULT_RECOMMENDER_WEIGHTS = {
      prerequisites_met: 6,
      level_fit: 5,
      unlock_value: 4.5,
      time_to_power_ratio: 3.5,
      progression_role: 4,
      coop_synergy: 2.5,
      risk_vs_mode: 2.5,
      tag_alignment: 4,
      novelty: 1,
      metric_efficiency: 3,
      resource_relief: 4,
      dynamic_alignment: 2.5,
      progress_momentum: 4.5,
      closeout_bonus: 3.5,
      goal_objective_alignment: 5,
      context_goal_keyword: 3.5,
      synergy_next_routes: 2.5,
      resource_urgency: 3,
      returning_focus: 3,
      boss_alignment: 3.5,
      tower_alignment: 3.5,
      pal_gap: 3.5,
      tech_gap: 3.5,
      prereq_pal_ready: 4.2,
      prereq_tech_ready: 3.8,
      region_alignment: 3.6,
      mission_alignment: 3.3,
      base_alignment: 3.2,
      stage_alignment: 4.2,
      boss_prep: 4.8,
      boss_support: 3.7,
      pal_ready_highlight: 3.4,
      tech_followthrough: 3.9,
      supporting_stage: 3.6,
      active_region_chain: 3.2,
      quest_cluster: 2.9,
      boss_requirement_alignment: 3.8,
      phase_alignment: 3.4,
      level_window_penalty: 3.1
    };
    const MAIN_STORY_PHASE_HINTS = [
      {
        key: 'volcano-prep',
        prefixes: [
          'quest-main-story-early:013a',
          'quest-main-story-early:013b',
          'quest-main-story-early:013c',
          'quest-main-story-early:014'
        ],
        recommended: [
          'resource-carbon-fiber',
          'resource-polymer',
          'resource-sulfur',
          'resource-coal'
        ],
        optional: [
          'resource-precious-pelt',
          'resource-high-quality-pal-oil'
        ],
        kidSummary: 'Stacks gear for the volcano run.',
        grownSummary: 'Preps heat protection before Mount Obsidian.',
        kidOptional: 'Optional support before tackling Orserk.',
        grownOptional: 'Optional padding ahead of the Eternal Pyre assault.'
      },
      {
        key: 'desert-siege',
        prefixes: ['quest-main-story-early:015'],
        recommended: [
          'resource-gunpowder',
          'resource-carbon-fiber',
          'resource-ancient-civilization-parts'
        ],
        optional: [
          'resource-high-quality-cloth',
          'resource-precious-dragon-stone'
        ],
        kidSummary: 'Loads ammo and tech for the desert tower.',
        grownSummary: 'Builds PIDF firepower and gadgets.',
        kidOptional: 'Optional loot before the PIDF siege.',
        grownOptional: 'Optional desert farming while staging explosives.'
      },
      {
        key: 'ice-research',
        prefixes: ['quest-main-story-early:016'],
        recommended: [
          'resource-ice-organ',
          'resource-carbon-fiber',
          'resource-medium-pal-soul'
        ],
        optional: [
          'resource-large-pal-soul',
          'resource-ancient-civilization-parts'
        ],
        kidSummary: 'Gathers ice ammo for PAL Research.',
        grownSummary: 'Lines up Shadowbeak counters and tech cores.',
        kidOptional: 'Optional farming before the frozen lab.',
        grownOptional: 'Optional reserves before storming PAL Research.'
      },
      {
        key: 'moonlit-raid',
        prefixes: ['quest-main-story-early:017'],
        recommended: [
          'resource-carbon-fiber',
          'resource-precious-pelt',
          'resource-ancient-civilization-parts'
        ],
        optional: [
          'resource-high-quality-pal-oil',
          'purposeful-arc-legendary-push'
        ],
        kidSummary: 'Packs armour and elixirs for Saya & Selyne.',
        grownSummary: 'Bolsters Moonlit Duel loadouts and tech.',
        kidOptional: 'Optional legendary prep before Sakurajima.',
        grownOptional: 'Optional legendary hunts while staging Moonlit Duel.'
      },
      {
        key: 'feybreak-assault',
        prefixes: ['quest-main-story-early:018'],
        recommended: [
          'resource-ancient-civilization-parts',
          'resource-carbon-fiber',
          'capture-jetragon',
          'purposeful-arc-legendary-push'
        ],
        optional: [
          'resource-precious-dragon-stone',
          'resource-large-pal-soul'
        ],
        kidSummary: 'Final gear check before Bjorn & Bastigor.',
        grownSummary: 'Finalise Feybreak loadouts and legendary mount plans.',
        kidOptional: 'Optional polish before the finale.',
        grownOptional: 'Optional legendary detours while staging Feybreak.',
        progressFallback: 92
      }
    ];

    function normalizeRouteIdentifier(value){
      if(!value) return null;
      if(typeof value === 'string') return value.trim();
      if(typeof value === 'object'){
        if(value.route_id) return String(value.route_id).trim();
        if(value.id) return String(value.id).trim();
      }
      return null;
    }

    function createRouteIdSet(list){
      const result = new Set();
      (Array.isArray(list) ? list : []).forEach(value => {
        const id = normalizeRouteIdentifier(value);
        if(id) result.add(id);
      });
      return result;
    }

    function determineMainStoryPhase(stageSnapshot){
      if(!stageSnapshot || stageSnapshot.stageId !== 'quest-main-story-early') return null;
      const nextId = String(stageSnapshot?.nextStep?.id || '').toLowerCase();
      if(nextId){
        for(const phase of MAIN_STORY_PHASE_HINTS){
          if(phase.prefixes.some(prefix => nextId.startsWith(prefix))){
            return phase;
          }
        }
      }
      if(stageSnapshot.progressPercent != null){
        const fallback = MAIN_STORY_PHASE_HINTS.find(phase => typeof phase.progressFallback === 'number'
          && stageSnapshot.progressPercent >= phase.progressFallback);
        if(fallback) return fallback;
      }
      return null;
    }
    let currentRouteSuggestionEntries = [];
    let currentRouteRecommendationEntries = [];
    let activeSuggestedRouteId = null;
    let routeSuggestionsAbort = null;
    let activeRouteIds = new Set();
    let routeLibrarySearchTerm = '';
    let routeLibraryFilter = 'incomplete';
    let routeLibraryMatchContext = false;
    let latestRecommendations = [];

    function loadActiveRouteIdsFromState(state){
      const meta = state && typeof state.__meta === 'object' ? state.__meta : null;
      const stored = meta && Array.isArray(meta.activeRoutes) ? meta.activeRoutes : [];
      return stored
        .map(id => typeof id === 'string' ? id.trim() : '')
        .filter(Boolean);
    }

    function syncActiveRouteIds(){
      activeRouteIds = new Set(loadActiveRouteIdsFromState(routeState));
    }

    function persistActiveRouteIds(){
      if(!routeState.__meta || typeof routeState.__meta !== 'object'){
        routeState.__meta = {};
      }
      routeState.__meta.activeRoutes = Array.from(activeRouteIds);
      saveRouteState(routeState);
    }

    function isRouteActive(routeId){
      if(!routeId) return false;
      return activeRouteIds.has(routeId);
    }

    function addActiveRoute(routeId){
      if(!routeId || isRouteActive(routeId)) return;
      activeRouteIds.add(routeId);
      persistActiveRouteIds();
      renderActiveRoutesList();
      renderRouteLibraryList();
      refreshRouteIntelligenceUI();
      requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
    }

    function removeActiveRoute(routeId){
      if(!routeId || !isRouteActive(routeId)) return;
      activeRouteIds.delete(routeId);
      persistActiveRouteIds();
      renderActiveRoutesList();
      renderRouteLibraryList();
      refreshRouteIntelligenceUI();
      requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
    }

    function pruneCompletedActiveRoutes(){
      if(!routeGuideData || !routeGuideData.routes) return;
      let changed = false;
      activeRouteIds.forEach(routeId => {
        const route = routeGuideData.routeLookup?.[routeId];
        if(route && isRouteComplete(route)){
          activeRouteIds.delete(routeId);
          changed = true;
        }
      });
      if(changed){
        persistActiveRouteIds();
      }
    }

    function rebuildTechLookup(){
      TECH_LOOKUP = {};
      (Array.isArray(TECH) ? TECH : []).forEach(level => {
        if(!level || !Array.isArray(level.items)) return;
        level.items.forEach(item => {
          if(!item) return;
          const identifiers = [];
          if(item.id) identifiers.push(item.id);
          if(item.name) identifiers.push(item.name);
          identifiers.forEach(identifier => {
            const slug = slugifyForPalworld(String(identifier));
            if(slug){
              TECH_LOOKUP[slug] = { item, level };
            }
          });
        });
      });
    }

    async function ensureRouteGuide(){
      if(routeGuideData){
        return routeGuideData;
      }
      try {
        const guide = await loadGuideDataset();
        routeGuideData = guide;
        ensureGuideCatalogFiltersValid();
        ensurePurposefulGuideFiltersValid();
        return routeGuideData;
      } catch (err) {
        console.error('Failed to load adaptive guide', err);
        routeGuideData = createEmptyGuideData();
        return routeGuideData;
      }
    }

    async function loadGuideDataset(){
      const markdown = await loadGuideFromMarkdown();
      if(markdown && Array.isArray(markdown.routes) && markdown.routes.length){
        try {
          return await augmentGuideData(markdown);
        } catch(err){
          console.warn('Failed to augment guide markdown', err);
        }
      }
      const bundled = await loadBundledGuideData();
      if(bundled && Array.isArray(bundled.routes) && bundled.routes.length){
        try {
          return await augmentGuideData(bundled);
        } catch(err){
          console.warn('Failed to augment bundled guide data', err);
        }
      }
      throw new Error('Guide datasets unavailable');
    }

    function createEmptyGuideData(){
      return {
        routes: [],
        chapters: [],
        tags: [],
        routeLookup: {},
        metadata: null,
        xp: null,
        levelEstimator: null,
        recommender: null,
        guideCatalog: null,
        keyResources: [],
        resourceGuides: {},
        resourceGuideGaps: [],
        extras: [],
        errors: []
      };
    }

    async function loadGuideFromMarkdown(){
      try {
        const res = await fetch('guides.md');
        if(!res.ok){
          throw new Error(`HTTP ${res.status}`);
        }
        const text = await res.text();
        if(!text){
          return null;
        }
        const parsed = parseGuideMarkdown(text || '');
        if(!Array.isArray(parsed.routes) || !parsed.routes.length){
          console.warn('Guide markdown parsed without routes; attempting bundled fallback.');
        }
        return parsed;
      } catch(err){
        console.warn('Failed to fetch guide markdown', err);
        return null;
      }
    }

    async function loadBundledGuideData(){
      const preloaded = await loadPreloadedGuideBundle();
      if(preloaded) return preloaded;
      try {
        const res = await fetch('data/guides.bundle.json');
        if(!res.ok){
          throw new Error(`HTTP ${res.status}`);
        }
        const payload = await res.json();
        return normalizeGuideBundle(payload);
      } catch(err){
        console.warn('Failed to load bundled guide data', err);
      }
      return null;
    }

    async function loadPreloadedGuideBundle(){
      try {
        if(window.__GUIDE_BUNDLE_PROMISE__ instanceof Promise){
          const payload = await window.__GUIDE_BUNDLE_PROMISE__;
          const normalized = normalizeGuideBundle(payload);
          if(normalized) return normalized;
        }
        if(window.__GUIDE_BUNDLE__){
          const normalized = normalizeGuideBundle(window.__GUIDE_BUNDLE__);
          if(normalized) return normalized;
        }
      } catch(err){
        console.warn('Failed to use preloaded guide bundle', err);
      }
      return null;
    }

    function normalizeGuideBundle(payload){
      const clone = cloneGuidePayload(payload);
      if(!clone || typeof clone !== 'object') return null;
      if(!Array.isArray(clone.routes)) clone.routes = [];
      if(!Array.isArray(clone.extras)) clone.extras = [];
      if(clone.metadata === undefined) clone.metadata = null;
      return clone;
    }

    function cloneGuidePayload(payload){
      if(!payload || typeof payload !== 'object') return null;
      if(typeof structuredClone === 'function'){
        try {
          return structuredClone(payload);
        } catch(err){
          console.warn('Structured clone failed for guide payload, using JSON fallback.', err);
        }
      }
      try {
        return JSON.parse(JSON.stringify(payload));
      } catch(err){
        console.warn('JSON clone failed for guide payload; returning shallow copy.', err);
        return { ...payload };
      }
    }

    function parseGuideMarkdown(markdown){
      const result = {
        metadata: null,
        xp: null,
        routes: [],
        routeSchema: null,
        levelEstimator: null,
        recommender: null,
        sourceRegistry: null,
        guideCatalog: null,
        extras: [],
        errors: []
      };
      if(typeof markdown !== 'string' || !markdown.trim()){
        return result;
      }
      const blockPattern = /```json\s*([\s\S]*?)```/g;
      let match;
      while((match = blockPattern.exec(markdown))){
        const snippet = match[1] ? match[1].trim() : '';
        if(!snippet) continue;
        try {
          const json = JSON.parse(snippet);
          if(json && typeof json === 'object'){
            if(json.route_id){
              result.routes.push(json);
              continue;
            }
            if(Object.prototype.hasOwnProperty.call(json, 'schema_version')){
              result.metadata = json;
              continue;
            }
            if(json.route_schema){
              result.routeSchema = json.route_schema;
              continue;
            }
            if(Array.isArray(json.xp_thresholds)){
              result.xp = json;
              continue;
            }
            if(json.level_estimator){
              result.levelEstimator = json.level_estimator;
              continue;
            }
            if(json.recommender){
              result.recommender = json.recommender;
              continue;
            }
            if(json.source_registry){
              result.sourceRegistry = json.source_registry;
              continue;
            }
            if(json.guide_catalog){
              result.guideCatalog = json.guide_catalog;
              continue;
            }
          }
          result.extras.push(json);
        } catch(err){
          console.warn('Failed to parse guide block', err);
          result.errors.push({ error: err, snippet });
        }
      }
      return result;
    }

    const ROUTE_ROLE_CORE_VALUES = new Set(['core', 'main', 'story', 'campaign', 'primary', 'critical']);
    const ROUTE_ROLE_SUPPORT_VALUES = new Set(['support', 'supporting', 'resource', 'farm', 'utility', 'supplemental']);
    const ROUTE_ROLE_OPTIONAL_VALUES = new Set(['optional', 'side', 'branch', 'bonus', 'supplementary', 'situational']);
    const STEP_REQUIRED_IMPORTANCE_VALUES = new Set(['required', 'core', 'critical', 'mandatory', 'main', 'story']);
    const STEP_OPTIONAL_IMPORTANCE_VALUES = new Set(['optional', 'support', 'supporting', 'bonus', 'stretch', 'side', 'branch', 'situational', 'contextual']);

    function normalizeRouteRole(value){
      const raw = typeof value === 'string' ? value.trim().toLowerCase() : '';
      if(ROUTE_ROLE_CORE_VALUES.has(raw)) return 'core';
      if(ROUTE_ROLE_SUPPORT_VALUES.has(raw)) return 'support';
      if(ROUTE_ROLE_OPTIONAL_VALUES.has(raw)) return 'optional';
      if(raw) return raw;
      return 'optional';
    }

    function normalizeStepImportance(step){
      if(!step || typeof step !== 'object') return 'required';
      const candidates = [
        step.importance,
        step.step_importance,
        step.stepImportance,
        step.role,
        step.step_role,
        step.progression_role,
        step.tier
      ];
      for(const candidate of candidates){
        if(typeof candidate === 'string' && candidate.trim()){
          return candidate.trim().toLowerCase();
        }
      }
      if(step.optional === true) return 'optional';
      if(step.optional === false) return 'required';
      if(Array.isArray(step.branching) && step.branching.length){
        return 'support';
      }
      return 'required';
    }

    function stepImportanceIsOptional(importance){
      return STEP_OPTIONAL_IMPORTANCE_VALUES.has(importance);
    }

    function stepImportanceIsRequired(importance){
      return STEP_REQUIRED_IMPORTANCE_VALUES.has(importance);
    }

    function deriveStepProgressionState(route, rawStep){
      const routeRole = normalizeRouteRole(route?.progression_role || route?.raw?.progression_role);
      const routeIsCore = routeRole === 'core';
      const importance = normalizeStepImportance(rawStep);
      const optionalByImportance = stepImportanceIsOptional(importance);
      const requiredByImportance = stepImportanceIsRequired(importance);
      let optional = null;
      if(requiredByImportance){
        optional = false;
      } else if(optionalByImportance){
        optional = true;
      }
      if(optional === null){
        optional = routeIsCore ? false : true;
      } else if(!routeIsCore){
        optional = true;
      }
      return { importance, optional: !!optional, routeRole };
    }

    const RESOURCE_ITEM_TYPE_WHITELIST = new Set(['material', 'materials', 'ingredient', 'ingredients', 'food']);
    const RESOURCE_ITEM_CATEGORY_WHITELIST = new Set(['material', 'food']);
    const RESOURCE_SHORTAGE_MENU_EXCLUSIONS = new Set([
      'diamond',
      'ruby',
      'sapphire',
      'gumoss_leaf',
      'penking_plume',
      'mushroom',
      'raw_dumud',
      'raw_kelpsea',
      'rushoar_pork',
      'mammorest_meat',
      'reindrix_venison',
      'eikthyrdeer_venison',
      'tocotoco_feather'
    ]);

    function isResourceItemId(itemId){
      if(!itemId) return false;
      const key = String(itemId).trim();
      if(!key) return false;
      const detail = ITEM_DETAILS?.[key];
      if(detail && typeof detail.type === 'string'){
        const type = detail.type.trim().toLowerCase();
        if(RESOURCE_ITEM_TYPE_WHITELIST.has(type)){
          return true;
        }
      }
      const item = ITEMS?.[key];
      if(item && typeof item.category === 'string'){
        const category = item.category.trim().toLowerCase();
        if(RESOURCE_ITEM_CATEGORY_WHITELIST.has(category)){
          return true;
        }
      }
      return false;
    }

    function collectAllResourceItemIds(){
      const ids = new Set();
      if(ITEM_DETAILS && typeof ITEM_DETAILS === 'object'){
        Object.keys(ITEM_DETAILS).forEach(key => {
          if(isResourceItemId(key)){
            ids.add(key);
          }
        });
      }
      if(ITEMS && typeof ITEMS === 'object'){
        Object.keys(ITEMS).forEach(key => {
          if(isResourceItemId(key)){
            ids.add(key);
          }
        });
      }
      return Array.from(ids).sort((a, b) => itemDisplayName(a).localeCompare(itemDisplayName(b), undefined, { sensitivity: 'base' }));
    }

    function sortResourceGuideRoutes(routeIds, routeLookup){
      const ids = Array.isArray(routeIds) ? routeIds.slice() : [];
      const weightForRoute = route => {
        if(!route) return 99;
        const category = String(route.category || '').toLowerCase();
        const role = String(route.progression_role || '').toLowerCase();
        if(category === 'resources') return 0;
        if(role === 'support') return 1;
        if(category === 'crafting' || category === 'automation') return 2;
        return 3;
      };
      ids.sort((a, b) => {
        const routeA = routeLookup?.[a];
        const routeB = routeLookup?.[b];
        const diff = weightForRoute(routeA) - weightForRoute(routeB);
        if(diff !== 0) return diff;
        return (routeA?.title || a).localeCompare(routeB?.title || b, undefined, { sensitivity: 'base' });
      });
      return ids;
    }

    async function augmentGuideData(parsed){
      const routes = Array.isArray(parsed?.routes) ? parsed.routes : [];
      const baseAugmentedRoutes = routes.map((route, index) => augmentRoute(route, index));
      const catalogMeta = parsed?.guideCatalog || null;
      let catalogData = null;
      if(catalogMeta){
        catalogData = await loadGuideCatalog(catalogMeta);
      }
      const preparedCatalog = prepareGuideCatalog(catalogData, catalogMeta);
      const generatedRoutes = generateGuideCatalogRoutes(preparedCatalog, {
        existingRouteIds: new Set(baseAugmentedRoutes.map(entry => entry.id)),
        startIndex: baseAugmentedRoutes.length
      });
      const augmentedRoutes = baseAugmentedRoutes.concat(generatedRoutes);
      const chapters = augmentedRoutes.map(entry => entry.chapter);
      const routeLookup = {};
      const tagSet = new Set();
      const resourceFrequency = new Map();
      const resourceRoutes = new Map();
      augmentedRoutes.forEach(entry => {
        routeLookup[entry.id] = entry;
        entry.tags.forEach(tag => tagSet.add(tag));
        entry.resourceOutputs.forEach(itemId => {
          if(!isResourceItemId(itemId)) return;
          resourceFrequency.set(itemId, (resourceFrequency.get(itemId) || 0) + 1);
          if(!resourceRoutes.has(itemId)){
            resourceRoutes.set(itemId, new Set());
          }
          resourceRoutes.get(itemId).add(entry.id);
        });
      });
      const collectedResourceIds = collectAllResourceItemIds();
      const resourceIdSet = new Set(collectedResourceIds);
      resourceFrequency.forEach((count, key) => {
        if(isResourceItemId(key)){
          resourceIdSet.add(key);
        }
      });
      const sortedResources = Array.from(resourceIdSet)
        .sort((a, b) => itemDisplayName(a).localeCompare(itemDisplayName(b), undefined, { sensitivity: 'base' }));
      const resourceGuides = {};
      const missingResourceGuides = [];
      const filteredResources = [];
      sortedResources.forEach(itemId => {
        const routesForItem = resourceRoutes.has(itemId)
          ? Array.from(resourceRoutes.get(itemId))
          : [];
        const orderedRoutes = sortResourceGuideRoutes(routesForItem, routeLookup);
        const entries = orderedRoutes.map(routeId => {
          const routeEntry = routeLookup?.[routeId];
          const objectives = Array.isArray(routeEntry?.objectives) ? routeEntry.objectives : [];
          const shortages = Array.isArray(routeEntry?.adaptive_guidance?.resource_shortages)
            ? routeEntry.adaptive_guidance.resource_shortages.filter(shortage => shortage && (shortage.solution || shortage.note))
            : [];
          return {
            id: routeId,
            title: routeEntry?.title || niceName(routeId),
            level: routeEntry?.recommended_level || null,
            levelLabel: formatLevelRangeLabel(routeEntry?.recommended_level) || '',
            time: routeEntry?.estimated_time_minutes || null,
            timeLabel: formatTimeLabel(routeEntry?.estimated_time_minutes) || '',
            summary: objectives.length ? objectives[0] : '',
            shortageNotes: shortages
              .map(shortage => cleanGuideText(shortage.solution || shortage.note || ''))
              .filter(Boolean)
              .slice(0, 2)
          };
        });
        if(!entries.length && RESOURCE_SHORTAGE_MENU_EXCLUSIONS.has(itemId)){
          return;
        }
        resourceGuides[itemId] = entries;
        filteredResources.push(itemId);
        if(!entries.length){
          missingResourceGuides.push(itemId);
        }
      });
      return {
        metadata: parsed?.metadata || null,
        xp: parsed?.xp || null,
        levelEstimator: parsed?.levelEstimator || null,
        recommender: parsed?.recommender || null,
        routes: augmentedRoutes,
        chapters,
        routeLookup,
        tags: Array.from(tagSet).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' })),
        keyResources: filteredResources,
        resourceGuides,
        resourceGuideGaps: missingResourceGuides,
        extras: parsed?.extras || [],
        errors: parsed?.errors || [],
        guideCatalog: preparedCatalog
      };
    }

    function cloneGuideCatalog(value){
      if(!value || typeof value !== 'object') return null;
      if(typeof structuredClone === 'function'){
        try {
          return structuredClone(value);
        } catch(err){
          console.warn('structuredClone failed for guide catalog; using JSON fallback.', err);
        }
      }
      try {
        return JSON.parse(JSON.stringify(value));
      } catch(err){
        console.warn('JSON clone failed for guide catalog fallback.', err);
        return null;
      }
    }

    async function loadGuideCatalog(meta){
      const inlineData = meta && typeof meta === 'object'
        ? (meta.inline ?? meta.data ?? null)
        : null;
      if(inlineData){
        const clonedInline = cloneGuideCatalog(inlineData);
        if(clonedInline){
          return clonedInline;
        }
      }

      const source = meta?.path;
      if(source){
        try {
          const res = await fetch(source);
          if(!res.ok){
            throw new Error(`HTTP ${res.status}`);
          }
          const payload = await res.json();
          if(payload && typeof payload === 'object'){
            return payload;
          }
        } catch(err){
          console.warn('Failed to load guide catalog', err);
        }
      }

      const fallbackPromise = window.__GUIDE_CATALOG_FALLBACK_PROMISE__;
      if(fallbackPromise && typeof fallbackPromise.then === 'function'){
        try {
          const fallback = await fallbackPromise;
          const clonedFallback = cloneGuideCatalog(fallback);
          if(clonedFallback){
            return clonedFallback;
          }
        } catch(err){
          console.warn('Guide catalog fallback promise rejected', err);
        }
      }

      const fallback = window.__GUIDE_CATALOG_FALLBACK__;
      if(fallback){
        const cloned = cloneGuideCatalog(fallback);
        if(cloned){
          return cloned;
        }
      }

      return null;
    }

    function normalizeGuideCatalogLink(link){
      if(!link || typeof link !== 'object') return null;
      const type = typeof link.type === 'string' ? link.type.trim().toLowerCase() : '';
      if(!type) return null;
      const normalized = { type };
      const assignString = (key, value, { slugify = false } = {}) => {
        if(value == null) return;
        const raw = String(value).trim();
        if(!raw) return;
        if(slugify){
          const slug = slugifyForPalworld(raw) || raw;
          normalized[key] = slug;
        } else {
          normalized[key] = raw;
        }
      };
      const assignNumber = (key, value) => {
        if(value == null || value === '') return;
        const num = Number(value);
        if(Number.isFinite(num)) normalized[key] = num;
      };
      assignString('id', link.id);
      if(link.slug != null){
        assignString('slug', link.slug, { slugify: true });
      }
      assignString('name', link.name);
      assignString('role', link.role);
      assignString('url', link.url);
      assignString('image', link.image);
      assignString('region', link.region);
      assignNumber('quantity', link.quantity);
      assignNumber('level', link.level);
      if(Array.isArray(link.coords)){
        const coords = link.coords
          .slice(0, 2)
          .map(entry => Number(entry))
          .filter(entry => Number.isFinite(entry));
        if(coords.length === 2) normalized.coords = coords;
      }
      if(Array.isArray(link.entranceCoords)){
        const coords = link.entranceCoords
          .slice(0, 2)
          .map(entry => Number(entry))
          .filter(entry => Number.isFinite(entry));
        if(coords.length === 2) normalized.entranceCoords = coords;
      }
      return normalized;
    }

    function normalizeGuideCatalogLinks(list){
      if(!Array.isArray(list)) return [];
      const links = list
        .map(normalizeGuideCatalogLink)
        .filter(Boolean);
      return links;
    }

    function prepareGuideCatalog(raw, meta){
      if(!raw || typeof raw !== 'object' || !Array.isArray(raw.guides)){
        return null;
      }
      const entries = [];
      raw.guides.forEach((guide, index) => {
        if(!guide || typeof guide !== 'object') return;
        const groupLabelRaw = String(guide.category_group || 'General').trim() || 'General';
        const groupLabel = groupLabelRaw;
        const groupId = slugifyForPalworld(groupLabelRaw) || `group-${index}`;
        const categoryLabelRaw = String(guide.category || 'General').trim() || 'General';
        const categoryLabel = categoryLabelRaw;
        const categoryId = slugifyForPalworld(categoryLabelRaw) || `${groupId}-category`;
        const title = guide.title || guide.source_heading || 'Guide';
        const trigger = guide.trigger || '';
        const keywords = Array.isArray(guide.keywords) ? guide.keywords.filter(Boolean).map(value => String(value)) : [];
        const steps = Array.isArray(guide.steps)
          ? guide.steps.map((step, stepIndex) => {
            const entry = {
              order: Number(step?.order ?? (stepIndex + 1)),
              instruction: step?.instruction || '',
              citations: Array.isArray(step?.citations) ? step.citations.slice() : []
            };
            const links = normalizeGuideCatalogLinks(step?.links);
            if(links.length) entry.links = links;
            return entry;
          }).filter(step => step.instruction)
          : [];
        steps.sort((a, b) => (a.order || 0) - (b.order || 0));
        const searchParts = [title, groupLabel, categoryLabel, trigger, keywords.join(' '), steps.map(step => step.instruction).join(' ')];
        const searchText = searchParts.join(' ').toLowerCase();
        entries.push({
          id: guide.id || `${groupId}-${categoryId}-${index}`,
          title,
          groupId,
          groupLabel,
          categoryId,
          categoryLabel,
          trigger,
          keywords,
          steps,
          searchText
        });
      });
      entries.sort((a, b) => {
        const groupCompare = a.groupLabel.localeCompare(b.groupLabel, undefined, { sensitivity: 'base' });
        if(groupCompare !== 0) return groupCompare;
        return a.title.localeCompare(b.title, undefined, { sensitivity: 'base' });
      });
      const groupMap = new Map();
      entries.forEach(entry => {
        if(!groupMap.has(entry.groupId)){
          groupMap.set(entry.groupId, { id: entry.groupId, label: entry.groupLabel, categories: new Map() });
        }
        const group = groupMap.get(entry.groupId);
        if(!group.categories.has(entry.categoryId)){
          group.categories.set(entry.categoryId, { id: entry.categoryId, label: entry.categoryLabel });
        }
      });
      const groups = Array.from(groupMap.values()).map(group => ({
        id: group.id,
        label: group.label,
        categories: Array.from(group.categories.values()).sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base' }))
      })).sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base' }));
      return { entries, groups, meta: meta || null, count: entries.length };
    }

    function generateGuideCatalogRoutes(catalog, { existingRouteIds = new Set(), startIndex = 0 } = {}){
      if(!catalog || !Array.isArray(catalog.entries)){
        return [];
      }
      const usedIds = existingRouteIds instanceof Set
        ? existingRouteIds
        : new Set(Array.isArray(existingRouteIds) ? existingRouteIds : []);
      const routes = [];
      let offset = 0;
      catalog.entries.forEach((entry, entryIndex) => {
        const rawRoute = convertGuideCatalogEntryToRoute(entry, { usedIds, entryIndex });
        if(!rawRoute) return;
        const augmented = augmentRoute(rawRoute, startIndex + offset);
        if(augmented){
          routes.push(augmented);
          offset += 1;
        }
      });
      return routes;
    }

    function convertGuideCatalogEntryToRoute(entry, { usedIds, entryIndex = 0 } = {}){
      if(!entry || !entry.title) return null;
      const routeId = ensureGuideCatalogRouteId(entry, usedIds, entryIndex);
      const category = mapGuideCatalogCategoryToRouteCategory(entry);
      const progressionRole = deriveGuideCatalogProgressionRole(category);
      const steps = deriveGuideCatalogSteps(entry, { routeId, category });
      if(!steps.length){
        steps.push(createPlaceholderCatalogStep(routeId, entry));
      }
      const levelRange = deriveGuideCatalogLevelRange(entry);
      const timeEstimate = deriveGuideCatalogTimeEstimate(entry, { steps });
      const xpEstimate = deriveGuideCatalogXpEstimate(steps);
      const risk = deriveGuideCatalogRiskProfile(entry, category);
      const objectives = deriveGuideCatalogObjectives(entry, steps);
      const adaptiveGuidance = deriveGuideCatalogAdaptiveGuidance(entry, { steps, levelRange, title: entry.title });
      const checkpoints = deriveGuideCatalogCheckpoints(routeId, entry, steps);
      const tags = buildGuideCatalogTags(entry);
      const metrics = {
        progress_segments: steps.length,
        boss_targets: category === 'bosses' ? 1 : 0,
        quest_nodes: steps.length
      };
      const yields = {
        levels_estimate: levelRange.max <= 15 ? '+0 to +1' : (levelRange.max <= 30 ? '+0 to +2' : 'Knowledge boost'),
        key_unlocks: []
      };
      return {
        route_id: routeId,
        title: entry.title,
        category,
        tags,
        progression_role: progressionRole,
        recommended_level: levelRange,
        modes: { normal: true, hardcore: true, solo: true, coop: true },
        prerequisites: { routes: [], tech: [], items: [], pals: [] },
        objectives,
        estimated_time_minutes: timeEstimate,
        estimated_xp_gain: xpEstimate,
        risk_profile: risk,
        failure_penalties: {
          normal: `If a step is missed, revisit the checklist for ${cleanGuideText(entry.title)} and repeat it calmly.`,
          hardcore: `In Hardcore, retreat to safety, restock, and retry the ${cleanGuideText(entry.title)} checklist carefully.`
        },
        adaptive_guidance: adaptiveGuidance,
        checkpoints,
        supporting_routes: { recommended: [], optional: [] },
        failure_recovery: {
          normal: 'Backtrack to the last completed checkpoint, restock consumables, and repeat the missing steps.',
          hardcore: 'Stabilise your base, bring defensive gear, and resume from the last checkpoint once ready.'
        },
        steps,
        completion_criteria: [
          { type: 'quest-chain', quest_id: routeId }
        ],
        yields,
        metrics,
        next_routes: []
      };
    }

    function ensureGuideCatalogRouteId(entry, usedIds, entryIndex){
      const baseSlug = slugifyForPalworld(entry?.id || entry?.title || `guide-${entryIndex + 1}`);
      const prefix = baseSlug ? `catalog-${baseSlug}` : `catalog-guide-${entryIndex + 1}`;
      let candidate = prefix || `catalog-guide-${entryIndex + 1}`;
      let counter = 2;
      while(usedIds && usedIds.has(candidate)){
        candidate = `${prefix || 'catalog-guide'}-${counter}`;
        counter += 1;
      }
      if(usedIds) usedIds.add(candidate);
      return candidate;
    }

    function mapGuideCatalogCategoryToRouteCategory(entry){
      const raw = entry?.categoryId || entry?.category || entry?.categoryLabel || '';
      const slug = slugifyForPalworld(raw);
      if(slug && GUIDE_CATALOG_CATEGORY_ROUTE_MAP[slug]){
        return GUIDE_CATALOG_CATEGORY_ROUTE_MAP[slug];
      }
      return 'misc';
    }

    function deriveGuideCatalogProgressionRole(category){
      if(category === 'progression' || category === 'bosses') return 'core';
      if(category === 'resources' || category === 'tech' || category === 'automation') return 'support';
      return 'optional';
    }

    function deriveGuideCatalogLevelRange(entry){
      const slug = slugifyForPalworld(entry?.groupId || entry?.groupLabel || '');
      if(slug && GUIDE_CATALOG_GROUP_LEVEL_MAP[slug]){
        const range = GUIDE_CATALOG_GROUP_LEVEL_MAP[slug];
        return { min: range.min, max: range.max };
      }
      return { min: 1, max: 60 };
    }

    function deriveGuideCatalogTimeEstimate(entry, { steps } = {}){
      const slug = slugifyForPalworld(entry?.groupId || entry?.groupLabel || '');
      const base = GUIDE_CATALOG_GROUP_TIME_MAP[slug] || 24;
      const count = Array.isArray(steps) && steps.length ? steps.length : 1;
      const solo = Math.max(8, Math.round(base + (count - 1) * 2));
      const coop = Math.max(6, Math.round(solo * 0.8));
      return { solo, coop };
    }

    function deriveGuideCatalogXpEstimate(steps){
      const count = Array.isArray(steps) ? steps.length : 0;
      const min = Math.max(40, count * 35);
      const max = Math.max(min + 20, count * 60);
      return { min, max };
    }

    function deriveGuideCatalogRiskProfile(entry, category){
      const slug = slugifyForPalworld(entry?.groupId || entry?.groupLabel || '');
      if(slug && GUIDE_CATALOG_GROUP_RISK_MAP[slug]){
        return GUIDE_CATALOG_GROUP_RISK_MAP[slug];
      }
      if(category === 'bosses') return 'high';
      if(category === 'progression') return 'medium';
      return 'low';
    }

    function buildGuideCatalogTags(entry){
      const tags = new Set();
      const add = (value) => {
        const cleaned = cleanGuideText(value);
        if(cleaned) tags.add(cleaned);
      };
      add(entry?.categoryLabel || entry?.category);
      add(entry?.groupLabel);
      if(Array.isArray(entry?.keywords)){
        entry.keywords.forEach(keyword => add(keyword));
      }
      return Array.from(tags).slice(0, 8);
    }

    function deriveGuideCatalogObjectives(entry, steps){
      const objectives = [];
      const trigger = cleanGuideText(entry?.trigger);
      if(trigger) objectives.push(trigger);
      if(Array.isArray(steps)){
        steps.slice(0, 3).forEach(step => {
          const text = cleanGuideText(step?.summary || step?.detail);
          if(text) objectives.push(text);
        });
      }
      if(!objectives.length && entry?.title){
        objectives.push(`Work through the ${cleanGuideText(entry.title)} checklist.`);
      }
      return dedupeStrings(objectives);
    }

    function deriveGuideCatalogSteps(entry, { routeId, category } = {}){
      const steps = [];
      const list = Array.isArray(entry?.steps) ? entry.steps : [];
      list.forEach((rawStep, index) => {
        const detail = guideInstructionDetail(rawStep?.instruction);
        if(!detail) return;
        const orderValue = Number(rawStep?.order);
        const order = Number.isFinite(orderValue) ? orderValue : index + 1;
        const summary = guideInstructionSummary(rawStep?.instruction) || detail;
        const stepType = guideCatalogStepType(category, entry);
        const normalizedLinks = normalizeGuideCatalogLinks(rawStep?.links);
        const stepEntry = {
          step_id: `${routeId}:${String(order).padStart(3, '0')}`,
          type: stepType,
          summary,
          detail,
          targets: [],
          locations: [],
          mode_adjustments: {},
          recommended_loadout: { gear: [], pals: [], consumables: [] },
          xp_award_estimate: { min: 30, max: 60 },
          outputs: { items: [], pals: [], unlocks: {} },
          branching: [],
          citations: Array.isArray(rawStep?.citations) ? rawStep.citations.slice() : []
        };
        if(normalizedLinks.length) stepEntry.links = normalizedLinks;
        steps.push(stepEntry);
      });
      return steps;
    }

    function guideCatalogStepType(routeCategory, entry){
      const categorySlug = routeCategory && GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP[routeCategory]
        ? routeCategory
        : null;
      if(categorySlug && GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP[categorySlug]){
        return GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP[categorySlug];
      }
      const raw = slugifyForPalworld(entry?.categoryId || entry?.category || '');
      if(raw && GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP[raw]){
        return GUIDE_CATALOG_CATEGORY_STEP_TYPE_MAP[raw];
      }
      return 'quest';
    }

    function guideInstructionDetail(instruction){
      return cleanGuideText(instruction);
    }

    function guideInstructionSummary(instruction){
      const detail = guideInstructionDetail(instruction);
      if(!detail) return '';
      const sentenceMatch = detail.match(/[^.!?]+[.!?]?/);
      const summary = sentenceMatch ? sentenceMatch[0].trim() : detail;
      if(summary.length > 140){
        return `${summary.slice(0, 137)}…`;
      }
      return summary;
    }

    function deriveGuideCatalogAdaptiveGuidance(entry, { steps, levelRange, title } = {}){
      const list = Array.isArray(steps) ? steps : [];
      const firstStep = list[0] || null;
      const lastStep = list.length ? list[list.length - 1] : null;
      const firstSummary = cleanGuideText(firstStep?.summary || title || 'the first step');
      const lastSummary = cleanGuideText(lastStep?.summary || firstSummary);
      const relatedFirst = firstStep ? [firstStep.step_id] : [];
      const relatedLast = lastStep ? [lastStep.step_id] : relatedFirst.slice();
      const dynamicRules = [];
      if(relatedFirst.length){
        dynamicRules.push({
          signal: 'time_budget_short',
          condition: 'available_time_minutes && available_time_minutes < 15',
          adjustment: `Complete ${firstSummary} now and bookmark the remaining steps for later.`,
          priority: 3,
          mode_scope: ['normal', 'hardcore', 'solo', 'coop'],
          related_steps: relatedFirst.slice()
        });
      }
      if(relatedLast.length && levelRange){
        dynamicRules.push({
          signal: 'level_gap:over',
          condition: 'player.estimated_level >= recommended_level.max + 5',
          adjustment: `Skip ahead to ${lastSummary} to fast-track the checklist.`,
          priority: 2,
          mode_scope: ['normal', 'hardcore', 'solo', 'coop'],
          related_steps: relatedLast.slice()
        });
      }
      return {
        underleveled: firstSummary
          ? `If you're underleveled, focus on ${firstSummary} before tackling the remaining steps.`
          : 'If underleveled, complete the first step and pause until you improve your gear.',
        overleveled: lastSummary
          ? `If you're overleveled, skim the early steps and prioritise ${lastSummary} to finish quickly.`
          : 'Skim the checklist to confirm nothing critical is missing.',
        resource_shortages: [],
        time_limited: firstSummary
          ? `Short on time? Complete ${firstSummary} and return later for the rest.`
          : 'Short on time? Finish the first step and return later.',
        dynamic_rules: dynamicRules
      };
    }

    function deriveGuideCatalogCheckpoints(routeId, entry, steps){
      const list = Array.isArray(steps) ? steps : [];
      if(!list.length){
        return [];
      }
      const checkpoints = [];
      const firstStep = list[0];
      if(firstStep){
        checkpoints.push({
          id: `${routeId}:checkpoint-start`,
          summary: firstStep.summary || cleanGuideText(entry.title) || 'Begin the checklist',
          benefits: [`${cleanGuideText(entry.title) || 'Guide'} underway`],
          related_steps: [firstStep.step_id]
        });
      }
      if(list.length > 2){
        const midStep = list[Math.floor(list.length / 2)];
        if(midStep){
          checkpoints.push({
            id: `${routeId}:checkpoint-mid`,
            summary: midStep.summary || 'Midpoint review',
            benefits: ['Progress confirmed'],
            related_steps: [midStep.step_id]
          });
        }
      }
      const lastStep = list[list.length - 1];
      if(lastStep && (!firstStep || lastStep.step_id !== firstStep.step_id)){
        checkpoints.push({
          id: `${routeId}:checkpoint-complete`,
          summary: `Checklist complete: ${cleanGuideText(entry.title) || 'Guide finished'}`,
          benefits: ['Checklist cleared'],
          related_steps: [lastStep.step_id]
        });
      }
      return checkpoints;
    }

    function createPlaceholderCatalogStep(routeId, entry){
      const detail = cleanGuideText(entry?.title || 'Review the quick guide instructions.');
      return {
        step_id: `${routeId}:001`,
        type: 'quest',
        summary: detail || 'Review the quick guide instructions.',
        detail: detail || 'Review the quick guide instructions.',
        targets: [],
        locations: [],
        mode_adjustments: {},
        recommended_loadout: { gear: [], pals: [], consumables: [] },
        xp_award_estimate: { min: 30, max: 60 },
        outputs: { items: [], pals: [], unlocks: {} },
        branching: [],
        citations: [],
        links: []
      };
    }

    function dedupeStrings(values){
      const result = [];
      const seen = new Set();
      values.forEach(value => {
        if(!value && value !== 0) return;
        const text = String(value).trim();
        if(!text) return;
        const key = text.toLowerCase();
        if(seen.has(key)) return;
        seen.add(key);
        result.push(text);
      });
      return result;
    }

    function normalizeHeadingText(text){
      const stripped = stripMarkdownFormatting(text);
      return stripped.replace(/^\d+\.\s*/, '').trim();
    }

    function stripMarkdownFormatting(text){
      if(!text) return '';
      return String(text)
        .replace(/!\[[^\]]*?\]\([^)]*?\)/g, '')
        .replace(/\[([^\]]+)]\(([^)]+)\)/g, '$1')
        .replace(/[`*_~]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }

    function stripGuideCitations(value){
      if(value == null) return '';
      return String(value).replace(/\u3010[\s\S]*?\u3011/g, '');
    }

    function cleanGuideText(value){
      if(value == null) return '';
      const stripped = stripGuideCitations(value);
      const normalized = stripped
        .replace(/\s+([,.;!?])/g, '$1')
        .replace(/\s{2,}/g, ' ')
        .trim();
      const fallback = typeof value === 'string' ? value.trim() : '';
      return normalized || stripped.trim() || fallback;
    }

    function cleanGuideTextList(list){
      if(!Array.isArray(list)) return [];
      return list
        .map(entry => {
          const cleaned = cleanGuideText(entry);
          if(cleaned) return cleaned;
          if(typeof entry === 'string') return entry.trim();
          return '';
        })
        .filter(Boolean);
    }

    function parseRelatedGuideList(text){
      if(!text) return [];
      return text
        .split(/[;,•]/)
        .map(part => stripMarkdownFormatting(part))
        .map(part => part.replace(/^[-–—]\s*/, '').trim())
        .filter(Boolean);
    }

    function ensureGuideCatalogFiltersValid(){
      const catalog = routeGuideData?.guideCatalog;
      if(!catalog || !Array.isArray(catalog.entries)){
        return;
      }
      const groups = Array.isArray(catalog.groups) ? catalog.groups : [];
      if(guideCatalogGroupFilter !== 'all' && !groups.some(group => group.id === guideCatalogGroupFilter)){
        guideCatalogGroupFilter = 'all';
      }
      const categorySet = new Set();
      if(guideCatalogGroupFilter === 'all'){
        groups.forEach(group => {
          (group.categories || []).forEach(cat => categorySet.add(cat.id));
        });
      } else {
        const group = groups.find(entry => entry.id === guideCatalogGroupFilter);
        if(group){
          (group.categories || []).forEach(cat => categorySet.add(cat.id));
        }
      }
      if(guideCatalogCategoryFilter !== 'all' && !categorySet.has(guideCatalogCategoryFilter)){
        guideCatalogCategoryFilter = 'all';
      }
    }

    function ensurePurposefulGuideFiltersValid(){
      // Legacy builds exposed dedicated Purposeful Arc toggles.  Modern
      // releases collapsed those controls, but stale preferences may still
      // exist in localStorage.  Guard the hook so the dataset loader remains
      // resilient when those keys are absent.
    }

    function augmentRoute(route, index){
      const id = route?.route_id || `route-${index + 1}`;
      const tags = Array.isArray(route?.tags) ? route.tags.slice() : [];
      const objectives = cleanGuideTextList(route?.objectives);
      const level = route?.recommended_level || {};
      const time = route?.estimated_time_minutes || {};
      const xpGain = route?.estimated_xp_gain || {};
      const risk = route?.risk_profile || 'medium';
      const normalizedRole = normalizeRouteRole(route?.progression_role);
      const adaptiveGuidance = route?.adaptive_guidance || {};
      const steps = Array.isArray(route?.steps) ? route.steps.slice() : [];
      const chapter = convertRouteToChapter(route, { index, role: normalizedRole });
      const resourceOutputs = collectRouteResourceOutputs(route);
      const highlights = collectRouteHighlights(route, resourceOutputs);
      const playstyleKey = deriveRoutePlaystyleKey(route);
      return {
        id,
        index,
        title: cleanGuideText(route?.title || 'Route') || 'Route',
        category: route?.category || 'progression',
        tags,
        progression_role: normalizedRole,
        progression_role_raw: route?.progression_role || null,
        recommended_level: level,
        modes: route?.modes || {},
        prerequisites: route?.prerequisites || { routes: [], tech: [], items: [], pals: [] },
        objectives,
        estimated_time_minutes: time,
        estimated_xp_gain: xpGain,
        risk_profile: risk,
        failure_penalties: route?.failure_penalties || {},
        adaptive_guidance: adaptiveGuidance,
        checkpoints: Array.isArray(route?.checkpoints) ? route.checkpoints.slice() : [],
        supporting_routes: route?.supporting_routes || { recommended: [], optional: [] },
        failure_recovery: route?.failure_recovery || {},
        steps,
        completion_criteria: Array.isArray(route?.completion_criteria) ? route.completion_criteria.slice() : [],
        yields: route?.yields || {},
        metrics: route?.metrics || {},
        next_routes: Array.isArray(route?.next_routes) ? route.next_routes.slice() : [],
        raw: route,
        chapter,
        regions: collectRouteRegions(route),
        resourceOutputs,
        highlightPals: highlights.pals,
        highlightItems: highlights.items,
        highlightTech: highlights.tech,
        playstyleKey
      };
    }

    function convertRouteToChapter(route, { index = 0, role } = {}){
      const id = route?.route_id || `route-${index + 1}`;
      const steps = Array.isArray(route?.steps) ? route.steps : [];
      const title = cleanGuideText(route?.title || 'Route') || 'Route';
      const level = route?.recommended_level || {};
      const levelLabel = level && (level.min != null || level.max != null)
        ? `Lv ${level.min != null ? level.min : '?'}-${level.max != null ? level.max : '?'}`
        : '';
      const composedTitle = levelLabel ? `${title} — ${levelLabel}` : title;
      const objectives = cleanGuideTextList(route?.objectives);
      const whyParts = [];
      if(objectives.length){
        whyParts.push(objectives.join('; '));
      }
      if(route?.risk_profile){
        whyParts.push(`Risk: ${capitalize(route.risk_profile)}`);
      }
      if(route?.estimated_time_minutes){
        const solo = route.estimated_time_minutes.solo;
        const coop = route.estimated_time_minutes.coop;
        if(solo || coop){
          const timeBits = [];
          if(solo) timeBits.push(`${solo}m solo`);
          if(coop) timeBits.push(`${coop}m co-op`);
          whyParts.push(`Time: ${timeBits.join(' / ')}`);
        }
      }
      const kidSummary = objectives.length ? objectives[0] : 'Follow the plan and have fun!';
      const normalizedRole = normalizeRouteRole(role || route?.progression_role);
      return {
        id,
        title: composedTitle,
        titleKid: title,
        why: whyParts.join(' • '),
        whyKid: kidSummary,
        steps: steps.map((step, stepIndex) => convertRouteStep(route, step, stepIndex, normalizedRole))
      };
    }

    function convertRouteStep(route, step, index, routeRoleOverride){
      const id = step?.step_id || `${route?.route_id || 'route'}:${String(index + 1).padStart(3, '0')}`;
      const type = step?.type || 'task';
      const categoryLabel = stepCategoryLabel(type);
      const detail = cleanGuideText(step?.detail);
      const summary = cleanGuideText(step?.summary);
      const text = detail || summary;
      const textKid = summary || detail || '';
      const routeRole = routeRoleOverride || normalizeRouteRole(route?.progression_role);
      const progressionState = deriveStepProgressionState({ progression_role: routeRole, raw: route }, step);
      const optional = progressionState.optional;
      const links = createStepLinks(step);
      return {
        id,
        category: categoryLabel,
        text,
        textKid,
        optional,
        importance: progressionState.importance,
        routeRole,
        links,
        raw: step,
        routeId: route?.route_id || null,
        type
      };
    }

    function stepCategoryLabel(type){
      const map = {
        'travel': 'Travel',
        'gather': 'Gather',
        'farm': 'Farm',
        'capture': 'Catch',
        'fight': 'Boss',
        'craft': 'Craft',
        'build': 'Build',
        'unlock-tech': 'Tech',
        'breed': 'Breed',
        'deliver': 'Deliver',
        'talk': 'Talk',
        'explore': 'Explore',
        'prepare': 'Prep'
      };
      return map[type] || capitalize(type || 'Task');
    }

    function createStepLinks(step){
      const links = [];
      const linkMap = new Map();
      const pushLink = (link) => {
        if(!link || !link.type) return;
        const keyBits = [link.type];
        if(link.id){
          keyBits.push(String(link.id).toLowerCase());
        } else if(link.slug){
          keyBits.push(String(link.slug).toLowerCase());
        } else if(link.name){
          keyBits.push(String(link.name).toLowerCase());
        } else if(Array.isArray(link.coords)){
          keyBits.push(link.coords.join(','));
        }
        const key = keyBits.join(':');
        const existing = linkMap.get(key);
        if(existing){
          if(link.quantity != null && existing.quantity == null) existing.quantity = link.quantity;
          if(link.map && !existing.map) existing.map = link.map;
          if(Array.isArray(link.coords) && (!existing.coords || !existing.coords.length)) existing.coords = link.coords;
          if(link.region && !existing.region) existing.region = link.region;
          if(link.role && !existing.role) existing.role = link.role;
          if(link.url && !existing.url) existing.url = link.url;
          if(link.level != null && existing.level == null) existing.level = link.level;
          if(link.name && !existing.name) existing.name = link.name;
          if(link.slug && !existing.slug) existing.slug = link.slug;
          return;
        }
        const entry = { ...link };
        if(Array.isArray(entry.coords)){
          entry.coords = entry.coords.slice(0, 2).map(Number);
        }
        linkMap.set(key, entry);
        links.push(entry);
      };
      const normaliseString = (value) => {
        if(value == null) return '';
        return String(value).trim();
      };
      const addPalLink = (value) => {
        if(!value) return;
        if(typeof value === 'object'){
          const slug = slugifyForPalworld(normaliseString(value.slug || value.id || value.name));
          const palLink = {
            type: 'pal',
            id: value.id || slug || normaliseString(value.name),
            slug,
            name: value.name || value.label,
            role: value.role || value.assignment || value.task || null
          };
          if(value.level != null) palLink.level = Number(value.level);
          pushLink(palLink);
          return;
        }
        const slug = slugifyForPalworld(normaliseString(value));
        pushLink({ type: 'pal', id: slug || normaliseString(value), slug: slug || normaliseString(value) });
      };
      const addNpcLink = (value) => {
        if(!value) return;
        if(typeof value === 'object'){
          const slug = slugifyForPalworld(normaliseString(value.slug || value.id || value.name));
          const entry = {
            type: 'npc',
            id: value.id || slug || normaliseString(value.name),
            slug,
            name: value.name || value.label || normaliseString(value.id),
            role: value.role || value.title || value.job || null,
            region: value.region || value.region_id || null,
            url: value.url || null
          };
          if(Array.isArray(value.coords)) entry.coords = value.coords.slice(0, 2).map(Number);
          if(value.map && typeof value.map === 'object') entry.map = value.map;
          pushLink(entry);
          return;
        }
        const slug = slugifyForPalworld(normaliseString(value));
        const label = normaliseString(value);
        pushLink({ type: 'npc', id: slug || label, slug: slug || label, name: label });
      };
      const addItemLink = (value) => {
        if(!value) return;
        if(typeof value === 'object'){
          const id = value.item_id || value.itemId || value.id || value.slug || normaliseString(value.name);
          if(!id) return;
          const quantity = value.quantity ?? value.amount ?? value.count ?? value.qty ?? value.total ?? null;
          const entry = { type: 'item', id };
          if(quantity != null) entry.quantity = Number(quantity);
          pushLink(entry);
          return;
        }
        pushLink({ type: 'item', id: normaliseString(value) });
      };
      const addTechLink = (value) => {
        if(!value) return;
        if(typeof value === 'object'){
          const id = value.id || value.slug || value.tech_id || value.station_id || value.name;
          if(!id) return;
          const entry = { type: 'tech', id };
          if(value.level != null) entry.level = Number(value.level);
          pushLink(entry);
          return;
        }
        pushLink({ type: 'tech', id: normaliseString(value) });
      };
      const addLocationLink = (location) => {
        if(!location) return;
        const coords = Array.isArray(location.coords) ? location.coords.slice(0, 2).map(Number) : null;
        const entranceCoords = location.entrance && Array.isArray(location.entrance.coords)
          ? location.entrance.coords.slice(0, 2).map(Number)
          : null;
        const regionId = normalizeRegionId(location.region_id || location.region || '');
        const regionLabel = regionId ? describeRegionLabel(regionId) : '';
        const baseLabel = normaliseString(location.label || location.landmark || regionLabel);
        const coordsLabel = coords ? `(${coords[0]}, ${coords[1]})` : '';
        const label = baseLabel || coordsLabel || 'Route location';
        const identifier = regionId || (coords ? coords.join(',') : label);
        const mapInfo = {
          coords: coords || null,
          entrance: location.entrance || null,
          entranceCoords: entranceCoords || null,
          region: regionLabel || null,
          label,
          title: label,
          url: location.url || `${PALWORLD_BASE_URL}/map`
        };
        pushLink({
          type: 'location',
          id: identifier,
          name: label,
          region: regionLabel,
          coords: coords || null,
          map: mapInfo,
          url: location.url || `${PALWORLD_BASE_URL}/map`
        });
      };
      const processItemCollection = (collection) => {
        if(!Array.isArray(collection)) return;
        collection.forEach(addItemLink);
      };
      const processPalCollection = (collection) => {
        if(!Array.isArray(collection)) return;
        collection.forEach(addPalLink);
      };
      const processTechCollection = (collection) => {
        if(!Array.isArray(collection)) return;
        collection.forEach(addTechLink);
      };
      if(step && Array.isArray(step.links)){
        step.links.forEach(raw => pushLink(raw));
      }
      if(step && Array.isArray(step.targets)){
        step.targets.forEach(target => {
          if(!target || !target.kind) return;
          if(target.kind === 'pal'){
            pushLink({ type: 'pal', slug: target.slug || target.id, id: target.id || target.slug, name: target.name });
          } else if(target.kind === 'item'){
            pushLink({ type: 'item', id: target.id });
          } else if(target.kind === 'tech' || target.kind === 'station'){
            pushLink({ type: 'tech', id: target.id });
          } else if(target.kind === 'boss'){
            pushLink({ type: 'tower', id: target.id || target.slug || target.name, map: target.map });
          } else if(target.kind === 'npc'){
            addNpcLink(target);
          } else if(target.kind === 'location'){
            addLocationLink(target);
          }
        });
      }
      const requirementSources = [];
      if(Array.isArray(step?.requirements)) requirementSources.push(step.requirements);
      if(step?.raw && Array.isArray(step.raw.requirements)) requirementSources.push(step.raw.requirements);
      const processRequirement = (req) => {
        if(!req) return;
        if(typeof req === 'string'){
          addItemLink(req);
          return;
        }
        if(typeof req !== 'object') return;
        if(req.kind === 'location'){
          addLocationLink(req);
          return;
        }
        if(req.kind === 'pal'){
          addPalLink(req);
          return;
        }
        if(req.kind === 'tech' || req.kind === 'station'){
          const id = req.id || req.tech_id || req.station_id;
          if(id) addTechLink({ ...req, id });
          return;
        }
        if(req.kind === 'npc'){
          addNpcLink(req);
          return;
        }
        if(req.kind === 'item'){
          addItemLink({ ...req, id: req.id || req.item_id });
          return;
        }
        if(req.item_id || req.itemId || req.id){
          addItemLink(req);
          return;
        }
        if(req.tech_id || req.station_id || req.tech){
          const id = req.tech_id || req.station_id || req.tech;
          addTechLink({ ...req, id });
          return;
        }
        if(req.pal_id || req.pal || req.slug || req.name){
          addPalLink(req);
          return;
        }
        if(req.npc_id || req.npc || req.kind === 'npc'){
          addNpcLink(req);
          return;
        }
        if(req.location){
          addLocationLink(req.location);
        }
      };
      requirementSources.forEach(list => {
        list.forEach(processRequirement);
      });
      const adjustmentSources = [];
      if(step?.mode_adjustments && typeof step.mode_adjustments === 'object') adjustmentSources.push(step.mode_adjustments);
      if(step?.raw?.mode_adjustments && typeof step.raw.mode_adjustments === 'object' && step.raw.mode_adjustments !== step.mode_adjustments){
        adjustmentSources.push(step.raw.mode_adjustments);
      }
      const handleModeArray = (key, value) => {
        if(!Array.isArray(value)) return;
        const lowerKey = key.toLowerCase();
        if(lowerKey.includes('pal') || lowerKey.includes('ally') || lowerKey.includes('companion')){
          processPalCollection(value);
        } else if(lowerKey.includes('tech') || lowerKey.includes('station')){
          processTechCollection(value);
        } else if(lowerKey.includes('npc')){
          value.forEach(addNpcLink);
        } else if(lowerKey.includes('location')){
          value.forEach(addLocationLink);
        } else if(lowerKey.includes('item') || lowerKey.includes('consum') || lowerKey.includes('supply') || lowerKey.includes('gear')){
          processItemCollection(value);
        }
      };
      adjustmentSources.forEach(modeMap => {
        Object.values(modeMap || {}).forEach(mode => {
          if(!mode || typeof mode !== 'object') return;
          processItemCollection(mode.safety_buffer_items);
          processItemCollection(mode.support_items);
          processItemCollection(mode.items);
          processItemCollection(mode.gear);
          processItemCollection(mode.consumables);
          processPalCollection(mode.pals);
          processPalCollection(mode.allies);
          processTechCollection(mode.tech);
          processTechCollection(mode.stations);
          if(mode.loadout && typeof mode.loadout === 'object'){
            processItemCollection(mode.loadout.gear);
            processItemCollection(mode.loadout.consumables);
            processPalCollection(mode.loadout.pals);
          }
          Object.entries(mode).forEach(([key, value]) => handleModeArray(key, value));
        });
      });
      const outputs = step?.outputs || {};
      if(Array.isArray(outputs.items)){
        outputs.items.forEach(addItemLink);
      }
      if(Array.isArray(outputs.pals)){
        outputs.pals.forEach(addPalLink);
      }
      if(outputs.unlocks){
        if(Array.isArray(outputs.unlocks.tech)){
          outputs.unlocks.tech.forEach(addTechLink);
        }
        if(Array.isArray(outputs.unlocks.stations)){
          outputs.unlocks.stations.forEach(addTechLink);
        }
      }
      const loadout = step?.recommended_loadout || {};
      if(Array.isArray(loadout.pals)){
        loadout.pals.forEach(addPalLink);
      }
      if(Array.isArray(loadout.gear)){
        loadout.gear.forEach(addItemLink);
      }
      if(Array.isArray(loadout.consumables)){
        loadout.consumables.forEach(addItemLink);
      }
      if(Array.isArray(step?.locations)){
        step.locations.forEach(addLocationLink);
      }
      return links;
    }

    function collectRouteResourceOutputs(route){
      const items = new Set();
      const addItem = value => {
        if(!value) return;
        const itemId = value.item_id || value.itemId || value.id || value.slug || value;
        if(!itemId) return;
        if(isResourceItemId(itemId)){
          items.add(itemId);
        }
      };
      if(route?.steps){
        route.steps.forEach(step => {
          const outputs = step?.outputs?.items || [];
          outputs.forEach(addItem);
          const links = Array.isArray(step?.links) ? step.links : [];
          links.forEach(link => {
            if(link && link.type === 'item'){
              addItem(link);
            }
          });
          const targets = Array.isArray(step?.targets) ? step.targets : [];
          targets.forEach(target => {
            if(target && target.kind === 'item'){
              addItem(target);
            }
          });
        });
      }
      const routeOutputs = route?.outputs?.items || [];
      routeOutputs.forEach(addItem);
      return Array.from(items);
    }

    function normalizeTechSlug(value){
      if(!value) return '';
      const slug = slugifyForPalworld(String(value));
      if(!slug) return '';
      const trimmed = slug.replace(/^(tech-|station-)/, '');
      return trimmed || slug;
    }

    function collectRouteHighlights(route, resourceOutputs = []){
      const pals = new Set();
      const items = new Set();
      const tech = new Set();
      const addPal = value => {
        if(!value) return;
        const slug = slugifyForPalworld(String(value));
        if(slug) pals.add(slug);
      };
      const addItem = value => {
        if(!value) return;
        const slug = slugifyForPalworld(String(value));
        if(slug) items.add(slug);
      };
      const addTech = value => {
        if(!value) return;
        const slug = normalizeTechSlug(value);
        if(slug) tech.add(slug);
      };
      const steps = Array.isArray(route?.steps) ? route.steps : [];
      steps.forEach(step => {
        const targets = Array.isArray(step?.targets) ? step.targets : [];
        targets.forEach(target => {
          if(!target || !target.kind) return;
          if(target.kind === 'pal'){ addPal(target.id || target.slug || target.name); }
          if(target.kind === 'item'){ addItem(target.id); }
          if(target.kind === 'tech' || target.kind === 'station'){ addTech(target.id); }
        });
        const outputs = step?.outputs || {};
        if(Array.isArray(outputs.pals)){
          outputs.pals.forEach(addPal);
        }
        if(Array.isArray(outputs.items)){
          outputs.items.forEach(entry => addItem(entry?.item_id || entry?.itemId || entry));
        }
        if(outputs.unlocks){
          if(Array.isArray(outputs.unlocks.tech)) outputs.unlocks.tech.forEach(addTech);
          if(Array.isArray(outputs.unlocks.stations)) outputs.unlocks.stations.forEach(addTech);
        }
        const links = Array.isArray(step?.links) ? step.links : [];
        links.forEach(link => {
          if(!link || !link.type) return;
          if(link.type === 'pal'){ addPal(link.id || link.slug || link.name); }
          if(link.type === 'item'){ addItem(link.id); }
          if(link.type === 'tech'){ addTech(link.id || link.slug || link.name); }
        });
      });
      const yields = route?.yields || {};
      if(Array.isArray(yields.pals)) yields.pals.forEach(addPal);
      if(Array.isArray(yields.items)) yields.items.forEach(entry => addItem(entry?.item_id || entry));
      if(Array.isArray(yields.key_unlocks)) yields.key_unlocks.forEach(addTech);
      const prereq = route?.prerequisites || {};
      if(Array.isArray(prereq.pals)) prereq.pals.forEach(addPal);
      if(Array.isArray(prereq.items)) prereq.items.forEach(entry => addItem(entry?.item_id || entry));
      if(Array.isArray(prereq.tech)) prereq.tech.forEach(addTech);
      const criteria = Array.isArray(route?.completion_criteria) ? route.completion_criteria : [];
      criteria.forEach(entry => {
        if(!entry || !entry.type) return;
        if(entry.type.startsWith('have-pal')) addPal(entry.pal_id || entry.id);
        if(entry.type.startsWith('have-item')) addItem(entry.item_id || entry.id);
        if(entry.type.startsWith('unlock-tech')) addTech(entry.tech_id || entry.id);
      });
      if(Array.isArray(resourceOutputs)){
        resourceOutputs.forEach(addItem);
      }
      return {
        pals: Array.from(pals),
        items: Array.from(items),
        tech: Array.from(tech)
      };
    }

    function collectRouteRegions(route){
      const counts = new Map();
      const labels = new Map();
      const register = (raw) => {
        const slug = normalizeRegionId(raw);
        if(!slug) return;
        counts.set(slug, (counts.get(slug) || 0) + 1);
        if(!labels.has(slug)){
          labels.set(slug, describeRegionLabel(slug));
        }
      };
      const rawRegions = Array.isArray(route?.regions) ? route.regions : [];
      rawRegions.forEach(register);
      const steps = Array.isArray(route?.steps) ? route.steps : [];
      steps.forEach(step => {
        const locations = Array.isArray(step?.locations) ? step.locations : [];
        locations.forEach(location => {
          if(location?.region_id){
            register(location.region_id);
          } else if(location?.region){
            register(location.region);
          }
        });
      });
      const summary = Array.from(counts.entries())
        .sort((a, b) => b[1] - a[1])
        .map(([id, count]) => ({ id, count, name: labels.get(id) || describeRegionLabel(id) }));
      return {
        ids: summary.map(entry => entry.id),
        summary,
        primary: summary.length ? summary[0].id : null
      };
    }

    function summarizeRouteRegions(route){
      if(!route) return [];
      const summary = Array.isArray(route?.regions?.summary) ? route.regions.summary : null;
      if(summary && summary.length) return summary;
      const derived = collectRouteRegions(route);
      return Array.isArray(derived?.summary) ? derived.summary : [];
    }

    function normalizeRegionId(value){
      if(!value) return '';
      if(typeof value === 'string' && value.startsWith('region:')){
        return slugifyForPalworld(value.slice(7));
      }
      return slugifyForPalworld(String(value));
    }

    function describeRegionLabel(id){
      if(!id) return '';
      const raw = id.replace(/^region:/, '');
      return niceName(raw);
    }

    function resolvePalInfoBySlug(slug){
      const normalized = slugifyForPalworld(String(slug || ''));
      if(!normalized){
        return { slug: '', id: null, pal: null, name: '', caught: false };
      }
      const link = { id: normalized, slug: normalized };
      const palId = resolvePalIdFromLink(link);
      const pal = palId != null && PALS ? PALS[palId] : null;
      const name = pal?.name || niceName(normalized);
      const caughtStatus = palId != null ? !!caught[palId] : isPalCaughtByName(name);
      return { slug: normalized, id: palId, pal, name, caught: caughtStatus };
    }

    function resolveTechInfoBySlug(slug){
      const normalized = slugifyForPalworld(String(slug || ''));
      if(!normalized){
        return { slug: '', name: '', unlocked: false };
      }
      const info = lookupTechBySlug(normalized) || lookupTechBySlug(`tech-${normalized}`);
      const name = info?.item?.name || niceName(normalized);
      return { slug: normalized, name, unlocked: isTechUnlocked(name) };
    }

    function deriveStageRegions(stageSnapshot){
      const regions = new Map();
      if(!stageSnapshot || !stageSnapshot.stageId){
        return [];
      }
      const route = routeGuideData?.routeLookup?.[stageSnapshot.stageId];
      if(route){
        const regionSummary = Array.isArray(route?.regions?.summary) ? route.regions.summary : [];
        regionSummary.slice(0, 4).forEach(entry => {
          if(!regions.has(entry.id)){
            regions.set(entry.id, { id: entry.id, name: entry.name });
          }
        });
        if(stageSnapshot.nextStep && stageSnapshot.nextStep.id){
          const raw = findRawStep(route, stageSnapshot.nextStep.id);
          extractRegionsFromRawStep(raw).forEach(entry => {
            if(!regions.has(entry.id)){
              regions.set(entry.id, entry);
            }
          });
        }
      }
      return Array.from(regions.values());
    }

    function extractRegionsFromRawStep(rawStep){
      if(!rawStep) return [];
      const map = new Map();
      const locations = Array.isArray(rawStep?.locations) ? rawStep.locations : [];
      locations.forEach(location => {
        const id = normalizeRegionId(location?.region_id || location?.region || '');
        if(!id || map.has(id)) return;
        map.set(id, { id, name: describeRegionLabel(id) });
      });
      return Array.from(map.values());
    }

    function gatherPendingBaseRouteIds(stageSnapshot){
      const ids = new Set();
      const pending = Array.isArray(stageSnapshot?.pendingBaseSteps) ? stageSnapshot.pendingBaseSteps : [];
      pending.forEach(entry => {
        const chapterId = entry?.chapter?.id;
        if(chapterId){
          ids.add(chapterId);
        }
      });
      return ids;
    }

    function deriveRoutePlaystyleKey(route){
      const tags = new Set((Array.isArray(route?.tags) ? route.tags : []).map(tag => String(tag || '').toLowerCase()));
      const category = String(route?.category || '').toLowerCase();
      if(tags.has('boss') || tags.has('tower') || category.includes('boss') || category.includes('tower')){
        return 'boss';
      }
      if(tags.has('resource-gathering') || tags.has('farming') || category.includes('resource') || category.includes('farm')){
        return 'resource';
      }
      if(tags.has('capture') || tags.has('taming')){
        return 'capture';
      }
      if(tags.has('base-building') || category.includes('base')){
        return 'base';
      }
      if(tags.has('crafting') || tags.has('tech') || category.includes('craft')){
        return 'craft';
      }
      if(tags.has('exploration') || tags.has('travel') || category.includes('explore')){
        return 'explore';
      }
      if(route?.progression_role === 'core'){
        return 'core';
      }
      if(route?.progression_role === 'support'){
        return 'support';
      }
      return 'adventure';
    }

    function routeChapterTitle(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.titleKid || chapter.title || '') : (chapter.title || chapter.titleKid || '');
    }

    function routeChapterWhy(chapter){
      if(!chapter) return '';
      return kidMode ? (chapter.whyKid || chapter.why || '') : (chapter.why || chapter.whyKid || '');
    }

    function routeStepText(step){
      if(!step) return '';
      if(!kidMode && step.textAdult) return step.textAdult;
      return kidMode ? (step.textKid || step.text || '') : (step.text || step.textKid || '');
    }

    function routeOptionalToggleLabel(hidden){
      if(kidMode){
        return hidden ? 'Show bonus steps' : 'Hide bonus steps';
      }
      return hidden ? 'Show Optional' : 'Hide Optional';
    }

    function routeCategorySlug(category, { fallback = 'task', strict = false } = {}){
      const raw = category == null ? '' : String(category);
      const slug = raw.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
      if(slug) return slug;
      return strict ? '' : fallback;
    }

    function sanitizeImageUrl(url){
      const raw = typeof url === 'string' ? url.trim() : '';
      let safe = raw || ROUTE_ART_IMAGE;
      if(!safe){
        safe = '';
      }
      const lower = safe.toLowerCase();
      const isAbsolute = /^(https?:|data:|blob:|\/{1,2})/.test(lower);
      if(!isAbsolute){
        // Remove leading './' segments so we can normalise relative paths cleanly.
        safe = safe.replace(/^\.\/+/,'');
        // Keep any existing '../' segments (some assets already specify them).
        if(!safe.startsWith('../')){
          safe = `../${safe}`;
        }
      }
      return safe.replace(/'/g, "\\'");
    }

    function guideCatalogThemeFor(entry){
      const fallback = GUIDE_CATALOG_THEME_MAP.generic;
      if(!entry || typeof entry !== 'object') return fallback;
      const candidates = [];
      if(entry.categoryId) candidates.push(String(entry.categoryId));
      if(entry.categoryLabel) candidates.push(slugifyForPalworld(entry.categoryLabel));
      if(entry.groupId) candidates.push(String(entry.groupId));
      if(entry.groupLabel) candidates.push(slugifyForPalworld(entry.groupLabel));
      candidates.push('generic');
      for(const candidate of candidates){
        if(!candidate) continue;
        const key = candidate.toLowerCase();
        if(GUIDE_CATALOG_THEME_MAP[key]) return GUIDE_CATALOG_THEME_MAP[key];
      }
      return fallback;
    }

    function guideCatalogArtFor(entry){
      const theme = guideCatalogThemeFor(entry) || GUIDE_CATALOG_THEME_MAP.generic;
      return {
        image: ROUTE_ART_IMAGE,
        overlay: theme.overlay || GUIDE_CATALOG_THEME_MAP.generic.overlay,
        accent: theme.accent || GUIDE_CATALOG_THEME_MAP.generic.accent,
        icon: theme.icon || GUIDE_CATALOG_THEME_MAP.generic.icon,
        position: theme.position || GUIDE_CATALOG_THEME_MAP.generic.position
      };
    }

    function guideCardStyleAttr(art, { includeRouteSuggestionVars = false } = {}){
      if(!art || typeof art !== 'object') return '';
      const styleParts = [];
      if(art.image){
        const urlValue = `url('${sanitizeImageUrl(art.image)}')`;
        styleParts.push(`--guide-card-image:${urlValue}`);
        if(includeRouteSuggestionVars){
          styleParts.push(`--route-suggestion-image:${urlValue}`);
        }
      }
      if(art.overlay){
        styleParts.push(`--guide-card-overlay:${art.overlay}`);
        if(includeRouteSuggestionVars){
          styleParts.push(`--route-suggestion-overlay:${art.overlay}`);
        }
      }
      if(art.accent){
        styleParts.push(`--guide-card-accent:${art.accent}`);
        if(includeRouteSuggestionVars){
          styleParts.push(`--route-suggestion-accent:${art.accent}`);
        }
      }
      if(art.position){
        styleParts.push(`--guide-card-position:${art.position}`);
        if(includeRouteSuggestionVars){
          styleParts.push(`--route-suggestion-position:${art.position}`);
        }
      }
      if(includeRouteSuggestionVars && art.marker && typeof art.marker.left === 'number' && typeof art.marker.top === 'number'){
        styleParts.push(`--route-suggestion-marker-left:${art.marker.left}%`);
        styleParts.push(`--route-suggestion-marker-top:${art.marker.top}%`);
        styleParts.push('--route-suggestion-marker-opacity:1');
      }
      if(!styleParts.length) return '';
      return `style="${escapeHTML(styleParts.join('; '))}"`;
    }

    function palVisualTheme(pal){
      const primary = getPrimaryType(pal) || 'Neutral';
      return PAL_TYPE_VISUALS[primary] || PAL_TYPE_VISUALS.Neutral || { overlay: ROUTE_VISUAL_THEMES.pal.overlay, accent: ROUTE_VISUAL_THEMES.pal.accent };
    }

    function resolveItemDetail(itemId){
      if(!itemId || !ITEM_DETAILS) return null;
      if(ITEM_DETAILS[itemId]) return ITEM_DETAILS[itemId];
      const slug = slugifyForPalworld(String(itemId));
      if(slug && ITEM_DETAILS[slug]) return ITEM_DETAILS[slug];
      return null;
    }

    function gatherStepTargets(step){
      const targets = [];
      const seen = new Set();
      const links = Array.isArray(step?.links) ? step.links : [];
      links.forEach(link => {
        if(!link || !link.type) return;
        const key = `${link.type}:${link.id || link.slug || link.name || ''}`;
        seen.add(key);
        targets.push(link);
      });
      const rawTargets = Array.isArray(step?.raw?.targets) ? step.raw.targets : [];
      rawTargets.forEach(target => {
        if(!target || !target.kind) return;
        const typeMap = { pal: 'pal', item: 'item', tech: 'tech', station: 'tech', boss: 'tower', npc: 'npc' };
        const mapped = typeMap[target.kind];
        if(!mapped) return;
        const ident = target.id || target.slug || target.name || '';
        const key = `${mapped}:${ident}`;
        if(seen.has(key)) return;
        seen.add(key);
        targets.push({ type: mapped, id: target.id || target.slug, slug: target.slug, name: target.name, map: target.map });
      });
      return targets;
    }

    function routeStepLocation(step){
      const raw = step?.raw;
      if(raw && Array.isArray(raw.locations) && raw.locations.length){
        const loc = raw.locations.find(entry => Array.isArray(entry.coords) && entry.coords.length >= 2) || raw.locations[0];
        if(loc){
          const coords = Array.isArray(loc.coords) && loc.coords.length >= 2 ? [Number(loc.coords[0]), Number(loc.coords[1])] : null;
          const region = loc.region || loc.region_id || '';
          const label = loc.label || loc.landmark || (region ? niceName(region) : '');
          return { coords, region, label };
        }
      }
      const link = (step?.links || []).find(entry => entry && entry.type === 'tower' && entry.map);
      if(link && link.map){
        const map = link.map;
        const coords = Array.isArray(map.coords) ? [Number(map.coords[0]), Number(map.coords[1])] : (
          map.entrance && Array.isArray(map.entrance.coords) ? [Number(map.entrance.coords[0]), Number(map.entrance.coords[1])] : null
        );
        const region = map.region || '';
        const label = map.label || map.title || (map.entrance && map.entrance.label) || '';
        return { coords, region, label };
      }
      return null;
    }

    function routeVisualFromStep(step, route){
      const targets = gatherStepTargets(step);
      for(const target of targets){
        if(target.type === 'pal'){
          const palId = resolvePalIdFromLink(target);
          const pal = palId != null ? PALS?.[palId] : null;
          if(pal){
            const theme = palVisualTheme(pal);
            const image = getPalArtSource(pal) || getPalOnlineArtSource(pal) || getPalIconSource(pal);
            if(image){
              return {
                type: 'pal',
                image,
                overlay: theme.overlay,
                accent: theme.accent,
                icon: ROUTE_VISUAL_THEMES.pal.icon,
                position: ROUTE_VISUAL_THEMES.pal.position,
                label: pal.name,
                alt: `${pal.name} pal artwork`
              };
            }
          }
        } else if(target.type === 'tech'){
          const tech = resolveTechFromLink(target);
          const item = tech?.item;
          const image = item?.image || item?.icon;
          if(item && image){
            return {
              type: 'tech',
              image,
              overlay: ROUTE_VISUAL_THEMES.tech.overlay,
              accent: ROUTE_VISUAL_THEMES.tech.accent,
              icon: ROUTE_VISUAL_THEMES.tech.icon,
              position: ROUTE_VISUAL_THEMES.tech.position,
              label: item.name || niceName(target.id || target.slug || ''),
              alt: `${item.name || niceName(target.id || target.slug || '')} technology`
            };
          }
        } else if(target.type === 'item'){
          const detail = resolveItemDetail(target.id);
          const image = detail?.image || detail?.icon;
          if(image){
            const name = detail?.name || niceName(target.id || '');
            return {
              type: 'item',
              image,
              overlay: ROUTE_VISUAL_THEMES.item.overlay,
              accent: ROUTE_VISUAL_THEMES.item.accent,
              icon: ROUTE_VISUAL_THEMES.item.icon,
              position: ROUTE_VISUAL_THEMES.item.position,
              label: name,
              alt: `${name} item`
            };
          }
        } else if(target.type === 'tower'){
          const location = routeStepLocation(step);
          const marker = location?.coords ? worldCoordsToPercent(location.coords) : null;
          return {
            type: 'boss',
            image: ROUTE_ART_IMAGE,
            overlay: ROUTE_VISUAL_THEMES.boss.overlay,
            accent: ROUTE_VISUAL_THEMES.boss.accent,
            icon: ROUTE_VISUAL_THEMES.boss.icon,
            position: ROUTE_VISUAL_THEMES.boss.position,
            marker,
            label: location?.label || niceName(target.id || target.slug || target.name || ''),
            alt: `${route?.title || 'Boss'} location`
          };
        } else if(target.type === 'npc'){
          const slug = slugifyForPalworld(target.slug || target.id || target.name || '');
          const portrait = target.image || (slug ? NPC_ART_LIBRARY[slug] : null) || ROUTE_VISUAL_THEMES.npc.image;
          if(portrait){
            return {
              type: 'npc',
              image: portrait,
              overlay: ROUTE_VISUAL_THEMES.npc.overlay,
              accent: ROUTE_VISUAL_THEMES.npc.accent,
              icon: ROUTE_VISUAL_THEMES.npc.icon,
              position: ROUTE_VISUAL_THEMES.npc.position,
              label: target.name || niceName(target.id || ''),
              alt: `${target.name || 'NPC'} portrait`
            };
          }
        }
      }
      const location = routeStepLocation(step);
      if(location){
        const marker = location.coords ? worldCoordsToPercent(location.coords) : null;
        return {
          type: 'map',
          image: ROUTE_ART_IMAGE,
          overlay: ROUTE_VISUAL_THEMES.map.overlay,
          accent: ROUTE_VISUAL_THEMES.map.accent,
          icon: ROUTE_VISUAL_THEMES.map.icon,
          position: ROUTE_VISUAL_THEMES.map.position,
          marker,
          label: location.label || niceName(location.region || ''),
          alt: `${route?.title || 'Route'} map location`
        };
      }
      return null;
    }

    function routeVisualFromTags(route){
      if(!route) return {};
      const keys = [];
      if(route.progression_role) keys.push(String(route.progression_role).toLowerCase());
      if(route.route_id){
        String(route.route_id)
          .toLowerCase()
          .split(/[^a-z0-9]+/)
          .filter(Boolean)
          .forEach(part => keys.push(part));
      }
      if(route.category) keys.push(String(route.category).toLowerCase());
      if(Array.isArray(route.tags)){
        route.tags.forEach(tag => keys.push(String(tag).toLowerCase()));
      }
      for(const key of keys){
        if(!key) continue;
        const directKey = ROUTE_ART_LIBRARY[key] ? key : null;
        if(directKey){
          return { ...ROUTE_ART_LIBRARY[directKey], type: directKey };
        }
        const aliasKey = ROUTE_ART_ALIASES[key];
        if(aliasKey && ROUTE_ART_LIBRARY[aliasKey]){
          return { ...ROUTE_ART_LIBRARY[aliasKey], type: aliasKey };
        }
        if(key.includes('tower') || key.includes('boss')){
          return { ...ROUTE_VISUAL_THEMES.boss, type: 'boss' };
        }
        if(key.includes('farm') || key.includes('gather')){
          return { ...ROUTE_VISUAL_THEMES.item, icon: 'fa-seedling', type: 'item' };
        }
        if(key.includes('resource')){
          const art = ROUTE_ART_LIBRARY.resource || ROUTE_VISUAL_THEMES.item;
          return { ...art, type: 'resource' };
        }
        if(key.includes('mount')){
          const art = ROUTE_ART_LIBRARY.mount || ROUTE_VISUAL_THEMES.map;
          return { ...art, type: 'mount' };
        }
        if(key.includes('capture') || key.includes('tame')){
          const art = ROUTE_ART_LIBRARY.capture || ROUTE_VISUAL_THEMES.pal;
          return { ...art, type: 'capture' };
        }
        if(key.includes('tech') || key.includes('craft') || key.includes('build')){
          const art = ROUTE_ART_LIBRARY.craft || ROUTE_VISUAL_THEMES.tech;
          return { ...art, type: 'craft' };
        }
        if(key.includes('base') || key.includes('automation')){
          const art = ROUTE_ART_LIBRARY.base || ROUTE_VISUAL_THEMES.item;
          return { ...art, type: 'base' };
        }
        if(key.includes('campaign') || key.includes('story')){
          const art = ROUTE_ART_LIBRARY.campaign || ROUTE_VISUAL_THEMES.map;
          return { ...art, type: 'campaign' };
        }
      }
      return {};
    }

    function computeRouteVisual(route){
      const baseTheme = ROUTE_VISUAL_THEMES.generic || {};
      const fallbackImage = baseTheme.image || ROUTE_ART_IMAGE;
      const fallback = { ...baseTheme, image: fallbackImage, type: 'generic', label: route?.title || 'Route', alt: route?.title ? `${route.title} guide artwork` : 'Route guide artwork', marker: null };
      if(!route) return fallback;
      const steps = Array.isArray(route?.chapter?.steps) ? route.chapter.steps : [];
      for(const step of steps){
        const visual = routeVisualFromStep(step, route);
        if(visual && visual.image){
          return { ...fallback, ...visual };
        }
      }
      const tagVisual = routeVisualFromTags(route);
      if(tagVisual && Object.keys(tagVisual).length){
        return { ...fallback, ...tagVisual };
      }
      const variants = ROUTE_ART_VARIANTS.length ? ROUTE_ART_VARIANTS : [{ ...baseTheme, image: fallbackImage }];
      const variant = variants[Math.abs(hashString(route?.id || route?.title || 'route')) % variants.length] || variants[0];
      return { ...fallback, ...variant };
    }

    function routeArtFor(route){
      const visual = computeRouteVisual(route);
      const highlight = (routeHighlightMedia(route, { limit: 1 }) || [])[0];
      if(highlight && highlight.image){
        const themeMap = { pal: ROUTE_VISUAL_THEMES.pal, tech: ROUTE_VISUAL_THEMES.tech, item: ROUTE_VISUAL_THEMES.item };
        const theme = themeMap[highlight.type] || {};
        return {
          ...visual,
          image: sanitizeImageUrl(highlight.image || visual.image),
          overlay: theme.overlay || visual.overlay || ROUTE_VISUAL_THEMES.generic.overlay,
          accent: theme.accent || visual.accent || ROUTE_VISUAL_THEMES.generic.accent,
          icon: theme.icon || visual.icon || ROUTE_VISUAL_THEMES.generic.icon,
          position: visual.position || ROUTE_VISUAL_THEMES.generic.position,
          marker: visual.marker || null
        };
      }
      return {
        ...visual,
        image: sanitizeImageUrl(visual.image),
        overlay: visual.overlay || ROUTE_VISUAL_THEMES.generic.overlay,
        accent: visual.accent || ROUTE_VISUAL_THEMES.generic.accent,
        icon: visual.icon || ROUTE_VISUAL_THEMES.generic.icon,
        position: visual.position || ROUTE_VISUAL_THEMES.generic.position,
        marker: visual.marker || null
      };
    }

    function setRouteCardBackdrop(element, art, fallbackKey){
      if(!element) return;
      const fallback = ROUTE_CARD_BACKDROP_FALLBACKS[fallbackKey] || {};
      const imageSource = art && art.image ? art.image : (fallback.image || ROUTE_ART_IMAGE);
      const overlay = art && art.overlay ? art.overlay : (fallback.overlay || 'rgba(12, 28, 44, 0.85)');
      const position = art && art.position ? art.position : (fallback.position || 'center 50%');
      const accent = art && art.accent ? art.accent : fallback.accent;
      const imageValue = `url('${sanitizeImageUrl(imageSource)}')`;
      element.style.setProperty('--route-card-backdrop', imageValue);
      element.style.setProperty('--route-card-overlay', overlay);
      element.style.setProperty('--route-card-position', position);
      if(accent){
        element.style.setProperty('--route-card-accent', accent);
      } else {
        element.style.removeProperty('--route-card-accent');
      }
    }

    function determineActiveRoute(){
      const ids = Array.isArray(activeRouteIds) ? Array.from(activeRouteIds) : [];
      for(const id of ids){
        const route = routeGuideData?.routeLookup?.[id];
        if(route) return route;
      }
      return null;
    }

    function determineHeroRoute(){
      const next = findNextRouteStep() || findNextRouteStep({ includeOptional: true });
      if(next && next.chapter){
        const route = routeGuideData?.routeLookup?.[next.chapter.id];
        if(route) return route;
      }
      const activeRoute = determineActiveRoute();
      if(activeRoute) return activeRoute;
      if(Array.isArray(currentRouteSuggestionEntries) && currentRouteSuggestionEntries.length){
        const entry = currentRouteSuggestionEntries[0];
        if(entry && entry.route) return entry.route;
      }
      if(Array.isArray(routeGuideData?.routes) && routeGuideData.routes.length){
        return routeGuideData.routes[0];
      }
      return null;
    }

    function updateRouteSuggestionCardBackdrop(entries){
      const card = document.getElementById('routeSuggestionsCard');
      if(!card) return;
      const collection = Array.isArray(entries) && entries.length ? entries : currentRouteSuggestionEntries;
      let entry = null;
      if(collection && collection.length){
        entry = collection.find(item => item && item.route && item.route.id === activeSuggestedRouteId) || collection[0];
      }
      const art = entry && entry.route ? routeArtFor(entry.route) : null;
      setRouteCardBackdrop(card, art, 'suggestions');
    }

    function updateRouteRecommendationBackdrop(recommendations, offset = 0){
      const card = document.getElementById('routeRecommendationsCard');
      if(!card) return;
      const list = Array.isArray(recommendations) && recommendations.length ? recommendations : latestRecommendations;
      const entry = list && list.length ? list[offset] || list[0] : null;
      const art = entry && entry.route ? routeArtFor(entry.route) : null;
      setRouteCardBackdrop(card, art, 'recommendations');
    }

    function updateRouteCardBackdrops({ recommendations } = {}){
      const heroCard = document.getElementById('routeContextCard');
      if(heroCard){
        const heroRoute = determineHeroRoute();
        const art = heroRoute ? routeArtFor(heroRoute) : null;
        setRouteCardBackdrop(heroCard, art, 'hero');
      }
      const activeCard = document.getElementById('routeActiveCard');
      if(activeCard){
        const activeRoute = determineActiveRoute();
        const art = activeRoute ? routeArtFor(activeRoute) : null;
        setRouteCardBackdrop(activeCard, art, 'active');
      }
      updateRouteSuggestionCardBackdrop();
      updateRouteRecommendationBackdrop(recommendations);
      const libraryCard = document.getElementById('routeLibraryCard');
      if(libraryCard){
        setRouteCardBackdrop(libraryCard, null, 'library');
      }
      const catalogCard = document.getElementById('guideCatalogCard');
      if(catalogCard){
        setRouteCardBackdrop(catalogCard, null, 'catalog');
      }
    }

    function isRemoteAsset(url){
      return /^https?:/i.test(String(url || ''));
    }

    function routePlaystyleKey(route){
      if(route && route.playstyleKey) return route.playstyleKey;
      return deriveRoutePlaystyleKey(route);
    }

    function routePlaystyleLabel(route){
      const key = routePlaystyleKey(route);
      const mapping = ROUTE_PLAYSTYLE_LABELS[key] || ROUTE_PLAYSTYLE_LABELS.adventure;
      return kidMode ? mapping.kid : mapping.grown;
    }

    function routeGoalIcon(tag){
      const iconEntry = ROUTE_GOAL_ICON_MAP[tag];
      return iconEntry && iconEntry.icon ? iconEntry.icon : ROUTE_DEFAULT_GOAL_ICON;
    }

    function lookupTechBySlug(slug){
      if(!slug) return null;
      const direct = TECH_LOOKUP?.[slug];
      if(direct) return direct;
      if(slug.startsWith('tech-') || slug.startsWith('station-')){
        const trimmed = slug.replace(/^(tech-|station-)/, '');
        if(TECH_LOOKUP?.[trimmed]) return TECH_LOOKUP[trimmed];
      }
      return null;
    }

    function routeHighlightMedia(route, { limit = 3 } = {}){
      if(!route) return [];
      const entries = [];
      const seenKeys = new Set();
      const seenSlugs = new Set();
      const typeOrder = ['pal', 'tech', 'item'];
      const register = (entry) => {
        if(!entry || !entry.image) return;
        const key = entry.key || '';
        const slugKey = entry.slug ? String(entry.slug).toLowerCase() : '';
        if(key && seenKeys.has(key)) return;
        if(slugKey && seenSlugs.has(slugKey)) return;
        if(key) seenKeys.add(key);
        if(slugKey) seenSlugs.add(slugKey);
        entries.push(entry);
      };
      const palIds = Array.isArray(route?.highlightPals) ? route.highlightPals : [];
      palIds.forEach(slug => {
        if(!slug) return;
        const link = { id: slug, slug };
        const palId = resolvePalIdFromLink(link);
        const pal = palId != null ? PALS?.[palId] : null;
        const label = pal?.name || niceName(slug);
        let image = null;
        if(pal){
          image = getPalArtSource(pal) || getPalOnlineArtSource(pal) || getPalIconSource(pal);
        }
        if(!image) return;
        const obtained = palId != null ? !!caught[palId] : false;
        register({
          type: 'pal',
          key: `pal:${palId != null ? palId : slug}`,
          slug: palId != null ? String(palId) : slug,
          label,
          image,
          obtained
        });
      });
      const techIds = Array.isArray(route?.highlightTech) ? route.highlightTech : [];
      techIds.forEach(id => {
        if(!id) return;
        const normalized = normalizeTechSlug(id);
        const entry = lookupTechBySlug(normalized);
        const item = entry?.item;
        if(!item || !item.name) return;
        const image = item.image || item.icon || null;
        if(!image) return;
        const obtained = isTechUnlocked(item.name);
        register({
          type: 'tech',
          key: `tech:${normalized}`,
          slug: normalized,
          label: item.name,
          image,
          obtained
        });
      });
      const itemIds = Array.isArray(route?.highlightItems) ? route.highlightItems : [];
      itemIds.forEach(id => {
        if(!id) return;
        const detail = resolveItemDetail(id);
        const image = detail?.image || null;
        if(!image) return;
        const slugValue = slugifyForPalworld(String(id)) || String(id);
        register({
          type: 'item',
          key: `item:${id}`,
          slug: slugValue,
          label: detail?.name || niceName(id),
          image,
          obtained: false
        });
      });
      const missing = entries.filter(entry => !entry.obtained);
      const owned = entries.filter(entry => entry.obtained);
      const sortByType = list => list.sort((a, b) => typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type));
      const ordered = [...sortByType(missing), ...sortByType(owned)];
      return limit && limit > 0 ? ordered.slice(0, limit) : ordered;
    }

    function renderRouteHighlight(entry, { showLabel = false, size = 'default' } = {}){
      if(!entry || !entry.image) return '';
      const classes = ['route-highlight', `route-highlight--${entry.type}`];
      if(entry.obtained) classes.push('route-highlight--obtained');
      if(size === 'small') classes.push('route-highlight--small');
      const label = entry.label || '';
      const titleAttr = label ? ` title="${escapeHTML(label)}"` : '';
      const referrer = isRemoteAsset(entry.image) ? ' referrerpolicy="no-referrer"' : '';
      const img = `<img src="${escapeHTML(entry.image)}" alt="" loading="lazy" decoding="async"${referrer}>`;
      const caption = showLabel && label ? `<span class="route-highlight__label">${escapeHTML(label)}</span>` : '';
      return `<span class="${classes.join(' ')}"${titleAttr}>${img}${caption}</span>`;
    }

    function routeProgressBreakdown(route){
      const chapter = route?.chapter;
      const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
      let requiredTotal = 0;
      let requiredDone = 0;
      let optionalTotal = 0;
      let optionalDone = 0;
      let totalDone = 0;
      steps.forEach(step => {
        if(!step || !step.id) return;
        const checked = !!routeState[step.id];
        if(checked) totalDone += 1;
        if(step.optional){
          optionalTotal += 1;
          if(checked) optionalDone += 1;
        } else {
          requiredTotal += 1;
          if(checked) requiredDone += 1;
        }
      });
      return {
        total: steps.length,
        totalDone,
        requiredTotal,
        requiredDone,
        optionalTotal,
        optionalDone
      };
    }

    function refreshRouteIntelligenceUI({ summary, levelEstimate, recommendations, skipActiveList = false } = {}){
      if(!routeGuideData) return;
      pruneCompletedActiveRoutes();
      const effectiveSummary = summary || calculateGuideProgressSummary();
      const effectiveLevel = levelEstimate || estimatePlayerLevel(routeContext);
      const stageSnapshot = determineGuideStageSnapshot();
      const effectiveRecommendations = recommendations || computeRouteRecommendations(routeGuideData, routeContext, effectiveLevel, stageSnapshot);
      const suggestionCount = renderRouteSuggestions(effectiveRecommendations);
      renderRouteRecommendationsList(effectiveRecommendations, { offset: suggestionCount });
      updateRouteOverviewUI(effectiveSummary);
      renderBossRouteTimeline();
      if(!skipActiveList){
        renderActiveRoutesList();
      }
      renderRouteLibraryList();
      latestRecommendations = Array.isArray(effectiveRecommendations) ? effectiveRecommendations.slice() : [];
      updateRouteCardBackdrops({ recommendations: effectiveRecommendations });
    }

    function selectRouteSuggestions(recommendations, { min = 3, max = 4 } = {}){
      if(!Array.isArray(recommendations) || !recommendations.length) return [];
      const activeSet = new Set(Array.from(activeRouteIds || []));
      const pool = recommendations.filter(entry => {
        return entry && entry.route && !isRouteComplete(entry.route) && !activeSet.has(entry.route.id);
      });
      if(!pool.length) return [];
      const sortedByScore = pool.slice().sort((a, b) => (b.score || 0) - (a.score || 0));
      const picks = [];
      const taken = new Set();
      const stageSnapshot = typeof determineGuideStageSnapshot === 'function' ? determineGuideStageSnapshot() : null;
      const stageRouteId = stageSnapshot?.stageId || null;
      const stageRoute = stageRouteId ? routeGuideData?.routeLookup?.[stageRouteId] : null;
      const stageRouteIsActive = stageRouteId ? activeSet.has(stageRouteId) : false;
      const stageSupportRecommended = createRouteIdSet(stageRoute?.supporting_routes?.recommended);
      const stageSupportOptional = createRouteIdSet(stageRoute?.supporting_routes?.optional);
      const stageNextRoutes = createRouteIdSet(stageRoute?.next_routes);
      const stagePhase = stageRouteId === 'quest-main-story-early'
        ? determineMainStoryPhase(stageSnapshot)
        : null;
      const phaseRecommended = stagePhase ? createRouteIdSet(stagePhase.recommended) : new Set();
      const phaseOptional = stagePhase ? createRouteIdSet(stagePhase.optional) : new Set();
      const activeFollowUps = new Set();
      if(activeRouteIds && typeof activeRouteIds.forEach === 'function'){
        activeRouteIds.forEach(id => {
          const route = routeGuideData?.routeLookup?.[id];
          if(!route) return;
          createRouteIdSet(route.next_routes).forEach(nextId => activeFollowUps.add(nextId));
        });
      }
      const ensureFromSet = (idSet, { limit = 1 } = {}) => {
        if(!idSet || !idSet.size) return;
        let remaining = limit == null ? Infinity : Number(limit);
        if(!Number.isFinite(remaining) && remaining !== Infinity) remaining = Infinity;
        if(remaining <= 0) return;
        for(const entry of sortedByScore){
          if(picks.length >= max) break;
          if(remaining <= 0) break;
          if(taken.has(entry.route.id)) continue;
          if(idSet.has(entry.route.id)){
            picks.push(entry);
            taken.add(entry.route.id);
            if(remaining !== Infinity){
              remaining -= 1;
            }
          }
        }
      };

      if(stageRouteId && !stageRouteIsActive){
        ensureFromSet(new Set([stageRouteId]));
      }
      if(phaseRecommended.size){
        const limit = stageRouteIsActive ? Math.min(2, Math.max(0, max - picks.length)) : 1;
        ensureFromSet(phaseRecommended, { limit });
      }
      if(stageSupportRecommended.size){
        const limit = stageRouteIsActive ? Math.min(2, Math.max(0, max - picks.length)) : 1;
        ensureFromSet(stageSupportRecommended, { limit });
      }
      if(stageNextRoutes.size){
        ensureFromSet(stageNextRoutes);
      }
      if(activeFollowUps.size){
        ensureFromSet(activeFollowUps);
      }
      if(picks.length < min && phaseOptional.size){
        ensureFromSet(phaseOptional, { limit: 1 });
      }
      if(picks.length < min && stageSupportOptional.size){
        ensureFromSet(stageSupportOptional, { limit: 1 });
      }

      const remainingPool = sortedByScore.filter(entry => !taken.has(entry.route.id));
      const remainingMax = Math.max(0, max - picks.length);
      const remainingMin = Math.max(0, min - picks.length);
      const additional = bucketSelectFromPool(remainingPool, { min: remainingMin, max: remainingMax });
      return [...picks, ...additional].slice(0, max);
    }

    function bucketSelectFromPool(pool, { min = 0, max = Array.isArray(pool) ? pool.length : 0 } = {}){
      if(!Array.isArray(pool) || !pool.length || max <= 0) return [];
      const buckets = new Map();
      pool.forEach(entry => {
        const key = routePlaystyleKey(entry.route);
        if(!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(entry);
      });
      buckets.forEach(list => list.sort((a, b) => (b.score || 0) - (a.score || 0)));
      const sortedStyles = Array.from(buckets.entries())
        .sort((a, b) => (b[1][0]?.score || 0) - (a[1][0]?.score || 0));
      const maxAvailable = Math.min(max, pool.length);
      if(maxAvailable <= 0) return [];
      const baseline = Math.min(min, maxAvailable);
      const target = Math.max(Math.min(sortedStyles.length, maxAvailable), baseline);
      const picks = [];
      sortedStyles.forEach(([, list]) => {
        if(picks.length >= maxAvailable) return;
        if(list.length){
          picks.push(list.shift());
        }
      });
      const ensureCount = desired => {
        if(desired <= picks.length) return;
        const remaining = pool
          .filter(entry => !picks.includes(entry))
          .sort((a, b) => (b.score || 0) - (a.score || 0));
        while(picks.length < desired && picks.length < maxAvailable && remaining.length){
          picks.push(remaining.shift());
        }
      };
      ensureCount(baseline);
      ensureCount(target);
      if(picks.length < maxAvailable){
        const remaining = pool
          .filter(entry => !picks.includes(entry))
          .sort((a, b) => (b.score || 0) - (a.score || 0));
        while(picks.length < maxAvailable && remaining.length){
          picks.push(remaining.shift());
        }
      }
      return picks.slice(0, maxAvailable);
    }

    function renderRouteSuggestions(recommendations){
      const card = document.getElementById('routeSuggestionsCard');
      const list = card ? card.querySelector('#routeSuggestionsList') : null;
      const detail = card ? card.querySelector('#routeSuggestionDetail') : null;
      if(routeSuggestionsAbort){
        routeSuggestionsAbort.abort();
      }
      const entries = selectRouteSuggestions(recommendations);
      currentRouteSuggestionEntries = entries;
      if(!entries.length){
        activeSuggestedRouteId = null;
        if(list){
          list.innerHTML = `<p class="route-suggestions__empty">${escapeHTML(kidMode
            ? 'Adjust the context above to unlock personalised picks.'
            : 'Fine-tune the context above to surface tailored paths.')}</p>`;
        }
        if(detail){
          detail.innerHTML = `<p class="route-suggestions__placeholder">${escapeHTML(kidMode
            ? 'Highlight a suggestion to preview the guide here.'
            : 'Highlight a suggestion to preview the full walkthrough here.')}</p>`;
          detail.removeAttribute('data-chapter-id');
          detail.removeAttribute('data-route-id');
          ['--route-suggestion-image', '--route-suggestion-overlay', '--route-suggestion-accent', '--route-suggestion-position'].forEach(prop => detail.style.removeProperty(prop));
        }
        return 0;
      }
      if(activeSuggestedRouteId && !entries.some(entry => entry.route.id === activeSuggestedRouteId)){
        activeSuggestedRouteId = null;
      }
      if(!activeSuggestedRouteId){
        activeSuggestedRouteId = entries[0].route.id;
      }
      if(list){
        list.innerHTML = entries.map(entry => renderRouteSuggestionCard(entry, entry.route.id === activeSuggestedRouteId)).join('');
        applyRouteSuggestionArtStyles(list);
        updateRouteSuggestionCardBackdrop(entries);
      }
      routeSuggestionsAbort = new AbortController();
      const { signal } = routeSuggestionsAbort;
      if(list){
        const handleSelect = event => {
          const cardEl = event.target.closest('[data-suggestion-route]');
          if(!cardEl) return;
          const routeId = cardEl.dataset.suggestionRoute;
          const entry = currentRouteSuggestionEntries.find(item => item.route.id === routeId);
          if(entry){
            setActiveRouteSuggestion(routeId, entry);
          }
        };
        list.addEventListener('click', handleSelect, { signal });
        list.addEventListener('mouseenter', handleSelect, { signal });
        list.addEventListener('focusin', handleSelect, { signal });
      }
      if(detail){
        const detailHandler = event => {
          const routeBtn = event.target.closest('[data-route-focus]');
          if(routeBtn){
            event.preventDefault();
            const routeId = routeBtn.dataset.routeFocus;
            const route = routeGuideData?.routeLookup?.[routeId];
            const nextStep = route ? findFirstIncompleteStepForRoute(route, { includeOptional: true }) : null;
            if(nextStep){
              queueRouteFocus(nextStep.id);
            } else if(route && route.chapter?.steps?.[0]){
              queueRouteFocus(route.chapter.steps[0].id);
            }
            switchPage('route');
            playSound(clickSound);
            return;
          }
          const stepBtn = event.target.closest('[data-step-focus]');
          if(stepBtn){
            event.preventDefault();
            const stepId = stepBtn.dataset.stepFocus;
            if(stepId){
              queueRouteFocus(stepId);
              switchPage('route');
              playSound(clickSound);
            }
            return;
          }
          handleRouteClick(event);
        };
        detail.addEventListener('click', detailHandler, { signal });
      }
      setActiveRouteSuggestion(activeSuggestedRouteId, entries.find(entry => entry.route.id === activeSuggestedRouteId));
      applyRouteSuggestionsCollapseState();
      return entries.length;
    }

    function setActiveRouteSuggestion(routeId, entry){
      if(!routeId) return;
      activeSuggestedRouteId = routeId;
      const list = document.getElementById('routeSuggestionsList');
      if(list){
        list.querySelectorAll('[data-suggestion-route]').forEach(card => {
          const isActive = card.dataset.suggestionRoute === routeId;
          card.classList.toggle('route-suggestion-card--active', isActive);
          card.setAttribute('aria-pressed', isActive ? 'true' : 'false');
        });
      }
      const targetEntry = entry || currentRouteSuggestionEntries.find(item => item.route.id === routeId);
      if(targetEntry){
        renderRouteSuggestionDetail(targetEntry);
      }
      updateRouteCardBackdrops();
    }

    function routeSuggestionChipLabel(art, route){
      if(art && art.label){
        return art.label;
      }
      const typeKey = art && art.type ? String(art.type).toLowerCase() : '';
      const lookup = typeKey ? ROUTE_SUGGESTION_CHIP_LABELS[typeKey] : null;
      if(lookup){
        return kidMode ? lookup.kid : lookup.grown;
      }
      return routePlaystyleLabel(route);
    }

    function renderRouteSuggestionDetail(entry){
      const detail = document.getElementById('routeSuggestionDetail');
      if(!detail) return;
      if(!entry || !entry.route){
        detail.innerHTML = `<p class="route-suggestions__placeholder">${escapeHTML(kidMode
          ? 'Highlight a suggestion to preview the guide here.'
          : 'Highlight a suggestion to preview the full walkthrough here.')}</p>`;
        detail.removeAttribute('data-chapter-id');
        detail.removeAttribute('data-route-id');
        ['--route-suggestion-image', '--route-suggestion-overlay', '--route-suggestion-accent', '--route-suggestion-position', '--guide-card-image', '--guide-card-overlay', '--guide-card-accent', '--guide-card-position'].forEach(prop => detail.style.removeProperty(prop));
        return;
      }
      const route = entry.route;
      const art = routeArtFor(route);
      detail.dataset.chapterId = route.chapter?.id || '';
      detail.dataset.routeId = route.id || '';
      const detailImage = `url('${sanitizeImageUrl(art.image)}')`;
      detail.style.setProperty('--route-suggestion-image', detailImage);
      detail.style.setProperty('--guide-card-image', detailImage);
      detail.style.setProperty('--route-suggestion-overlay', art.overlay);
      detail.style.setProperty('--guide-card-overlay', art.overlay);
      detail.style.setProperty('--route-suggestion-accent', art.accent);
      detail.style.setProperty('--guide-card-accent', art.accent);
      detail.style.setProperty('--route-suggestion-position', art.position);
      detail.style.setProperty('--guide-card-position', art.position);
      if(art.marker){
        detail.style.setProperty('--route-suggestion-marker-left', `${art.marker.left}%`);
        detail.style.setProperty('--route-suggestion-marker-top', `${art.marker.top}%`);
        detail.style.setProperty('--route-suggestion-marker-opacity', '1');
      } else {
        detail.style.removeProperty('--route-suggestion-marker-left');
        detail.style.removeProperty('--route-suggestion-marker-top');
        detail.style.setProperty('--route-suggestion-marker-opacity', '0');
      }
      const breakdown = routeProgressBreakdown(route);
      const requiredLabel = breakdown.requiredTotal
        ? `${breakdown.requiredDone}/${breakdown.requiredTotal} ${kidMode ? 'big steps' : 'required'}`
        : '';
      const optionalLabel = breakdown.optionalTotal
        ? `${breakdown.optionalDone}/${breakdown.optionalTotal} ${kidMode ? 'bonus' : 'optional'}`
        : '';
      const progressDetail = [requiredLabel, optionalLabel].filter(Boolean).join(' • ');
      const overallPct = breakdown.total
        ? Math.round((breakdown.totalDone / breakdown.total) * 100)
        : (breakdown.requiredTotal ? Math.round((breakdown.requiredDone / breakdown.requiredTotal) * 100) : 0);
      const progressLabel = progressDetail || (kidMode ? `${overallPct}% ready` : `${overallPct}% complete`);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const reasons = Array.isArray(entry.reasons) && entry.reasons.length
        ? entry.reasons.slice(0, 3).map(reason => `<li>${escapeHTML(reason)}</li>`).join('')
        : '';
      const reasonsHtml = reasons
        ? `<ul class="route-suggestion-detail__reasons">${reasons}</ul>`
        : `<p class="route-suggestion-detail__reason">${escapeHTML(kidMode ? 'Balanced for your crew.' : 'Balanced recommendation tailored to your context.')}</p>`;
      const focusStep = entry.nextStepId || (findFirstIncompleteStepForRoute(route, { includeOptional: true })?.id || '');
      const roleLabel = routePlaystyleLabel(route);
      const chipLabel = routeSuggestionChipLabel(art, route);
      const typeLabel = chipLabel && chipLabel !== roleLabel ? chipLabel : '';
      const highlights = routeHighlightMedia(route, { limit: 5 });
      const highlightsHtml = highlights.length
        ? `<div class="route-suggestion-detail__highlights">${highlights.map(entry => renderRouteHighlight(entry, { showLabel: true })).join('')}</div>`
        : '';
      const stepButton = focusStep
        ? `<button type="button" class="btn" data-step-focus="${escapeHTML(focusStep)}">${escapeHTML(kidMode ? 'Jump to this step' : 'Jump to this step')}</button>`
        : '';
      const queueButton = isRouteActive(route.id)
        ? `<button type="button" class="btn" data-action="deactivateRoute" data-route-id="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Remove from queue' : 'Remove from active')}</button>`
        : `<button type="button" class="btn" data-action="activateRoute" data-route-id="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Add to queue' : 'Add to active')}</button>`;
      const objectives = Array.isArray(route?.objectives) && route.objectives.length
        ? `<ul class="route-suggestion-detail__objectives">${route.objectives.slice(0, 4).map(obj => `<li>${escapeHTML(obj)}</li>`).join('')}</ul>`
        : '';
      detail.innerHTML = `
        <div class="route-suggestion-detail__hero">
          <div class="route-suggestion-detail__badges">
            <span class="route-suggestion-detail__badge">${escapeHTML(roleLabel)}</span>
            ${typeLabel ? `<span class="route-suggestion-detail__badge route-suggestion-detail__badge--accent">${escapeHTML(typeLabel)}</span>` : ''}
          </div>
          <h4 class="route-suggestion-detail__title">${escapeHTML(route.title)}</h4>
          ${metaLine ? `<p class="route-suggestion-detail__meta">${escapeHTML(metaLine)}</p>` : ''}
          <div class="route-suggestion-detail__progress">
            <div class="route-suggestion-detail__progress-bar"><span style="width:${overallPct}%"></span></div>
            <span class="route-suggestion-detail__progress-label">${escapeHTML(progressLabel)}</span>
          </div>
          ${highlightsHtml}
        </div>
        <div class="route-suggestion-detail__body">
          ${reasonsHtml}
          ${objectives}
          <div class="route-suggestion-detail__actions">
            ${queueButton}
            <button type="button" class="btn" data-route-focus="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Open full guide' : 'Open full guide')}</button>
            ${stepButton}
          </div>
        </div>
      `;
    }

    function renderRouteSuggestionCard(entry, active){
      const route = entry.route;
      const art = routeArtFor(route);
      const breakdown = routeProgressBreakdown(route);
      const overallPct = breakdown.total
        ? Math.round((breakdown.totalDone / breakdown.total) * 100)
        : (breakdown.requiredTotal ? Math.round((breakdown.requiredDone / breakdown.requiredTotal) * 100) : 0);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const reasonHighlight = Array.isArray(entry.reasons) && entry.reasons.length
        ? entry.reasons[0]
        : (kidMode ? 'Balanced for your crew.' : 'Balanced recommendation tailored to your context.');
      const scoreLabel = typeof entry.score === 'number' ? entry.score.toFixed(1) : '';
      const queued = isRouteActive(route.id);
      const highlights = routeHighlightMedia(route, { limit: 3 });
      const highlightsHtml = highlights.length
        ? `<div class="route-suggestion-card__highlights">${highlights.map(item => renderRouteHighlight(item, { size: 'small' })).join('')}</div>`
        : '';
      const typeLabel = routeSuggestionChipLabel(art, route);
      const dataAttributes = [
        `data-suggestion-route="${escapeHTML(route.id)}"`,
        `aria-pressed="${active ? 'true' : 'false'}"`
      ];
      if(art.image){
        dataAttributes.push(`data-art-image="${escapeHTML(art.image)}"`);
      }
      if(art.overlay){
        dataAttributes.push(`data-art-overlay="${escapeHTML(art.overlay)}"`);
      }
      if(art.accent){
        dataAttributes.push(`data-art-accent="${escapeHTML(art.accent)}"`);
      }
      if(art.position){
        dataAttributes.push(`data-art-position="${escapeHTML(art.position)}"`);
      }
      if(art.marker && typeof art.marker.left === 'number' && typeof art.marker.top === 'number'){
        dataAttributes.push(`data-art-marker-left="${escapeHTML(String(art.marker.left))}"`);
        dataAttributes.push(`data-art-marker-top="${escapeHTML(String(art.marker.top))}"`);
      }
      const styleAttr = guideCardStyleAttr(art, { includeRouteSuggestionVars: true });
      if(styleAttr){
        dataAttributes.push(styleAttr);
      }
      return `
        <button type="button" class="route-suggestion-card${active ? ' route-suggestion-card--active' : ''}" ${dataAttributes.join(' ')}>
          <div class="route-suggestion-card__media">
            <div class="route-suggestion-card__avatar" aria-hidden="true"></div>
          </div>
          <div class="route-suggestion-card__body">
            <div class="route-suggestion-card__header">
              <span class="route-suggestion-card__icon"><i class="fa-solid ${escapeHTML(art.icon)}"></i></span>
              <div class="route-suggestion-card__headline">
                ${typeLabel ? `<span class="route-suggestion-card__tag">${escapeHTML(typeLabel)}</span>` : ''}
                <h4 class="route-suggestion-card__title">${escapeHTML(route.title)}</h4>
                ${metaLine ? `<p class="route-suggestion-card__meta">${escapeHTML(metaLine)}</p>` : ''}
                ${queued ? `<span class="route-suggestion-card__status">${escapeHTML(kidMode ? 'In your queue' : 'In queue')}</span>` : ''}
              </div>
              ${scoreLabel ? `<span class="route-suggestion-card__score">${escapeHTML(scoreLabel)}</span>` : ''}
            </div>
            <div class="route-suggestion-card__progress">
              <div class="route-suggestion-card__progress-bar"><span style="width:${overallPct}%"></span></div>
              <span class="route-suggestion-card__progress-label">${escapeHTML(kidMode ? `${overallPct}% ready` : `${overallPct}% complete`)}</span>
            </div>
            ${highlightsHtml}
            <p class="route-suggestion-card__reason">${escapeHTML(reasonHighlight)}</p>
          </div>
        </button>
      `;
    }

    function applyRouteSuggestionArtStyles(container){
      if(!container) return;
      const cards = container.querySelectorAll('.route-suggestion-card');
      cards.forEach(card => {
        const image = card.dataset.artImage;
        if(image){
          const urlValue = `url('${sanitizeImageUrl(image)}')`;
          card.style.setProperty('--route-suggestion-image', urlValue);
          card.style.setProperty('--guide-card-image', urlValue);
          card.style.setProperty('--route-suggestion-avatar', urlValue);
        } else {
          card.style.removeProperty('--route-suggestion-image');
          card.style.removeProperty('--guide-card-image');
          card.style.removeProperty('--route-suggestion-avatar');
        }
        const overlay = card.dataset.artOverlay;
        if(overlay){
          card.style.setProperty('--route-suggestion-overlay', overlay);
          card.style.setProperty('--guide-card-overlay', overlay);
        } else {
          card.style.removeProperty('--route-suggestion-overlay');
          card.style.removeProperty('--guide-card-overlay');
        }
        const accent = card.dataset.artAccent;
        if(accent){
          card.style.setProperty('--route-suggestion-accent', accent);
          card.style.setProperty('--guide-card-accent', accent);
        } else {
          card.style.removeProperty('--route-suggestion-accent');
          card.style.removeProperty('--guide-card-accent');
        }
        const position = card.dataset.artPosition;
        if(position){
          card.style.setProperty('--route-suggestion-position', position);
          card.style.setProperty('--guide-card-position', position);
        } else {
          card.style.removeProperty('--route-suggestion-position');
          card.style.removeProperty('--guide-card-position');
        }
        const markerLeft = Number(card.dataset.artMarkerLeft);
        const markerTop = Number(card.dataset.artMarkerTop);
        if(Number.isFinite(markerLeft) && Number.isFinite(markerTop)){
          card.style.setProperty('--route-suggestion-marker-left', `${markerLeft}%`);
          card.style.setProperty('--route-suggestion-marker-top', `${markerTop}%`);
          card.style.setProperty('--route-suggestion-marker-opacity', '1');
        } else {
          card.style.removeProperty('--route-suggestion-marker-left');
          card.style.removeProperty('--route-suggestion-marker-top');
          card.style.setProperty('--route-suggestion-marker-opacity', '0');
        }
      });
    }

    function renderActiveRoutesList(){
      const wrap = document.getElementById('routeChapters');
      if(!wrap) return;
      const showEmptyMessage = message => {
        wrap.classList.add('route-active__list--empty');
        wrap.innerHTML = `<p class="route-active__empty">${escapeHTML(message)}</p>`;
      };
      if(!routeGuideData || !Array.isArray(routeGuideData.routes)){
        showEmptyMessage(kidMode ? 'Guides are still loading…' : 'Guide data is still loading.');
        return;
      }
      const activeIds = Array.from(activeRouteIds);
      if(!activeIds.length){
        showEmptyMessage(kidMode
          ? 'Tap an adventure above to add it to your queue.'
          : 'Choose a guide from the suggestions above to add it to your queue.');
        return;
      }
      wrap.classList.remove('route-active__list--empty');
      wrap.innerHTML = '';
      activeIds.forEach((routeId, index) => {
        const route = routeGuideData.routeLookup?.[routeId];
        if(!route) return;
        wrap.appendChild(renderChapterCard(route.chapter, index === 0, route));
      });
    }

    function renderRouteLibraryList(){
      const list = document.getElementById('routeLibraryList');
      const countNode = document.querySelector('[data-route-role="library-count"]');
      if(!list){
        return;
      }
      if(routeLibraryListAbort){
        routeLibraryListAbort.abort();
        routeLibraryListAbort = null;
      }
      const updateControlState = () => {
        document.querySelectorAll('[data-route-library-filter]').forEach(btn => {
          const key = btn.dataset.routeLibraryFilter || '';
          const activeState = key === routeLibraryFilter;
          btn.classList.toggle('route-library__filter-btn--active', activeState);
          btn.setAttribute('aria-pressed', activeState ? 'true' : 'false');
        });
        const matchBtn = document.querySelector('[data-route-library-match]');
        if(matchBtn){
          const disabled = !Array.isArray(routeContext?.goals) || routeContext.goals.length === 0;
          matchBtn.disabled = disabled;
          const pressed = !disabled && routeLibraryMatchContext;
          matchBtn.classList.toggle('route-library__match--active', pressed);
          matchBtn.setAttribute('aria-pressed', pressed ? 'true' : 'false');
        }
      };
      if(!routeGuideData || !Array.isArray(routeGuideData.routes)){
        list.innerHTML = `<p class="route-library__empty">${escapeHTML(kidMode ? 'Guides are still loading…' : 'Guide library is still loading.')}</p>`;
        if(countNode) countNode.textContent = '';
        updateControlState();
        return;
      }
      if(!routeGuideData.routes.length){
        const emptyMessage = kidMode
          ? 'No guides available yet. Check back soon!'
          : 'No guides available yet. Check back soon.';
        list.innerHTML = `<p class="route-library__empty">${escapeHTML(emptyMessage)}</p>`;
        if(countNode) countNode.textContent = kidMode ? 'No guides yet' : 'No guides yet';
        updateControlState();
        return;
      }
      const query = (routeLibrarySearchTerm || '').trim().toLowerCase();
      const hasQuery = query.length > 0;
      const active = new Set(activeRouteIds);
      const statusFilter = routeLibraryFilter || 'incomplete';
      const shouldMatchContext = routeLibraryMatchContext && Array.isArray(routeContext?.goals) && routeContext.goals.length;
      const usingStatusFilter = statusFilter !== 'incomplete';
      const usingContextFilter = !!shouldMatchContext;
      const baseRoutes = routeGuideData.routes.filter(route => route && route.id && !active.has(route.id));
      const completedTotal = baseRoutes.filter(route => isRouteComplete(route)).length;
      const incompleteTotal = baseRoutes.length - completedTotal;
      const goalSet = shouldMatchContext
        ? new Set(routeContext.goals.map(goal => String(goal || '').toLowerCase()))
        : new Set();
      const matchesContext = route => {
        if(!shouldMatchContext) return true;
        const normalizedTags = Array.isArray(route?.tags) ? route.tags.map(tag => String(tag || '').toLowerCase()) : [];
        if(normalizedTags.some(tag => goalSet.has(tag))) return true;
        const title = String(route?.title || '').toLowerCase();
        if(Array.from(goalSet).some(goal => title.includes(goal))) return true;
        const objectives = Array.isArray(route?.objectives) ? route.objectives : [];
        if(objectives.some(obj => {
          const text = String(obj || '').toLowerCase();
          return Array.from(goalSet).some(goal => text.includes(goal));
        })){
          return true;
        }
        return false;
      };
      const availableRoutes = [];
      baseRoutes.forEach(route => {
        const complete = isRouteComplete(route);
        if(statusFilter === 'incomplete' && complete) return;
        if(statusFilter === 'complete' && !complete) return;
        const contextMatch = matchesContext(route);
        if(!contextMatch) return;
        if(hasQuery){
          const haystack = [
            route.title,
            route.category,
            ...(Array.isArray(route.tags) ? route.tags : []),
            ...(Array.isArray(route.objectives) ? route.objectives : [])
          ].filter(Boolean).join(' ').toLowerCase();
          if(!haystack.includes(query)) return;
        }
        availableRoutes.push({ route, contextMatch });
      });
      const totalMatches = availableRoutes.length;
      const usingAnyFilter = hasQuery || usingStatusFilter || usingContextFilter;
      if(!totalMatches){
        if(countNode){
          let countLabel;
          if(baseRoutes.length === 0){
            countLabel = kidMode ? 'No guides yet' : 'No guides yet';
          } else if(incompleteTotal === 0 && completedTotal > 0){
            countLabel = kidMode ? 'All caught up' : 'All guides complete';
          } else {
            countLabel = kidMode ? 'No matches' : 'No matches';
          }
          countNode.textContent = countLabel;
        }
        let emptyMessage;
        if(hasQuery){
          emptyMessage = kidMode ? 'No guides match that search.' : 'No guides match your search.';
        } else if(usingStatusFilter || usingContextFilter){
          emptyMessage = kidMode ? 'No guides fit these filters yet.' : 'No guides fit these filters yet.';
        } else if(baseRoutes.length === 0){
          emptyMessage = kidMode ? 'No guides available yet. Check back soon!' : 'No guides available yet. Check back soon.';
        } else if(incompleteTotal === 0 && completedTotal > 0){
          emptyMessage = kidMode
            ? 'You finished every guide! Switch to Completed to revisit the adventures.'
            : 'All routes are complete. Switch to the Completed filter to review finished guides.';
        } else {
          emptyMessage = kidMode ? 'No guides fit these filters yet.' : 'No guides fit these filters yet.';
        }
        list.innerHTML = `<p class="route-library__empty">${escapeHTML(emptyMessage)}</p>`;
        updateControlState();
        return;
      }

      availableRoutes.sort((a, b) => a.route.title.localeCompare(b.route.title, undefined, { sensitivity: 'base' }));

      const limit = usingAnyFilter ? totalMatches : Math.min(ROUTE_LIBRARY_DEFAULT_LIMIT, totalMatches);
      if(countNode){
        let label;
        const plural = totalMatches === 1 ? '' : 's';
        if(!usingAnyFilter && totalMatches > limit){
          label = kidMode
            ? `Showing ${limit}/${totalMatches} guides`
            : `Showing ${limit} of ${totalMatches} guides`;
        } else if(hasQuery){
          label = kidMode
            ? `${totalMatches} guide${plural} found`
            : `${totalMatches} guide${plural} found`;
        } else if(usingContextFilter){
          label = kidMode
            ? `${totalMatches} guide${plural} match the goals`
            : `${totalMatches} guide${plural} match tonight's goals`;
        } else if(usingStatusFilter && statusFilter === 'complete'){
          label = kidMode
            ? `${totalMatches} completed guide${plural}`
            : `${totalMatches} completed guide${plural}`;
        } else if(usingStatusFilter && statusFilter === 'all'){
          label = kidMode
            ? `${totalMatches} guide${plural} available`
            : `${totalMatches} total guide${plural}`;
        } else {
          label = kidMode
            ? `${totalMatches} guide${totalMatches === 1 ? '' : 's'} ready`
            : `${totalMatches} guide${totalMatches === 1 ? '' : 's'} available`;
        }
        countNode.textContent = label;
      }

      const displayRoutes = availableRoutes.slice(0, limit);
      list.innerHTML = displayRoutes
        .map(entry => renderRouteLibraryCard(entry.route, { matchContext: shouldMatchContext && entry.contextMatch }))
        .join('');
      bindRouteLibraryListInteractions(list);
      if(!usingAnyFilter && totalMatches > limit){
        const hint = kidMode
          ? 'Refine your search or filters to see more guides.'
          : 'Use search or filters to explore the full guide catalog.';
        list.insertAdjacentHTML('beforeend', `<p class="route-library__hint">${escapeHTML(hint)}</p>`);
      }
      updateControlState();
    }

    function bindRouteLibraryListInteractions(list){
      if(!list) return;
      if(routeLibraryListAbort){
        routeLibraryListAbort.abort();
      }
      routeLibraryListAbort = new AbortController();
      const { signal } = routeLibraryListAbort;
      list.addEventListener('click', event => {
        const actionBtn = event.target.closest('button[data-action]');
        if(actionBtn){
          handleRouteClick(event);
          return;
        }
        if(event.target.closest('.route-library-card__actions')) return;
        const card = event.target.closest('.route-library-card');
        if(!card) return;
        const routeId = card.dataset.routeId;
        if(!routeId) return;
        event.preventDefault();
        openRoutePreviewById(routeId);
      }, { signal });
    }

    function renderRouteLibraryCard(route, { matchContext = false } = {}){
      const art = routeArtFor(route);
      const metaBits = [];
      const level = route?.recommended_level || {};
      if(level.min != null || level.max != null){
        metaBits.push(`Lv ${level.min != null ? level.min : '?'}-${level.max != null ? level.max : '?'}`);
      }
      if(route?.risk_profile){
        metaBits.push(`${capitalize(route.risk_profile)} risk`);
      }
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes);
      if(timeLabel){
        metaBits.push(timeLabel);
      }
      const metaLine = metaBits.length ? metaBits.join(' • ') : '';
      const tags = Array.isArray(route?.tags) && route.tags.length
        ? `<div class="route-library-card__tags">${route.tags.slice(0, 4).map(tag => `<span class="chip route-library-card__tag">${escapeHTML(tag)}</span>`).join('')}</div>`
        : '';
      const complete = isRouteComplete(route);
      const markerStyle = art.marker ? `style="left:${art.marker.left}%;top:${art.marker.top}%"` : '';
      const highlight = routeHighlightMedia(route, { limit: 3 });
      const highlightHtml = highlight.length
        ? `<div class="route-library-card__highlights">${highlight.map(entry => renderRouteHighlight(entry, { size: 'small' })).join('')}</div>`
        : '';
      const cardClasses = ['route-library-card'];
      if(complete) cardClasses.push('route-library-card--complete');
      if(matchContext) cardClasses.push('route-library-card--context');
      const previewLabel = kidMode ? 'Preview guide' : 'Preview guide';
      return `
        <article class="${cardClasses.join(' ')}" data-route-id="${escapeHTML(route.id)}">
          <div class="route-library-card__media" style="--route-visual-image: url('${art.image}'); --route-visual-overlay: ${art.overlay}; --route-visual-accent: ${art.accent};">
            ${art.marker ? `<span class="route-visual__marker" ${markerStyle}></span>` : ''}
          </div>
          <div class="route-library-card__body">
            <h4>${escapeHTML(route.title)}</h4>
            ${metaLine ? `<p class="route-library-card__meta">${escapeHTML(metaLine)}</p>` : ''}
            ${tags}
            ${highlightHtml}
          </div>
          <div class="route-library-card__actions">
            ${complete ? `<span class="route-library-card__status">${escapeHTML(kidMode ? 'Complete' : 'Complete')}</span>` : ''}
            <button type="button" class="chip route-library-card__preview" data-action="previewRoute" data-route-id="${escapeHTML(route.id)}">${escapeHTML(previewLabel)}</button>
            <button type="button" class="chip route-library-card__activate" data-action="activateRoute" data-route-id="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Add to queue' : 'Add to active')}</button>
          </div>
        </article>
      `;
    }

    function renderGuideCatalogGroupOptions(catalog){
      const groups = Array.isArray(catalog?.groups) ? catalog.groups : [];
      const options = [`<option value="all"${guideCatalogGroupFilter === 'all' ? ' selected' : ''}>${escapeHTML(kidMode ? 'All categories' : 'All categories')}</option>`];
      groups.forEach(group => {
        if(!group || !group.id) return;
        const value = String(group.id);
        const label = group.label || niceName(value);
        options.push(`<option value="${escapeHTML(value)}"${guideCatalogGroupFilter === value ? ' selected' : ''}>${escapeHTML(label)}</option>`);
      });
      return options.join('');
    }

    function renderGuideCatalogCategoryOptions(catalog){
      const groups = Array.isArray(catalog?.groups) ? catalog.groups : [];
      const categories = new Map();
      if(guideCatalogGroupFilter === 'all'){
        groups.forEach(group => {
          (group?.categories || []).forEach(cat => {
            if(cat && cat.id && !categories.has(cat.id)){
              categories.set(cat.id, cat.label || niceName(cat.id));
            }
          });
        });
      } else {
        const group = groups.find(entry => entry && entry.id === guideCatalogGroupFilter);
        if(group){
          (group.categories || []).forEach(cat => {
            if(cat && cat.id && !categories.has(cat.id)){
              categories.set(cat.id, cat.label || niceName(cat.id));
            }
          });
        }
      }
      const sorted = Array.from(categories.entries()).sort((a, b) => a[1].localeCompare(b[1], undefined, { sensitivity: 'base' }));
      const labelAll = kidMode ? 'All focuses' : 'All focuses';
      const options = [`<option value="all"${guideCatalogCategoryFilter === 'all' ? ' selected' : ''}>${escapeHTML(labelAll)}</option>`];
      sorted.forEach(([id, label]) => {
        options.push(`<option value="${escapeHTML(id)}"${guideCatalogCategoryFilter === id ? ' selected' : ''}>${escapeHTML(label)}</option>`);
      });
      return options.join('');
    }

    function renderGuideCatalogStep(step){
      if(!step) return '';
      const hasLinks = Array.isArray(step.links) && step.links.length;
      const instructionHtml = renderSimpleMarkdown(step.instruction || '');
      if(!instructionHtml && !hasLinks) return '';
      const linksHtml = hasLinks ? renderLinks(step.links) : '';
      return `<li>${instructionHtml}${linksHtml}</li>`;
    }

    function renderGuideCatalogCard(entry){
      if(!entry) return '';
      const art = guideCatalogArtFor(entry);
      const styleAttr = guideCardStyleAttr(art);
      const badge = `<span class="guide-card__badge">${escapeHTML(entry.categoryLabel || 'Guide')}</span>`;
      const groupLine = entry.groupLabel ? `<p class="guide-catalog__group">${escapeHTML(entry.groupLabel)}</p>` : '';
      const triggerLabel = kidMode ? 'Why use it:' : 'Trigger:';
      const trigger = entry.trigger ? `<p class="guide-catalog__trigger"><strong>${escapeHTML(triggerLabel)}</strong> ${escapeHTML(entry.trigger)}</p>` : '';
      const keywords = entry.keywords && entry.keywords.length
        ? `<div class="guide-card__keywords guide-catalog__keywords">${entry.keywords.map(keyword => `<span class="guide-card__keyword guide-catalog__keyword">${escapeHTML(keyword)}</span>`).join('')}</div>`
        : '';
      const stepItems = Array.isArray(entry.steps)
        ? entry.steps.map(renderGuideCatalogStep).filter(Boolean)
        : [];
      const steps = stepItems.length
        ? `<ol class="guide-catalog__steps">${stepItems.join('')}</ol>`
        : '';
      const attributes = [];
      if(styleAttr){
        attributes.push(styleAttr);
      }
      return `
        <article class="guide-card guide-catalog__item" ${attributes.join(' ')}>
          <div class="guide-card__header">
            <span class="guide-card__icon"><i class="fa-solid ${escapeHTML(art.icon)}"></i></span>
            <div class="guide-card__headline">
              ${badge}
              <h4 class="guide-card__title">${escapeHTML(entry.title)}</h4>
              ${groupLine}
            </div>
          </div>
          ${trigger}
          ${keywords}
          ${steps}
        </article>
      `;
    }

    function renderSimpleMarkdown(text){
      if(text == null) return '';
      let html = String(text);
      html = html
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      html = html.replace(/`([^`]+)`/g, '<code>$1</code>');
      html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
      html = html.replace(/(^|[^*])\*([^*\n]+)\*(?!\*)/g, (match, prefix, content) => `${prefix}<em>${content}</em>`);
      html = html.replace(/\[([^\]]+)\]\((https?:[^)]+)\)/g, '<a href="$2" target="_blank" rel="noopener">$1</a>');
      html = html.replace(/\n/g, '<br />');
      return html;
    }

    function renderGuideCatalogList(){
      const card = document.getElementById('guideCatalogCard');
      if(!card) return;
      const list = card.querySelector('#guideCatalogList');
      const countNode = card.querySelector('[data-guide-catalog-count]');
      if(!list) return;
      if(guideCatalogListAbort){
        guideCatalogListAbort.abort();
        guideCatalogListAbort = null;
      }
      const catalog = routeGuideData?.guideCatalog;
      if(!catalog || !Array.isArray(catalog.entries)){
        list.innerHTML = `<p class="guide-catalog__empty">${escapeHTML(kidMode ? 'Guide index loading…' : 'Guide catalog loading…')}</p>`;
        if(countNode) countNode.textContent = '';
        return;
      }
      if(!catalog.entries.length){
        const emptyMessage = kidMode
          ? 'No guides available yet. Check back soon!'
          : 'No guides available yet. Check back soon.';
        list.innerHTML = `<p class="guide-catalog__empty">${escapeHTML(emptyMessage)}</p>`;
        if(countNode) countNode.textContent = kidMode ? '0 guides' : '0 guides';
        return;
      }
      let entries = catalog.entries.slice();
      if(guideCatalogGroupFilter !== 'all'){
        entries = entries.filter(entry => entry.groupId === guideCatalogGroupFilter);
      }
      if(guideCatalogCategoryFilter !== 'all'){
        entries = entries.filter(entry => entry.categoryId === guideCatalogCategoryFilter);
      }
      const query = (guideCatalogSearchTerm || '').trim().toLowerCase();
      const hasQuery = query.length > 0;
      const usingFilters = guideCatalogGroupFilter !== 'all' || guideCatalogCategoryFilter !== 'all';
      if(hasQuery){
        entries = entries.filter(entry => entry.searchText.includes(query));
      }
      const totalEntries = catalog.entries.length;
      const totalFiltered = entries.length;
      if(!totalFiltered){
        if(countNode) countNode.textContent = kidMode ? 'No matches' : 'No matches';
        const emptyMessage = hasQuery
          ? (kidMode ? 'No guides match that search yet.' : 'No guides match your search yet.')
          : (usingFilters
            ? (kidMode ? 'No guides match those filters yet.' : 'No guides match your filters yet.')
            : (kidMode ? 'Guides will appear here soon.' : 'Guides will appear here soon.'));
        list.innerHTML = `<p class="guide-catalog__empty">${escapeHTML(emptyMessage)}</p>`;
        return;
      }

      const limit = totalFiltered;
      const displayEntries = entries.slice(0, limit);
      list.innerHTML = displayEntries.map(renderGuideCatalogCard).join('');
      guideCatalogListAbort = new AbortController();
      const { signal } = guideCatalogListAbort;
      list.addEventListener('click', handleRouteClick, { signal });
      if(countNode){
        let label;
        if(!hasQuery && !usingFilters){
          label = `${totalEntries} ${totalEntries === 1 ? 'guide' : 'guides'}`;
        } else if(totalFiltered === totalEntries){
          label = `${totalFiltered} ${totalFiltered === 1 ? 'guide' : 'guides'}`;
        } else {
          label = `${totalFiltered} of ${totalEntries} guides`;
        }
        countNode.textContent = label;
      }
    }

    function hashString(value){
      const str = String(value);
      let hash = 0;
      for(let i = 0; i < str.length; i += 1){
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
      }
      return hash;
    }

    function getLastCompletedRouteMeta(){
      const meta = routeState?.__meta;
      if(!meta || typeof meta !== 'object' || !meta.completedRoutes) return null;
      const entries = Object.entries(meta.completedRoutes)
        .map(([id, info]) => ({
          id,
          title: info?.title || (routeGuideData?.routeLookup?.[id]?.title) || niceName(id),
          completedAt: info?.completedAt || null
        }));
      if(!entries.length) return null;
      entries.sort((a, b) => {
        const aTime = a.completedAt ? Date.parse(a.completedAt) : 0;
        const bTime = b.completedAt ? Date.parse(b.completedAt) : 0;
        return aTime - bTime;
      });
      return entries[entries.length - 1];
    }

    function formatGuideCompletionDate(iso){
      if(!iso) return '';
      const date = new Date(iso);
      if(Number.isNaN(date.getTime())) return '';
      try {
        return new Intl.DateTimeFormat(undefined, { month: 'short', day: 'numeric' }).format(date);
      } catch(err){
        return date.toLocaleDateString();
      }
    }

    function syncRouteCompletionMetadata(){
      if(!routeGuideData) return false;
      const meta = routeState.__meta && typeof routeState.__meta === 'object' ? { ...routeState.__meta } : {};
      const previous = meta.completedRoutes && typeof meta.completedRoutes === 'object' ? meta.completedRoutes : {};
      const updated = {};
      let changed = false;
      routeGuideData.routes.forEach(route => {
        const complete = isRouteComplete(route);
        const prior = previous[route.id];
        if(complete){
          const entry = {
            title: route.title,
            completedAt: prior?.completedAt || new Date().toISOString()
          };
          updated[route.id] = entry;
          if(!prior || prior.title !== entry.title){
            changed = true;
          }
        } else if(prior){
          changed = true;
        }
      });
      const previousKeys = Object.keys(previous);
      const updatedKeys = Object.keys(updated);
      if(previousKeys.length !== updatedKeys.length){
        changed = true;
      }
      if(changed){
        if(updatedKeys.length){
          routeState.__meta = { ...meta, completedRoutes: updated, updatedAt: new Date().toISOString() };
        } else if(routeState.__meta){
          delete routeState.__meta.completedRoutes;
          delete routeState.__meta.updatedAt;
          if(!Object.keys(routeState.__meta).length){
            delete routeState.__meta;
          }
        }
      }
      return changed;
    }

    function renderRouteGuide(){
      const node = document.getElementById('routePage');
      if(!node) return;
      if(!routeGuideData){
        node.innerHTML = `
          <section class="card route-loading" data-route-loading>
            <div class="route-loading__spinner" aria-hidden="true"></div>
            <p class="route-loading__label">Loading adaptive routes…</p>
            <p class="route-loading__hint">Palmate is syncing the latest guide catalog.</p>
          </section>
        `;
      }
      ensureRouteGuide().then(guide => {
        const routes = Array.isArray(guide?.routes) ? guide.routes : [];
        const chapters = Array.isArray(guide?.chapters) ? guide.chapters : [];
        if(!routes.length || !chapters.length){
          node.innerHTML = `
            <section class="card route-error" role="alert">
              <h2>Adaptive Route Planner</h2>
              <p>We couldn’t load the adaptive guide library. Check your connection and try again.</p>
              <button type="button" class="btn btn--ghost route-error__retry">Retry loading guides</button>
            </section>
          `;
          const retry = node.querySelector('.route-error__retry');
          if(retry && !retry.dataset.bound){
            retry.dataset.bound = 'true';
            retry.addEventListener('click', () => {
              routeGuideData = null;
              renderRouteGuide();
            });
          }
        }
        else {
          routeGuideData = guide;
          routeState = loadRouteState();
          if(syncRouteCompletionMetadata()){
            saveRouteState(routeState);
          }
          routeContext = normalizeRouteContext(routeContext);
          const summary = calculateGuideProgressSummary(chapters);
          const levelEstimate = estimatePlayerLevel(routeContext);
          const stageSnapshot = determineGuideStageSnapshot();
          const recommendations = computeRouteRecommendations(guide, routeContext, levelEstimate, stageSnapshot);
          latestRecommendations = Array.isArray(recommendations) ? recommendations.slice() : [];
          const heading = kidMode ? 'Adaptive Adventure Planner' : 'Adaptive Route Planner';
          const suggestionsHeading = kidMode ? 'Tonight’s Adventure Paths' : 'Tonight’s Adventure Paths';
          const suggestionsLead = kidMode
            ? 'These curated paths keep your crew moving through the story while spotlighting bonus quests worth sampling tonight.'
            : 'These curated paths balance main quest momentum, optional clean-up, and boss prep for tonight’s session.';
          const recommendationLead = kidMode
            ? 'Need other ideas? These extra adventures re-rank when your context changes.'
            : 'Want alternatives? The rest of the ranked library updates whenever your context shifts.';
          const plannerLead = kidMode
            ? 'Tell Palmate what you need tonight and we’ll build the perfect plan.'
            : 'Dial in your context and Palmate will surface the routes that matter most.';
          const contextCollapsedClass = routeOverviewCollapsed ? ' route-context--collapsed' : '';
          const tonightStats = [];
          if(summary.requiredTotal){
            tonightStats.push({
              value: `${summary.requiredComplete}/${summary.requiredTotal}`,
              label: kidMode ? 'Core quests done' : 'Core quests complete'
            });
          }
          if(summary.questsTotal){
            tonightStats.push({
              value: `${summary.questsComplete}/${summary.questsTotal}`,
              label: kidMode ? 'Story & bonus quests' : 'Story & optional quests'
            });
          }
          if(summary.bossesTotal){
            tonightStats.push({
              value: `${summary.bossesComplete}/${summary.bossesTotal}`,
              label: kidMode ? 'Boss wins' : 'Bosses cleared'
            });
          }
          const tonightMetrics = tonightStats.length
            ? `<ul class="route-tonight__metrics">${tonightStats.map(stat => `
                <li class="route-tonight__metric">
                  <span class="route-tonight__metric-value">${escapeHTML(stat.value)}</span>
                  <span class="route-tonight__metric-label">${escapeHTML(stat.label)}</span>
                </li>
              `).join('')}</ul>`
            : '';
          const suggestionsToggleLabel = routeSuggestionsCollapsed
            ? (kidMode ? 'Show preview' : 'Show preview')
            : (kidMode ? 'Hide preview' : 'Hide preview');
          const suggestionsToggleTitle = routeSuggestionsCollapsed
            ? (kidMode ? 'Expand suggestion preview' : 'Show suggestion preview panel')
            : (kidMode ? 'Collapse suggestion preview' : 'Hide suggestion preview panel');
          node.innerHTML = `
          <header class="page-header route-page-header">
            <div class="route-page-header__title">
              <h2>${escapeHTML(heading)}</h2>
              <p class="route-page-lead">${escapeHTML(plannerLead)}</p>
            </div>
          </header>
          <div class="route-shell">
            <section class="card route-hero route-context${contextCollapsedClass}" id="routeContextCard">
              <div class="route-hero__layout">
                <div class="route-hero__overview">
                  ${renderRouteContextOverview(routeContext, levelEstimate, summary)}
                </div>
                <div class="route-hero__controls">
                  ${renderRouteContextControls(routeGuideData, routeContext)}
                </div>
              </div>
            </section>
            <div class="route-grid route-grid--primary">
              <section class="card route-suggestions-card route-suggestions-card--slim route-tonight-card${routeSuggestionsCollapsed ? ' route-suggestions-card--collapsed' : ''}" id="routeSuggestionsCard">
                <div class="route-suggestions__header route-tonight__header">
                  <div class="route-tonight__summary">
                    <div class="route-tonight__titles">
                      <h3>${escapeHTML(suggestionsHeading)}</h3>
                      <p class="route-tonight__intro">${escapeHTML(suggestionsLead)}</p>
                    </div>
                    ${tonightMetrics}
                  </div>
                  <button type="button" class="route-suggestions__toggle" data-route-action="toggle-suggestions" aria-expanded="${routeSuggestionsCollapsed ? 'false' : 'true'}" aria-label="${escapeHTML(suggestionsToggleTitle)}">
                    <span data-route-suggestions-toggle-label>${escapeHTML(suggestionsToggleLabel)}</span>
                    <i class="fa-solid ${routeSuggestionsCollapsed ? 'fa-chevron-down' : 'fa-chevron-up'}" aria-hidden="true"></i>
                  </button>
                </div>
                <div class="route-suggestions__list" id="routeSuggestionsList">
                  <p class="route-suggestions__empty">${escapeHTML(kidMode
                    ? 'Adjust the options above to unlock personalised picks.'
                    : 'Tune the planner above to surface tailored paths.')}</p>
                </div>
                <div class="route-suggestions__detail" id="routeSuggestionDetail">
                  <p class="route-suggestions__placeholder">${escapeHTML(kidMode
                    ? 'Highlight a suggestion to preview the guide here.'
                    : 'Highlight a suggestion to preview the full walkthrough here.')}</p>
                </div>
              </section>
              <section class="card route-active-card" id="routeActiveCard">
                <div class="route-active__header">
                  <div class="route-active__title">
                    <h3>${escapeHTML(kidMode ? 'Your adventure queue' : 'Active guides')}</h3>
                    <p class="route-active__intro">${escapeHTML(kidMode
                      ? 'Pick guides from the suggestions above. Only your chosen adventures stay visible here until you finish them.'
                      : 'Pick guides from the suggestions above. Only the adventures you select stay visible here until they are complete.')}</p>
                  </div>
                  <div class="route-active__actions">
                    <button type="button" class="btn" data-route-action="toggle-optional">${routeOptionalToggleLabel(routeHideOptional)}</button>
                    <button type="button" class="btn" data-route-action="jump-next" data-step-id="">${kidMode ? 'Jump to next step' : 'Jump to next required'}</button>
                  </div>
                </div>
                <div class="route-active__filters" data-route-role="filters" aria-label="Filter steps by category"></div>
                <div class="route-active__list" id="routeChapters"></div>
              </section>
            </div>
            <div class="route-grid route-grid--secondary">
              <section class="card route-recommendations-card" id="routeRecommendationsCard">
                <div class="route-recommendations__header">
                  <h3>${kidMode ? 'More adventures to consider' : 'More adaptive picks'}</h3>
                  <p class="route-recommendations__intro">${escapeHTML(recommendationLead)}</p>
                </div>
                <div id="routeRecommendationsList" class="route-recommendations__list"></div>
              </section>
              <section class="card route-library" id="routeLibraryCard">
                <details class="route-library__details">
                  <summary class="route-library__summary">
                    <div class="route-library__summary-text">
                      <h3>${escapeHTML(kidMode ? 'Browse every guide' : 'Browse the full library')}</h3>
                      <p>${escapeHTML(kidMode
                        ? 'Open this drawer when you want to look up older or completed guides.'
                        : 'Open the drawer to search the full guide library, including completed runs.')}</p>
                    </div>
                    <span class="route-library__count" data-route-role="library-count"></span>
                  </summary>
                  <div class="route-library__body">
                    <div class="route-library__filters" data-route-library-controls>
                      <div class="route-library__filter-group" role="group" aria-label="${escapeHTML(kidMode ? 'Filter guides' : 'Filter guides by status')}">
                        <button type="button" class="chip route-library__filter-btn${routeLibraryFilter === 'incomplete' ? ' route-library__filter-btn--active' : ''}" data-route-library-filter="incomplete">${escapeHTML(kidMode ? 'In progress' : 'In progress')}</button>
                        <button type="button" class="chip route-library__filter-btn${routeLibraryFilter === 'complete' ? ' route-library__filter-btn--active' : ''}" data-route-library-filter="complete">${escapeHTML(kidMode ? 'Completed' : 'Completed')}</button>
                        <button type="button" class="chip route-library__filter-btn${routeLibraryFilter === 'all' ? ' route-library__filter-btn--active' : ''}" data-route-library-filter="all">${escapeHTML(kidMode ? 'All guides' : 'All guides')}</button>
                      </div>
                      <button type="button" class="chip route-library__match${routeLibraryMatchContext && routeContext.goals.length ? ' route-library__match--active' : ''}" data-route-library-match="toggle" ${routeContext.goals.length ? '' : 'disabled'}>${escapeHTML(kidMode ? 'Match tonight’s goals' : 'Match tonight’s goals')}</button>
                    </div>
                    <label class="route-library__search">
                      <span class="route-library__search-icon"><i class="fa-solid fa-magnifying-glass"></i></span>
                      <input type="search" id="routeLibrarySearch" placeholder="${escapeHTML(kidMode ? 'Search guides' : 'Search guides')}" aria-label="${escapeHTML(kidMode ? 'Search guides' : 'Search guides')}" />
                    </label>
                    <div class="route-library__list" id="routeLibraryList"></div>
                  </div>
                </details>
              </section>
            </div>
          </div>
        `;
          const wrap = node.querySelector('#routeChapters');
          syncActiveRouteIds();
          pruneCompletedActiveRoutes();
          renderActiveRoutesList();
          renderRouteLibraryList();
          const librarySearch = node.querySelector('#routeLibrarySearch');
          if(librarySearch && !librarySearch.dataset.bound){
            librarySearch.value = routeLibrarySearchTerm;
            librarySearch.dataset.bound = 'true';
            librarySearch.addEventListener('input', () => {
              routeLibrarySearchTerm = librarySearch.value || '';
              renderRouteLibraryList();
            });
          }
          bindRouteLibraryControls(node);
          wrap.addEventListener('change', handleRouteCheckboxChange);
          wrap.addEventListener('click', handleRouteClick);
          bindRouteActionButtons();
          renderRouteFiltersUI(summary.categories);
          applyQueuedRouteFocus();
          refreshRouteIntelligenceUI({ summary, levelEstimate, recommendations });
          updateProgressUI();
          bindRouteContextControls(node, { guide, summary, levelEstimate, recommendations });
          applyRouteOverviewCollapseState(node);
          applyRouteSuggestionsCollapseState(node);
          updateRouteCardBackdrops({ recommendations });
        }
      }).catch(err => {
        console.error('Failed to render adaptive guide UI', err);
        node.innerHTML = `
          <section class="card route-error" role="alert">
            <h2>Adaptive Route Planner</h2>
            <p>Something went wrong while building the route interface. Try refreshing the page.</p>
            <button type="button" class="btn btn--ghost route-error__retry">Reload routes</button>
          </section>
        `;
        const retry = node.querySelector('.route-error__retry');
        if(retry && !retry.dataset.bound){
          retry.dataset.bound = 'true';
          retry.addEventListener('click', () => {
            routeGuideData = null;
            renderRouteGuide();
          });
        }
      });
    }


    function renderRouteContextOverview(context, levelEstimate, summary){
      const declared = context?.declaredLevel != null ? Number(context.declaredLevel) : null;
      const estimatedLevel = levelEstimate?.level != null ? levelEstimate.level : null;
      const xpTotal = levelEstimate?.totalXp != null ? Math.round(levelEstimate.totalXp) : null;
      const confidence = levelEstimate?.confidence != null ? Math.round(levelEstimate.confidence * 100) : null;
      const requiredPct = summary.requiredTotal ? Math.round((summary.requiredComplete / summary.requiredTotal) * 100) : 0;
      const optionalPct = summary.optionalTotal ? Math.round((summary.optionalComplete / summary.optionalTotal) * 100) : 0;
      const bossesPct = summary.bossesTotal ? Math.round((summary.bossesComplete / summary.bossesTotal) * 100) : 0;
      const questsPct = summary.questsTotal ? Math.round((summary.questsComplete / summary.questsTotal) * 100) : 0;
      const declaredLabel = declared != null ? String(declared) : (kidMode ? 'Not set' : 'Not set');
      const estimatedLabel = estimatedLevel != null ? String(estimatedLevel) : '—';
      const xpLabel = xpTotal != null ? xpTotal.toLocaleString() : '';
      const confidenceLabel = confidence != null ? `${confidence}%` : '';
      const coreRoutes = summary?.routes?.core || { total: 0, complete: 0 };
      const stepsRemaining = summary.requiredTotal ? summary.requiredTotal - summary.requiredComplete : 0;
      const routesRemaining = coreRoutes.total ? coreRoutes.total - coreRoutes.complete : 0;
      let progressNote;
      if(summary.requiredTotal){
        if(routesRemaining > 0){
          const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
          const stepLabel = stepsRemaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
          progressNote = `${routesRemaining} ${routeLabel} • ${stepsRemaining} ${stepLabel} left`;
        } else if(stepsRemaining > 0){
          const stepLabel = stepsRemaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
          progressNote = `${stepsRemaining} ${stepLabel} remaining`;
        } else {
          progressNote = kidMode ? 'All big steps complete!' : 'All required steps complete.';
        }
      } else {
        progressNote = kidMode ? 'Start any route to begin the journey.' : 'Start a route to begin tracking progress.';
      }
      let optionalNote;
      if(summary.optionalTotal){
        const remainingOptional = summary.optionalTotal - summary.optionalComplete;
        if(remainingOptional === 0){
          optionalNote = kidMode ? 'Bonus adventures wrapped!' : 'All optional tasks completed.';
        } else {
          optionalNote = kidMode
            ? `${remainingOptional} bonus step${remainingOptional === 1 ? '' : 's'} to try`
            : `${remainingOptional} optional step${remainingOptional === 1 ? '' : 's'} remaining`;
        }
      } else {
        optionalNote = kidMode ? 'Extra fun chores' : 'Bonus cleanup and prep';
      }
      let bossNote;
      if(summary.bossesTotal){
        const remainingBosses = summary.bossesTotal - summary.bossesComplete;
        if(remainingBosses === 0){
          bossNote = kidMode ? 'Every boss champion beaten!' : 'All campaign bosses defeated.';
        } else {
          bossNote = kidMode
            ? `${remainingBosses} boss${remainingBosses === 1 ? '' : 'es'} left`
            : `${remainingBosses} boss${remainingBosses === 1 ? '' : 'es'} remaining`;
        }
      } else {
        bossNote = kidMode ? 'Defeat bosses together' : 'Boss progress will appear here';
      }
      let questNote;
      if(summary.questsTotal){
        const remainingQuests = summary.questsTotal - summary.questsComplete;
        if(remainingQuests === 0){
          questNote = kidMode ? 'Every story quest wrapped!' : 'All story and optional quests complete.';
        } else {
          questNote = kidMode
            ? `${remainingQuests} quest${remainingQuests === 1 ? '' : 's'} to finish`
            : `${remainingQuests} story or optional quest${remainingQuests === 1 ? '' : 's'} remaining`;
        }
      } else {
        questNote = kidMode ? 'Story & bonus quests show here' : 'Story and optional quest progress appears here';
      }
      const lastCompleted = getLastCompletedRouteMeta();
      const lastLabel = (() => {
        if(!lastCompleted) return kidMode ? 'No routes completed yet.' : 'No routes completed yet.';
        const title = lastCompleted.title || niceName(lastCompleted.id);
        const dateLabel = lastCompleted.completedAt ? formatGuideCompletionDate(lastCompleted.completedAt) : '';
        if(kidMode){
          return dateLabel ? `Finished ${title} (${dateLabel})` : `Finished ${title}`;
        }
        return dateLabel ? `Last cleared: ${title} — ${dateLabel}` : `Last cleared: ${title}`;
      })();
      const badgeLabel = kidMode ? 'Session snapshot' : 'Session snapshot';
      const leadCopy = kidMode
        ? 'Keep this snapshot in view while you choose what to tackle next.'
        : 'Use this snapshot to line up the perfect push for tonight.';
      const historyCaption = kidMode ? 'Latest finish' : 'Latest completion';
      const requiredValue = summary.requiredTotal ? `${summary.requiredComplete}/${summary.requiredTotal}` : '0/0';
      const optionalValue = summary.optionalTotal ? `${summary.optionalComplete}/${summary.optionalTotal}` : '0/0';
      const bossValue = summary.bossesTotal ? `${summary.bossesComplete}/${summary.bossesTotal}` : '0/0';
      const questValue = summary.questsTotal ? `${summary.questsComplete}/${summary.questsTotal}` : '0/0';
      const collapsedClass = routeOverviewCollapsed ? ' route-overview--collapsed' : '';
      const toggleLabel = routeOverviewCollapsed
        ? (kidMode ? 'Show snapshot & options' : 'Show snapshot & options')
        : (kidMode ? 'Hide snapshot & options' : 'Hide snapshot & options');
      const toggleTitle = routeOverviewCollapsed
        ? (kidMode ? 'Show session snapshot and context controls' : 'Show session snapshot and context controls')
        : (kidMode ? 'Hide session snapshot and context controls' : 'Hide session snapshot and context controls');
      const condensedProgress = summary.requiredTotal
        ? `${summary.requiredComplete}/${summary.requiredTotal} ${kidMode ? 'big steps done' : 'required complete'}`
        : (kidMode ? 'No adventures tracked yet' : 'No routes tracked yet');
      const nextRequired = findNextRouteStep();
      const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });
      const nextCalloutHtml = (() => {
        if(nextAny && nextAny.step){
          const isOptional = nextAny.step.optional && !nextRequired;
          const prefix = isOptional
            ? (kidMode ? 'Bonus idea:' : 'Optional focus:')
            : (kidMode ? 'Next big step:' : 'Next priority:');
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopyRaw = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const chapterHtml = chapterTitle ? ` <span class="route-overview__next-chapter">(${escapeHTML(chapterTitle)})</span>` : '';
          const stepCopy = stepCopyRaw ? escapeHTML(stepCopyRaw) : '';
          return `<strong>${escapeHTML(prefix)}</strong> ${stepCopy}${chapterHtml}`;
        }
        return kidMode
          ? '<strong>Guide complete!</strong> Revisit bonus adventures anytime.'
          : '<strong>Guide complete!</strong> Re-run boss fights or tidy up optional chores.';
      })();
      return `
        <div class="route-overview${collapsedClass}" data-route-role="overview">
          <div class="route-overview__lead">
            <div class="route-overview__lead-text">
              <span class="route-overview__badge">${escapeHTML(badgeLabel)}</span>
              <p class="route-overview__lead-copy">${escapeHTML(leadCopy)}</p>
            </div>
            <button type="button" class="route-overview__toggle" data-route-action="toggle-overview" aria-expanded="${routeOverviewCollapsed ? 'false' : 'true'}" aria-label="${escapeHTML(toggleTitle)}">
              <span data-route-overview-toggle-label>${escapeHTML(toggleLabel)}</span>
              <i class="fa-solid ${routeOverviewCollapsed ? 'fa-chevron-down' : 'fa-chevron-up'}" aria-hidden="true"></i>
            </button>
          </div>
          <div class="route-overview__condensed">
            <div class="route-overview__condensed-row">
              <span class="route-overview__condensed-label">${escapeHTML(kidMode ? 'Progress' : 'Progress')}</span>
              <span class="route-overview__condensed-value" data-route-role="snapshot-progress">${escapeHTML(condensedProgress)}</span>
            </div>
            <p class="route-overview__condensed-next" data-route-role="next-callout">${nextCalloutHtml}</p>
            <p class="route-overview__condensed-history">
              <span class="route-overview__condensed-label">${escapeHTML(historyCaption)}</span>
              <span data-route-role="last-completed">${escapeHTML(lastLabel)}</span>
            </p>
          </div>
          <div class="route-overview__body" id="routeOverviewDetail">
            <div class="route-overview__stats">
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-signal"></i></span>
                  <p class="route-overview__stat-title">${kidMode ? 'Declared level' : 'Declared level'}</p>
                </div>
                <p class="route-overview__stat-value">${escapeHTML(declaredLabel)}</p>
                <p class="route-overview__stat-sub">${escapeHTML(kidMode ? 'Use the slider below to tell Palmate your level.' : 'Override the estimated level with your own.')}</p>
              </article>
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-user-astronaut"></i></span>
                  <p class="route-overview__stat-title">${kidMode ? 'Estimated level' : 'Estimated level'}</p>
                </div>
                <p class="route-overview__stat-value">${escapeHTML(estimatedLabel)}</p>
                <p class="route-overview__stat-sub">${xpLabel
                  ? `${escapeHTML(xpLabel)} XP${confidenceLabel ? ` • ${escapeHTML(confidenceLabel)} confidence` : ''}`
                  : escapeHTML(kidMode ? 'Complete steps to power up this estimate.' : 'Finish more steps to refine this estimate.')}</p>
              </article>
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-list-check"></i></span>
                  <p class="route-overview__stat-title" data-route-role="required-title">${kidMode ? 'Big steps' : 'Required steps'}</p>
                </div>
                <p class="route-overview__stat-value" data-route-role="required-count">${escapeHTML(requiredValue)}</p>
                <div class="route-overview__meter" data-route-role="required-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${requiredPct}">
                  <span class="fill" data-route-role="required-fill" style="width:${requiredPct}%"></span>
                </div>
                <p class="route-overview__stat-sub" data-route-role="required-note">${escapeHTML(progressNote)}</p>
              </article>
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-wand-magic-sparkles"></i></span>
                  <p class="route-overview__stat-title" data-route-role="optional-title">${kidMode ? 'Bonus ideas' : 'Optional tasks'}</p>
                </div>
                <p class="route-overview__stat-value" data-route-role="optional-count">${escapeHTML(optionalValue)}</p>
                <div class="route-overview__meter" data-route-role="optional-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${optionalPct}">
                  <span class="fill" data-route-role="optional-fill" style="width:${optionalPct}%"></span>
                </div>
                <p class="route-overview__stat-sub" data-route-role="optional-note">${escapeHTML(optionalNote)}</p>
              </article>
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-chess-king"></i></span>
                  <p class="route-overview__stat-title" data-route-role="boss-title">${kidMode ? 'Boss wins' : 'Bosses defeated'}</p>
                </div>
                <p class="route-overview__stat-value" data-route-role="boss-count">${escapeHTML(bossValue)}</p>
                <div class="route-overview__meter" data-route-role="boss-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${bossesPct}">
                  <span class="fill" data-route-role="boss-fill" style="width:${bossesPct}%"></span>
                </div>
                <p class="route-overview__stat-sub" data-route-role="boss-note">${escapeHTML(bossNote)}</p>
              </article>
              <article class="route-overview__stat">
                <div class="route-overview__stat-header">
                  <span class="route-overview__stat-icon"><i class="fa-solid fa-scroll"></i></span>
                  <p class="route-overview__stat-title" data-route-role="quest-title">${kidMode ? 'Story quests' : 'Story & optional quests'}</p>
                </div>
                <p class="route-overview__stat-value" data-route-role="quest-count">${escapeHTML(questValue)}</p>
                <div class="route-overview__meter" data-route-role="quest-meter" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="${questsPct}">
                  <span class="fill" data-route-role="quest-fill" style="width:${questsPct}%"></span>
                </div>
                <p class="route-overview__stat-sub" data-route-role="quest-note">${escapeHTML(questNote)}</p>
              </article>
            </div>
            <div class="route-overview__controls route-overview__controls--compact">
              <p class="route-overview__next" data-route-role="next-callout">${nextCalloutHtml}</p>
              <div class="route-overview__history-block">
                <span class="route-overview__history-label">${escapeHTML(historyCaption)}</span>
                <p class="route-overview__history" data-route-role="last-completed">${escapeHTML(lastLabel)}</p>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function renderRouteContextControls(guide, context){
      const levelValue = context?.declaredLevel != null ? Number(context.declaredLevel) : '';
      const timeValue = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : '';
      const tags = Array.isArray(guide?.tags) ? guide.tags : [];
      if(!tags.length){
        routeGoalDrawerOpen = false;
      }
      const resourceOptions = Array.isArray(guide?.keyResources) ? guide.keyResources : [];
      const resourceGuideMap = guide?.resourceGuides || {};
      const resourceGuideGaps = Array.isArray(guide?.resourceGuideGaps) ? guide.resourceGuideGaps : [];
      const totalResources = resourceOptions.length;
      let coveredResources = 0;
      resourceOptions.forEach(itemId => {
        const guides = Array.isArray(resourceGuideMap[itemId]) ? resourceGuideMap[itemId] : [];
        if(guides.length){
          coveredResources += 1;
        }
      });
      const missingResources = Math.max(0, totalResources - coveredResources);
      const backlogClass = missingResources
        ? ' route-context__resource-stat--pending'
        : ' route-context__resource-stat--success';
      const backlogLabel = missingResources
        ? (kidMode ? 'Coming soon' : 'Queued next')
        : (kidMode ? 'All covered' : 'Backlog clear');
      const backlogValueHtml = missingResources
        ? escapeHTML(String(missingResources))
        : '<i class="fa-solid fa-check" aria-hidden="true"></i>';
      const coverageSummary = missingResources
        ? (kidMode
          ? `${coveredResources} guides ready · ${missingResources} coming soon`
          : `${coveredResources} of ${totalResources} shortages wired · ${missingResources} queued next`)
        : (kidMode
          ? 'Guides ready for every tracked resource.'
          : `Coverage complete for all ${coveredResources} tracked resources.`);
      const backlogPreview = missingResources
        ? resourceGuideGaps
            .filter(itemId => resourceOptions.includes(itemId))
            .slice(0, 2)
            .map(itemId => itemDisplayName(itemId))
            .filter(Boolean)
        : [];
      const backlogPreviewHtml = backlogPreview.length
        ? `<span class="route-context__resource-next">${escapeHTML(kidMode ? `Next: ${backlogPreview.join(', ')}` : `Queued: ${backlogPreview.join(', ')}`)}</span>`
        : '';
      const goalTiles = tags.length
        ? renderGoalDrawer(tags, context.goals)
        : `<p class="route-context__empty">${escapeHTML(kidMode ? 'Goals load soon.' : 'No goals available yet.')}</p>`;
      const resourceChips = context.resourceGaps.length
        ? context.resourceGaps.map(entry => renderResourceGapChip(entry)).join('')
        : `<p class="route-context__empty">${escapeHTML(kidMode ? 'Add items you are missing.' : 'Add resource gaps to surface farming routes.')}</p>`;
      const resourcePickerLabel = kidMode ? 'Pick a resource' : 'Select a resource';
      const resourceOptionButtons = resourceOptions.length
        ? resourceOptions.map(itemId => {
            const guides = Array.isArray(resourceGuideMap[itemId]) ? resourceGuideMap[itemId] : [];
            const guideCount = guides.length;
            const classes = ['route-resource-option'];
            if(guideCount === 0){
              classes.push('route-resource-option--queued');
            }
            const status = guideCount
              ? (kidMode
                ? `${guideCount} plan${guideCount === 1 ? '' : 's'}`
                : `${guideCount} guide${guideCount === 1 ? '' : 's'}`)
              : (kidMode ? 'Queued' : 'Queued');
            return `
              <button type="button" class="${classes.join(' ')}" data-resource-option="${escapeHTML(itemId)}" data-guide-count="${guideCount}">
                <span class="route-resource-option__label">${escapeHTML(itemDisplayName(itemId))}</span>
                <span class="route-resource-option__status">${escapeHTML(status)}</span>
              </button>
            `;
          }).join('')
        : `<p class="route-resource-option__empty">${escapeHTML(kidMode ? 'Resources load soon.' : 'Resources load shortly.')}</p>`;
      const levelSliderValue = levelValue === '' ? 1 : levelValue;
      const sliderEmptyAttr = levelValue === '' ? ' data-empty="true"' : '';
      return `
        <div class="route-context__controls">
          <div class="route-context__grid">
            <div class="route-context__field">
              <label class="route-context__label" for="routeLevelRange">${escapeHTML(kidMode ? 'Tell Palmate your level' : 'Declared level')}</label>
              <div class="route-context__level">
                <input type="range" id="routeLevelRange" min="1" max="50" value="${escapeHTML(String(levelSliderValue))}"${sliderEmptyAttr} />
                <input type="number" id="routeLevelInput" min="1" max="50" value="${levelValue === '' ? '' : escapeHTML(String(levelValue))}" placeholder="${escapeHTML(kidMode ? 'Unset' : 'Optional')}" />
              </div>
            </div>
            <div class="route-context__field">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Mode & party' : 'Difficulty & party')}</label>
              <div class="route-context__toggles">
                <button type="button" class="chip route-context__toggle${context.hardcore ? ' route-context__toggle--active' : ''}" data-context-toggle="hardcore">${escapeHTML(kidMode ? 'Hardcore' : 'Hardcore')}</button>
                <button type="button" class="chip route-context__toggle${context.coop ? ' route-context__toggle--active' : ''}" data-context-toggle="coop">${escapeHTML(kidMode ? 'Co-Op' : 'Co-Op')}</button>
              </div>
            </div>
            <div class="route-context__field">
              <label class="route-context__label" for="routeTimeInput">${escapeHTML(kidMode ? 'Time available (minutes)' : 'Available time (minutes)')}</label>
              <input type="number" class="route-context__input" id="routeTimeInput" min="5" max="480" step="5" value="${timeValue === '' ? '' : escapeHTML(String(timeValue))}" placeholder="${escapeHTML(kidMode ? 'Leave blank if unsure' : 'Leave blank if flexible')}" />
            </div>
            <div class="route-context__field">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Goals' : 'Focus goals')}</label>
              <div class="route-context__goals">${goalTiles}</div>
            </div>
            <div class="route-context__field route-context__field--resources">
              <label class="route-context__label">${escapeHTML(kidMode ? 'Resource gaps' : 'Resource shortages')}</label>
              <div class="route-context__resource-banner">
                <div class="route-context__resource-icon" aria-hidden="true"><i class="fa-solid fa-seedling"></i></div>
                <div class="route-context__resource-copy">
                  <p class="route-context__resource-title">${escapeHTML(kidMode ? 'Match a farming route' : 'Match a farming route')}</p>
                  <p class="route-context__resource-text">${escapeHTML(coverageSummary)}</p>
                  ${backlogPreviewHtml}
                </div>
                <div class="route-context__resource-stats">
                  <div class="route-context__resource-stat">
                    <span class="route-context__resource-stat-value">${escapeHTML(String(coveredResources))}</span>
                    <span class="route-context__resource-stat-label">${escapeHTML(kidMode ? 'Guides ready' : 'Guides ready')}</span>
                  </div>
                  <div class="route-context__resource-stat${backlogClass}">
                    <span class="route-context__resource-stat-value">${backlogValueHtml}</span>
                    <span class="route-context__resource-stat-label">${escapeHTML(backlogLabel)}</span>
                  </div>
                </div>
              </div>
              <div class="route-context__resources">
                <div class="route-context__resource-add">
                  <div class="route-resource-picker" data-resource-picker>
                    <button type="button" class="route-resource-picker__toggle" data-resource-toggle aria-expanded="false">
                      <span class="route-resource-picker__toggle-label" data-resource-toggle-label>${escapeHTML(resourcePickerLabel)}</span>
                      <i class="fa-solid fa-chevron-down route-resource-picker__toggle-icon" data-resource-toggle-icon aria-hidden="true"></i>
                      <span class="sr-only">${escapeHTML(kidMode ? 'Open resource menu' : 'Open resource menu')}</span>
                    </button>
                    <div class="route-resource-picker__panel" data-resource-panel hidden>
                      <div class="route-resource-picker__list">
                        ${resourceOptionButtons}
                      </div>
                    </div>
                    <input type="hidden" id="routeResourceSelect" value="" />
                  </div>
                  <input type="number" id="routeResourceQty" min="1" max="999" placeholder="${escapeHTML(kidMode ? 'Qty' : 'Qty')}" />
                  <button type="button" class="btn route-context__resource-add-btn" data-action="add-resource-gap">${escapeHTML(kidMode ? 'Add' : 'Add')}</button>
                </div>
                <div class="route-context__resource-hint" id="routeResourceGuideHint"></div>
                <div class="route-context__resource-list" id="routeResourceList">${resourceChips}</div>
              </div>
            </div>
          </div>
        </div>
      `;
    }

    function applyRouteOverviewCollapseState(scope = document){
      const root = scope || document;
      const contextCard = root.id === 'routeContextCard'
        ? root
        : root.querySelector ? root.querySelector('#routeContextCard') : null;
      if(contextCard){
        contextCard.classList.toggle('route-context--collapsed', !!routeOverviewCollapsed);
        const controlsRegion = contextCard.querySelector('.route-hero__controls');
        if(controlsRegion){
          controlsRegion.hidden = !!routeOverviewCollapsed;
        }
      }
      const container = root.querySelector('[data-route-role="overview"]');
      if(container){
        container.classList.toggle('route-overview--collapsed', !!routeOverviewCollapsed);
      }
      const toggle = root.querySelector('[data-route-action="toggle-overview"]');
      if(toggle){
        const expanded = !routeOverviewCollapsed;
        toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        toggle.setAttribute('aria-label', expanded
          ? (kidMode ? 'Hide session snapshot and context controls' : 'Hide session snapshot and context controls')
          : (kidMode ? 'Show session snapshot and context controls' : 'Show session snapshot and context controls'));
        const label = toggle.querySelector('[data-route-overview-toggle-label]');
        if(label){
          label.textContent = routeOverviewCollapsed
            ? (kidMode ? 'Show snapshot & options' : 'Show snapshot & options')
            : (kidMode ? 'Hide snapshot & options' : 'Hide snapshot & options');
        }
        const icon = toggle.querySelector('i');
        if(icon){
          icon.classList.toggle('fa-chevron-down', !!routeOverviewCollapsed);
          icon.classList.toggle('fa-chevron-up', !routeOverviewCollapsed);
        }
      }
    }

    function applyRouteSuggestionsCollapseState(scope = document){
      const root = scope || document;
      const card = root.querySelector('#routeSuggestionsCard');
      if(card){
        card.classList.toggle('route-suggestions-card--collapsed', !!routeSuggestionsCollapsed);
      }
      const toggle = root.querySelector('[data-route-action="toggle-suggestions"]');
      if(toggle){
        const expanded = !routeSuggestionsCollapsed;
        toggle.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        toggle.setAttribute('aria-label', expanded
          ? (kidMode ? 'Collapse suggestion preview' : 'Hide suggestion preview panel')
          : (kidMode ? 'Expand suggestion preview' : 'Show suggestion preview panel'));
        const label = toggle.querySelector('[data-route-suggestions-toggle-label]');
        if(label){
          label.textContent = routeSuggestionsCollapsed
            ? (kidMode ? 'Show preview' : 'Show preview')
            : (kidMode ? 'Hide preview' : 'Hide preview');
        }
        const icon = toggle.querySelector('i');
        if(icon){
          icon.classList.toggle('fa-chevron-down', !!routeSuggestionsCollapsed);
          icon.classList.toggle('fa-chevron-up', !routeSuggestionsCollapsed);
        }
      }
    }

    function formatGoalSummary(goals){
      const selection = Array.isArray(goals) ? goals.filter(Boolean) : [];
      if(!selection.length){
        return kidMode ? 'No goals selected yet' : 'No goals selected yet';
      }
      if(selection.length === 1){
        return kidMode ? '1 goal selected' : '1 focus selected';
      }
      return kidMode
        ? `${selection.length} goals selected`
        : `${selection.length} focuses selected`;
    }

    function renderGoalSummaryMarkup(goals){
      const summaryLabel = formatGoalSummary(goals);
      const empty = !Array.isArray(goals) || !goals.length;
      const classes = ['route-goal-summary__count'];
      if(empty) classes.push('route-goal-summary__count--empty');
      return `<span class="${classes.join(' ')}">${escapeHTML(summaryLabel)}</span>`;
    }

    function renderGoalDrawer(tags, selectedGoals){
      const selectedSet = new Set((selectedGoals || []).map(goal => String(goal)));
      const summary = formatGoalSummary(selectedGoals);
      const summaryMarkup = renderGoalSummaryMarkup(selectedGoals);
      const toggleLabel = kidMode ? 'Tonight’s goals' : 'Tonight’s goals';
      const classes = ['route-goal-drawer'];
      if(routeGoalDrawerOpen) classes.push('route-goal-drawer--open');
      const panelHiddenAttr = routeGoalDrawerOpen ? '' : ' hidden';
      const options = tags.map(tag => {
        const normalized = String(tag);
        const active = selectedSet.has(normalized);
        const optionClasses = ['route-goal-option'];
        if(active) optionClasses.push('route-goal-option--active');
        const icon = routeGoalIcon(normalized);
        return `<label class="${optionClasses.join(' ')}"><input type="checkbox" data-context-goal value="${escapeHTML(normalized)}" ${active ? 'checked' : ''} /><span class="route-goal-option__icon"><i class="fa-solid ${escapeHTML(icon)}"></i></span><span class="route-goal-option__label">${escapeHTML(capitalize(normalized))}</span></label>`;
      }).join('');
      const selectAllLabel = kidMode ? 'Select all goals' : 'Select all goals';
      const clearAllLabel = kidMode ? 'Clear goals' : 'Deselect all goals';
      const manageLabel = kidMode ? 'Browse goals' : 'Manage goals';
      const summaryHint = kidMode ? 'Focus areas update recommendations instantly.' : 'Adjusting goals tunes every recommendation.';
      return `
        <div class="${classes.join(' ')}" data-goal-picker>
          <div class="route-goal-drawer__surface">
            <div class="route-goal-drawer__header">
              <div class="route-goal-drawer__title-block">
                <span class="route-goal-drawer__title">${escapeHTML(toggleLabel)}</span>
                <div class="route-goal-drawer__summary" data-goal-summary data-goal-summary-text="${escapeHTML(summary)}" title="${escapeHTML(summaryHint)}">${summaryMarkup}</div>
              </div>
              <button type="button" class="route-goal-drawer__manage" data-goal-toggle aria-expanded="${routeGoalDrawerOpen ? 'true' : 'false'}" aria-label="${escapeHTML(`${toggleLabel}: ${summary}`)}">
                <span>${escapeHTML(manageLabel)}</span>
                <i class="fa-solid fa-chevron-${routeGoalDrawerOpen ? 'up' : 'down'}" data-goal-toggle-icon></i>
              </button>
            </div>
            <div class="route-goal-drawer__actions">
              <button type="button" class="chip route-goal-drawer__action" data-goal-bulk="select-all">${escapeHTML(selectAllLabel)}</button>
              <button type="button" class="chip route-goal-drawer__action" data-goal-bulk="clear">${escapeHTML(clearAllLabel)}</button>
              <button type="button" class="chip route-goal-drawer__action route-goal-drawer__action--primary" data-goal-close>${escapeHTML(kidMode ? 'Done picking' : 'Lock selections')}</button>
            </div>
          </div>
          <div class="route-goal-drawer__panel"${panelHiddenAttr}>
            <div class="route-goal-drawer__list">
              ${options}
            </div>
          </div>
        </div>
      `;
    }

    function itemDisplayName(itemId){
      if(!itemId) return 'Item';
      const detail = ITEM_DETAILS?.[itemId];
      if(detail?.name) return detail.name;
      const item = ITEMS?.[itemId];
      if(item?.name) return item.name;
      return niceName(itemId);
    }

    function resourceGuideEntries(itemId){
      if(!itemId) return [];
      const guides = routeGuideData?.resourceGuides || {};
      const entries = guides[itemId];
      return Array.isArray(entries) ? entries : [];
    }

    function renderResourceGuideHelp(itemId){
      const entries = resourceGuideEntries(itemId);
      const guideGaps = new Set(Array.isArray(routeGuideData?.resourceGuideGaps) ? routeGuideData.resourceGuideGaps : []);
      const allResources = Array.isArray(routeGuideData?.keyResources) ? routeGuideData.keyResources : [];
      const totalTracked = allResources.length;
      const coveredCount = Object.values(routeGuideData?.resourceGuides || {}).reduce((acc, list) => {
        if(Array.isArray(list) && list.length){
          return acc + 1;
        }
        return acc;
      }, 0);
      const missingCount = guideGaps.size;
      if(!itemId){
        const intro = missingCount
          ? (kidMode
            ? `${coveredCount} guides ready · ${missingCount} on the way.`
            : `${coveredCount} of ${totalTracked} shortages wired · ${missingCount} queued next.`)
          : (kidMode
            ? 'Every tracked shortage has a matching adventure.'
            : `Every tracked shortage now has a matching plan. Pick one to dive in.`);
        const prompt = kidMode
          ? 'Choose a resource from the list above to see its guides.'
          : 'Pick a resource from the list above to preview the matching farming plans.';
        return `
          <div class="route-resource-guides route-resource-guides--empty">
            <p class="route-resource-guides__intro">${escapeHTML(intro)}</p>
            <p class="route-resource-guides__hint">${escapeHTML(prompt)}</p>
          </div>
        `;
      }
      if(!entries.length){
        const queued = guideGaps.has(itemId);
        const message = queued
          ? (kidMode
            ? 'This farming adventure is already on our to-do list. Check back after the next update!'
            : 'This shortage is queued for the next coverage sprint. It will be published in the upcoming batch.')
          : (kidMode
            ? 'No guide yet — let a teammate know you need it!'
            : 'No dedicated guide yet. Flag this shortage so the team can prioritise it.');
        return `
          <div class="route-resource-guides route-resource-guides--empty">
            <p class="route-resource-guides__intro route-resource-guides__intro--empty">${escapeHTML(message)}</p>
          </div>
        `;
      }
      const name = itemDisplayName(itemId);
      const safeName = name ? escapeHTML(name) : escapeHTML('this resource');
      const introLabel = kidMode ? 'Pick a guide to refill ' : 'Pick a plan to restock ';
      const introHtml = `${escapeHTML(introLabel)}${safeName}.`;
      const limited = entries.slice(0, 4);
      const cards = limited.map(entry => {
        const metaParts = [];
        if(entry.levelLabel){
          metaParts.push(entry.levelLabel);
        }
        if(entry.timeLabel){
          metaParts.push(entry.timeLabel);
        }
        const meta = metaParts.length
          ? `<span class="route-resource-guide-card__meta">${escapeHTML(metaParts.join(' • '))}</span>`
          : '';
        const summary = entry.summary
          ? `<p class="route-resource-guide-card__summary">${escapeHTML(entry.summary)}</p>`
          : '';
        const notes = Array.isArray(entry.shortageNotes) && entry.shortageNotes.length
          ? `<div class="route-resource-guide-card__notes">${entry.shortageNotes.map(note => `<span class="route-resource-guide-card__note">${escapeHTML(note)}</span>`).join('')}</div>`
          : '';
        const ctaLabel = kidMode ? 'Open plan' : 'Preview guide';
        return `
          <li>
            <button type="button" class="route-resource-guide-card" data-resource-guide="${escapeHTML(entry.id)}">
              <div class="route-resource-guide-card__header">
                <span class="route-resource-guide-card__title">${escapeHTML(entry.title)}</span>
                ${meta}
              </div>
              ${summary}
              ${notes}
              <div class="route-resource-guide-card__footer">
                <span class="route-resource-guide-card__cta">${escapeHTML(ctaLabel)} <i class="fa-solid fa-arrow-right"></i></span>
              </div>
            </button>
          </li>
        `;
      }).join('');
      const extra = entries.length - limited.length;
      const extraLabel = extra > 0
        ? `<p class="route-resource-guides__more">${escapeHTML(kidMode ? `+${extra} more guide${extra === 1 ? '' : 's'} ready in the library.` : `+${extra} additional guide${extra === 1 ? '' : 's'} available in the library.`)}</p>`
        : '';
      return `
        <div class="route-resource-guides">
          <p class="route-resource-guides__intro">${introHtml}</p>
          <ul class="route-resource-guide-list">${cards}</ul>
          ${extraLabel}
        </div>
      `;
    }

    function renderResourceGapChip(entry){
      const itemId = entry?.item_id || entry?.itemId || '';
      if(!itemId) return '';
      const qty = entry?.qty != null ? Number(entry.qty) : null;
      const qtyLabel = qty != null && !Number.isNaN(qty) ? ` ×${qty}` : '';
      const guidesForItem = resourceGuideEntries(itemId);
      const guideTitles = guidesForItem.slice(0, 2).map(entry => entry.title);
      const titleAttr = guideTitles.length
        ? ` title="${escapeHTML((kidMode ? 'Guides: ' : 'Guides: ') + guideTitles.join(', '))}"`
        : '';
      const guideBadge = guidesForItem.length
        ? `<span class="route-resource-chip__badge" aria-hidden="true">${escapeHTML(String(guidesForItem.length))}</span>`
        : '';
      return `<button type="button" class="chip route-resource-chip" data-resource-id="${escapeHTML(itemId)}"${titleAttr}>${escapeHTML(itemDisplayName(itemId))}${escapeHTML(qtyLabel)}${guideBadge}<span class="route-resource-chip__remove" aria-hidden="true">&times;</span></button>`;
    }

    let routeRecommendationsAbort = null;

    function renderRouteRecommendationsList(recommendations, { offset = 0 } = {}){
      const list = document.getElementById('routeRecommendationsList');
      if(!list) return;
      const pool = Array.isArray(recommendations)
        ? recommendations.filter(entry => entry && entry.route)
        : [];
      if(!pool.length){
        list.innerHTML = `<p class="route-recommendations__empty">${escapeHTML(kidMode ? 'Add goals or mark progress to unlock fresh adventures.' : 'Adjust your goals or progress to unlock new recommendations.')}</p>`;
        updateRouteRecommendationBackdrop([]);
        currentRouteRecommendationEntries = [];
      } else {
        const suggestionIds = new Set(
          Array.isArray(currentRouteSuggestionEntries)
            ? currentRouteSuggestionEntries
                .map(entry => entry && entry.route ? entry.route.id : null)
                .filter(Boolean)
            : []
        );
        let extras = pool.filter(entry => entry && entry.route && !suggestionIds.has(entry.route.id));
        if(offset > 0 && extras.length > offset){
          extras = extras.slice(offset);
        }
        if(!extras.length){
          extras = pool.slice();
        }
        const visible = extras.slice(0, 5);
        list.innerHTML = visible.map(renderRouteRecommendation).join('');
        currentRouteRecommendationEntries = visible.map(entry => ({ ...entry }));
        updateRouteRecommendationBackdrop(visible);
      }
      if(routeRecommendationsAbort){
        routeRecommendationsAbort.abort();
      }
      routeRecommendationsAbort = new AbortController();
      const { signal } = routeRecommendationsAbort;
      list.addEventListener('click', event => {
        const previewBtn = event.target.closest('[data-route-preview]');
        if(previewBtn){
          const routeId = previewBtn.dataset.routePreview;
          if(routeId){
            const entry = currentRouteRecommendationEntries.find(item => item && item.route && item.route.id === routeId);
            const stepId = previewBtn.dataset.routeStep;
            openRoutePreviewById(routeId, { entry, stepId });
          }
          event.preventDefault();
          return;
        }
        const btn = event.target.closest('[data-route-focus]');
        if(!btn) return;
        const routeId = btn.dataset.routeFocus;
        const requestedStep = btn.dataset.routeStep;
        const route = routeGuideData?.routeLookup?.[routeId];
        let stepId = requestedStep;
        if(!stepId && route){
          const nextStep = findFirstIncompleteStepForRoute(route, { includeOptional: true });
          if(nextStep) stepId = nextStep.id;
        }
        if(stepId){
          queueRouteFocus(stepId);
        }
        switchPage('route');
        playSound(clickSound);
      }, { signal });
    }

    function renderRouteRecommendation(entry){
      const route = entry.route;
      const art = routeArtFor(route);
      const styleAttr = guideCardStyleAttr(art);
      const range = route?.recommended_level || {};
      const rangeLabel = (range.min != null || range.max != null)
        ? `Lv ${range.min != null ? range.min : '?'}-${range.max != null ? range.max : '?'}`
        : '';
      const risk = route?.risk_profile ? `${capitalize(route.risk_profile)} risk` : '';
      const timeLabel = formatTimeLabel(route?.estimated_time_minutes) || '';
      const metaParts = [rangeLabel, risk, timeLabel].filter(Boolean);
      const metaLine = metaParts.length ? metaParts.join(' • ') : '';
      const scoreLabel = typeof entry.score === 'number' ? entry.score.toFixed(1) : '';
      const tags = Array.isArray(route?.tags) && route.tags.length
        ? `<div class="route-recommendation__tags">${route.tags.map(tag => `<span class="chip route-recommendation__tag">${escapeHTML(tag)}</span>`).join('')}</div>`
        : '';
      const reasons = Array.isArray(entry.reasons) && entry.reasons.length
        ? `<ul class="route-recommendation__reasons">${entry.reasons.map(reason => `<li>${escapeHTML(reason)}</li>`).join('')}</ul>`
        : `<p class="route-recommendation__fallback">${escapeHTML(kidMode ? 'Palmate picked this route for balanced fun and progress.' : 'Palmate selected this route based on your context.')}</p>`;
      const focusStep = entry.nextStepId || route?.chapter?.steps?.[0]?.id || '';
      const stepAttr = focusStep ? ` data-route-step="${escapeHTML(focusStep)}"` : '';
      const roleLabel = routePlaystyleLabel(route);
      const attributes = [`data-route-id="${escapeHTML(route.id)}"`];
      if(styleAttr){
        attributes.push(styleAttr);
      }
      const previewLabel = kidMode ? 'Show steps' : 'Show steps';
      const plannerLabel = kidMode ? 'Open planner' : 'Open in planner';
      return `
        <article class="guide-card route-recommendation" ${attributes.join(' ')}>
          <div class="guide-card__header">
            <span class="guide-card__icon"><i class="fa-solid ${escapeHTML(art.icon)}"></i></span>
            <div class="guide-card__headline">
              <span class="guide-card__badge">${escapeHTML(roleLabel)}</span>
              <h4 class="guide-card__title">${escapeHTML(route.title)}</h4>
              ${metaLine ? `<p class="guide-card__meta">${escapeHTML(metaLine)}</p>` : ''}
            </div>
            ${scoreLabel ? `<span class="route-recommendation__score">${escapeHTML(scoreLabel)}</span>` : ''}
          </div>
          <div class="route-recommendation__body">
            ${reasons}
          </div>
          <div class="guide-card__footer">
            ${tags}
            <div class="guide-card__actions">
              <button type="button" class="btn" data-route-preview="${escapeHTML(route.id)}"${stepAttr}>${escapeHTML(previewLabel)}</button>
              <button type="button" class="btn btn--ghost" data-route-focus="${escapeHTML(route.id)}"${stepAttr}>${escapeHTML(plannerLabel)}</button>
            </div>
          </div>
        </article>
      `;
    }

    function openRoutePreviewById(routeId, { entry = null, stepId } = {}){
      if(!routeId) return;
      const route = routeGuideData?.routeLookup?.[routeId];
      if(!route) return;
      openRoutePreviewModal(route, { entry, stepId });
    }

    function buildRoutePreviewSteps(chapter, { limit = ROUTE_PREVIEW_STEP_LIMIT } = {}){
      if(!chapter) return '';
      const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
      if(!steps.length){
        return `<p class="route-preview__empty">${escapeHTML(kidMode ? 'Step list coming soon.' : 'Step list coming soon.')}</p>`;
      }
      const bounded = limit > 0 ? steps.slice(0, limit) : steps.slice();
      const items = bounded.map((step, index) => {
        const text = routeStepText(step) || cleanGuideText(step?.raw?.summary || step?.raw?.detail || '') || `Step ${index + 1}`;
        const category = step.category ? escapeHTML(step.category) : escapeHTML(kidMode ? 'Step' : 'Step');
        const optional = step.optional ? `<span class="route-preview__step-optional">${escapeHTML(kidMode ? 'Bonus' : 'Optional')}</span>` : '';
        return `
          <li>
            <div class="route-preview__step-meta">
              <span class="route-preview__step-index">${index + 1}</span>
              <span class="route-preview__step-tag">${category}</span>
              ${optional}
            </div>
            <p class="route-preview__step-text">${escapeHTML(text)}</p>
          </li>
        `;
      }).join('');
      const remainder = steps.length - bounded.length;
      const more = remainder > 0
        ? `<li class="route-preview__more">${escapeHTML(kidMode ? `+${remainder} more step${remainder === 1 ? '' : 's'}` : `+${remainder} additional step${remainder === 1 ? '' : 's'}`)}</li>`
        : '';
      return `<ol class="route-preview__steps-list">${items}${more}</ol>`;
    }

    function openRoutePreviewModal(route, { entry = null, stepId } = {}){
      if(!route) return;
      const chapter = route?.chapter;
      if(!chapter) return;
      const art = routeArtFor(route);
      const reasons = Array.isArray(entry?.reasons) ? entry.reasons.filter(Boolean) : [];
      const reasonsHtml = reasons.length
        ? `<div class="route-preview__reasons-wrap"><h4>${escapeHTML(kidMode ? 'Why try it' : 'Why this route')}</h4><ul class="route-preview__reasons">${reasons.map(reason => `<li>${escapeHTML(reason)}</li>`).join('')}</ul></div>`
        : '';
      const highlights = routeHighlightMedia(route, { limit: 4 });
      const highlightsHtml = highlights.length
        ? `<div class="route-preview__highlights">${highlights.map(item => renderRouteHighlight(item, { showLabel: true, size: 'small' })).join('')}</div>`
        : '';
      const stepList = buildRoutePreviewSteps(chapter);
      const meta = renderRouteMeta(route);
      const targetStep = stepId
        || entry?.nextStepId
        || (findFirstIncompleteStepForRoute(route, { includeOptional: true })?.id || '')
        || (chapter.steps && chapter.steps[0] ? chapter.steps[0].id : '');
      const previewMarkup = `
        <article class="route-preview" style="--route-preview-image: url('${sanitizeImageUrl(art.image)}'); --route-preview-overlay: ${art.overlay}; --route-preview-accent: ${art.accent}; --route-preview-position: ${art.position};">
          <header class="route-preview__header">
            <div class="route-preview__avatar" aria-hidden="true"></div>
            <div class="route-preview__heading">
              <h3>${escapeHTML(route.title)}</h3>
              ${meta || ''}
              ${reasonsHtml}
            </div>
          </header>
          ${highlightsHtml}
          <div class="route-preview__steps">
            <h4>${escapeHTML(kidMode ? 'Step preview' : 'Step preview')}</h4>
            ${stepList}
          </div>
          <footer class="route-preview__actions">
            <button type="button" class="btn" data-preview-focus="${escapeHTML(route.id)}" data-preview-step="${escapeHTML(targetStep || '')}">${escapeHTML(kidMode ? 'Open in planner' : 'Open in planner')}</button>
            <button type="button" class="btn btn--ghost" data-preview-activate="${escapeHTML(route.id)}">${escapeHTML(kidMode ? 'Add to queue' : 'Add to active')}</button>
          </footer>
        </article>
      `;
      modalBody.innerHTML = previewMarkup;
      openModal();
      const focusBtn = modalBody.querySelector('[data-preview-focus]');
      if(focusBtn){
        focusBtn.addEventListener('click', () => {
          const focusStepId = focusBtn.dataset.previewStep;
          if(focusStepId){
            queueRouteFocus(focusStepId);
          }
          switchPage('route');
          closeModal();
          playSound(clickSound);
        });
      }
      const activateBtn = modalBody.querySelector('[data-preview-activate]');
      if(activateBtn){
        activateBtn.addEventListener('click', () => {
          addActiveRoute(route.id);
          activateBtn.disabled = true;
          activateBtn.textContent = kidMode ? 'Added to queue' : 'Added to active';
          playSound(clickSound);
        });
      }
    }

    let routeContextControlAbort = null;
    let routeLibraryControlsAbort = null;
    let guideCatalogControlsAbort = null;
    function bindGuideCatalogControls(root){
      if(!root) return;
      if(guideCatalogControlsAbort){
        guideCatalogControlsAbort.abort();
      }
      guideCatalogControlsAbort = new AbortController();
      const { signal } = guideCatalogControlsAbort;
      const card = root.querySelector('#guideCatalogCard');
      if(!card) return;
      const searchInput = card.querySelector('#guideCatalogSearch');
      const groupSelect = card.querySelector('#guideCatalogGroup');
      const categorySelect = card.querySelector('#guideCatalogCategory');
      if(searchInput){
        searchInput.value = guideCatalogSearchTerm;
        searchInput.addEventListener('input', () => {
          guideCatalogSearchTerm = searchInput.value || '';
          renderGuideCatalogList();
        }, { signal });
      }
      if(groupSelect){
        groupSelect.value = guideCatalogGroupFilter;
        groupSelect.addEventListener('change', () => {
          guideCatalogGroupFilter = groupSelect.value || 'all';
          guideCatalogCategoryFilter = 'all';
          const catalog = routeGuideData?.guideCatalog;
          if(categorySelect){
            categorySelect.innerHTML = renderGuideCatalogCategoryOptions(catalog);
            categorySelect.value = guideCatalogCategoryFilter;
          }
          renderGuideCatalogList();
        }, { signal });
      }
      if(categorySelect){
        categorySelect.value = guideCatalogCategoryFilter;
        categorySelect.addEventListener('change', () => {
          guideCatalogCategoryFilter = categorySelect.value || 'all';
          renderGuideCatalogList();
        }, { signal });
      }
    }

    function bindRouteLibraryControls(root){
      if(!root) return;
      if(routeLibraryControlsAbort){
        routeLibraryControlsAbort.abort();
      }
      routeLibraryControlsAbort = new AbortController();
      const { signal } = routeLibraryControlsAbort;
      const controls = root.querySelector('[data-route-library-controls]');
      if(!controls) return;
      controls.querySelectorAll('[data-route-library-filter]').forEach(btn => {
        btn.addEventListener('click', event => {
          const key = event.currentTarget?.dataset?.routeLibraryFilter;
          if(!key) return;
          if(routeLibraryFilter === key) return;
          routeLibraryFilter = key;
          renderRouteLibraryList();
        }, { signal });
      });
      const matchToggle = controls.querySelector('[data-route-library-match]');
      if(matchToggle){
        matchToggle.addEventListener('click', () => {
          if(matchToggle.disabled) return;
          routeLibraryMatchContext = !routeLibraryMatchContext;
          renderRouteLibraryList();
        }, { signal });
      }
    }

    function bindRouteContextControls(root){
      if(!root) return;
      if(routeContextControlAbort){
        routeContextControlAbort.abort();
      }
      routeContextControlAbort = new AbortController();
      const { signal } = routeContextControlAbort;
      const card = root.querySelector('#routeContextCard');
      if(!card) return;
      applyRouteOverviewCollapseState(card);

      const overviewToggle = card.querySelector('[data-route-action="toggle-overview"]');
      if(overviewToggle){
        overviewToggle.addEventListener('click', () => {
          routeOverviewCollapsed = !routeOverviewCollapsed;
          applyRouteOverviewCollapseState(card);
          persistRoutePreferences();
          playSound(clickSound);
        }, { signal });
      }

      const levelSlider = card.querySelector('#routeLevelRange');
      const levelInput = card.querySelector('#routeLevelInput');
      const syncLevelInputs = value => {
        if(levelSlider){
          if(value == null){
            levelSlider.setAttribute('data-empty', 'true');
          } else {
            levelSlider.value = String(value);
            levelSlider.removeAttribute('data-empty');
          }
        }
        if(levelInput){
          levelInput.value = value == null ? '' : String(value);
        }
      };
      if(levelSlider){
        levelSlider.addEventListener('input', () => {
          if(levelInput){
            levelInput.value = levelSlider.value;
          }
          levelSlider.removeAttribute('data-empty');
        }, { signal });
        levelSlider.addEventListener('change', () => {
          const num = clampNumber(levelSlider.value, 1, 50);
          syncLevelInputs(num);
          updateRouteContextState({ declaredLevel: num });
        }, { signal });
      }
      if(levelInput){
        levelInput.addEventListener('input', () => {
          const raw = levelInput.value.trim();
          if(!raw){
            if(levelSlider){
              levelSlider.setAttribute('data-empty', 'true');
            }
          } else {
            const num = clampNumber(raw, 1, 50);
            if(num != null && levelSlider){
              levelSlider.value = String(num);
              levelSlider.removeAttribute('data-empty');
            }
          }
        }, { signal });
        levelInput.addEventListener('change', () => {
          const raw = levelInput.value.trim();
          if(!raw){
            syncLevelInputs(null);
            updateRouteContextState({ declaredLevel: null });
            return;
          }
          const num = clampNumber(raw, 1, 50);
          if(num == null){
            syncLevelInputs(null);
            updateRouteContextState({ declaredLevel: null });
            return;
          }
          syncLevelInputs(num);
          updateRouteContextState({ declaredLevel: num });
        }, { signal });
      }

      const timeInput = card.querySelector('#routeTimeInput');
      if(timeInput){
        timeInput.addEventListener('change', () => {
          const raw = timeInput.value.trim();
          if(!raw){
            updateRouteContextState({ availableTimeMinutes: null });
            return;
          }
          const num = clampNumber(raw, 5, 480);
          if(num == null){
            timeInput.value = '';
            updateRouteContextState({ availableTimeMinutes: null });
            return;
          }
          timeInput.value = String(num);
          updateRouteContextState({ availableTimeMinutes: num });
        }, { signal });
      }

      card.querySelectorAll('[data-context-toggle]').forEach(btn => {
        btn.addEventListener('click', () => {
          const key = btn.dataset.contextToggle;
          if(!key) return;
          const nextValue = !routeContext?.[key];
          updateRouteContextState({ [key]: nextValue });
        }, { signal });
      });

      const goalPicker = card.querySelector('[data-goal-picker]');
      if(goalPicker){
        const toggle = goalPicker.querySelector('[data-goal-toggle]');
        const toggleIcon = goalPicker.querySelector('[data-goal-toggle-icon]');
        const panel = goalPicker.querySelector('.route-goal-drawer__panel');
        const applyDrawerState = () => {
          goalPicker.classList.toggle('route-goal-drawer--open', routeGoalDrawerOpen);
          if(panel){
            if(routeGoalDrawerOpen){
              panel.removeAttribute('hidden');
            } else {
              panel.setAttribute('hidden', '');
            }
          }
          if(toggle){
            toggle.setAttribute('aria-expanded', routeGoalDrawerOpen ? 'true' : 'false');
          }
          if(toggleIcon){
            toggleIcon.classList.toggle('fa-chevron-up', routeGoalDrawerOpen);
            toggleIcon.classList.toggle('fa-chevron-down', !routeGoalDrawerOpen);
          }
        };
        if(toggle){
          toggle.addEventListener('click', () => {
            routeGoalDrawerOpen = !routeGoalDrawerOpen;
            applyDrawerState();
          }, { signal });
        }
        const closeBtn = goalPicker.querySelector('[data-goal-close]');
        if(closeBtn){
          closeBtn.addEventListener('click', () => {
            routeGoalDrawerOpen = false;
            applyDrawerState();
          }, { signal });
        }
        goalPicker.querySelectorAll('[data-context-goal]').forEach(box => {
          box.addEventListener('change', () => {
            const selected = Array.from(goalPicker.querySelectorAll('[data-context-goal]:checked'))
              .map(el => el.value)
              .filter(Boolean);
            updateRouteContextState({ goals: selected });
          }, { signal });
        });
        goalPicker.querySelectorAll('[data-goal-bulk]').forEach(btn => {
          btn.addEventListener('click', () => {
            const action = btn.dataset.goalBulk;
            const boxes = Array.from(goalPicker.querySelectorAll('[data-context-goal]'));
            if(!boxes.length) return;
            if(action === 'select-all'){
              boxes.forEach(box => { box.checked = true; });
              const selected = boxes.map(box => box.value).filter(Boolean);
              updateRouteContextState({ goals: selected });
            } else if(action === 'clear'){
              boxes.forEach(box => { box.checked = false; });
              updateRouteContextState({ goals: [] });
            }
          }, { signal });
        });
        applyDrawerState();
      }

      const resourceSelect = card.querySelector('#routeResourceSelect');
      const resourceQty = card.querySelector('#routeResourceQty');
      const resourceList = card.querySelector('#routeResourceList');
      const resourceHelp = card.querySelector('#routeResourceGuideHint');
      const resourcePicker = card.querySelector('[data-resource-picker]');
      const resourcePanel = resourcePicker?.querySelector('[data-resource-panel]');
      const resourceToggle = resourcePicker?.querySelector('[data-resource-toggle]');
      const resourceToggleIcon = resourcePicker?.querySelector('[data-resource-toggle-icon]');
      const resourceToggleLabel = resourcePicker?.querySelector('[data-resource-toggle-label]');
      const resourcePlaceholderLabel = kidMode ? 'Pick a resource' : 'Select a resource';
      let resourcePickerOpen = false;
      const renderResourceHelp = itemId => {
        if(resourceHelp){
          resourceHelp.innerHTML = renderResourceGuideHelp(itemId);
        }
      };
      const applyResourcePickerState = () => {
        if(resourcePanel){
          if(resourcePickerOpen){
            resourcePanel.removeAttribute('hidden');
          } else {
            resourcePanel.setAttribute('hidden', '');
          }
        }
        if(resourceToggle){
          resourceToggle.setAttribute('aria-expanded', resourcePickerOpen ? 'true' : 'false');
        }
        if(resourceToggleIcon){
          resourceToggleIcon.classList.toggle('fa-chevron-up', resourcePickerOpen);
          resourceToggleIcon.classList.toggle('fa-chevron-down', !resourcePickerOpen);
        }
        if(resourcePicker){
          resourcePicker.classList.toggle('route-resource-picker--open', resourcePickerOpen);
        }
      };
      const updateResourceToggleLabel = itemId => {
        if(!resourceToggleLabel) return;
        if(itemId){
          resourceToggleLabel.textContent = itemDisplayName(itemId);
        } else {
          resourceToggleLabel.textContent = resourcePlaceholderLabel;
        }
      };
      const highlightResourceOption = itemId => {
        if(!resourcePicker) return;
        resourcePicker.querySelectorAll('[data-resource-option]').forEach(btn => {
          const active = btn?.dataset?.resourceOption === itemId;
          btn.classList.toggle('route-resource-option--active', active);
        });
      };
      if(resourceToggle){
        resourceToggle.addEventListener('click', () => {
          resourcePickerOpen = !resourcePickerOpen;
          applyResourcePickerState();
        }, { signal });
      }
      if(resourcePicker){
        resourcePicker.addEventListener('click', event => {
          const option = event.target.closest('[data-resource-option]');
          if(!option) return;
          const itemId = option.dataset.resourceOption || '';
          if(resourceSelect){
            resourceSelect.value = itemId;
            const changeEvent = new Event('change', { bubbles: false });
            resourceSelect.dispatchEvent(changeEvent);
          } else {
            renderResourceHelp(itemId);
          }
          resourcePickerOpen = false;
          applyResourcePickerState();
        }, { signal });
      }
      const addButton = card.querySelector('[data-action="add-resource-gap"]');
      if(addButton && resourceSelect){
        addButton.addEventListener('click', () => {
          const itemId = resourceSelect.value;
          if(!itemId) return;
          const qtyRaw = resourceQty ? resourceQty.value.trim() : '';
          const qty = qtyRaw ? clampNumber(qtyRaw, 1, 999) : null;
          const existing = Array.isArray(routeContext?.resourceGaps) ? routeContext.resourceGaps : [];
          const filtered = existing.filter(entry => (entry?.item_id || entry?.itemId) !== itemId);
          filtered.push({ item_id: itemId, qty });
          if(resourceQty) resourceQty.value = '';
          resourceSelect.value = '';
          renderResourceHelp('');
          updateRouteContextState({ resourceGaps: filtered });
        }, { signal });
      }
      if(resourceSelect){
        resourceSelect.addEventListener('change', () => {
          const value = resourceSelect.value || '';
          updateResourceToggleLabel(value);
          highlightResourceOption(value);
          renderResourceHelp(value);
        }, { signal });
      }
      if(resourceHelp){
        renderResourceHelp(resourceSelect ? resourceSelect.value : '');
        resourceHelp.addEventListener('click', event => {
          const btn = event.target.closest('[data-resource-guide]');
          if(!btn) return;
          const routeId = btn.dataset.resourceGuide;
          if(routeId){
            openRoutePreviewById(routeId);
          }
        }, { signal });
      }
      updateResourceToggleLabel(resourceSelect ? resourceSelect.value : '');
      highlightResourceOption(resourceSelect ? resourceSelect.value : '');
      applyResourcePickerState();
      if(resourceList){
        resourceList.addEventListener('click', event => {
          const chip = event.target.closest('[data-resource-id]');
          if(!chip) return;
          const id = chip.dataset.resourceId;
          if(!id) return;
          const next = Array.isArray(routeContext?.resourceGaps)
            ? routeContext.resourceGaps.filter(entry => (entry?.item_id || entry?.itemId) !== id)
            : [];
          updateRouteContextState({ resourceGaps: next });
        }, { signal });
      }
    }

    function updateRouteContextState(updates){
      routeContext = normalizeRouteContext({ ...routeContext, ...(updates || {}) });
      saveRouteContext(routeContext);
      renderRouteGuide();
      requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
    }

    function findFirstIncompleteStepForRoute(route, { includeOptional = false } = {}){
      if(!route) return null;
      const steps = Array.isArray(route?.chapter?.steps) ? route.chapter.steps : [];
      for(const step of steps){
        if(step.optional && !includeOptional) continue;
        if(!routeState[step.id]){
          return step;
        }
      }
      if(includeOptional){
        return steps.find(step => !routeState[step.id]) || null;
      }
      return null;
    }

    function formatLevelRangeLabel(level){
      if(!level || typeof level !== 'object') return '';
      const min = level.min != null ? Number(level.min) : null;
      const max = level.max != null ? Number(level.max) : null;
      const hasMin = Number.isFinite(min);
      const hasMax = Number.isFinite(max);
      if(hasMin && hasMax){
        return `Lv ${min}-${max}`;
      }
      if(hasMin){
        return `Lv ${min}+`;
      }
      if(hasMax){
        return `Up to Lv ${max}`;
      }
      return '';
    }

    function formatTimeLabel(time){
      if(!time) return '';
      const solo = time.solo;
      const coop = time.coop;
      if(solo && coop) return `${solo}m solo / ${coop}m co-op`;
      if(solo) return `${solo}m solo`;
      if(coop) return `${coop}m co-op`;
      return '';
    }

    function formatRecommendationText(template, values = {}){
      if(!template) return '';
      return template.replace(/\{(\w+)\}/g, (match, key) => {
        const replacement = values[key];
        return replacement != null ? String(replacement) : match;
      });
    }

    function computeRouteRecommendations(guide, context, levelEstimate, stageSnapshot){
      const routes = Array.isArray(guide?.routes) ? guide.routes : [];
      if(!routes.length) return [];
      const weights = { ...DEFAULT_RECOMMENDER_WEIGHTS, ...(guide?.recommender?.scoring_signals || {}) };
      const templates = guide?.recommender?.explanation_templates || {};
      const completedRoutes = new Set(routes.filter(route => isRouteComplete(route)).map(route => route.id));
      const resourceMap = new Map();
      (context?.resourceGaps || []).forEach(entry => {
        if(entry && entry.item_id){
          resourceMap.set(entry.item_id, entry.qty != null ? Number(entry.qty) : null);
        }
      });
      const availableTime = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null;
      const playerLevel = context?.declaredLevel != null ? Number(context.declaredLevel) : (levelEstimate?.level ?? null);
      const goalSet = new Set((context?.goals || []).map(goal => String(goal || '').toLowerCase()));
      const activeRouteSet = new Set(loadActiveRouteIdsFromState(routeState));
      const routeLookup = guide?.routeLookup || {};
      const stage = stageSnapshot || determineGuideStageSnapshot();
      const activeRegions = deriveStageRegions(stage);
      const activeRegionSet = new Set(activeRegions.map(entry => entry.id));
      const activeRegionNames = activeRegions.map(entry => entry.name);
      const pendingBaseRouteIds = gatherPendingBaseRouteIds(stage);
      const stageIndex = typeof stage?.stageIndex === 'number' ? stage.stageIndex : null;
      const stageRouteId = stage?.stageId || null;
      const stageRoute = stageRouteId ? routeLookup[stageRouteId] : null;
      const stageSupportRecommended = createRouteIdSet(stageRoute?.supporting_routes?.recommended);
      const stageSupportOptional = createRouteIdSet(stageRoute?.supporting_routes?.optional);
      const stagePhase = stageRouteId === 'quest-main-story-early'
        ? determineMainStoryPhase(stageSnapshot)
        : null;
      const phaseRecommendedSet = stagePhase ? createRouteIdSet(stagePhase.recommended) : new Set();
      const phaseOptionalSet = stagePhase ? createRouteIdSet(stagePhase.optional) : new Set();
      phaseRecommendedSet.forEach(id => stageSupportRecommended.add(id));
      phaseOptionalSet.forEach(id => stageSupportOptional.add(id));
      const activeRouteRegionSet = new Set();
      const activeRouteRegionNames = new Map();
      activeRouteSet.forEach(id => {
        const activeRoute = routeLookup[id];
        if(!activeRoute) return;
        const summary = summarizeRouteRegions(activeRoute);
        summary.forEach(entry => {
          if(!entry?.id) return;
          activeRouteRegionSet.add(entry.id);
          if(entry.name && !activeRouteRegionNames.has(entry.id)){
            activeRouteRegionNames.set(entry.id, entry.name);
          }
        });
      });
      const stageNextCategory = stage?.nextStep?.category ? String(stage.nextStep.category).toLowerCase() : '';
      const upcomingBoss = (() => {
        const candidates = routes
          .filter(route => !completedRoutes.has(route.id) && routePlaystyleKey(route) === 'boss')
          .sort((a, b) => (a.index || 0) - (b.index || 0));
        if(!candidates.length) return null;
        if(stageIndex == null){
          return { route: candidates[0], distanceFromStage: null };
        }
        const next = candidates.find(route => (route.index || 0) >= stageIndex) || candidates[candidates.length - 1];
        return { route: next, distanceFromStage: (next.index || 0) - stageIndex };
      })();
      const bossPrereq = upcomingBoss?.route?.prerequisites || {};
      const bossNeededTech = new Set();
      const bossNeededTechNames = new Map();
      (Array.isArray(bossPrereq?.tech) ? bossPrereq.tech : []).forEach(value => {
        const info = resolveTechInfoBySlug(value);
        if(!info.slug) return;
        bossNeededTech.add(info.slug);
        if(info.name && !bossNeededTechNames.has(info.slug)){
          bossNeededTechNames.set(info.slug, info.name);
        }
      });
      const bossNeededItems = new Set();
      const bossNeededItemNames = new Map();
      (Array.isArray(bossPrereq?.items) ? bossPrereq.items : []).forEach(entry => {
        if(!entry) return;
        const rawId = typeof entry === 'string' ? entry : (entry.item_id || entry.id);
        const slug = slugifyForPalworld(String(rawId || ''));
        if(!slug) return;
        bossNeededItems.add(slug);
        if(!bossNeededItemNames.has(slug)){
          bossNeededItemNames.set(slug, niceName(slug));
        }
      });
      const bossNeededPals = new Set();
      const bossNeededPalNames = new Map();
      (Array.isArray(bossPrereq?.pals) ? bossPrereq.pals : []).forEach(value => {
        const info = resolvePalInfoBySlug(value);
        if(!info.slug) return;
        bossNeededPals.add(info.slug);
        if(info.name && !bossNeededPalNames.has(info.slug)){
          bossNeededPalNames.set(info.slug, info.name);
        }
      });
      const missionRegionMap = new Map();
      routes.forEach(routeEntry => {
        const category = String(routeEntry?.category || '').toLowerCase();
        const tags = Array.isArray(routeEntry?.tags) ? routeEntry.tags.map(tag => String(tag || '').toLowerCase()) : [];
        const missionLike = category.includes('mission') || category.includes('quest') || tags.some(tag => tag.includes('mission') || tag.includes('quest'));
        if(!missionLike) return;
        const regionSummary = summarizeRouteRegions(routeEntry);
        regionSummary.forEach(entry => {
          if(!entry?.id) return;
          if(!missionRegionMap.has(entry.id)){
            missionRegionMap.set(entry.id, { id: entry.id, name: entry.name || describeRegionLabel(entry.id), total: 0, incomplete: 0 });
          }
          const info = missionRegionMap.get(entry.id);
          info.total += 1;
          if(!completedRoutes.has(routeEntry.id)){
            info.incomplete += 1;
          }
        });
      });
      const results = [];
      routes.forEach(route => {
        const unmetRoutes = (route?.prerequisites?.routes || []).filter(id => !completedRoutes.has(id));
        if(unmetRoutes.length) return;
        const routeComplete = completedRoutes.has(route.id);
        const isActive = activeRouteSet.has(route.id);
        if(routeComplete && !isActive) return;
        const breakdown = routeProgressBreakdown(route);
        const reasons = [];
        let score = 0;
        let contextSignals = isActive ? 2 : 0;
        let levelGap = 0;
        let timeDelta = null;
        let tier = 4;
        if(weights.prerequisites_met){
          score += weights.prerequisites_met;
          if(templates.prerequisites_met){
            reasons.push(formatRecommendationText(templates.prerequisites_met));
          }
        }
        const stageDistance = stageIndex != null ? (route.index || 0) - stageIndex : null;
        const normalizedCategory = (route?.category || '').toLowerCase();
        const normalizedTags = Array.isArray(route?.tags) ? route.tags.map(tag => String(tag || '').toLowerCase()) : [];
        const playstyleKey = routePlaystyleKey(route);
        const routeRegionSummary = summarizeRouteRegions(route);
        const prereq = route?.prerequisites || {};
        const requiredPalInfos = Array.isArray(prereq.pals) ? prereq.pals.map(resolvePalInfoBySlug).filter(info => info.slug) : [];
        const missingPrereqPals = requiredPalInfos.filter(info => !info.caught);
        const readyPrereqPalNames = requiredPalInfos.filter(info => info.caught).map(info => info.name);
        if(requiredPalInfos.length){
          if(!missingPrereqPals.length){
            score += weights.prereq_pal_ready || 0;
            const palNames = requiredPalInfos.map(info => info.name).join(', ');
            if(templates.prereq_pal_ready){
              reasons.push(formatRecommendationText(templates.prereq_pal_ready, { pals: palNames }));
            } else {
              reasons.push(kidMode ? `${palNames} are on your team—let them shine!` : `Prerequisite pals ready: ${palNames}.`);
            }
            contextSignals += requiredPalInfos.length;
          } else {
            score -= (weights.prereq_pal_ready || 0) * 0.8;
            const palNames = missingPrereqPals.map(info => info.name).join(', ');
            if(templates.prereq_pal_missing){
              reasons.push(formatRecommendationText(templates.prereq_pal_missing, { pals: palNames }));
            } else {
              reasons.push(kidMode ? `Catch ${palNames} first.` : `Catch required pals: ${palNames}.`);
            }
          }
        }
        const requiredTechInfos = Array.isArray(prereq.tech) ? prereq.tech.map(resolveTechInfoBySlug).filter(info => info.slug) : [];
        const missingPrereqTech = requiredTechInfos.filter(info => !info.unlocked);
        if(requiredTechInfos.length){
          if(!missingPrereqTech.length){
            score += weights.prereq_tech_ready || 0;
            const techNames = requiredTechInfos.map(info => info.name).join(', ');
            if(templates.prereq_tech_ready){
              reasons.push(formatRecommendationText(templates.prereq_tech_ready, { tech: techNames }));
            } else {
              reasons.push(kidMode ? `You already unlocked ${techNames}.` : `Required tech unlocked: ${techNames}.`);
            }
            contextSignals += 1;
          } else {
            score -= (weights.prereq_tech_ready || 0) * 0.7;
            const techNames = missingPrereqTech.map(info => info.name).join(', ');
            if(templates.prereq_tech_missing){
              reasons.push(formatRecommendationText(templates.prereq_tech_missing, { tech: techNames }));
            } else {
              reasons.push(kidMode ? `Unlock ${techNames} to start.` : `Unlock required tech: ${techNames}.`);
            }
          }
        }
        const range = route?.recommended_level || {};
        if(playerLevel != null && (range.min != null || range.max != null)){
          const min = range.min != null ? Number(range.min) : null;
          const max = range.max != null ? Number(range.max) : null;
          let inRange = true;
          if(min != null && playerLevel < min){
            const gap = min - playerLevel;
            levelGap = Math.max(levelGap, gap);
            inRange = false;
            score -= (weights.level_fit || 0) / 2;
            if(gap >= 5){
              score -= (weights.level_fit || 0) / 2;
            }
            if(route?.adaptive_guidance?.underleveled){
              reasons.push(formatRecommendationText(templates.adaptive_guidance, { recommendation: route.adaptive_guidance.underleveled }));
            }
          } else if(max != null && playerLevel > max){
            const gap = playerLevel - max;
            levelGap = Math.max(levelGap, gap);
            inRange = false;
            score -= (weights.level_fit || 0) / 2;
            if(gap >= 5){
              score -= (weights.level_fit || 0) / 2;
            }
            if(route?.adaptive_guidance?.overleveled){
              reasons.push(formatRecommendationText(templates.adaptive_guidance, { recommendation: route.adaptive_guidance.overleveled }));
            }
          } else {
            score += weights.level_fit || 0;
          }
          if(inRange){
            if(templates.level_fit){
              reasons.push(formatRecommendationText(templates.level_fit, { level: playerLevel, min: range.min, max: range.max }));
            }
            contextSignals += 1;
          }
        }
        if(Array.isArray(route?.yields?.key_unlocks) && route.yields.key_unlocks.length){
          score += weights.unlock_value || 0;
          const unlockList = route.yields.key_unlocks.map(niceName).join(', ');
          if(templates.unlock_value){
            reasons.push(formatRecommendationText(templates.unlock_value, { unlocks: unlockList }));
          } else {
            reasons.push(kidMode ? `Unlocks ${unlockList}.` : `Unlocks: ${unlockList}`);
          }
          contextSignals += 1;
        }
        if(availableTime != null){
          const desired = context.coop ? route?.estimated_time_minutes?.coop : route?.estimated_time_minutes?.solo;
          const fallback = context.coop ? route?.estimated_time_minutes?.solo : route?.estimated_time_minutes?.coop;
          const timeValue = desired != null ? desired : fallback;
          if(timeValue != null){
            timeDelta = timeValue - availableTime;
            if(timeValue <= availableTime){
              score += weights.time_to_power_ratio || 0;
              contextSignals += 1;
            } else {
              score -= (weights.time_to_power_ratio || 0) / 2;
              if(timeDelta > 20){
                score -= (weights.time_to_power_ratio || 0) / 2;
              }
            }
          }
        }
        if(route?.progression_role){
          const baseRole = route.progression_role === 'core' ? 1 : route.progression_role === 'support' ? 0.7 : 0.4;
          score += (weights.progression_role || 0) * baseRole;
          if(templates.progression_role){
            reasons.push(formatRecommendationText(templates.progression_role, { role: capitalize(route.progression_role) }));
          }
          if(route.progression_role === 'core'){
            contextSignals += 1;
          }
        }
        const matchedRegions = routeRegionSummary.filter(entry => activeRegionSet.has(entry.id));
        if(matchedRegions.length){
          score += weights.region_alignment || 0;
          const regionNames = matchedRegions.slice(0, 2).map(entry => entry.name).join(', ');
          if(templates.region_alignment){
            reasons.push(formatRecommendationText(templates.region_alignment, { region: regionNames }));
          } else {
            const prefix = activeRegionNames.length ? 'already in' : 'focused on';
            reasons.push(kidMode ? `We’re ${prefix} ${regionNames}.` : `Matches your time in ${regionNames}.`);
          }
          contextSignals += matchedRegions.length;
        }
        if(activeRouteRegionSet.size){
          const sharedActiveRegions = routeRegionSummary.filter(entry => activeRouteRegionSet.has(entry.id));
          if(sharedActiveRegions.length && !isActive){
            score += weights.active_region_chain || 0;
            const names = sharedActiveRegions.slice(0, 2).map(entry => entry.name || activeRouteRegionNames.get(entry.id) || describeRegionLabel(entry.id));
            reasons.push(kidMode ? `Stacks with other plans in ${names.join(', ')}.` : `Shares region focus with active guides in ${names.join(', ')}.`);
            contextSignals += sharedActiveRegions.length;
          }
        }
        if(stageRouteId && route.id === stageRouteId){
          score += weights.stage_alignment || 0;
          reasons.push(kidMode ? 'This is the current story chapter.' : 'Current chapter objective.');
          contextSignals += 1;
          tier = Math.min(tier, 0);
        } else if(stageDistance === 1){
          score += (weights.stage_alignment || 0) * 0.6;
          reasons.push(kidMode ? 'Next story step is right here.' : 'Up next in the storyline.');
          contextSignals += 1;
          tier = Math.min(tier, 1);
        } else if(stageDistance === -1 && !routeComplete){
          score += (weights.stage_alignment || 0) * 0.4;
          reasons.push(kidMode ? 'Clean up this step before moving on.' : 'Backfill the previous chapter.');
          contextSignals += 1;
        }
        if(stageNextCategory && stageDistance != null && stageDistance <= 1){
          const categoryMatch = normalizedCategory.includes(stageNextCategory) || normalizedTags.some(tag => tag.includes(stageNextCategory));
          if(categoryMatch){
            score += (weights.stage_alignment || 0) * 0.3;
            reasons.push(kidMode ? 'Matches the next guide step.' : 'Lines up with the upcoming guide beat.');
            contextSignals += 1;
          }
        }
        if(stageRouteId && stageRouteId !== route.id && !routeComplete){
          const stageLabel = kidMode ? (stage?.stageTitleKid || stage?.stageTitleGrown || '') : (stage?.stageTitleGrown || stage?.stageTitleKid || '');
          if(phaseRecommendedSet.has(route.id)){
            score += (weights.supporting_stage || 0) + (weights.phase_alignment || 0);
            const summary = kidMode
              ? (stagePhase?.kidSummary || stageLabel || 'Supports the current story prep.')
              : (stagePhase?.grownSummary || stageLabel || 'Supports the active chapter.');
            reasons.push(summary);
            contextSignals += 1;
            tier = Math.min(tier, 1);
          } else if(stageSupportRecommended.has(route.id)){
            score += weights.supporting_stage || 0;
            reasons.push(stageLabel
              ? (kidMode ? `Helps finish ${stageLabel}.` : `Supports current chapter: ${stageLabel}.`)
              : (kidMode ? 'Supports the current story prep.' : 'Supports the active chapter.'));
            contextSignals += 1;
            tier = Math.min(tier, 1);
          } else if(phaseOptionalSet.has(route.id)){
            score += ((weights.supporting_stage || 0) * 0.6) + ((weights.phase_alignment || 0) * 0.6);
            const optionalSummary = kidMode
              ? (stagePhase?.kidOptional || stageLabel || 'Optional story support.')
              : (stagePhase?.grownOptional || stageLabel || 'Optional chapter support.');
            reasons.push(optionalSummary);
            contextSignals += 1;
          } else if(stageSupportOptional.has(route.id)){
            score += (weights.supporting_stage || 0) * 0.6;
            reasons.push(stageLabel
              ? (kidMode ? `Optional help for ${stageLabel}.` : `Optional prep for ${stageLabel}.`)
              : (kidMode ? 'Optional story support.' : 'Optional chapter support.'));
            contextSignals += 1;
          }
        }
        if(pendingBaseRouteIds.has(route.id)){
          score += weights.base_alignment || 0;
          if(templates.base_alignment){
            reasons.push(formatRecommendationText(templates.base_alignment, { stage: stage?.stageTitleGrown || '' }));
          } else {
            reasons.push(kidMode ? 'Clears the base chores Palmate flagged.' : 'Tackles the base tasks waiting in the planner.');
          }
          contextSignals += 1;
        }
        const isMissionRoute = normalizedCategory.includes('mission') || normalizedCategory.includes('quest') || normalizedTags.some(tag => tag.includes('mission') || tag.includes('quest'));
        if(isMissionRoute && matchedRegions.length && (stageDistance == null || stageDistance <= 1)){
          score += weights.mission_alignment || 0;
          const regionName = matchedRegions[0]?.name || activeRegionNames[0] || route.title;
          if(templates.mission_alignment){
            reasons.push(formatRecommendationText(templates.mission_alignment, { region: regionName }));
          } else {
            reasons.push(kidMode ? `Quest fits this area in ${regionName}.` : `Quest aligns with your stop in ${regionName}.`);
          }
          contextSignals += 1;
        }
        if(isMissionRoute && missionRegionMap.size){
          const clusterRegions = routeRegionSummary
            .map(entry => missionRegionMap.get(entry.id))
            .filter(info => info && info.incomplete > 1);
          if(clusterRegions.length){
            const clusterName = clusterRegions[0].name;
            score += weights.quest_cluster || 0;
            reasons.push(kidMode
              ? `Bundle nearby quests in ${clusterName}.`
              : `Cluster quests together while you’re in ${clusterName}.`);
            contextSignals += clusterRegions.length;
          }
        }
        const isBossPlaystyle = playstyleKey === 'boss';
        if(isBossPlaystyle){
          if(stageDistance != null){
            if(stageDistance <= 0){
              score += weights.boss_prep || 0;
              reasons.push(kidMode ? 'Boss showdown is ready—gear up!' : `Boss encounter ready: ${route.title || 'Boss fight'}.`);
              contextSignals += 1;
            } else if(stageDistance === 1){
              score += (weights.boss_prep || 0) * 0.8;
              reasons.push(kidMode ? 'Get ready for the next boss.' : `Prep for upcoming boss: ${route.title || 'Boss fight'}.`);
              contextSignals += 1;
            } else if(stageDistance <= 3){
              score += (weights.boss_prep || 0) * 0.4;
            }
          }
        }
        if(upcomingBoss && upcomingBoss.route && upcomingBoss.route.id !== route.id){
          const supportDistance = upcomingBoss.route.index - (route.index || 0);
          const leadsToBoss = Array.isArray(route?.next_routes) && route.next_routes.includes(upcomingBoss.route.id);
          const recommendedSupport = Array.isArray(route?.supporting_routes?.recommended) && route.supporting_routes.recommended.includes(upcomingBoss.route.id);
          const preppingRole = playstyleKey === 'resource' || playstyleKey === 'craft' || playstyleKey === 'base' || route.progression_role === 'support';
          if(leadsToBoss || recommendedSupport || (preppingRole && supportDistance >= -1 && supportDistance <= 2)){
            score += weights.boss_support || 0;
            const bossName = upcomingBoss.route.title || 'boss fight';
            if(templates.boss_support){
              reasons.push(formatRecommendationText(templates.boss_support, { boss: bossName }));
            } else {
              reasons.push(kidMode ? `Prep gear for ${bossName}.` : `Sets up ${bossName}.`);
            }
            contextSignals += 1;
          }
        }
        const unlocks = route?.outputs?.unlocks || {};
        const techInfoMap = new Map();
        const registerTechInfo = info => {
          if(info && info.slug && !techInfoMap.has(info.slug)){
            techInfoMap.set(info.slug, info);
          }
        };
        if(unlocks){
          if(Array.isArray(unlocks.tech)){
            unlocks.tech.map(resolveTechInfoBySlug).forEach(registerTechInfo);
          }
          if(Array.isArray(unlocks.stations)){
            unlocks.stations.map(resolveTechInfoBySlug).forEach(registerTechInfo);
          }
        }
        if(Array.isArray(route?.yields?.key_unlocks)){
          route.yields.key_unlocks.map(resolveTechInfoBySlug).forEach(registerTechInfo);
        }
        const plannedTechInfos = Array.from(techInfoMap.values());
        const lockedTechInfos = plannedTechInfos.filter(info => !info.unlocked);
        const resourceOutputSlugSet = new Set();
        (Array.isArray(route?.resourceOutputs) ? route.resourceOutputs : []).forEach(itemId => {
          const slug = slugifyForPalworld(String(itemId || ''));
          if(slug){
            resourceOutputSlugSet.add(slug);
          }
        });
        const routePalRewardSet = new Set();
        const registerPalReward = value => {
          const info = resolvePalInfoBySlug(value);
          if(info.slug){
            routePalRewardSet.add(info.slug);
          }
        };
        const rawSteps = Array.isArray(route?.steps) ? route.steps : [];
        rawSteps.forEach(step => {
          const outputs = step?.outputs || {};
          if(Array.isArray(outputs.pals)){
            outputs.pals.forEach(registerPalReward);
          }
        });
        if(Array.isArray(route?.outputs?.pals)){
          route.outputs.pals.forEach(registerPalReward);
        }
        const highlightPals = Array.isArray(route?.highlightPals) ? route.highlightPals : [];
        const highlightPalInfos = highlightPals.map(resolvePalInfoBySlug).filter(info => info.slug);
        const missingPalEntries = highlightPalInfos.filter(info => !info.caught).map(info => info.name);
        const readyHighlightPals = highlightPalInfos.filter(info => info.caught);
        if(highlightPalInfos.length && weights.pal_gap && missingPalEntries.length){
          score += weights.pal_gap;
          const sample = missingPalEntries.slice(0, 2).join(', ');
          reasons.push(kidMode ? `Adds new pals like ${sample}.` : `Uncaught pals: ${sample}.`);
          contextSignals += 1;
        }
        if(readyHighlightPals.length && (weights.pal_ready_highlight || 0) && !routeComplete){
          const readyNames = readyHighlightPals.slice(0, 2).map(info => info.name).join(' & ');
          reasons.push(kidMode ? `${readyNames} are ready for this plan.` : `Captured pals ready to leverage: ${readyNames}.`);
          score += weights.pal_ready_highlight || 0;
          contextSignals += readyHighlightPals.length;
        }
        const highlightTech = Array.isArray(route?.highlightTech) ? route.highlightTech : [];
        const highlightTechInfos = highlightTech.map(resolveTechInfoBySlug).filter(info => info.slug);
        const missingTechEntries = highlightTechInfos.filter(info => !info.unlocked).map(info => info.name);
        if(highlightTechInfos.length && weights.tech_gap && missingTechEntries.length){
          score += weights.tech_gap;
          const sample = missingTechEntries.slice(0, 2).join(', ');
          reasons.push(kidMode ? `Unlocks tech like ${sample}.` : `Fills tech gaps: ${sample}.`);
          contextSignals += 1;
        }
        if(lockedTechInfos.length && (weights.tech_followthrough || 0) && !routeComplete){
          const techNames = lockedTechInfos.slice(0, 2).map(info => info.name).join(', ');
          const palSupportNames = readyPrereqPalNames.length ? readyPrereqPalNames : readyHighlightPals.map(info => info.name);
          if(palSupportNames.length){
            const palNames = palSupportNames.slice(0, 2).join(' & ');
            reasons.push(kidMode ? `${palNames} are ready—build ${techNames}.` : `${palNames} now enable ${techNames}.`);
            score += weights.tech_followthrough || 0;
            contextSignals += lockedTechInfos.length;
          }
        }
        if(upcomingBoss && upcomingBoss.route){
          const bossName = upcomingBoss.route.title || 'boss fight';
          const bossPrepSet = new Set();
          lockedTechInfos.forEach(info => {
            if(bossNeededTech.has(info.slug)){
              bossPrepSet.add(bossNeededTechNames.get(info.slug) || info.name || niceName(info.slug));
            }
          });
          resourceOutputSlugSet.forEach(slug => {
            if(bossNeededItems.has(slug)){
              bossPrepSet.add(bossNeededItemNames.get(slug) || niceName(slug));
            }
          });
          routePalRewardSet.forEach(slug => {
            if(bossNeededPals.has(slug)){
              bossPrepSet.add(bossNeededPalNames.get(slug) || niceName(slug));
            }
          });
          if(bossPrepSet.size){
            score += weights.boss_requirement_alignment || 0;
            const sample = Array.from(bossPrepSet).slice(0, 2).join(', ');
            reasons.push(kidMode ? `Covers ${sample} before ${bossName}.` : `Delivers ${sample} needed for ${bossName}.`);
            contextSignals += bossPrepSet.size;
          }
        }
        const levelInfo = route?.recommended_level || {};
        const minLevel = levelInfo && levelInfo.min != null ? Number(levelInfo.min) : null;
        const maxLevel = levelInfo && levelInfo.max != null ? Number(levelInfo.max) : null;
        const levelSpan = Number.isFinite(minLevel) && Number.isFinite(maxLevel) ? maxLevel - minLevel : null;
        const deepMainStoryPhase = stageRouteId === 'quest-main-story-early' && !!stagePhase;
        const highPlayerLevel = playerLevel != null && Number.isFinite(playerLevel) && playerLevel >= 30;
        if(levelSpan != null && levelSpan >= 45 && !routeComplete && route.id !== stageRouteId && (deepMainStoryPhase || highPlayerLevel)){
          score -= weights.level_window_penalty || 0;
          reasons.push(kidMode
            ? 'Stick with chapter-ready guides instead of all-level tours.'
            : 'Prefer chapter-tuned guidance over broad level 1–60 overviews.');
        }
        if(context.coop && route?.modes?.coop){
          score += weights.coop_synergy || 0;
          contextSignals += 1;
        } else if(context.coop && route?.modes && route.modes.coop === false){
          score -= (weights.coop_synergy || 0) / 2;
        }
        if(context.hardcore){
          if(route?.risk_profile === 'high'){
            score -= weights.risk_vs_mode || 0;
          } else if(route?.risk_profile === 'low'){
            score += (weights.risk_vs_mode || 0) / 2;
          }
        }
        const overlapTags = normalizedTags.filter(tag => goalSet.has(tag));
        if(overlapTags.length){
          const label = overlapTags.map(capitalize).join(', ');
          score += weights.tag_alignment || 0;
          reasons.push(kidMode ? `Goal match: ${label}` : `Goal focus: ${overlapTags.join(', ')}`);
          contextSignals += overlapTags.length * 2;
        }
        const objectives = Array.isArray(route?.objectives) ? route.objectives.map(obj => String(obj || '').toLowerCase()) : [];
        const objectiveMatches = goalSet.size ? objectives.filter(obj => Array.from(goalSet).some(goal => obj.includes(goal))) : [];
        if(objectiveMatches.length){
          score += weights.goal_objective_alignment || 0;
          const display = objectiveMatches.slice(0, 2).map(niceName);
          reasons.push(kidMode ? `Matches goals: ${display.join(', ')}` : `Objectives align with: ${display.join(', ')}`);
          contextSignals += objectiveMatches.length;
        }
        if(goalSet.size && !overlapTags.length){
          const titleLower = (route.title || '').toLowerCase();
          const keywordMatch = Array.from(goalSet).find(goal => titleLower.includes(goal));
          if(keywordMatch){
            score += weights.context_goal_keyword || 0;
            reasons.push(kidMode ? `Focuses on ${capitalize(keywordMatch)}.` : `Title includes ${keywordMatch}.`);
            contextSignals += 1;
          }
        }
        const isBossRoute = normalizedCategory.includes('tower') || normalizedCategory.includes('boss') || normalizedTags.some(tag => tag.includes('tower') || tag.includes('boss'));
        const bossGoal = goalSet.has('tower') || goalSet.has('boss');
        if(isBossRoute && bossGoal){
          const bossAlignmentWeight = weights.boss_alignment ?? weights.tower_alignment ?? 0;
          score += bossAlignmentWeight;
          reasons.push(kidMode ? 'Perfect for boss showdowns.' : 'Aligns with your boss/story focus.');
          contextSignals += 1;
        }
        if(!routeComplete){
          score += weights.novelty || 0;
        }
        if(breakdown.requiredDone > 0 && breakdown.requiredDone < breakdown.requiredTotal){
          score += weights.progress_momentum || 0;
          reasons.push(kidMode ? 'You already started this route—keep going!' : 'Momentum bonus: you have partial progress here.');
          contextSignals += 1;
        }
        const remainingRequired = breakdown.requiredTotal - breakdown.requiredDone;
        if(breakdown.requiredTotal && remainingRequired > 0 && remainingRequired <= 2){
          score += weights.closeout_bonus || 0;
          reasons.push(kidMode ? 'Only a couple big steps left!' : 'Close to completion — only a few required steps remain.');
          contextSignals += 1;
        }
        if(breakdown.totalDone > 0 && !routeComplete){
          score += weights.returning_focus || 0;
          reasons.push(kidMode ? 'Let’s finish what you started.' : 'Finish the route you already began.');
          contextSignals += 1;
        }
        const metrics = route?.metrics || {};
        const progressSegments = Number(metrics.progress_segments || 0);
        const bossTargets = Number(metrics.boss_targets || 0);
        const questNodes = Number(metrics.quest_nodes || 0);
        if(progressSegments || bossTargets || questNodes){
          score += weights.metric_efficiency || 0;
          if(templates.metric_efficiency){
            reasons.push(formatRecommendationText(templates.metric_efficiency, {
              progress_segments: progressSegments,
              boss_targets: bossTargets,
              quest_nodes: questNodes
            }));
          } else {
            const parts = [];
            if(progressSegments){
              parts.push(`${progressSegments} major ${progressSegments === 1 ? 'segment' : 'segments'}`);
            }
            if(bossTargets){
              parts.push(`${bossTargets} boss ${bossTargets === 1 ? 'clear' : 'clears'}`);
            }
            if(questNodes){
              parts.push(`${questNodes} story ${questNodes === 1 ? 'question' : 'questions'}`);
            }
            const detail = parts.length > 1 ? parts.slice(0, -1).join(', ') + ' and ' + parts.slice(-1) : (parts[0] || 'key steps');
            reasons.push(kidMode ? `Covers ${detail}.` : `Guides through ${detail}.`);
          }
          const signalWeight = progressSegments + bossTargets + questNodes;
          contextSignals += Math.max(1, signalWeight);
        }
        const resourceMatches = [];
        resourceMap.forEach((qty, itemId) => {
          if(route.resourceOutputs.includes(itemId)){
            resourceMatches.push({ itemId, qty });
          }
        });
        if(resourceMatches.length){
          score += weights.resource_relief || 0;
          if(templates.resource_need){
            resourceMatches.forEach(match => {
              reasons.push(formatRecommendationText(templates.resource_need, { item: niceName(match.itemId) }));
            });
          } else {
            const names = resourceMatches.map(match => niceName(match.itemId));
            reasons.push(kidMode ? `Helps gather ${names.join(', ')}.` : `Addresses shortages: ${names.join(', ')}`);
          }
          contextSignals += resourceMatches.length * 2;
          if(resourceMatches.some(match => match.qty != null && match.qty >= 20)){
            score += weights.resource_urgency || 0;
            reasons.push(kidMode ? 'Big resource refill.' : 'High priority resource shortage covered.');
            contextSignals += 1;
          }
        }
        const dynamicHits = evaluateDynamicRules(route, context, levelEstimate, resourceMap);
        if(dynamicHits.length){
          score += weights.dynamic_alignment || 0;
          dynamicHits.forEach(hit => {
            reasons.push(formatRecommendationText(templates.dynamic_alignment, { rule_adjustment: hit }));
          });
          contextSignals += dynamicHits.length;
        }
        const futureRoutes = Array.isArray(route?.next_routes) ? route.next_routes.filter(id => !completedRoutes.has(id)) : [];
        if(futureRoutes.length){
          score += weights.synergy_next_routes || 0;
          reasons.push(kidMode ? 'Opens new adventures next.' : 'Sets up follow-up routes.');
        }
        if(isActive){
          tier = 0;
        } else if(breakdown.requiredDone > 0){
          tier = Math.min(tier, 1);
        }
        if(stageRouteId && route.id === stageRouteId){
          tier = Math.min(tier, 0);
        } else if(stageDistance === 1){
          tier = Math.min(tier, 1);
        }
        if(contextSignals > 0){
          tier = Math.min(tier, isActive ? 0 : 1);
        } else if(route.progression_role === 'core'){
          tier = Math.min(tier, 2);
        } else if(route.progression_role === 'support'){
          tier = Math.min(tier, 3);
        }
        if(levelGap >= 4){
          tier = Math.max(tier, 3);
        }
        if(timeDelta != null && timeDelta > 20){
          tier = Math.max(tier, 3);
        }
        const nextStep = findFirstIncompleteStepForRoute(route, { includeOptional: true });
        results.push({
          route,
          score,
          reasons,
          nextStepId: nextStep ? nextStep.id : null,
          tier,
          contextSignals,
          breakdown,
          levelGap,
          timeDelta
        });
      });
      return results.sort((a, b) => {
        const tierA = a.tier ?? 0;
        const tierB = b.tier ?? 0;
        if(tierA !== tierB) return tierA - tierB;
        const contextA = a.contextSignals ?? 0;
        const contextB = b.contextSignals ?? 0;
        if(contextA !== contextB) return contextB - contextA;
        const scoreDiff = (b.score || 0) - (a.score || 0);
        if(scoreDiff !== 0) return scoreDiff;
        const progressA = a.breakdown ? (a.breakdown.requiredDone / Math.max(1, a.breakdown.requiredTotal)) : 0;
        const progressB = b.breakdown ? (b.breakdown.requiredDone / Math.max(1, b.breakdown.requiredTotal)) : 0;
        if(progressA !== progressB) return progressB - progressA;
        const levelGapDiff = (a.levelGap || 0) - (b.levelGap || 0);
        if(levelGapDiff !== 0) return levelGapDiff;
        const timeDeltaDiff = (a.timeDelta ?? 0) - (b.timeDelta ?? 0);
        if(timeDeltaDiff !== 0) return timeDeltaDiff;
        return (a.route.index || 0) - (b.route.index || 0);
      });
    }
    function evaluateDynamicRules(route, context, levelEstimate, resourceMap){
      const hits = [];
      const rules = route?.adaptive_guidance?.dynamic_rules;
      if(!Array.isArray(rules) || !rules.length) return hits;
      const level = context?.declaredLevel != null ? Number(context.declaredLevel) : (levelEstimate?.level ?? null);
      const timeBudget = context?.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null;
      rules.forEach(rule => {
        if(!rule || !rule.signal) return;
        const scope = Array.isArray(rule.mode_scope) ? rule.mode_scope : [];
        if(scope.includes('hardcore') && !context.hardcore) return;
        if(scope.includes('solo') && context.coop) return;
        if(scope.includes('coop') && !context.coop) return;
        let triggered = false;
        if(rule.signal.startsWith('level_gap')){
          if(level == null) return;
          const recommended = route?.recommended_level || {};
          if(rule.signal.includes('over')){
            if(recommended.max != null && level >= recommended.max + 2){
              triggered = true;
            }
          } else if(rule.signal.includes('under')){
            if(recommended.min != null && level <= recommended.min - 2){
              triggered = true;
            }
          }
        } else if(rule.signal === 'time_budget_short'){
          if(timeBudget != null && timeBudget < 30){
            triggered = true;
          }
        } else if(rule.signal.startsWith('resource_gap:')){
          const itemId = rule.signal.split(':')[1];
          if(itemId && resourceMap.has(itemId)){
            triggered = true;
          }
        } else if(rule.signal.startsWith('mode:hardcore')){
          if(context.hardcore) triggered = true;
        }
        if(triggered && rule.adjustment){
          hits.push(rule.adjustment);
        }
      });
      return hits;
    }

    function estimatePlayerLevel(context = routeContext){
      if(!routeGuideData) return { level: null, totalXp: 0, confidence: 0 };
      const estimator = routeGuideData.levelEstimator || {};
      const xpThresholds = Array.isArray(routeGuideData?.xp?.xp_thresholds) ? routeGuideData.xp.xp_thresholds : [];
      const fallbackRanges = estimator.per_step_xp_ranges || {};
      const metricUsage = estimator.metric_usage || {};
      let totalXp = 0;
      let stepsWithXp = 0;
      let completedSteps = 0;
      routeGuideData.routes.forEach(route => {
        const rawSteps = Array.isArray(route?.steps) ? route.steps : [];
        let routeXp = 0;
        let routeCompleted = true;
        rawSteps.forEach(step => {
          const stepId = step?.step_id || step?.id;
          if(!stepId) return;
          if(!routeState[stepId]){
            routeCompleted = false;
            return;
          }
          completedSteps += 1;
          let xpMin = step?.xp_award_estimate?.min;
          let xpMax = step?.xp_award_estimate?.max;
          if((xpMin == null || xpMax == null) && step?.type){
            const fallback = fallbackRanges[step.type];
            if(fallback){
              if(xpMin == null) xpMin = fallback.min;
              if(xpMax == null) xpMax = fallback.max;
            }
          }
          if(xpMin != null || xpMax != null){
            const minVal = xpMin != null ? Number(xpMin) : Number(xpMax);
            const maxVal = xpMax != null ? Number(xpMax) : Number(xpMin);
            const median = (Number(minVal) + Number(maxVal)) / 2;
            if(!Number.isNaN(median)){
              totalXp += median;
              routeXp += median;
              stepsWithXp += 1;
            }
          }
          const isBoss = step?.type === 'fight' || (Array.isArray(step?.targets) && step.targets.some(target => target?.kind === 'boss'));
          if(isBoss){
            totalXp += 500;
            routeXp += 500;
          }
        });
        if(routeCompleted && context?.hardcore){
          totalXp += routeXp * 0.1;
        }
        const metrics = route?.metrics || {};
        const progressSegments = Number(metrics.progress_segments || 0);
        if(progressSegments){
          totalXp += progressSegments * (metricUsage.progress_segment_value || 0);
        }
        const bossTargets = Number(metrics.boss_targets || 0);
        if(bossTargets){
          totalXp += bossTargets * (metricUsage.boss_clear_value || 0);
        }
        const questNodes = Number(metrics.quest_nodes || 0);
        if(questNodes){
          totalXp += questNodes * (metricUsage.quest_node_value || 0);
        }
      });
      let level = null;
      if(xpThresholds.length){
        level = xpThresholds.reduce((acc, entry) => {
          if(entry && typeof entry.cumulative_xp === 'number' && totalXp >= entry.cumulative_xp){
            return entry.level != null ? entry.level : acc;
          }
          return acc;
        }, xpThresholds[0]?.level || 1);
      }
      if(level == null) level = 1;
      const confidenceBase = completedSteps ? stepsWithXp / completedSteps : 0;
      const confidence = Math.max(0, Math.min(1, confidenceBase + 0.1));
      return { level, totalXp, confidence };
    }

    function normalizeRouteContext(context){
      const base = { ...DEFAULT_ROUTE_CONTEXT, ...(context || {}) };
      base.declaredLevel = base.declaredLevel != null && base.declaredLevel !== '' ? clampNumber(base.declaredLevel, 1, 50) : null;
      base.availableTimeMinutes = base.availableTimeMinutes != null && base.availableTimeMinutes !== '' ? clampNumber(base.availableTimeMinutes, 5, 480) : null;
      base.hardcore = !!base.hardcore;
      base.coop = !!base.coop;
      base.goals = Array.from(new Set((Array.isArray(base.goals) ? base.goals : []).map(value => value == null ? '' : String(value).trim()))).filter(Boolean);
      base.resourceGaps = Array.isArray(base.resourceGaps)
        ? base.resourceGaps.map(entry => {
            const itemId = entry?.item_id || entry?.itemId || '';
            if(!itemId) return null;
            const qty = entry?.qty != null ? clampNumber(entry.qty, 1, 999) : null;
            return { item_id: itemId, qty };
          }).filter(Boolean)
        : [];
      return base;
    }

    function clampNumber(value, min, max){
      const num = Number(value);
      if(Number.isNaN(num)) return null;
      if(min != null && num < min) return min;
      if(max != null && num > max) return max;
      return num;
    }
    function queueRouteFocus(stepId){
      if(!stepId){
        pendingRouteFocus = null;
        return;
      }
      pendingRouteFocus = stepId;
      setTimeout(applyQueuedRouteFocus, 0);
    }

    function applyQueuedRouteFocus(){
      if(!pendingRouteFocus) return;
      const routePage = document.getElementById('routePage');
      if(!routePage) return;
      const stepId = pendingRouteFocus;
      const target = routePage.querySelector(`input[data-step="${stepId}"]`);
      if(!target){
        let revealed = false;
        if(ensureRouteOptionalVisible(stepId)){
          revealed = true;
        }
        if(ensureRouteCategoryVisible(stepId)){
          revealed = true;
        }
        if(revealed){
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          refreshRouteIntelligenceUI({ skipActiveList: true });
          requestAnimationFrame(applyQueuedRouteFocus);
        }
        return;
      }
      pendingRouteFocus = null;
      requestAnimationFrame(() => {
        target.scrollIntoView({ behavior: 'smooth', block: 'center' });
        const label = target.closest('.step');
        if(label) pulse(label);
        if(typeof target.focus === 'function'){
          try {
            target.focus({ preventScroll: true });
          } catch (err) {
            target.focus();
          }
        }
      });
    }

    function ensureRouteOptionalVisible(stepId){
      if(!routeHideOptional || !stepId || !routeGuideData) return false;
      const chapters = Array.isArray(routeGuideData.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const step = steps.find(entry => entry && entry.id === stepId);
        if(step && step.optional){
          routeHideOptional = false;
          updateRouteToggleButtons();
          persistRoutePreferences();
          return true;
        }
      }
      return false;
    }

    function ensureRouteCategoryVisible(stepId){
      if(!stepId || !routeGuideData) return false;
      const chapters = Array.isArray(routeGuideData.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const step = steps.find(entry => entry && entry.id === stepId);
        if(step){
          const slug = routeCategorySlug(step.category);
          if(routeHiddenCategories.has(slug)){
            routeHiddenCategories.delete(slug);
            persistRoutePreferences();
            return true;
          }
          break;
        }
      }
      return false;
    }

    function renderChapterCard(chapter, openByDefault, route){
      const section = document.createElement('section');
      section.className = 'card route-card route-card--stacked';
      section.id = `chapter-${chapter.id}`;
      section.dataset.chapterId = chapter.id;
      section.innerHTML = buildRouteCardInnerHTML(chapter, openByDefault, route);
      return section;
    }

    function buildRouteCardInnerHTML(chapter, openByDefault, route){
      const progress = chapterProgress(chapter);
      const meta = renderRouteMeta(route);
      const why = routeChapterWhy(chapter);
      const completeLabel = progress.requiredDone
        ? `<span class="route-card__complete">✅ ${escapeHTML(kidMode ? 'Route complete' : 'Chapter complete')}</span>`
        : '';
      const art = routeArtFor(route);
      const routeId = route?.id || chapter.id;
      const markerAttr = art.marker ? ` style="left:${art.marker.left}%;top:${art.marker.top}%"` : '';
      const label = art.label && art.label !== routeChapterTitle(chapter) ? art.label : '';
      const queueButton = isRouteActive(routeId)
        ? `<button type="button" class="chip route-card__queue" data-action="deactivateRoute" data-route-id="${escapeHTML(routeId)}">${escapeHTML(kidMode ? 'Remove from queue' : 'Remove from queue')}</button>`
        : '';
      return `
        <div class="route-card__header">
          <div class="route-card__info">
            <div class="route-card__thumb" style="--route-visual-image: url('${art.image}'); --route-visual-overlay: ${art.overlay}; --route-visual-accent: ${art.accent}; --route-visual-position: ${art.position};">
              ${art.marker ? `<span class="route-visual__marker"${markerAttr}></span>` : ''}
            </div>
            <div class="route-card__title">
              <h3>${escapeHTML(routeChapterTitle(chapter))}</h3>
              ${label ? `<span class="route-card__label">${escapeHTML(label)}</span>` : ''}
              ${why ? `<p class="route-card__why">${escapeHTML(why)}</p>` : ''}
              ${meta}
            </div>
          </div>
          <div class="route-card__toolbar">
            ${completeLabel}
            ${queueButton}
          </div>
        </div>
        <div class="route-card__progress">${renderProgress(progress)}</div>
        <details class="route-card__details"${openByDefault ? ' open' : ''}>
          <summary class="btn route-card__toggle">${escapeHTML(kidMode ? 'Show steps' : 'Open steps')}</summary>
          ${renderSteps(chapter, route)}
          <div class="route-card__actions">
            <button class="btn" data-action="markRequired" data-ch="${chapter.id}">${escapeHTML(kidMode ? 'Mark big steps complete' : 'Mark Required Complete')}</button>
            <button class="btn" data-action="resetChapter" data-ch="${chapter.id}">${escapeHTML(kidMode ? 'Reset route' : 'Reset Chapter')}</button>
          </div>
        </details>
      `;
    }

    function rerenderChapter(chapter, options = {}){
      const node = document.querySelector(`#chapter-${chapter.id}`);
      if(!node) return;
      const { focusStepId = '', previousScrollTop = null, anchorRect = null, restoreFocus = false } = options;
      const details = node.querySelector('.route-card__details');
      const wasOpen = details ? details.open : false;
      const route = routeGuideData?.routeLookup?.[chapter.id] || null;
      node.innerHTML = buildRouteCardInnerHTML(chapter, wasOpen, route);
      if(wasOpen){
        const nextDetails = node.querySelector('.route-card__details');
        if(nextDetails) nextDetails.open = true;
      }
      if(typeof previousScrollTop === 'number'){
        restoreScrollPosition(previousScrollTop);
      }
      if(focusStepId){
        const selector = `input[type="checkbox"][data-step="${cssEscape(focusStepId)}"]`;
        const checkbox = node.querySelector(selector);
        if(checkbox){
          if(anchorRect){
            const stepNode = checkbox.closest('label.step');
            if(stepNode){
              const newRect = stepNode.getBoundingClientRect();
              const delta = newRect.top - anchorRect.top;
              if(Math.abs(delta) > 1){
                window.scrollBy(0, delta);
              }
            }
          }
          if(restoreFocus){
            focusElement(checkbox);
          }
        }
      }
    }


    function renderRouteMeta(route){
      if(!route) return '';
      const parts = [];
      if(route.category){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(capitalize(route.category))}</span>`);
      }
      const level = route.recommended_level || {};
      if(level.min != null || level.max != null){
        parts.push(`<span class="chip route-meta-chip">Lv ${escapeHTML(level.min != null ? String(level.min) : '?')}-${escapeHTML(level.max != null ? String(level.max) : '?')}</span>`);
      }
      if(route.risk_profile){
        parts.push(`<span class="chip route-meta-chip route-meta-chip--${escapeHTML(route.risk_profile)}">${escapeHTML(capitalize(route.risk_profile))} risk</span>`);
      }
      const timeLabel = formatTimeLabel(route.estimated_time_minutes);
      if(timeLabel){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(timeLabel)}</span>`);
      }
      const xpGain = route.estimated_xp_gain || {};
      if(xpGain.min != null || xpGain.max != null){
        parts.push(`<span class="chip route-meta-chip">${escapeHTML(`${xpGain.min != null ? xpGain.min : '?'}-${xpGain.max != null ? xpGain.max : '?'} XP`)}</span>`);
      }
      if(Array.isArray(route.tags) && route.tags.length){
        const tagHtml = route.tags.map(tag => `<span class="chip route-meta-chip route-meta-chip--tag">${escapeHTML(tag)}</span>`).join('');
        parts.push(`<span class="route-meta-tags">${tagHtml}</span>`);
      }
      return parts.length ? `<div class="route-card__meta">${parts.join('')}</div>` : '';
    }

    function renderStepDetail(step, route){
      const raw = step?.raw || findRawStep(route, step.id);
      if(!raw) return '';
      const blocks = [];
      const descriptionSource = raw.detail && raw.detail !== raw.summary ? raw.detail : (raw.detail || raw.summary || '');
      const description = cleanGuideText(descriptionSource);
      if(description){
        blocks.push(`<p class="step-extra__text">${escapeHTML(description)}</p>`);
      }
      if(Array.isArray(raw.locations) && raw.locations.length){
        blocks.push(renderStepLocations(raw.locations));
      }
      if(raw.recommended_loadout && (Array.isArray(raw.recommended_loadout.gear) && raw.recommended_loadout.gear.length || Array.isArray(raw.recommended_loadout.pals) && raw.recommended_loadout.pals.length || Array.isArray(raw.recommended_loadout.consumables) && raw.recommended_loadout.consumables.length)){
        blocks.push(renderStepLoadout(raw.recommended_loadout));
      }
      if(raw.mode_adjustments && (raw.mode_adjustments.hardcore || raw.mode_adjustments.coop)){
        blocks.push(renderStepModeAdjustments(raw.mode_adjustments));
      }
      if(raw.outputs){
        const outputBlock = renderStepOutputs(raw.outputs);
        if(outputBlock) blocks.push(outputBlock);
      }
      if(Array.isArray(raw.branching) && raw.branching.length){
        const branchItems = raw.branching
          .map(entry => {
            const condition = cleanGuideText(entry?.condition);
            const action = cleanGuideText(entry?.action);
            const subroute = cleanGuideText(entry?.subroute_ref);
            const parts = [];
            if(condition) parts.push(condition);
            if(action) parts.push(`→ ${action}`);
            if(subroute) parts.push(`(${subroute})`);
            const content = parts.join(' ');
            if(!content) return '';
            return `<li>${escapeHTML(content)}</li>`;
          })
          .filter(Boolean)
          .join('');
        if(branchItems){
          blocks.push(`<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'If you need' : 'Branching')}</h5><ul class="step-extra__list">${branchItems}</ul></div>`);
        }
      }
      if(raw.xp_award_estimate && (raw.xp_award_estimate.min != null || raw.xp_award_estimate.max != null)){
        blocks.push(`<p class="step-extra__xp">${escapeHTML(`XP estimate: ${raw.xp_award_estimate.min != null ? raw.xp_award_estimate.min : '?'}-${raw.xp_award_estimate.max != null ? raw.xp_award_estimate.max : '?'}`)}</p>`);
      }
      return blocks.length ? `<div class="step-extra">${blocks.join('')}</div>` : '';
    }

    function renderStepLocations(locations){
      if(!Array.isArray(locations) || !locations.length) return '';
      const entries = locations.map(loc => {
        const parts = [];
        if(loc.region_id) parts.push(niceName(loc.region_id));
        if(Array.isArray(loc.coords) && loc.coords.length === 2){
          parts.push(`(${loc.coords[0]}, ${loc.coords[1]})`);
        }
        if(loc.time && loc.time !== 'any') parts.push(`Time: ${loc.time}`);
        if(loc.weather && loc.weather !== 'any') parts.push(`Weather: ${loc.weather}`);
        return `<li>${escapeHTML(parts.join(' • '))}</li>`;
      }).join('');
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'Where to go' : 'Locations')}</h5><ul class="step-extra__list">${entries}</ul></div>`;
    }

    function renderStepLoadout(loadout){
      const rows = [];
      if(Array.isArray(loadout.gear) && loadout.gear.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Gear' : 'Gear')}:</strong> ${escapeHTML(loadout.gear.map(niceName).join(', '))}</li>`);
      }
      if(Array.isArray(loadout.pals) && loadout.pals.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Pals' : 'Pals')}:</strong> ${escapeHTML(loadout.pals.map(niceName).join(', '))}</li>`);
      }
      if(Array.isArray(loadout.consumables) && loadout.consumables.length){
        rows.push(`<li><strong>${escapeHTML(kidMode ? 'Items' : 'Consumables')}:</strong> ${escapeHTML(loadout.consumables.map(entry => `${entry?.qty != null ? `${entry.qty}× ` : ''}${niceName(entry?.item_id || entry?.itemId || '')}`).join(', '))}</li>`);
      }
      if(!rows.length) return '';
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'Bring this' : 'Recommended loadout')}</h5><ul class="step-extra__list">${rows.join('')}</ul></div>`;
    }

    function renderStepModeAdjustments(adjustments){
      const sections = [];
      if(adjustments.hardcore){
        const tacticsText = cleanGuideText(adjustments.hardcore.tactics);
        const tactics = tacticsText ? `<p>${escapeHTML(tacticsText)}</p>` : '';
        const items = Array.isArray(adjustments.hardcore.safety_buffer_items) && adjustments.hardcore.safety_buffer_items.length
          ? `<ul class="step-extra__list">${adjustments.hardcore.safety_buffer_items.map(item => `<li>${escapeHTML(`${item.qty != null ? `${item.qty}× ` : ''}${niceName(item.item_id || item.itemId || '')}`)}</li>`).join('')}</ul>`
          : '';
        sections.push(`<div class="step-mode__entry"><h6>${escapeHTML(kidMode ? 'Hardcore tip' : 'Hardcore')}</h6>${tactics}${items}</div>`);
      }
      if(adjustments.coop){
        const roles = Array.isArray(adjustments.coop.role_splits) && adjustments.coop.role_splits.length
          ? `<ul class="step-extra__list">${adjustments.coop.role_splits.map(role => {
              const label = capitalize(role.role || 'Role');
              const tasks = cleanGuideText(role.tasks);
              return `<li><strong>${escapeHTML(label)}:</strong> ${escapeHTML(tasks)}</li>`;
            }).join('')}</ul>`
          : '';
        const lootRules = cleanGuideText(adjustments.coop.loot_rules);
        const loot = lootRules ? `<p>${escapeHTML(lootRules)}</p>` : '';
        sections.push(`<div class="step-mode__entry"><h6>${escapeHTML(kidMode ? 'Play together' : 'Co-Op')}</h6>${roles}${loot}</div>`);
      }
      if(!sections.length) return '';
      return `<div class="step-extra__section step-mode"><h5>${escapeHTML(kidMode ? 'Mode tweaks' : 'Mode adjustments')}</h5>${sections.join('')}</div>`;
    }

    function renderStepOutputs(outputs){
      const parts = [];
      if(Array.isArray(outputs.items) && outputs.items.length){
        parts.push(`${escapeHTML(kidMode ? 'Items' : 'Items')}: ${outputs.items.map(item => `${item.qty != null ? `${item.qty}× ` : ''}${niceName(item.item_id || item.itemId || '')}`).join(', ')}`);
      }
      if(Array.isArray(outputs.pals) && outputs.pals.length){
        parts.push(`${escapeHTML(kidMode ? 'Pals' : 'Pals')}: ${outputs.pals.map(niceName).join(', ')}`);
      }
      const unlocks = outputs.unlocks || {};
      if(Array.isArray(unlocks.tech) && unlocks.tech.length){
        parts.push(`${escapeHTML(kidMode ? 'Unlocks' : 'Unlocks')}: ${unlocks.tech.map(niceName).join(', ')}`);
      }
      if(Array.isArray(unlocks.stations) && unlocks.stations.length){
        parts.push(`${escapeHTML(kidMode ? 'Stations' : 'Stations')}: ${unlocks.stations.map(niceName).join(', ')}`);
      }
      if(!parts.length) return '';
      return `<div class="step-extra__section"><h5>${escapeHTML(kidMode ? 'You get' : 'Outputs')}</h5><ul class="step-extra__list">${parts.map(line => `<li>${escapeHTML(line)}</li>`).join('')}</ul></div>`;
    }

    function findRawStep(route, stepId){
      if(!route) return null;
      const rawSteps = Array.isArray(route?.steps) ? route.steps : [];
      return rawSteps.find(entry => entry?.step_id === stepId) || null;
    }

    function isRouteComplete(route){
      if(!route) return false;
      const steps = Array.isArray(route?.chapter?.steps) ? route.chapter.steps : [];
      if(!steps.length) return false;
      const requiredSteps = steps.filter(step => !step.optional);
      const targetSteps = requiredSteps.length ? requiredSteps : steps;
      return targetSteps.every(step => routeState[step.id]);
    }
    async function handleRouteCheckboxChange(event){
      const target = event.target;
      if(!target.matches('input[type="checkbox"][data-step]')) return;
      const stepId = target.dataset.step;
      const isChecked = target.checked;
      const container = target.closest('[data-chapter-id]');
      let chapter = null;
      let step = null;
      let chapterId = container ? container.dataset.chapterId : '';
      if(!chapterId){
        const legacySection = target.closest('section.card');
        if(legacySection){
          chapterId = legacySection.dataset.chapterId || legacySection.id.replace('chapter-','');
        }
      }
      if(chapterId){
        chapter = (routeGuideData?.chapters || []).find(ch => ch.id === chapterId) || null;
        if(chapter){
          step = (chapter.steps || []).find(s => s.id === stepId) || null;
        }
      }
      const stepLabel = target.closest('label.step');
      const anchorRect = stepLabel ? { top: stepLabel.getBoundingClientRect().top } : null;
      const shouldRestoreFocus = document.activeElement === target;
      const previousScrollTop = getScrollTop();
      if(isChecked && step){
        const options = buildStepProgressOptions(step);
        if(options.length > 1){
          const selection = await showStepChoiceDialog(step, options);
          if(selection === null){
            target.checked = false;
            return;
          }
          applyStepProgressSelection(options, selection);
        } else if(options.length === 1){
          applyStepProgressSelection(options, [options[0].key]);
        }
      }
      routeState[stepId] = isChecked;
      syncRouteCompletionMetadata();
      saveRouteState(routeState);
      if(chapter){
        rerenderChapter(chapter, {
          focusStepId: stepId,
          previousScrollTop,
          anchorRect,
          restoreFocus: shouldRestoreFocus
        });
      } else {
        restoreScrollPosition(previousScrollTop);
      }
      refreshRouteIntelligenceUI();
      updateProgressUI();
    }

    function handleRouteClick(event){
      const link = event.target.closest('[data-link]');
      if(link){
        const payload = JSON.parse(link.dataset.link);
        navigateLink(payload);
        event.preventDefault();
        return;
      }
      const btn = event.target.closest('button[data-action]');
      if(!btn) return;
      const action = btn.dataset.action;
      const relatedChapterId = btn.dataset.ch || btn.dataset.routeId || btn.dataset.route || '';
      const chapter = (routeGuideData?.chapters || []).find(ch => ch.id === relatedChapterId) || null;
      if(action === 'previewRoute'){
        const routeId = btn.dataset.routeId || btn.dataset.route;
        if(routeId){
          openRoutePreviewById(routeId);
        }
        event.preventDefault();
        return;
      }
      if(action === 'activateRoute'){
        const routeId = btn.dataset.routeId || btn.dataset.route;
        if(routeId){
          addActiveRoute(routeId);
          playSound(clickSound);
          if(chapter){
            rerenderChapter(chapter);
          }
        }
        event.preventDefault();
        return;
      }
      if(action === 'deactivateRoute'){
        const routeId = btn.dataset.routeId || btn.dataset.route;
        if(routeId){
          removeActiveRoute(routeId);
          playSound(clickSound);
          if(chapter){
            rerenderChapter(chapter);
          }
        }
        event.preventDefault();
        return;
      }
      if(!chapter) return;
      if(action === 'markRequired'){
        chapter.steps.filter(step => !step.optional).forEach(step => {
          routeState[step.id] = true;
          const options = buildStepProgressOptions(step);
          if(options.length === 1){
            applyStepProgressSelection(options, [options[0].key]);
          }
        });
        syncRouteCompletionMetadata();
        saveRouteState(routeState);
        rerenderChapter(chapter);
        refreshRouteIntelligenceUI();
        updateProgressUI();
      } else if(action === 'resetChapter'){
        chapter.steps.forEach(step => {
          delete routeState[step.id];
        });
        syncRouteCompletionMetadata();
        saveRouteState(routeState);
        rerenderChapter(chapter);
        refreshRouteIntelligenceUI();
        updateProgressUI();
      }
    }

    function renderSteps(chapter, route){
      const fragments = [];
      const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
      steps.forEach(step => {
        if(routeHideOptional && step.optional) return;
        const category = step.category || 'Task';
        const categorySlug = routeCategorySlug(category);
        if(routeHiddenCategories.has(categorySlug)) return;
        const checked = !!routeState[step.id];
        const optionalHint = step.optional ? ` <em>(${escapeHTML(kidMode ? 'Bonus' : 'Optional')})</em>` : '';
        const detailHtml = renderStepDetail(step, route);
        const linksHtml = renderLinks(step.links || []);
        const detailBlock = detailHtml ? `\n              ${detailHtml}` : '';
        const linksBlock = linksHtml ? `\n              ${linksHtml}` : '';
        fragments.push(`
          <label class="step${step.optional ? ' optional' : ''}${checked ? ' step--checked' : ''}">
            <input type="checkbox" data-step="${step.id}" ${checked ? 'checked' : ''} />
            <div class="step-content">
              <div class="step-header">
                <span class="step-category step-category--${categorySlug}">${escapeHTML(category)}</span>
                <span class="step-text">${escapeHTML(routeStepText(step))}${optionalHint}</span>
              </div>${linksBlock}${detailBlock}
            </div>
          </label>
        `);
      });
      if(!fragments.length){
        return '<p class="route-steps-empty">' + escapeHTML(kidMode ? 'All steps hidden by filters.' : 'All steps hidden by filters.') + '</p>';
      }
      return `<div class="step-list">${fragments.join('')}</div>`;
    }

    function getScrollTop(){
      if(typeof window === 'undefined') return 0;
      if(typeof window.scrollY === 'number') return window.scrollY;
      const doc = document.documentElement || document.body;
      return doc && typeof doc.scrollTop === 'number' ? doc.scrollTop : 0;
    }

    function restoreScrollPosition(scrollTop){
      if(typeof window === 'undefined') return;
      if(typeof scrollTop !== 'number' || Number.isNaN(scrollTop)) return;
      window.scrollTo(0, scrollTop);
    }

    function focusElement(element){
      if(!element || typeof element.focus !== 'function') return;
      try {
        element.focus({ preventScroll: true });
      } catch (error) {
        element.focus();
      }
    }

    function cssEscape(value){
      if(typeof value !== 'string') return '';
      if(typeof CSS !== 'undefined' && typeof CSS.escape === 'function'){
        return CSS.escape(value);
      }
      return value.replace(/(["\\])/g, '\\$1');
    }

    function renderRouteFiltersUI(categories){
      const containers = document.querySelectorAll('[data-route-role="filters"]');
      if(!containers.length) return;
      const headingLabel = kidMode ? 'Step types:' : 'Step categories:';
      const showAllLabel = kidMode ? 'Show every step type' : 'Show all categories';
      containers.forEach(container => {
        if(!Array.isArray(categories) || !categories.length){
          container.innerHTML = `<p class="route-filters__empty">${kidMode ? 'Step categories will appear once the guide loads.' : 'Step categories will appear once the guide loads.'}</p>`;
          return;
        }
        const chips = categories.map(cat => {
          const slug = cat.slug;
          const label = cat.label || niceName(slug);
          const total = cat.total || 0;
          const complete = cat.complete || 0;
          const active = !routeHiddenCategories.has(slug);
          const ariaLabel = `${label}: ${complete} of ${total} steps complete`;
          return `
            <button type="button" class="chip route-filter${active ? '' : ' route-filter--inactive'}" data-category="${slug}" aria-pressed="${active}" aria-label="${escapeHTML(ariaLabel)}">
              <span class="route-filter__label">${escapeHTML(label)}</span>
              <span class="route-filter__count">${complete}/${total}</span>
            </button>
          `;
        }).join('');
        const resetButton = routeHiddenCategories.size
          ? `<button type="button" class="home-progress-link route-filters__reset" data-action="route-filters-reset">${escapeHTML(showAllLabel)}</button>`
          : '';
        container.innerHTML = `
          <div class="route-filters__header">
            <span class="route-filters__label">${escapeHTML(headingLabel)}</span>
            ${resetButton}
          </div>
          <div class="route-filters__chips">
            ${chips}
          </div>
        `;
        if(!container.dataset.bound){
          container.addEventListener('click', handleRouteFilterClick);
          container.dataset.bound = 'true';
        }
      });
    }

    function renderBossRouteTimeline(){
      const timeline = document.getElementById('progressBossTimeline');
      if(!timeline) return;
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      const bosses = [];
      chapters.forEach((chapter, index) => {
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const bossStep = steps.find(step => step && step.category === 'Boss');
        if(!bossStep) return;
        const towerLink = (bossStep.links || []).find(link => link && link.type === 'tower');
        bosses.push({
          order: index + 1,
          chapter,
          step: bossStep,
          map: towerLink && towerLink.map ? towerLink.map : null
        });
      });
      if(!bosses.length){
        timeline.innerHTML = '<p class="progress-route__empty">Boss route data loading…</p>';
        return;
      }
      let nextAssigned = false;
      const cards = bosses.map(entry => {
        const { order, chapter, step, map } = entry;
        const complete = !!routeState[step.id];
        let status = 'upcoming';
        if(complete){
          status = 'complete';
        } else if(!nextAssigned){
          status = 'next';
          nextAssigned = true;
        }
        const title = map?.label || map?.title || routeChapterTitle(chapter) || `Tower ${order}`;
        const weakness = extractBossWeakness(step);
        const region = map?.region || '';
        const metaParts = [];
        if(region) metaParts.push(region);
        if(weakness) metaParts.push(`${kidMode ? 'Weak to' : 'Weakness'}: ${weakness}`);
        const metaLine = metaParts.length ? metaParts.join(' • ') : '';
        const copySourceKid = Array.isArray(map?.kid) && map.kid.length ? map.kid[0] : (step.textKid || step.text || '');
        const copySourceGrown = Array.isArray(map?.grown) && map.grown.length ? map.grown[0] : (step.text || step.textKid || '');
        const copy = kidMode ? copySourceKid : copySourceGrown;
        const statusLabel = status === 'complete'
          ? (kidMode ? 'Complete' : 'Complete')
          : status === 'next'
            ? (kidMode ? 'Next up' : 'Next')
            : (kidMode ? 'Upcoming' : 'Planned');
        return `
          <article class="progress-route__boss progress-route__boss--${status}">
            <div class="progress-route__boss-head">
              <span class="progress-route__boss-index">Tower ${order}</span>
              <div class="progress-route__boss-body">
                <h4>${escapeHTML(title)}</h4>
                ${metaLine ? `<p>${escapeHTML(metaLine)}</p>` : ''}
              </div>
              <span class="progress-route__boss-status">${escapeHTML(statusLabel)}</span>
            </div>
            <p class="progress-route__boss-copy">${escapeHTML(copy)}</p>
          </article>
        `;
      }).join('');
      timeline.innerHTML = cards;
    }

    function extractBossWeakness(step){
      if(!step) return '';
      const adult = step.text || '';
      const match = adult.match(/\(weak to ([^)]+)\)/i);
      if(match && match[1]){
        return match[1].trim();
      }
      return '';
    }

    function handleRouteFilterClick(event){
      const reset = event.target.closest('[data-action="route-filters-reset"]');
      if(reset){
        if(routeHiddenCategories.size){
          routeHiddenCategories.clear();
          persistRoutePreferences();
          const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
          chapters.forEach(ch => rerenderChapter(ch));
          refreshRouteIntelligenceUI({ skipActiveList: true });
        }
        return;
      }
      const btn = event.target.closest('button[data-category]');
      if(!btn) return;
      const slug = btn.dataset.category;
      if(!slug) return;
      const isActive = btn.getAttribute('aria-pressed') !== 'false';
      if(isActive){
        routeHiddenCategories.add(slug);
      } else {
        routeHiddenCategories.delete(slug);
      }
      persistRoutePreferences();
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      chapters.forEach(ch => rerenderChapter(ch));
      refreshRouteIntelligenceUI({ skipActiveList: true });
    }

    function buildStepProgressOptions(step){
      if(!step || !Array.isArray(step.links)) return [];
      const options = [];
      const seen = new Set();
      step.links.forEach(link => {
        if(!link || !link.type) return;
        if(link.type === 'pal'){
          const palId = resolvePalIdFromLink(link);
          if(palId !== undefined && palId !== null){
            const key = `pal:${palId}`;
            if(!seen.has(key)){
              seen.add(key);
              const pal = PALS[palId];
              const labelSource = link.name || link.slug || link.id;
              options.push({
                key,
                type: 'pal',
                palId,
                label: pal ? pal.name : (labelSource ? niceName(labelSource) : 'Pal'),
                selected: !!caught[palId]
              });
            }
          }
        } else if(link.type === 'tech'){
          const techInfo = resolveTechFromLink(link);
          if(techInfo && techInfo.item){
            const key = `tech:${techInfo.slug}`;
            if(!seen.has(key)){
              seen.add(key);
              const rawName = techInfo.item.name || link.name || link.id;
              const techName = rawName ? String(rawName) : '';
              const label = rawName ? String(rawName) : 'Tech';
              options.push({
                key,
                type: 'tech',
                slug: techInfo.slug,
                techName,
                label,
                selected: techName ? !!unlocked[techName] : false
              });
            }
          }
        }
      });
      return options;
    }

    function resolvePalIdFromLink(link){
      if(!link) return null;
      if(link.id && PALS[link.id]) return link.id;
      const candidates = [link.slug, link.id, link.name];
      for(const cand of candidates){
        if(!cand) continue;
        const slug = slugifyForPalworld(String(cand));
        if(slug && PAL_SLUG_TO_ID[slug]) return PAL_SLUG_TO_ID[slug];
        const byName = PAL_NAME_TO_ID[capitalize(String(cand))];
        if(byName) return byName;
      }
      return null;
    }

    function resolveTechFromLink(link){
      if(!link) return null;
      const identifiers = [link.id, link.slug, link.name];
      for(const ident of identifiers){
        if(!ident) continue;
        const slug = slugifyForPalworld(String(ident));
        if(slug && TECH_LOOKUP[slug]){
          return { ...TECH_LOOKUP[slug], slug };
        }
      }
      return null;
    }

    function applyStepProgressSelection(options, selectedKeys){
      if(!Array.isArray(options) || !options.length) return false;
      const selected = new Set(selectedKeys || []);
      let caughtChanged = false;
      let techChanged = false;
      options.forEach(option => {
        const isSelected = selected.has(option.key);
        if(option.type === 'pal' && option.palId !== undefined && option.palId !== null){
          const current = !!caught[option.palId];
          if(current !== isSelected){
            setPalCaught(option.palId, isSelected, { silent: true, skipAutoComplete: true, deferProgressUpdate: true });
            caughtChanged = true;
          }
        } else if(option.type === 'tech'){
          const techName = option.techName;
          if(techName){
            const current = !!unlocked[techName];
            if(current !== isSelected){
              setTechUnlocked(techName, isSelected, { techKey: option.slug, silent: true, skipAutoComplete: true, deferProgressUpdate: true });
              techChanged = true;
            } else if(option.slug){
              syncTechButtons(option.slug, techName);
            }
          } else if(option.slug){
            syncTechButtons(option.slug, techName);
          }
        }
      });
      return caughtChanged || techChanged;
    }

    function autoCompleteRouteStepsForPal(palId){
      if(palId === undefined || palId === null) return;
      autoCompleteRouteSteps({ type: 'pal', palId });
    }

    function autoCompleteRouteStepsForTech(rawKey, techName){
      const slugSource = rawKey || techName;
      if(!slugSource && !techName) return;
      const slug = slugifyForPalworld(slugSource || '');
      const name = typeof techName === 'string' ? techName.toLowerCase() : '';
      autoCompleteRouteSteps({ type: 'tech', slug, name });
    }

    function autoCompleteRouteSteps(change){
      if(!change) return;
      ensureRouteGuide()
        .then(guide => {
          const chapters = Array.isArray(guide?.chapters) ? guide.chapters : [];
          if(!chapters.length) return;
          routeState = loadRouteState();
          const rerenderIds = new Set();
          let stateChanged = false;

          chapters.forEach(chapter => {
            const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
            steps.forEach(step => {
              if(!step || !step.id) return;
              const options = buildStepProgressOptions(step);
              if(!Array.isArray(options) || !options.length) return;
              const matches = options.some(option => {
                if(change.type === 'pal'){
                  return option.type === 'pal' && option.palId === change.palId;
                }
                if(change.type === 'tech'){
                  if(option.type !== 'tech') return false;
                  const slugMatch = change.slug && option.slug === change.slug;
                  const nameMatch = change.name && option.techName && option.techName.toLowerCase() === change.name;
                  return slugMatch || nameMatch;
                }
                return false;
              });
              if(!matches) return;
              if(shouldAutoCompleteStep(step, options) && !routeState[step.id]){
                routeState[step.id] = true;
                stateChanged = true;
                rerenderIds.add(chapter.id);
              }
            });
          });

          if(stateChanged){
            saveRouteState(routeState);
            rerenderIds.forEach(id => {
              const chapter = chapters.find(ch => ch.id === id);
              if(chapter) rerenderChapter(chapter);
            });
            updateProgressUI();
          }
        })
        .catch(err => {
          console.error('Failed to auto-sync route progress', err);
        });
    }

    function shouldAutoCompleteStep(step, options){
      if(!step || !Array.isArray(options) || !options.length) return false;
      const relevant = options.filter(option => option.type === 'pal' || option.type === 'tech');
      if(!relevant.length) return false;
      const satisfiedCount = relevant.filter(optionIsComplete).length;
      if(satisfiedCount === 0) return false;
      if(stepRequiresAllOptions(step, relevant)){
        return satisfiedCount === relevant.length;
      }
      return true;
    }

    function stepRequiresAllOptions(step, options){
      if(!Array.isArray(options) || options.length <= 1) return true;
      const samples = [];
      if(typeof step.text === 'string') samples.push(step.text);
      if(typeof step.textKid === 'string') samples.push(step.textKid);
      if(typeof step.textAdult === 'string') samples.push(step.textAdult);
      const orPattern = /\b(or|either)\b/i;
      return !samples.some(sample => orPattern.test(sample));
    }

    function optionIsComplete(option){
      if(!option) return false;
      if(option.type === 'pal'){
        return option.palId !== undefined && option.palId !== null && !!caught[option.palId];
      }
      if(option.type === 'tech'){
        if(option.techName){
          const direct = unlocked[option.techName];
          if(direct) return true;
          const normalized = option.techName.toLowerCase();
          if(normalized){
            const match = Object.keys(unlocked || {}).some(key => {
              return unlocked[key] && typeof key === 'string' && key.toLowerCase() === normalized;
            });
            if(match) return true;
          }
        }
        if(option.slug){
          const entry = TECH_LOOKUP && TECH_LOOKUP[option.slug];
          const itemName = entry?.item?.name;
          if(itemName && unlocked[itemName]) return true;
        }
      }
      return false;
    }

    function showStepChoiceDialog(step, options){
      return new Promise(resolve => {
        if(!Array.isArray(options) || !options.length){
          resolve([]);
          return;
        }
        const overlay = document.createElement('div');
        overlay.className = 'progress-choice-backdrop';
        const dialog = document.createElement('div');
        dialog.className = 'progress-choice-dialog';
        const heading = document.createElement('h3');
        heading.textContent = kidMode ? 'Pick what you finished' : 'Track this step';
        dialog.appendChild(heading);
        if(step && step.text){
          const stepLine = document.createElement('p');
          stepLine.textContent = step.text;
          stepLine.style.fontStyle = 'italic';
          stepLine.style.color = 'var(--light)';
          dialog.appendChild(stepLine);
        }
        const desc = document.createElement('p');
        desc.textContent = kidMode
          ? 'Choose the pals or inventions you just completed. Uncheck anything you skipped.'
          : 'Select which pals or tech you completed. Uncheck anything you skipped.';
        dialog.appendChild(desc);
        const list = document.createElement('div');
        list.className = 'progress-choice-options';
        const checkboxes = [];
        options.forEach(option => {
          const row = document.createElement('label');
          row.className = 'progress-choice-option';
          const input = document.createElement('input');
          input.type = 'checkbox';
          input.value = option.key;
          input.checked = !!option.selected;
          row.appendChild(input);
          const text = document.createElement('span');
          text.textContent = option.label;
          row.appendChild(text);
          list.appendChild(row);
          checkboxes.push(input);
        });
        dialog.appendChild(list);
        if(options.length > 1){
          const helpers = document.createElement('div');
          helpers.className = 'progress-choice-helpers';
          const selectAllBtn = document.createElement('button');
          selectAllBtn.type = 'button';
          selectAllBtn.className = 'btn';
          selectAllBtn.textContent = kidMode ? 'Select everything' : 'Select all';
          selectAllBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = true;
            });
          });
          const clearBtn = document.createElement('button');
          clearBtn.type = 'button';
          clearBtn.className = 'btn';
          clearBtn.textContent = kidMode ? 'Clear choices' : 'Clear';
          clearBtn.addEventListener('click', () => {
            checkboxes.forEach(cb => {
              cb.checked = false;
            });
          });
          helpers.appendChild(selectAllBtn);
          helpers.appendChild(clearBtn);
          dialog.appendChild(helpers);
        }
        const actions = document.createElement('div');
        actions.className = 'progress-choice-actions';
        const cancelBtn = document.createElement('button');
        cancelBtn.type = 'button';
        cancelBtn.className = 'btn';
        cancelBtn.textContent = kidMode ? 'Go back' : 'Cancel';
        const saveBtn = document.createElement('button');
        saveBtn.type = 'button';
        saveBtn.className = 'btn';
        saveBtn.textContent = kidMode ? 'All done!' : 'Save choices';
        actions.appendChild(cancelBtn);
        actions.appendChild(saveBtn);
        dialog.appendChild(actions);
        overlay.appendChild(dialog);
        overlay.addEventListener('click', (ev) => {
          if(ev.target === overlay){
            cleanup(null);
          }
        });
        const cleanup = (result) => {
          overlay.remove();
          document.removeEventListener('keydown', onKeydown);
          resolve(result);
        };
        cancelBtn.addEventListener('click', () => cleanup(null));
        saveBtn.addEventListener('click', () => {
          const selectedValues = checkboxes.filter(cb => cb.checked).map(cb => cb.value);
          cleanup(selectedValues);
        });
        const onKeydown = (ev) => {
          if(ev.key === 'Escape'){
            ev.preventDefault();
            cleanup(null);
          }
          if(ev.key === 'Enter' && ev.target && ev.target.tagName !== 'TEXTAREA'){
            ev.preventDefault();
            saveBtn.click();
          }
        };
        document.addEventListener('keydown', onKeydown);
        document.body.appendChild(overlay);
        setTimeout(() => {
          if(checkboxes.length){
            checkboxes[0].focus();
          } else {
            saveBtn.focus();
          }
        }, 0);
      });
    }

    function chapterProgress(chapter){
      const required = (chapter.steps || []).filter(step => !step.optional);
      const requiredChecked = required.filter(step => routeState[step.id]).length;
      return {
        requiredCount: required.length,
        requiredChecked,
        requiredDone: required.length > 0 && requiredChecked === required.length
      };
    }

    function renderProgress(progress){
      const pct = progress.requiredCount ? Math.round((progress.requiredChecked / progress.requiredCount) * 100) : 0;
      const label = kidMode
        ? `${progress.requiredChecked}/${progress.requiredCount} steps done (${pct}%)`
        : `${progress.requiredChecked}/${progress.requiredCount} required done (${pct}%)`;
      return `
        <div class="progress" aria-label="Chapter progress" style="display:grid;gap:6px">
          <div style="height:10px;border-radius:999px;background:#22314A;overflow:hidden">
            <div style="height:10px;width:${pct}%;background:var(--accent)"></div>
          </div>
          <div style="font-size:.9rem;color:var(--muted)">${label}</div>
        </div>
      `;
    }

    function calculateGuideProgressSummary(chaptersOverride){
      const chapters = Array.isArray(chaptersOverride)
        ? chaptersOverride
        : (Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : []);
      const routeLookup = routeGuideData?.routeLookup || {};
      let requiredTotal = 0;
      let requiredComplete = 0;
      let optionalTotal = 0;
      let optionalComplete = 0;
      let bossesTotal = 0;
      let bossesComplete = 0;
      let questsTotal = 0;
      let questsComplete = 0;
      const routesByRole = {
        core: { total: 0, complete: 0 },
        support: { total: 0, complete: 0 },
        optional: { total: 0, complete: 0 }
      };
      const categoryMap = new Map();
      chapters.forEach(chapter => {
        const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
        const route = routeLookup[chapter?.id];
        const role = normalizeRouteRole(route?.progression_role || route?.progression_role_raw);
        const roleKey = routesByRole[role] ? role : 'optional';
        routesByRole[roleKey].total += 1;
        if(route && isRouteComplete(route)){
          routesByRole[roleKey].complete += 1;
        }
        steps.forEach(step => {
          if(!step || !step.id) return;
          const slug = routeCategorySlug(step.category);
          if(!categoryMap.has(slug)){
            categoryMap.set(slug, {
              slug,
              label: step.category || 'Task',
              total: 0,
              complete: 0,
              optional: 0,
              optionalComplete: 0
            });
          }
          const catStats = categoryMap.get(slug);
          catStats.total += 1;
          if(routeState[step.id]){
            catStats.complete += 1;
          }
          if(step.optional){
            optionalTotal += 1;
            catStats.optional += 1;
            if(routeState[step.id]){
              optionalComplete += 1;
              catStats.optionalComplete += 1;
            }
          } else {
            requiredTotal += 1;
            if(routeState[step.id]){
              requiredComplete += 1;
            }
          }
          if(step.category === 'Boss'){
            bossesTotal += 1;
            if(routeState[step.id]) bossesComplete += 1;
          }
          if(step.category === 'Quest'){
            questsTotal += 1;
            if(routeState[step.id]) questsComplete += 1;
          }
        });
      });
      const percent = requiredTotal ? Math.round((requiredComplete / requiredTotal) * 100) : 0;
      const categories = Array.from(categoryMap.values())
        .sort((a, b) => a.label.localeCompare(b.label, undefined, { sensitivity: 'base' }));
      return {
        requiredTotal,
        requiredComplete,
        optionalTotal,
        optionalComplete,
        bossesTotal,
        bossesComplete,
        questsTotal,
        questsComplete,
        percent,
        categories,
        routes: routesByRole
      };
    }

    function updateRouteOverviewUI(summaryOverride){
      const summary = summaryOverride || calculateGuideProgressSummary();
      const requiredPct = summary.requiredTotal
        ? Math.round((summary.requiredComplete / summary.requiredTotal) * 100)
        : 0;
      const optionalPct = summary.optionalTotal
        ? Math.round((summary.optionalComplete / summary.optionalTotal) * 100)
        : 0;
      const bossesPct = summary.bossesTotal
        ? Math.round((summary.bossesComplete / summary.bossesTotal) * 100)
        : 0;
      const questsPct = summary.questsTotal
        ? Math.round((summary.questsComplete / summary.questsTotal) * 100)
        : 0;
      const condensedProgress = summary.requiredTotal
        ? `${summary.requiredComplete}/${summary.requiredTotal} ${kidMode ? 'big steps done' : 'required complete'}`
        : (kidMode ? 'No adventures tracked yet' : 'No routes tracked yet');

      document.querySelectorAll('[data-route-role="snapshot-progress"]').forEach(el => {
        el.textContent = condensedProgress;
      });

      document.querySelectorAll('[data-route-role="required-title"]').forEach(el => {
        el.textContent = kidMode ? 'Big steps' : 'Required steps';
      });
      document.querySelectorAll('[data-route-role="optional-title"]').forEach(el => {
        el.textContent = kidMode ? 'Bonus ideas' : 'Optional tasks';
      });
      document.querySelectorAll('[data-route-role="boss-title"]').forEach(el => {
        el.textContent = kidMode ? 'Boss wins' : 'Bosses defeated';
      });
      document.querySelectorAll('[data-route-role="quest-title"]').forEach(el => {
        el.textContent = kidMode ? 'Story quests' : 'Story & optional quests';
      });

      document.querySelectorAll('[data-route-role="required-count"]').forEach(el => {
        el.textContent = summary.requiredTotal
          ? `${summary.requiredComplete}/${summary.requiredTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="required-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(requiredPct));
      });
      document.querySelectorAll('[data-route-role="required-fill"]').forEach(el => {
        el.style.width = `${requiredPct}%`;
      });
      document.querySelectorAll('[data-route-role="required-note"]').forEach(el => {
        if(summary.requiredTotal){
          const remaining = summary.requiredTotal - summary.requiredComplete;
          const coreRoutes = summary.routes?.core || { total: 0, complete: 0 };
          const routesRemaining = coreRoutes.total ? coreRoutes.total - coreRoutes.complete : 0;
          if(remaining === 0){
            if(routesRemaining === 0){
              el.textContent = kidMode
                ? 'All big steps complete!'
                : 'All required steps complete.';
            } else {
              const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
              el.textContent = kidMode
                ? `${routesRemaining} ${routeLabel} left`
                : `${routesRemaining} ${routeLabel} remaining`;
            }
          } else {
            const stepLabel = remaining === 1 ? (kidMode ? 'big step' : 'required step') : (kidMode ? 'big steps' : 'required steps');
            if(routesRemaining > 0){
              const routeLabel = routesRemaining === 1 ? (kidMode ? 'adventure' : 'core route') : (kidMode ? 'adventures' : 'core routes');
              el.textContent = kidMode
                ? `${routesRemaining} ${routeLabel} • ${remaining} ${stepLabel} left`
                : `${routesRemaining} ${routeLabel} • ${remaining} ${stepLabel} remaining`;
            } else {
              el.textContent = kidMode
                ? `${remaining} ${stepLabel} left`
                : `${remaining} ${stepLabel} remaining`;
            }
          }
        } else {
          el.textContent = kidMode ? 'Main path goals' : 'Main path objectives';
        }
      });

      document.querySelectorAll('[data-route-role="optional-count"]').forEach(el => {
        el.textContent = summary.optionalTotal
          ? `${summary.optionalComplete}/${summary.optionalTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="optional-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(optionalPct));
      });
      document.querySelectorAll('[data-route-role="optional-fill"]').forEach(el => {
        el.style.width = `${optionalPct}%`;
      });
      document.querySelectorAll('[data-route-role="optional-note"]').forEach(el => {
        if(summary.optionalTotal){
          const remainingOptional = summary.optionalTotal - summary.optionalComplete;
          if(remainingOptional === 0){
            el.textContent = kidMode
              ? 'Bonus adventures wrapped!'
              : 'All optional tasks completed.';
          } else {
            el.textContent = kidMode
              ? `${remainingOptional} bonus step${remainingOptional === 1 ? '' : 's'} to try`
              : `${remainingOptional} optional step${remainingOptional === 1 ? '' : 's'} remaining`;
          }
        } else {
          el.textContent = kidMode ? 'Extra fun chores' : 'Bonus cleanup and prep';
        }
      });

      document.querySelectorAll('[data-route-role="boss-count"]').forEach(el => {
        el.textContent = summary.bossesTotal
          ? `${summary.bossesComplete}/${summary.bossesTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="boss-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(bossesPct));
      });
      document.querySelectorAll('[data-route-role="boss-fill"]').forEach(el => {
        el.style.width = `${bossesPct}%`;
      });
      document.querySelectorAll('[data-route-role="boss-note"]').forEach(el => {
        if(summary.bossesTotal){
          const remainingBosses = summary.bossesTotal - summary.bossesComplete;
          if(remainingBosses === 0){
            el.textContent = kidMode
              ? 'Every boss champion beaten!'
              : 'All campaign bosses defeated.';
          } else {
            el.textContent = kidMode
              ? `${remainingBosses} boss${remainingBosses === 1 ? '' : 'es'} left`
              : `${remainingBosses} boss${remainingBosses === 1 ? '' : 'es'} remaining`;
          }
        } else {
          el.textContent = kidMode ? 'Defeat bosses together' : 'Boss progress will appear here';
        }
      });
      document.querySelectorAll('[data-route-role="quest-count"]').forEach(el => {
        el.textContent = summary.questsTotal
          ? `${summary.questsComplete}/${summary.questsTotal}`
          : '0/0';
      });
      document.querySelectorAll('[data-route-role="quest-meter"]').forEach(el => {
        el.setAttribute('aria-valuenow', String(questsPct));
      });
      document.querySelectorAll('[data-route-role="quest-fill"]').forEach(el => {
        el.style.width = `${questsPct}%`;
      });
      document.querySelectorAll('[data-route-role="quest-note"]').forEach(el => {
        if(summary.questsTotal){
          const remainingQuests = summary.questsTotal - summary.questsComplete;
          if(remainingQuests === 0){
            el.textContent = kidMode
              ? 'Every story quest wrapped!'
              : 'All story and optional quests complete.';
          } else {
            el.textContent = kidMode
              ? `${remainingQuests} quest${remainingQuests === 1 ? '' : 's'} to finish`
              : `${remainingQuests} story or optional quest${remainingQuests === 1 ? '' : 's'} remaining`;
          }
        } else {
          el.textContent = kidMode ? 'Story & bonus quests show here' : 'Story and optional quest progress appears here';
        }
      });

      const nextRequired = findNextRouteStep();
      const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });

      document.querySelectorAll('[data-route-role="next-callout"]').forEach(el => {
        if(nextAny && nextAny.step){
          const isOptional = nextAny.step.optional && !nextRequired;
          const prefix = isOptional
            ? (kidMode ? 'Bonus idea:' : 'Optional focus:')
            : (kidMode ? 'Next big step:' : 'Next priority:');
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopy = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const chapterHtml = chapterTitle
            ? ` <span class="route-overview__next-chapter">(${escapeHTML(chapterTitle)})</span>`
            : '';
          el.innerHTML = `<strong>${escapeHTML(prefix)}</strong> ${escapeHTML(stepCopy)}${chapterHtml}`;
        } else {
          el.innerHTML = kidMode
            ? '<strong>Guide complete!</strong> Revisit bonus adventures anytime.'
            : '<strong>Guide complete!</strong> Re-run boss fights or tidy up optional chores.';
        }
      });

      const lastMeta = getLastCompletedRouteMeta();
      document.querySelectorAll('[data-route-role="last-completed"]').forEach(el => {
        if(lastMeta){
          const title = lastMeta.title || niceName(lastMeta.id);
          const dateLabel = lastMeta.completedAt ? formatGuideCompletionDate(lastMeta.completedAt) : '';
          if(kidMode){
            el.textContent = dateLabel ? `Finished ${title} (${dateLabel})` : `Finished ${title}`;
          } else {
            el.textContent = dateLabel ? `Last cleared: ${title} — ${dateLabel}` : `Last cleared: ${title}`;
          }
        } else {
          el.textContent = kidMode ? 'No routes completed yet.' : 'No routes completed yet.';
        }
      });

      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        const targetStep = nextAny && nextAny.step ? nextAny.step.id : '';
        btn.dataset.stepId = targetStep || '';
        if(targetStep){
          btn.disabled = false;
          btn.textContent = nextRequired
            ? (kidMode ? 'Jump to next step' : 'Jump to next required')
            : (kidMode ? 'Jump to bonus step' : 'Jump to optional step');
        } else {
          btn.disabled = true;
          btn.textContent = kidMode ? 'All steps done!' : 'All steps complete';
        }
      });

      updateRouteToggleButtons();

      const summarySlugs = new Set(summary.categories.map(cat => cat.slug));
      const currentHidden = Array.from(routeHiddenCategories);
      const trimmed = currentHidden.filter(slug => summarySlugs.has(slug));
      if(trimmed.length !== currentHidden.length){
        routeHiddenCategories = new Set(trimmed);
        persistRoutePreferences();
      }
      renderRouteFiltersUI(summary.categories);
      renderBossRouteTimeline();
      applyRouteOverviewCollapseState();
    }

    function findNextRouteStep(options = {}){
      const includeOptional = !!options.includeOptional;
      const chapters = Array.isArray(routeGuideData?.chapters) ? routeGuideData.chapters : [];
      for(const chapter of chapters){
        const steps = Array.isArray(chapter.steps) ? chapter.steps : [];
        for(const step of steps){
          if(step.optional && !includeOptional) continue;
          if(!routeState[step.id]){
            return { chapter, step };
          }
        }
      }
      return null;
    }

    function findNextStepForChapter(chapter, { includeOptional = false } = {}){
      const steps = Array.isArray(chapter?.steps) ? chapter.steps : [];
      for(const step of steps){
        if(step.optional && !includeOptional) continue;
        if(!routeState[step.id]){
          return step;
        }
      }
      return null;
    }

    function findNextPalTarget(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const sorted = palsArray.slice().sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      const next = sorted.find(pal => !caught[pal.id]);
      return next || null;
    }

    function findRandomPalCandidate(){
      const palsArray = Object.values(PALS || {});
      if(!palsArray.length) return null;
      const accessible = palsArray.filter(p => (p.rarity || 0) <= 3);
      const pool = accessible.length ? accessible : palsArray;
      return pool[Math.floor(Math.random() * pool.length)] || null;
    }

    function findNextTechUnlock(){
      const levels = Array.isArray(TECH)
        ? TECH.slice().sort((a, b) => (a?.level || 0) - (b?.level || 0))
        : [];
      for(const level of levels){
        const items = Array.isArray(level?.items) ? level.items : [];
        for(const item of items){
          if(!item || !item.name) continue;
          if(!unlocked[item.name]){
            const techKey = item.id || slugifyForPalworld(item.name);
            return { level, item, techKey };
          }
        }
      }
      return null;
    }

    const STEP_LINK_TYPE_ORDER = { pal: 0, npc: 1, item: 2, tech: 3, location: 4, tower: 5, passive: 6, move: 7, glossary: 8 };

    function renderLinks(links){
      if(!Array.isArray(links) || !links.length) return '';
      const sorted = links.slice().sort((a, b) => {
        const orderA = STEP_LINK_TYPE_ORDER[a?.type] ?? 50;
        const orderB = STEP_LINK_TYPE_ORDER[b?.type] ?? 50;
        if(orderA !== orderB) return orderA - orderB;
        const labelA = linkLabel(a).toLowerCase();
        const labelB = linkLabel(b).toLowerCase();
        return labelA.localeCompare(labelB, undefined, { sensitivity: 'base' });
      });
      const chips = sorted.map(renderLinkChip).join('');
      return `<div class="step-links" role="list">${chips}</div>`;
    }

    function renderLinkChip(link){
      const payload = JSON.stringify(link)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
      const label = linkLabel(link);
      const meta = linkMeta(link);
      const typeAttr = link.type ? ` data-link-type="${escapeHTML(link.type)}"` : '';
      const titleAttr = label ? ` title="${escapeHTML(label)}"` : '';
      const metaHtml = meta ? `<span class="chip__meta">${escapeHTML(meta)}</span>` : '';
      return `<a href="#" class="chip link" data-link="${payload}" role="listitem"${typeAttr}${titleAttr}><span class="chip__body"><span class="chip__label">${escapeHTML(label)}</span>${metaHtml}</span></a>`;
    }

    function linkLabel(link){
      if(link.type === 'pal'){
        const source = link.slug || link.id || link.name;
        return capitalize(source);
      }
      if(link.type === 'npc'){
        if(link.name) return link.name;
        if(link.slug) return niceName(link.slug);
        if(link.id) return niceName(link.id);
        return 'NPC';
      }
      if(link.type === 'item') return niceName(link.id);
      if(link.type === 'passive') return capitalize(link.id);
      if(link.type === 'move') return niceName(link.id);
      if(link.type === 'tech') return niceName(link.id);
      if(link.type === 'glossary') return niceName(link.id);
      if(link.type === 'tower') return niceName(link.id);
      if(link.type === 'location'){
        if(link.name) return link.name;
        if(link.region) return link.region;
        if(Array.isArray(link.coords) && link.coords.length >= 2){
          return `(${link.coords[0]}, ${link.coords[1]})`;
        }
        return 'Location';
      }
      return 'Open';
    }

    function linkMeta(link){
      if(!link || typeof link !== 'object') return '';
      if(link.type === 'item'){
        if(link.quantity != null && !Number.isNaN(Number(link.quantity))){
          return `x${Number(link.quantity)}`;
        }
        return '';
      }
      if(link.type === 'pal'){
        const details = [];
        if(link.role) details.push(niceName(String(link.role)));
        if(link.level != null && !Number.isNaN(Number(link.level))) details.push(`Lv ${Number(link.level)}`);
        const palId = resolvePalIdFromLink(link);
        const pal = palId != null ? PALS?.[palId] : null;
        if(details.length === 0 && pal){
          const primary = getPrimaryType(pal);
          if(primary) details.push(primary);
        }
        return details.join(' • ');
      }
      if(link.type === 'npc'){
        const parts = [];
        if(link.role) parts.push(niceName(String(link.role)));
        if(link.region) parts.push(link.region);
        else if(Array.isArray(link.coords) && link.coords.length >= 2){
          parts.push(`${link.coords[0]}, ${link.coords[1]}`);
        }
        return parts.join(' • ');
      }
      if(link.type === 'tech'){
        const info = resolveTechFromLink(link);
        const item = info?.item;
        const parts = [];
        if(item?.level != null) parts.push(`Lv ${item.level}`);
        if(item?.category) parts.push(niceName(item.category));
        return parts.join(' • ');
      }
      if(link.type === 'location'){
        const parts = [];
        if(link.region) parts.push(link.region);
        if(Array.isArray(link.coords) && link.coords.length >= 2){
          parts.push(`${link.coords[0]}, ${link.coords[1]}`);
        }
        return parts.join(' • ');
      }
      if(link.type === 'tower'){
        if(link.map && link.map.region){
          return link.map.region;
        }
        return '';
      }
      return '';
    }

    function navigateLink(link){
      if(!link) return;
      if(link.type === 'pal'){
        if(window.viewPal){
          window.viewPal(link.slug || link.id);
        } else {
          focusSearch(link.slug || link.id, { target: 'pals' });
        }
      } else if(link.type === 'item'){
        const itemKey = resolveItemKeyFromLink(link);
        if(itemKey && (ITEMS[itemKey] || ITEM_DETAILS[itemKey])){
          openItemDetail(itemKey);
        } else {
          const fallbackTerm = link.name || niceName(link.id || link.slug || '');
          focusSearch(fallbackTerm, { target: 'items' });
        }
      } else if(link.type === 'tech'){
        showTechDetail(link.id);
      } else if(link.type === 'passive'){
        showTraitDetail(capitalize(link.id));
      } else if(link.type === 'move'){
        showSkillDetail(link.id);
      } else if(link.type === 'glossary'){
        showGlossaryDetail(link.id);
      } else if(link.type === 'npc'){
        showNpcDetail(link);
      } else if(link.type === 'location'){
        const map = link.map ? { ...link.map } : {};
        if(!map.coords && Array.isArray(link.coords)){
          map.coords = link.coords.slice(0, 2).map(Number);
        }
        if(!map.entrance && link.entrance){
          map.entrance = link.entrance;
        }
        if(!map.entranceCoords && Array.isArray(link.entranceCoords)){
          map.entranceCoords = link.entranceCoords.slice(0, 2).map(Number);
        }
        if(!map.label && link.name){
          map.label = link.name;
        }
        if(!map.title && link.name){
          map.title = link.name;
        }
        if(!map.region && link.region){
          map.region = link.region;
        }
        const fallbackUrl = link.url || `${PALWORLD_BASE_URL}/map`;
        openRouteMapModal(map, fallbackUrl);
      } else if(link.type === 'tower'){
        openTowerMap(link);
      }
    }

    function showTechDetail(techId){
      if(!techId) return;
      const slug = slugifyForPalworld(String(techId));
      const entry = TECH_LOOKUP[slug];
      const fallbackName = niceName(techId);
      const displayName = entry?.item?.name || fallbackName;
      const techUrl = `${PALWORLD_BASE_URL}/technology-tree?search=${encodeURIComponent(displayName)}`;
      modalBody.innerHTML = '';
      if(!entry){
        const wrap = document.createElement('div');
        wrap.className = 'tech-modal tech-modal--missing';
        const message = document.createElement('p');
        message.textContent = kidMode
          ? 'Palmate does not have details for this blueprint yet. Check Palworld.gg for the latest placement tips.'
          : 'Palmate does not have details for this blueprint yet. Visit Palworld.gg for the current information.';
        wrap.appendChild(message);
        const link = document.createElement('a');
        link.href = techUrl;
        link.target = '_blank';
        link.rel = 'noopener';
        link.className = 'tech-modal__external';
        link.textContent = kidMode ? 'Open Palworld.gg' : 'View on Palworld.gg';
        wrap.appendChild(link);
        modalBody.appendChild(wrap);
        openModal();
        return;
      }
      const { item, level } = entry;
      const techKey = item.id || slug;
      const isUnlocked = !!unlocked[item.name];
      const materials = computeTechMaterials(item);
      const descriptions = computeTechDescriptions(item);
      const branchLabel = getTechBranchLabel(item);
      const detail = document.createElement('article');
      detail.className = 'tech-modal';
      if (techKey) {
        detail.dataset.techKey = techKey;
      }
      const header = document.createElement('header');
      header.className = 'tech-modal__header';
      const titleWrap = document.createElement('div');
      titleWrap.className = 'tech-modal__title';
      const heading = document.createElement('h3');
      heading.textContent = item.name;
      titleWrap.appendChild(heading);
      const badgeContainer = document.createElement('div');
      badgeContainer.className = 'tech-modal__badges';
      const branchChip = document.createElement('span');
      branchChip.className = 'tech-chip';
      branchChip.textContent = branchLabel;
      badgeContainer.appendChild(branchChip);
      const badgeLabels = new Set();
      if (item.category) badgeLabels.add(item.category);
      if (item.group && item.group !== item.category) badgeLabels.add(item.group);
      badgeLabels.forEach(label => {
        const chip = document.createElement('span');
        chip.className = 'tech-chip';
        chip.textContent = label;
        badgeContainer.appendChild(chip);
      });
      if (badgeContainer.children.length) {
        titleWrap.appendChild(badgeContainer);
      }
      header.appendChild(titleWrap);
      const meta = document.createElement('div');
      meta.className = 'tech-modal__meta';
      if (level && typeof level.level === 'number') {
        const levelMeta = document.createElement('span');
        levelMeta.textContent = kidMode
          ? `Tech level ${level.level}`
          : `Tech level ${level.level}`;
        meta.appendChild(levelMeta);
      }
      if (typeof item.techPoints === 'number') {
        const costMeta = document.createElement('span');
        costMeta.textContent = formatTechCost(item, { kid: kidMode });
        meta.appendChild(costMeta);
      }
      if (meta.children.length) {
        header.appendChild(meta);
      }
      detail.appendChild(header);
      const body = document.createElement('div');
      body.className = 'tech-modal__body';
      const media = document.createElement('div');
      media.className = 'tech-modal__media';
      if (item.image) {
        const img = document.createElement('img');
        img.loading = 'lazy';
        img.decoding = 'async';
        img.alt = `${item.name} image`;
        img.referrerPolicy = 'no-referrer';
        img.src = item.image;
        img.onerror = () => {
          img.remove();
          media.classList.add('tech-modal__media--fallback');
          media.textContent = '⚙️';
        };
        media.appendChild(img);
      } else {
        media.classList.add('tech-modal__media--fallback');
        media.textContent = '⚙️';
      }
      body.appendChild(media);
      const content = document.createElement('div');
      content.className = 'tech-modal__content';
      const description = document.createElement('p');
      description.className = 'tech-modal__description';
      description.textContent = kidMode ? descriptions.kid : descriptions.grown;
      content.appendChild(description);
      const materialsSection = document.createElement('section');
      materialsSection.className = 'tech-modal__materials';
      const materialsHeading = document.createElement('h4');
      materialsHeading.textContent = kidMode ? 'Crafting ingredients' : 'Crafting ingredients';
      materialsSection.appendChild(materialsHeading);
      if (materials.length) {
        const list = document.createElement('ul');
        list.className = 'tech-modal__materials-list';
        materials.forEach(material => {
          const chip = createTechMaterialChip(material);
          if (!chip) return;
          chip.classList.add('tech-modal__materials-link');
          const li = document.createElement('li');
          li.appendChild(chip);
          list.appendChild(li);
        });
        if (list.children.length) {
          materialsSection.appendChild(list);
        } else {
          const note = document.createElement('p');
          note.className = 'tech-card__note';
          note.textContent = kidMode
            ? 'No ingredients needed for this unlock.'
            : 'No crafting ingredients required for this unlock.';
          materialsSection.appendChild(note);
        }
      } else {
        const note = document.createElement('p');
        note.className = 'tech-card__note';
        note.textContent = kidMode
          ? 'No ingredients needed for this unlock.'
          : 'No crafting ingredients required for this unlock.';
        materialsSection.appendChild(note);
      }
      content.appendChild(materialsSection);
      const actions = document.createElement('div');
      actions.className = 'tech-modal__actions';
      const status = document.createElement('span');
      status.className = 'tech-modal__status';
      if (isUnlocked) {
        status.classList.add('tech-modal__status--unlocked');
      }
      if (techKey) {
        status.dataset.techStatus = techKey;
      }
      status.textContent = formatTechStatusText(isUnlocked);
      actions.appendChild(status);
      const unlockBtn = document.createElement('button');
      unlockBtn.type = 'button';
      unlockBtn.className = 'unlock-btn';
      if (isUnlocked) {
        unlockBtn.classList.add('unlocked');
      }
      if (techKey) {
        unlockBtn.dataset.techKey = techKey;
      }
      unlockBtn.dataset.techName = item.name;
      unlockBtn.setAttribute('aria-pressed', isUnlocked ? 'true' : 'false');
      unlockBtn.textContent = isUnlocked ? 'Unlocked' : 'Unlock';
      unlockBtn.addEventListener('click', () => {
        const newState = setTechUnlocked(item.name, !unlocked[item.name], { techKey });
        unlockBtn.classList.toggle('unlocked', newState);
        unlockBtn.textContent = newState ? 'Unlocked' : 'Unlock';
        unlockBtn.setAttribute('aria-pressed', newState ? 'true' : 'false');
        status.textContent = formatTechStatusText(newState);
        status.classList.toggle('tech-modal__status--unlocked', newState);
      });
      actions.appendChild(unlockBtn);
      const externalLink = document.createElement('a');
      externalLink.className = 'tech-modal__external';
      externalLink.href = techUrl;
      externalLink.target = '_blank';
      externalLink.rel = 'noopener';
      externalLink.textContent = kidMode ? 'Open Palworld.gg' : 'View on Palworld.gg';
      actions.appendChild(externalLink);
      content.appendChild(actions);
      body.appendChild(content);
      detail.appendChild(body);
      detail.tabIndex = -1;
      modalBody.appendChild(detail);
      openModal();
      const focusDetail = () => {
        try {
          detail.focus({ preventScroll: true });
        } catch (err) {
          detail.focus();
        }
      };
      if (typeof requestAnimationFrame === 'function') {
        requestAnimationFrame(focusDetail);
      } else {
        setTimeout(focusDetail, 0);
      }
    }

    function showNpcDetail(link){
      if(!link) return;
      const identifier = link.slug || link.id || link.name || '';
      const slug = slugifyForPalworld(String(identifier));
      const displayName = link.name || (slug ? niceName(slug) : niceName(identifier) || 'NPC');
      const safeName = escapeHTML(displayName);
      const fallbackUrl = link.url || `${PALWORLD_BASE_URL}/bosses?search=${encodeURIComponent(displayName)}`;
      const summaryParts = [];
      if(kidMode){
        summaryParts.push(`<p>Let's visit <strong>${safeName}</strong> so you remember who to talk to.</p>`);
      } else {
        summaryParts.push(`<p><strong>${safeName}</strong> quick reference.</p>`);
      }
      if(link.role){
        summaryParts.push(`<p><strong>Role:</strong> ${escapeHTML(niceName(String(link.role)))}</p>`);
      }
      if(link.region){
        summaryParts.push(`<p><strong>Region:</strong> ${escapeHTML(link.region)}</p>`);
      } else if(Array.isArray(link.coords) && link.coords.length >= 2){
        summaryParts.push(`<p><strong>Coords:</strong> ${escapeHTML(`${link.coords[0]}, ${link.coords[1]}`)}</p>`);
      }
      const note = kidMode
        ? 'Palmate keeps this NPC profile beside your checklist so you never lose your place.'
        : 'Palmate opens the NPC profile in a modal so you can keep progressing the route.';
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url: fallbackUrl,
        fallbackUrl,
        note,
        summaryHtml: summaryParts.join('')
      });
    }

    function showGlossaryDetail(identifier){
      if(!identifier) return;
      const key = String(identifier).toLowerCase();
      const entry = ROUTE_GLOSSARY_SUMMARIES[key];
      const displayName = entry?.title || niceName(identifier);
      const url = entry?.url || `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(displayName)}`;
      const note = entry?.note || 'Palmate keeps this glossary entry in a modal so you never lose your place.';
      const lines = entry
        ? (kidMode ? entry.kid : entry.grown)
        : [kidMode
          ? `Let's learn about ${displayName}. Palworld.gg will open beside your checklist so you can keep exploring.`
          : `Palmate is opening a Palworld.gg search for ${displayName} so you can review it without leaving the route.`];
      const summaryHtml = lines.map(text => `<p>${escapeHTML(text)}</p>`).join('');
      openPalworldEmbed({
        heading: `${displayName} – Palworld.gg`,
        url,
        fallbackUrl: url,
        note,
        summaryHtml
      });
    }

    window.showTechDetail = showTechDetail;
    window.showNpcDetail = showNpcDetail;
    window.showGlossaryDetail = showGlossaryDetail;

    function pulse(el){
      el.classList.add('pulse');
      setTimeout(() => el.classList.remove('pulse'), 1500);
    }

    function focusSearch(term, { target } = {}) {
      const desiredTarget = target === 'items' ? 'items' : 'pals';
      const inputId = desiredTarget === 'items' ? 'itemSearch' : 'palSearch';
      const input = document.getElementById(inputId);
      if (!input) return;
      switchPage(desiredTarget);
      const applySearch = () => {
        if (typeof input.focus === 'function') {
          try {
            input.focus({ preventScroll: true });
          } catch (err) {
            input.focus();
          }
        }
        if (typeof input.select === 'function') {
          input.select();
        }
        input.value = term == null ? '' : String(term);
        input.dispatchEvent(new Event('input', { bubbles: true }));
      };
      if (typeof window.requestAnimationFrame === 'function') {
        window.requestAnimationFrame(applySearch);
      } else {
        applySearch();
      }
    }

    function loadRouteState(){
      try {
        return JSON.parse(localStorage.getItem(ROUTE_STORAGE_KEY)) || {};
      } catch(err){
        console.warn('Failed to load route progress', err);
        return {};
      }
    }

    function loadRoutePreferences(){
      try {
        const stored = JSON.parse(localStorage.getItem(ROUTE_PREFS_KEY));
        if(stored && typeof stored === 'object'){
          return stored;
        }
      } catch(err){
        console.warn('Failed to load route preferences', err);
      }
      return {};
    }

    function loadRouteContext(){
      try {
        const stored = JSON.parse(localStorage.getItem(ROUTE_CONTEXT_KEY));
        if(stored && typeof stored === 'object'){
          return {
            ...DEFAULT_ROUTE_CONTEXT,
            ...stored,
            goals: Array.isArray(stored.goals) ? stored.goals.slice() : [],
            resourceGaps: Array.isArray(stored.resourceGaps) ? stored.resourceGaps.map(entry => ({
              item_id: entry?.item_id || entry?.itemId || '',
              qty: typeof entry?.qty === 'number' ? entry.qty : null
            })).filter(entry => entry.item_id) : []
          };
        }
      } catch(err){
        console.warn('Failed to load route context', err);
      }
      return { ...DEFAULT_ROUTE_CONTEXT };
    }

    function persistRoutePreferences(){
      const payload = {
        hideOptional: !!routeHideOptional,
        hiddenCategories: Array.from(routeHiddenCategories),
        overviewCollapsed: !!routeOverviewCollapsed,
        suggestionsCollapsed: !!routeSuggestionsCollapsed
      };
      try {
        localStorage.setItem(ROUTE_PREFS_KEY, JSON.stringify(payload));
      } catch(err){
        console.warn('Failed to save route preferences', err);
      }
    }

    function saveRouteState(state){
      localStorage.setItem(ROUTE_STORAGE_KEY, JSON.stringify(state));
    }

    function saveRouteContext(context){
      if(!context || typeof context !== 'object') return;
      const payload = {
        declaredLevel: context.declaredLevel != null ? Number(context.declaredLevel) : null,
        hardcore: !!context.hardcore,
        coop: !!context.coop,
        availableTimeMinutes: context.availableTimeMinutes != null ? Number(context.availableTimeMinutes) : null,
        goals: Array.isArray(context.goals) ? context.goals.slice() : [],
        resourceGaps: Array.isArray(context.resourceGaps) ? context.resourceGaps.map(entry => ({
          item_id: entry?.item_id || entry?.itemId || '',
          qty: entry?.qty != null ? Number(entry.qty) : null
        })).filter(entry => entry.item_id) : []
      };
      try {
        localStorage.setItem(ROUTE_CONTEXT_KEY, JSON.stringify(payload));
      } catch(err){
        console.warn('Failed to save route context', err);
      }
    }

    function escapeHTML(str){
      return (str || '').replace(/[&<>"']/g, ch => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[ch] || ch));
    }

    function capitalize(value){
      return (value || '').replace(/(^|[-_])\w/g, m => m.toUpperCase()).replace(/[-_]/g, ' ');
    }

    function niceName(id){
      return capitalize(String(id).replace(/_/g, ' '));
    }
    // with their descriptions.  Elements and work suitabilities are
    // summarised in organised sections with quick filters for faster lookup.
    function buildGlossaryPage() {
      const container = document.getElementById('glossaryContent');
      if (!container) return;
      container.innerHTML = '';

      const normalizedSkillDetails = {};
      Object.entries(SKILL_DETAILS || {}).forEach(([name, info = {}]) => {
        const normalizedKey = name.toLowerCase().replace(/[\s-]+/g, '_');
        normalizedSkillDetails[normalizedKey] = { name, ...info };
      });

      const nav = document.createElement('div');
      nav.className = 'glossary-nav';
      container.appendChild(nav);

      function createSection(id, title, description) {
        const section = document.createElement('section');
        section.className = 'glossary-section card';
        section.id = id;
        const heading = document.createElement('h3');
        heading.textContent = title;
        section.appendChild(heading);
        if (description) {
          const desc = document.createElement('p');
          desc.textContent = description;
          section.appendChild(desc);
        }
        container.appendChild(section);

        const btn = document.createElement('button');
        btn.type = 'button';
        btn.textContent = title;
        btn.dataset.target = id;
        btn.setAttribute('aria-controls', id);
        btn.addEventListener('click', () => {
          section.scrollIntoView({ behavior: 'smooth', block: 'start' });
        });
        nav.appendChild(btn);

        return section;
      }

      function createSearch(placeholder) {
        const input = document.createElement('input');
        input.type = 'search';
        input.className = 'glossary-search';
        input.placeholder = placeholder;
        input.setAttribute('aria-label', placeholder);
        return input;
      }

      const elementsDescription = kidMode
        ? 'Check which elements pals are strong or weak against.'
        : 'Reference chart for attack advantages and resistances.';
      const elemSection = createSection('glossary-elements', 'Elements & Type Chart', elementsDescription);

      const typeRelations = {
        Neutral: { strong: [], weak: ['Dark'] },
        Fire: { strong: ['Grass', 'Ice'], weak: ['Water'] },
        Water: { strong: ['Fire'], weak: ['Electric'] },
        Electric: { strong: ['Water'], weak: ['Ground'] },
        Grass: { strong: ['Ground'], weak: ['Fire'] },
        Ice: { strong: ['Dragon'], weak: ['Fire'] },
        Ground: { strong: ['Electric'], weak: ['Grass'] },
        Dragon: { strong: ['Dark', 'Dragon'], weak: ['Ice'] },
        Dark: { strong: ['Neutral'], weak: ['Dragon'] }
      };

      const typeColors = {
        Neutral: '#a5b2c8',
        Fire: '#ff704a',
        Water: '#41c5ff',
        Grass: '#6fe07a',
        Electric: '#ffd45c',
        Ice: '#8fe5ff',
        Ground: '#dba667',
        Dragon: '#c490ff',
        Dark: '#8a7bff'
      };

      function toRGBString(hex) {
        if (!hex) return '154, 166, 198';
        const cleaned = hex.replace('#', '').trim();
        const normalized = cleaned.length === 3
          ? cleaned.split('').map(ch => ch + ch).join('')
          : (cleaned + '000000').slice(0, 6);
        const r = parseInt(normalized.slice(0, 2), 16);
        const g = parseInt(normalized.slice(2, 4), 16);
        const b = parseInt(normalized.slice(4, 6), 16);
        if ([r, g, b].some(num => Number.isNaN(num))) {
          return '154, 166, 198';
        }
        return `${r}, ${g}, ${b}`;
      }

      const typeColorRGB = {};
      Object.entries(typeColors).forEach(([type, color]) => {
        typeColorRGB[type] = toRGBString(color);
      });

      function getTypeIconSource(type) {
        const source = iconMap[type];
        if (typeof source === 'string' && source.trim().length) {
          return source;
        }
        return iconMap['Neutral'] || 'assets/icons/neutral.png';
      }

      const typeMapLayout = document.createElement('div');
      typeMapLayout.className = 'type-map-layout';
      elemSection.appendChild(typeMapLayout);

      const typeMap = document.createElement('div');
      typeMap.className = 'type-map';
      typeMapLayout.appendChild(typeMap);

      const svgNS = 'http://www.w3.org/2000/svg';
      const connections = document.createElementNS(svgNS, 'svg');
      connections.classList.add('type-map__connections');
      connections.setAttribute('viewBox', '0 0 100 100');
      connections.setAttribute('aria-hidden', 'true');

      const defs = document.createElementNS(svgNS, 'defs');
      const marker = document.createElementNS(svgNS, 'marker');
      marker.id = 'type-map-arrowhead';
      marker.setAttribute('viewBox', '0 0 10 10');
      marker.setAttribute('refX', '10');
      marker.setAttribute('refY', '5');
      marker.setAttribute('markerWidth', '6');
      marker.setAttribute('markerHeight', '6');
      marker.setAttribute('orient', 'auto');
      const markerPath = document.createElementNS(svgNS, 'path');
      markerPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
      markerPath.setAttribute('fill', 'currentColor');
      marker.appendChild(markerPath);
      defs.appendChild(marker);
      connections.appendChild(defs);

      const connectionGroup = document.createElementNS(svgNS, 'g');
      connectionGroup.classList.add('type-map__link-group');
      connections.appendChild(connectionGroup);
      typeMap.appendChild(connections);

      const nodesLayer = document.createElement('div');
      nodesLayer.className = 'type-map__nodes';
      typeMap.appendChild(nodesLayer);

      const detailPanel = document.createElement('aside');
      detailPanel.className = 'type-map__detail';
      detailPanel.setAttribute('aria-live', 'polite');
      typeMapLayout.appendChild(detailPanel);

      const legend = document.createElement('p');
      legend.className = 'type-map__legend';
      legend.textContent = kidMode
        ? 'Follow the glowing arrows—each line shows which pals hit super hard!'
        : 'Arrows flow from the attacking element to the element it overwhelms.';
      elemSection.appendChild(legend);

      const sourceNote = document.createElement('p');
      sourceNote.className = 'type-map__source';
      const sourceLink = document.createElement('a');
      sourceLink.href = 'https://palworld.wiki.gg/wiki/Elements';
      sourceLink.target = '_blank';
      sourceLink.rel = 'noreferrer noopener';
      sourceLink.textContent = kidMode ? 'Palworld Wiki type chart' : 'Palworld Wiki type chart (rev. 18881)';
      sourceNote.append(
        kidMode ? 'Matchup data double-checked with the ' : 'Strengths and weaknesses verified against the ',
        sourceLink,
        kidMode ? ' so you have the latest info.' : ' to keep this guide current.'
      );
      elemSection.appendChild(sourceNote);

      const critiqueWrap = document.createElement('div');
      critiqueWrap.className = 'type-audit';
      const critiqueTitle = document.createElement('h4');
      critiqueTitle.className = 'type-audit__title';
      critiqueTitle.textContent = kidMode ? 'Element highlights' : 'Matchup audit highlights';
      critiqueWrap.appendChild(critiqueTitle);
      const critiqueList = document.createElement('ul');
      critiqueList.className = 'type-audit__list';
      const critiqueData = [
        {
          type: 'Fire',
          kid: 'Fire pals roast Grass and Ice, but water buddies soak them fast.',
          grown: 'Fire is still the only element with two offensive wins (Grass, Ice) yet a single Water counter.'
        },
        {
          type: 'Water',
          kid: 'Water pals splash out Fire, but Electric shocks hurt the most.',
          grown: 'Water now only checks Fire consistently and is punished sharply by Electric damage.'
        },
        {
          type: 'Grass',
          kid: 'Grass beats Ground pals, yet hates taking Fire hits.',
          grown: 'Grass focuses on grounding Ground-types while Fire remains its lone hard weakness.'
        },
        {
          type: 'Ground',
          kid: 'Ground pals zap Electric foes but should dodge Grass moves.',
          grown: 'Ground reliably blanks Electric attacks, though modern charts show Grass as its clean counter.'
        },
        {
          type: 'Dragon',
          kid: 'Dragon pals smash Dark foes, but Ice chills them instantly.',
          grown: 'Dragon still rules mirrors and Dark types, yet every build must respect Ice coverage.'
        },
        {
          type: 'Dark',
          kid: 'Dark pals scare Neutral friends, but Dragons scare them back.',
          grown: 'Dark stays the dedicated Neutral breaker, with Dragon remaining its only elemental check.'
        }
      ];
      critiqueData.forEach(entry => {
        const item = document.createElement('li');
        item.className = 'type-audit__item';
        const header = document.createElement('div');
        header.className = 'type-audit__item-header';
        const icon = document.createElement('img');
        icon.className = 'type-audit__item-icon';
        icon.src = getTypeIconSource(entry.type);
        icon.alt = '';
        icon.loading = 'lazy';
        icon.setAttribute('aria-hidden', 'true');
        header.appendChild(icon);
        const label = document.createElement('span');
        label.textContent = entry.type;
        header.appendChild(label);
        const text = document.createElement('p');
        text.className = 'type-audit__item-text';
        text.textContent = kidMode ? entry.kid : entry.grown;
        item.appendChild(header);
        item.appendChild(text);
        critiqueList.appendChild(item);
      });
      critiqueWrap.appendChild(critiqueList);
      elemSection.appendChild(critiqueWrap);

      const orbitElements = Object.keys(typeRelations).filter(type => type !== 'Neutral');
      const nodePositions = {};
      const smallScreen = window.matchMedia('(max-width: 520px)').matches;
      const mediumScreen = window.matchMedia('(max-width: 880px)').matches;
      const radius = smallScreen ? 40 : (mediumScreen ? 38 : 36);
      orbitElements.forEach((type, index) => {
        const angle = (index / orbitElements.length) * (Math.PI * 2) - Math.PI / 2;
        const x = 50 + radius * Math.cos(angle);
        const y = 50 + radius * Math.sin(angle);
        nodePositions[type] = { x, y };
      });
      nodePositions.Neutral = { x: 50, y: 50 };

      const links = [];

      function createPath(start, end) {
        const midX = (start.x + end.x) / 2;
        const midY = (start.y + end.y) / 2;
        const dx = end.x - start.x;
        const dy = end.y - start.y;
        const distance = Math.hypot(dx, dy) || 1;
        const offset = Math.min(12, distance / 3);
        const controlX = midX + (-dy / distance) * offset;
        const controlY = midY + (dx / distance) * offset;
        return `M ${start.x} ${start.y} Q ${controlX} ${controlY} ${end.x} ${end.y}`;
      }

      Object.entries(typeRelations).forEach(([source, info]) => {
        const start = nodePositions[source];
        if (!start) return;
        (info.strong || []).forEach(target => {
          if (target === source) return;
          const end = nodePositions[target];
          if (!end) return;
          const path = document.createElementNS(svgNS, 'path');
          path.classList.add('type-map__link');
          path.dataset.source = source;
          path.dataset.target = target;
          path.setAttribute('d', createPath(start, end));
          const color = typeColors[source] || '#f0f4f8';
          const rgb = typeColorRGB[source] || toRGBString(color);
          path.style.setProperty('--type-color', color);
          path.style.setProperty('--type-color-rgb', rgb);
          path.style.color = color;
          path.setAttribute('marker-end', 'url(#type-map-arrowhead)');
          connectionGroup.appendChild(path);
          links.push(path);
        });
      });

      const nodeButtons = [];

      function createNode(type) {
        const pos = nodePositions[type];
        if (!pos) return;
        const strong = (typeRelations[type] && typeRelations[type].strong) || [];
        const weak = (typeRelations[type] && typeRelations[type].weak) || [];
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'type-map__node';
        button.dataset.type = type;
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        button.style.setProperty('--type-color', color);
        button.style.setProperty('--type-color-rgb', rgb);
        button.style.setProperty('--type-x', `${pos.x}%`);
        button.style.setProperty('--type-y', `${pos.y}%`);
        button.setAttribute('aria-label', `${type} element: strong against ${strong.length ? strong.join(', ') : 'no elements'}; weak against ${weak.length ? weak.join(', ') : 'no elements'}`);
        button.setAttribute('aria-pressed', 'false');
        const iconSrc = getTypeIconSource(type);
        button.innerHTML = `
          <span class="type-map__node-ring"></span>
          <span class="type-map__node-visual">
            <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__node-icon" aria-hidden="true">
          </span>
          <span class="type-map__node-name">${escapeHTML(type)}</span>
          <span class="type-map__node-meta">
            <span class="type-map__node-pill type-map__node-pill--strong" title="${kidMode ? 'Number of elements you overpower' : 'Advantage count'}">${strong.length}</span>
            <span class="type-map__node-pill type-map__node-pill--weak" title="${kidMode ? 'Number of elements that overpower you' : 'Weakness count'}">${weak.length}</span>
          </span>
        `;
        button.addEventListener('click', () => selectType(type));
        nodesLayer.appendChild(button);
        nodeButtons.push(button);
      }

      Object.keys(typeRelations).forEach(createNode);

      function renderList(items, empty) {
        if (!items || items.length === 0) {
          return `<p class="type-map__detail-empty">${empty}</p>`;
        }
        return `
          <ul class="type-map__detail-list">
            ${items.map(item => `<li>${escapeHTML(item)}</li>`).join('')}
          </ul>
        `;
      }

      function selectType(type) {
        const info = typeRelations[type] || { strong: [], weak: [] };
        const strongSet = new Set(info.strong);
        const weakSet = new Set(info.weak);
        nodeButtons.forEach(btn => {
          const nodeType = btn.dataset.type;
          const isFocus = nodeType === type;
          btn.classList.toggle('type-map__node--focus', isFocus);
          btn.classList.toggle('type-map__node--ally', strongSet.has(nodeType));
          btn.classList.toggle('type-map__node--danger', weakSet.has(nodeType));
          btn.setAttribute('aria-pressed', isFocus ? 'true' : 'false');
        });
        links.forEach(path => {
          const fromSelected = path.dataset.source === type;
          const toSelected = path.dataset.target === type;
          path.classList.toggle('type-map__link--active', fromSelected);
          path.classList.toggle('type-map__link--incoming', toSelected);
          path.classList.toggle('type-map__link--dim', !fromSelected && !toSelected);
        });

        const strongLabel = kidMode ? 'Super Effective On' : 'Dominates';
        const weakLabel = kidMode ? 'Takes Big Damage From' : 'Vulnerable To';
        const noteText = kidMode
          ? 'Tap another element to see who it blasts or who blasts it.'
          : 'Select different nodes to trace optimal matchups and counters.';
        const color = typeColors[type] || '#9aa6c6';
        const rgb = typeColorRGB[type] || toRGBString(color);
        const iconSrc = getTypeIconSource(type);
        detailPanel.style.setProperty('--type-color', color);
        detailPanel.style.setProperty('--type-color-rgb', rgb);
        detailPanel.innerHTML = `
          <header class="type-map__detail-header">
            <span class="type-map__detail-chip">
              <img src="${escapeHTML(iconSrc)}" alt="" loading="lazy" class="type-map__detail-icon" aria-hidden="true">
              ${escapeHTML(type)}
            </span>
            <span class="type-map__detail-sub">${info.strong.length} advantage${info.strong.length === 1 ? '' : 's'} • ${info.weak.length} weakness${info.weak.length === 1 ? '' : 'es'}</span>
          </header>
          <div class="type-map__detail-columns">
            <div>
              <h4>${strongLabel}</h4>
              ${renderList(info.strong, kidMode ? 'No super strengths.' : 'No direct advantages recorded.')}
            </div>
            <div>
              <h4>${weakLabel}</h4>
              ${renderList(info.weak, kidMode ? 'No big threats.' : 'No notable weaknesses recorded.')}
            </div>
          </div>
          <p class="type-map__detail-note">${noteText}</p>
        `;
      }

      selectType('Fire');

      const workDescription = kidMode
        ? 'These jobs tell you what pals can help with at base.'
        : 'Use these notes to decide which pals to station at each production line.';
      const workSection = createSection('glossary-work', 'Work Suitabilities', workDescription);
      const workLevelLabels = {
        5: kidMode ? 'Mythic helper' : 'Mythic specialist',
        4: kidMode ? 'Master helper' : 'Master specialist',
        3: kidMode ? 'Elite helper' : 'Expert artisan',
        2: kidMode ? 'Trained helper' : 'Skilled worker',
        1: kidMode ? 'Rookie helper' : 'Apprentice',
        0: kidMode ? 'Needs practice' : 'Untrained'
      };

      const tierLookup = {
        5: { badge: 'SS', className: 'work-tier-badge work-tier-badge--ss' },
        4: { badge: 'S', className: 'work-tier-badge work-tier-badge--s' },
        3: { badge: 'A', className: 'work-tier-badge work-tier-badge--a' },
        2: { badge: 'B', className: 'work-tier-badge work-tier-badge--b' },
        1: { badge: 'C', className: 'work-tier-badge work-tier-badge--c' },
        0: { badge: '—', className: 'work-tier-badge work-tier-badge--d' }
      };

      const tierLegend = document.createElement('div');
      tierLegend.className = 'work-tier-legend';
      const tierLegendLabel = document.createElement('span');
      tierLegendLabel.className = 'work-tier-legend__label';
      tierLegendLabel.textContent = kidMode
        ? 'Badges show how strong a pal is at the job:'
        : 'Tier badges convert work levels at a glance:';
      tierLegend.appendChild(tierLegendLabel);
      const tierLegendItems = document.createElement('div');
      tierLegendItems.className = 'work-tier-legend__items';
      [4, 3, 2, 1].forEach(level => {
        const tierInfo = tierLookup[level];
        if (!tierInfo) return;
        const item = document.createElement('span');
        item.className = 'work-tier-legend__item';
        const badge = document.createElement('span');
        badge.className = tierInfo.className;
        badge.textContent = tierInfo.badge;
        const text = document.createElement('span');
        text.textContent = `${kidMode ? 'Level' : 'Level'} ${level} • ${workLevelLabels[level]}`;
        item.appendChild(badge);
        item.appendChild(text);
        tierLegendItems.appendChild(item);
      });
      if (tierLegendItems.childElementCount) {
        tierLegend.appendChild(tierLegendItems);
        workSection.appendChild(tierLegend);
      }

      const allPals = Object.values(PALS || {});
      let highestWorkLevel = 0;
      allPals.forEach(pal => {
        const work = pal?.work || {};
        Object.values(work).forEach(val => {
          if (typeof val === 'number' && val > highestWorkLevel) {
            highestWorkLevel = val;
          }
        });
      });
      if (!highestWorkLevel) {
        highestWorkLevel = 4;
      }

      function getWorkLevel(pal, keys) {
        const work = pal?.work || {};
        return keys.reduce((max, key) => {
          const value = work?.[key] ?? 0;
          return typeof value === 'number' && value > max ? value : max;
        }, 0);
      }

      function findTopPals(keys) {
        return allPals
          .map(pal => ({ pal, level: getWorkLevel(pal, keys) }))
          .filter(item => item.level > 0 && item.pal && item.pal.name)
          .sort((a, b) => {
            if (b.level !== a.level) return b.level - a.level;
            return (a.pal.name || '').localeCompare(b.pal.name || '', undefined, { sensitivity: 'base' });
          })
          .slice(0, 5);
      }

      function getTierInfo(level) {
        if (level >= 5 && tierLookup[5]) return tierLookup[5];
        if (level >= 4) return tierLookup[4];
        if (level >= 3) return tierLookup[3];
        if (level >= 2) return tierLookup[2];
        if (level >= 1) return tierLookup[1];
        return tierLookup[0];
      }

      function getWorkLabel(level) {
        if (level > 0) {
          const descriptor = workLevelLabels[level] != null
            ? workLevelLabels[level]
            : (kidMode ? 'Trusted helper' : 'Seasoned worker');
          return `${kidMode ? 'Level' : 'Level'} ${level} • ${descriptor}`;
        }
        return workLevelLabels[0];
      }

      const workEntries = [
        { id: 'kindling', name: 'Kindling', icon: '🔥', keys: ['kindling'], desc: 'Lights furnaces, cooking pots and heaters so crafting stays on schedule.' },
        { id: 'watering', name: 'Watering', icon: '💧', keys: ['watering'], desc: 'Keeps berry plantations, mill wheels and condensers supplied with water.' },
        { id: 'planting', name: 'Planting', icon: '🌱', keys: ['planting'], desc: 'Sows seeds in your fields and refills ranch plots automatically.' },
        { id: 'electricity', name: 'Electricity', icon: '⚡', keys: ['generating_electricity', 'electricity'], desc: 'Generates power for batteries, assembly lines and refrigerators.' },
        { id: 'handiwork', name: 'Handiwork', icon: '🛠️', keys: ['handiwork'], desc: 'Builds structures, crafts gear and assists with any construction queue.' },
        { id: 'gathering', name: 'Gathering', icon: '🎒', keys: ['gathering'], desc: 'Picks up dropped items around base and hauls them to nearby chests.' },
        { id: 'lumbering', name: 'Lumbering', icon: '🪓', keys: ['lumbering'], desc: 'Cuts logs at the logging site and processes wood for crafting.' },
        { id: 'mining', name: 'Mining', icon: '⛏️', keys: ['mining'], desc: 'Breaks ore nodes and keeps refining stations stocked with stone and ingots.' },
        { id: 'medicine', name: 'Medicine', icon: '💊', keys: ['medicine_production', 'medicine'], desc: 'Brews medical supplies at the workbench and treats sick pals faster.' },
        { id: 'cooling', name: 'Cooling', icon: '❄️', keys: ['cooling'], desc: 'Runs refrigerators, air conditioners and ice workbenches.' },
        { id: 'transporting', name: 'Transporting', icon: '📦', keys: ['transporting'], desc: 'Moves materials between stations and storage so production never stalls.' },
        { id: 'farming', name: 'Farming', icon: '🐑', keys: ['farming'], desc: 'Produces rare drops like milk, wool and eggs while stationed at the ranch.' }
      ];

      const workGrid = document.createElement('div');
      workGrid.className = 'glossary-work-grid';

      workEntries.forEach(entry => {
        const card = document.createElement('article');
        card.className = 'work-role-card';
        card.id = `work-${entry.id}`;

        const header = document.createElement('header');
        header.className = 'work-role-card__header';

        const icon = document.createElement('span');
        icon.className = 'work-role-card__icon';
        icon.textContent = entry.icon || '⭐';
        icon.setAttribute('aria-hidden', 'true');
        header.appendChild(icon);

        const titles = document.createElement('div');
        titles.className = 'work-role-card__titles';

        const title = document.createElement('h4');
        title.className = 'work-role-card__name';
        title.textContent = entry.name;
        titles.appendChild(title);

        const blurb = document.createElement('p');
        blurb.className = 'work-role-card__blurb';
        blurb.textContent = entry.desc;
        titles.appendChild(blurb);

        header.appendChild(titles);
        card.appendChild(header);

        const palGrid = document.createElement('div');
        palGrid.className = 'work-pal-grid';

        const topPals = findTopPals(entry.keys);
        if (!topPals.length) {
          const emptyState = document.createElement('p');
          emptyState.className = 'work-pal-empty';
          emptyState.textContent = kidMode
            ? 'No pals recorded yet.'
            : 'No pals currently specialise in this task.';
          palGrid.appendChild(emptyState);
        } else {
          topPals.forEach((item, index) => {
            const { pal, level } = item;
            const palId = pal.id || pal.key || '';
            const palName = pal.name || 'Unknown Pal';
            const tierInfo = getTierInfo(level);
            const label = getWorkLabel(level);
            const normalizedWidth = Math.min(100, Math.max(0, (level / Math.max(1, highestWorkLevel)) * 100));
            const initial = (palName || '?').trim().charAt(0) || '?';

            const cardBtn = document.createElement('button');
            cardBtn.type = 'button';
            cardBtn.className = 'work-pal-card';
            cardBtn.dataset.palId = palId;
            cardBtn.dataset.workRole = entry.id;
            cardBtn.dataset.workLevel = String(level);
            cardBtn.setAttribute('aria-label', `${palName} ${label}`);
            cardBtn.title = `${palName} — ${label}`;

            const rank = document.createElement('span');
            rank.className = 'work-pal-card__rank';
            rank.textContent = `#${index + 1}`;
            cardBtn.appendChild(rank);

            const artWrap = document.createElement('span');
            artWrap.className = 'work-pal-card__art';
            const placeholder = document.createElement('span');
            placeholder.className = 'work-pal-card__placeholder';
            placeholder.textContent = initial;
            artWrap.appendChild(placeholder);

            const artImg = document.createElement('img');
            artImg.alt = palName;
            artImg.addEventListener('load', () => {
              placeholder.hidden = true;
            });
            applyPalArtwork(artImg, pal, { alt: palName });
            artWrap.appendChild(artImg);
            cardBtn.appendChild(artWrap);

            const infoWrap = document.createElement('span');
            infoWrap.className = 'work-pal-card__info';

            const head = document.createElement('span');
            head.className = 'work-pal-card__head';
            const nameEl = document.createElement('span');
            nameEl.className = 'work-pal-card__name';
            nameEl.textContent = palName;
            head.appendChild(nameEl);

            const badge = document.createElement('span');
            badge.className = tierInfo.className;
            badge.textContent = tierInfo.badge;
            head.appendChild(badge);
            infoWrap.appendChild(head);

            const skill = document.createElement('span');
            skill.className = 'work-pal-card__skill';
            skill.textContent = label;
            infoWrap.appendChild(skill);

            const meter = document.createElement('span');
            meter.className = 'work-skill-meter';
            meter.setAttribute('aria-hidden', 'true');
            const meterFill = document.createElement('span');
            meterFill.className = 'work-skill-meter__fill';
            meterFill.style.width = `${normalizedWidth.toFixed(0)}%`;
            meter.appendChild(meterFill);
            infoWrap.appendChild(meter);

            cardBtn.appendChild(infoWrap);
            palGrid.appendChild(cardBtn);
          });
        }

        card.appendChild(palGrid);
        workGrid.appendChild(card);
      });

      workSection.appendChild(workGrid);

      const partnerSkillsData = Array.isArray(PARTNER_SKILLS) ? PARTNER_SKILLS.slice() : [];
      const partnerDescription = kidMode
        ? 'Press the Partner Skill button to trigger these buddy powers.'
        : 'Every ability you unlock with the Partner button, from mount bonuses to farming helpers.';
      const partnerSection = createSection('glossary-partners', 'Partner Skills', partnerDescription);

      const partnerSummary = document.createElement('div');
      partnerSummary.className = 'glossary-callout';
      const partnerCountLabel = kidMode
        ? `Palmate now tracks ${partnerSkillsData.length} partner skills.`
        : `${partnerSkillsData.length} partner skills catalogued across the full roster.`;
      partnerSummary.innerHTML = kidMode
        ? `<strong>Partner skill quick facts</strong><ul><li>${partnerCountLabel}—that’s even more than the 94 skills Palworld launched with.</li><li>Mount badges mark pals that boost you while you ride—look for the Damage Boost tag when you want your own attacks to hit harder.</li><li>Utility and farming pals are flagged so you can find harvest bonuses fast.</li></ul>`
        : `<strong>Partner skill quick reference</strong><ul><li>${partnerCountLabel} (the roster has already grown past the ~94 launch abilities). Use the filters to zero in on combat, mount or production buffs.</li><li>The Damage Boost tag highlights mounts that amplify player or pal damage while ridden.</li><li>Utility and Ranch labels surface weight carriers, harvest multipliers and other base-side perks.</li></ul>`;
      partnerSection.appendChild(partnerSummary);

      const condenserCallout = document.createElement('div');
      condenserCallout.className = 'glossary-callout';
      condenserCallout.innerHTML = kidMode
        ? `<strong>Power Condenser bonuses</strong><ul><li>Feed extra pals into the Power Condenser to add blue stars—each star raises the partner skill level.</li><li>Stars also boost a pal's stats, and the fourth star gives every job +1 level.</li><li>It takes 4 + 16 + 32 + 64 pals (116 total) to reach five stars, so mark your favorites before condensing.</li></ul>`
        : `<strong>Power Condenser benefits</strong><ul><li>The Pal Essence Condenser consumes 4, 16, 32 and 64 duplicates (116 total) to push a partner skill to Lv.5.</li><li>Each condensation star raises base stats; the 4★ upgrade grants +1 to every work suitability.</li><li>Damage-focused partner skills scale with those levels—mount element swaps and active skill multipliers can double or better by rank 5.</li></ul>`;
      partnerSection.appendChild(condenserCallout);

      const partnerSearch = createSearch(kidMode ? 'Search partner skills…' : 'Filter partner skills by name, pal or effect…');
      partnerSection.appendChild(partnerSearch);

      const partnerFilterBar = document.createElement('div');
      partnerFilterBar.className = 'partner-filter-bar';
      partnerSection.appendChild(partnerFilterBar);

      const partnerFilterState = { category: 'all', damageOnly: false };
      const partnerCategoryButtons = [];
      const partnerCategoryOptions = [
        { key: 'all', kid: 'All', grown: 'All roles' },
        { key: 'mount', kid: 'Mounts', grown: 'Mount bonuses' },
        { key: 'combat', kid: 'Battle', grown: 'Combat' },
        { key: 'utility', kid: 'Helpers', grown: 'Utility' },
        { key: 'farming', kid: 'Ranch', grown: 'Farming' }
      ];
      partnerCategoryOptions.forEach(option => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'partner-filter';
        btn.dataset.category = option.key;
        btn.textContent = kidMode ? option.kid : option.grown;
        btn.setAttribute('aria-pressed', option.key === partnerFilterState.category ? 'true' : 'false');
        btn.addEventListener('click', () => {
          if (partnerFilterState.category === option.key) return;
          partnerFilterState.category = option.key;
          updatePartnerCategoryButtons();
          renderPartnerSkills();
        });
        partnerCategoryButtons.push(btn);
        partnerFilterBar.appendChild(btn);
      });

      const damageToggle = document.createElement('button');
      damageToggle.type = 'button';
      damageToggle.className = 'partner-filter';
      damageToggle.dataset.filter = 'damage';
      damageToggle.textContent = kidMode ? 'Damage boost' : 'Damage boosts';
      damageToggle.setAttribute('aria-pressed', partnerFilterState.damageOnly ? 'true' : 'false');
      damageToggle.addEventListener('click', () => {
        partnerFilterState.damageOnly = !partnerFilterState.damageOnly;
        damageToggle.setAttribute('aria-pressed', partnerFilterState.damageOnly ? 'true' : 'false');
        renderPartnerSkills();
      });
      partnerFilterBar.appendChild(damageToggle);

      const partnerCount = document.createElement('p');
      partnerCount.className = 'glossary-count';
      partnerSection.appendChild(partnerCount);

      const partnerGrid = document.createElement('div');
      partnerGrid.className = 'partner-skill-grid';
      partnerSection.appendChild(partnerGrid);

      const partnerEmpty = document.createElement('p');
      partnerEmpty.className = 'glossary-empty';
      partnerEmpty.textContent = kidMode
        ? 'No partner skills found. Try a different word or filter.'
        : 'No partner skills match the current filters.';
      partnerEmpty.hidden = true;
      partnerSection.appendChild(partnerEmpty);

      const categoryLabels = {
        'Combat': { kid: 'Battle', grown: 'Combat' },
        'Utility': { kid: 'Helper', grown: 'Utility' },
        'Farming': { kid: 'Ranch', grown: 'Farming' },
        'Mount': { kid: 'Ride', grown: 'Mount' },
        'Mount (Flying)': { kid: 'Fly', grown: 'Flying Mount' },
        'Mount (Glider)': { kid: 'Glide', grown: 'Glider Mount' },
        'Mount (Swimmer)': { kid: 'Swim', grown: 'Swim Mount' },
        'Mount (Ridden)': { kid: 'Ground', grown: 'Ground Mount' }
      };

      const decoratedPartnerSkills = partnerSkillsData.map(skill => {
        const categories = Array.isArray(skill.categories) ? skill.categories.slice() : [];
        const normalizedCategories = new Set();
        const hasSpecializedMount = categories.some(cat => /^Mount \(/i.test(cat));
        categories.forEach(cat => {
          const lower = String(cat || '').toLowerCase();
          if (!lower) return;
          if (lower.includes('combat')) normalizedCategories.add('combat');
          if (lower.includes('utility')) normalizedCategories.add('utility');
          if (lower.includes('farming')) normalizedCategories.add('farming');
          if (lower.startsWith('mount')) {
            normalizedCategories.add('mount');
            if (lower.includes('flying')) normalizedCategories.add('mount-flying');
            if (lower.includes('glider')) normalizedCategories.add('mount-glider');
            if (lower.includes('swimmer')) normalizedCategories.add('mount-swimmer');
            if (lower.includes('ridden')) normalizedCategories.add('mount-ridden');
          }
        });
        const description = typeof skill.description === 'string' ? skill.description : '';
        const descLower = description.toLowerCase();
        const modifiesPlayerDamage = descLower.includes('player') && descLower.includes('mounted') && (descLower.includes('damage') || descLower.includes('attack'));
        const modifiesPalDamage = descLower.includes('pal') && descLower.includes('mounted') && descLower.includes('damage');
        const modifiesAnyDamage = (descLower.includes('damage') || descLower.includes('attack')) && descLower.includes('mounted');
        const dropBoost = descLower.includes('drop') || descLower.includes('harvest') || descLower.includes('ranch');
        const workBoost = descLower.includes('work') || descLower.includes('carry') || descLower.includes('weight');
        const speedBoost = descLower.includes('speed') && descLower.includes('mount');
        const mountCategory = categories.find(cat => /^Mount/i.test(cat));
        const palEntries = (Array.isArray(skill.pals) ? skill.pals : []).map(name => {
          const palId = PAL_NAME_TO_ID[name];
          const pal = palId != null ? PALS[palId] : null;
          return { name, pal, palId };
        });
        const searchText = [
          skill.name || '',
          description,
          skill.type || '',
          (Array.isArray(skill.pals) ? skill.pals.join(' ') : '')
        ].join(' ').toLowerCase();
        return {
          ...skill,
          categories,
          normalizedCategories,
          hasSpecializedMount,
          mountCategory,
          modifiesPlayerDamage,
          modifiesPalDamage,
          modifiesAnyDamage,
          dropBoost,
          workBoost,
          speedBoost,
          palEntries,
          searchText,
          descLower
        };
      });

      function updatePartnerCategoryButtons() {
        partnerCategoryButtons.forEach(btn => {
          const active = btn.dataset.category === partnerFilterState.category;
          btn.setAttribute('aria-pressed', active ? 'true' : 'false');
        });
      }

      function renderPartnerSkills() {
        const totalSkills = decoratedPartnerSkills.length;
        if (!totalSkills) {
          partnerGrid.innerHTML = '';
          partnerCount.textContent = kidMode
            ? 'Partner skill data is loading…'
            : 'Partner skill dataset unavailable.';
          partnerEmpty.hidden = false;
          partnerEmpty.textContent = kidMode
            ? 'Partner skill list will appear once the data loads.'
            : 'Partner skill dataset is unavailable.';
          return;
        }
        const term = partnerSearch.value.trim().toLowerCase();
        const category = partnerFilterState.category;
        const requireDamage = partnerFilterState.damageOnly;
        partnerGrid.innerHTML = '';
        let visible = 0;
        decoratedPartnerSkills.forEach(skill => {
          const matchesTerm = !term || skill.searchText.includes(term);
          const matchesCategory = category === 'all' || skill.normalizedCategories.has(category);
          const matchesDamage = !requireDamage || skill.modifiesAnyDamage;
          if (!matchesTerm || !matchesCategory || !matchesDamage) {
            return;
          }
          visible += 1;
          const card = document.createElement('article');
          card.className = 'partner-skill-card';
          card.dataset.skillId = skill.id || '';

          const header = document.createElement('header');
          header.className = 'partner-skill-card__header';
          const nameEl = document.createElement('h4');
          nameEl.className = 'partner-skill-card__name';
          nameEl.textContent = skill.name || 'Partner Skill';
          const numberEl = document.createElement('span');
          numberEl.className = 'partner-skill-card__number';
          numberEl.textContent = skill.number != null ? String(skill.number).padStart(3, '0') : '—';
          header.appendChild(nameEl);
          header.appendChild(numberEl);
          card.appendChild(header);

          const tags = document.createElement('div');
          tags.className = 'partner-skill-card__tags';
          const shownTags = new Set();
          const hasMountSpecialisation = skill.hasSpecializedMount;
          skill.categories.forEach(cat => {
            if (!cat) return;
            if (cat === 'Mount' && hasMountSpecialisation) return;
            const mapping = categoryLabels[cat];
            const label = mapping ? (kidMode ? mapping.kid : mapping.grown) : cat;
            const tagKey = `cat:${label}`;
            if (shownTags.has(tagKey)) return;
            shownTags.add(tagKey);
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            if (/^Mount/i.test(cat)) {
              tag.classList.add('partner-skill-card__tag--mount');
            }
            tag.textContent = label;
            tags.appendChild(tag);
          });
          if (skill.modifiesAnyDamage) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag partner-skill-card__tag--damage';
            tag.textContent = kidMode
              ? (skill.modifiesPlayerDamage ? 'You hit harder' : 'Pal hits harder')
              : (skill.modifiesPlayerDamage ? 'Player damage' : 'Pal damage');
            tags.appendChild(tag);
          }
          if (skill.dropBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag partner-skill-card__tag--drops';
            tag.textContent = kidMode ? 'More drops' : 'Drop bonus';
            tags.appendChild(tag);
          }
          if (skill.workBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            tag.textContent = kidMode ? 'Helper boost' : 'Support bonus';
            tags.appendChild(tag);
          }
          if (skill.speedBoost) {
            const tag = document.createElement('span');
            tag.className = 'partner-skill-card__tag';
            tag.textContent = kidMode ? 'Faster ride' : 'Speed boost';
            tags.appendChild(tag);
          }
          if (tags.childElementCount) {
            card.appendChild(tags);
          }

          const description = document.createElement('p');
          description.className = 'partner-skill-card__description';
          description.textContent = skill.description || (kidMode ? 'Partner skill info unavailable.' : 'No description available.');
          card.appendChild(description);

          if (skill.palEntries.length) {
            const palWrap = document.createElement('div');
            palWrap.className = 'partner-skill-card__pals';
            skill.palEntries.forEach(entry => {
              const palBtn = document.createElement('button');
              palBtn.type = 'button';
              palBtn.className = 'partner-skill-card__pal';
              const palId = entry.palId;
              if (palId != null) {
                palBtn.dataset.palId = String(palId);
              } else {
                palBtn.setAttribute('aria-disabled', 'true');
                palBtn.disabled = true;
              }
              const avatar = document.createElement('span');
              avatar.className = 'partner-skill-card__pal-avatar';
              if (entry.pal) {
                const img = document.createElement('img');
                img.alt = '';
                applyPalArtwork(img, entry.pal, { alt: '' });
                avatar.appendChild(img);
              } else {
                avatar.textContent = entry.name ? entry.name.charAt(0).toUpperCase() : '?';
              }
              const label = document.createElement('span');
              label.textContent = entry.name || (kidMode ? 'Pal' : 'Unknown Pal');
              palBtn.appendChild(avatar);
              palBtn.appendChild(label);
              palWrap.appendChild(palBtn);
            });
            card.appendChild(palWrap);
          }

          partnerGrid.appendChild(card);
        });

        partnerCount.textContent = visible === totalSkills
          ? `${visible} partner skills listed.`
          : `Showing ${visible} of ${totalSkills} partner skills.`;
        partnerEmpty.hidden = visible !== 0;
      }

      updatePartnerCategoryButtons();
      partnerSearch.addEventListener('input', renderPartnerSkills);
      renderPartnerSkills();

      const passiveDescription = kidMode
        ? 'All partner traits pals can roll. Tap a trait to read what it does.'
        : 'Complete alphabetical list of every passive trait. Select any entry for detailed effects.';
      const passiveSection = createSection('glossary-passives', 'Passive Skills', passiveDescription);
      const passiveSearch = createSearch(kidMode ? 'Search passive traits…' : 'Filter passive traits…');
      passiveSection.appendChild(passiveSearch);
      const passiveCount = document.createElement('p');
      passiveCount.className = 'glossary-count';
      passiveSection.appendChild(passiveCount);
      const passiveWrap = document.createElement('div');
      passiveWrap.className = 'glossary-chip-grid';
      passiveSection.appendChild(passiveWrap);
      const passiveEmpty = document.createElement('p');
      passiveEmpty.className = 'glossary-empty';
      passiveEmpty.textContent = kidMode
        ? 'No passives found. Try a different word.'
        : 'No passive traits match your search.';
      passiveEmpty.hidden = true;
      passiveSection.appendChild(passiveEmpty);

      const passiveEntries = Object.keys(traitsDictionary || {})
        .sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
      passiveEntries.forEach(trait => {
        const description = typeof traitsDictionary[trait] === 'string' ? traitsDictionary[trait] : '';
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'chip passive';
        btn.dataset.trait = trait;
        const slug = slugifyForPalworld(trait);
        if (slug) {
          btn.id = `passive-${slug}`;
        }
        btn.title = description || trait;
        btn.textContent = trait;
        btn.dataset.search = `${trait} ${description}`.toLowerCase();
        passiveWrap.appendChild(btn);
      });

      const totalPassives = passiveEntries.length;
      function filterPassives() {
        const term = passiveSearch.value.trim().toLowerCase();
        let visible = 0;
        passiveWrap.querySelectorAll('.chip.passive').forEach(btn => {
          const searchable = btn.dataset.search || '';
          const matches = !term || searchable.includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        passiveCount.textContent = totalPassives
          ? (visible === totalPassives
            ? `${totalPassives} passive traits listed.`
            : `Showing ${visible} of ${totalPassives} passive traits.`)
          : 'No passive traits available.';
        passiveEmpty.hidden = visible !== 0;
      }
      filterPassives();
      passiveSearch.addEventListener('input', filterPassives);

      const activeDescription = kidMode
        ? 'Every move pals can learn. Search by name, element or effect.'
        : 'Complete catalogue of partner and weapon skills. Filter by name, element or effect.';
      const activeSection = createSection('glossary-active', 'Active Skills', activeDescription);
      const rainbowCallout = document.createElement('div');
      rainbowCallout.className = 'glossary-callout';
      rainbowCallout.innerHTML = `<strong>Rainbow skills</strong>Rainbow-fruit moves ignore normal type weaknesses and resistances, so they deal steady damage even when enemies resist your pal’s element. They can be taught to any pal, making them perfect coverage options for favourite partners.`;
      activeSection.appendChild(rainbowCallout);

      const skillSearch = createSearch(kidMode ? 'Search active skills…' : 'Filter active skills by name, element or effect…');
      activeSection.appendChild(skillSearch);
      const skillCount = document.createElement('p');
      skillCount.className = 'glossary-count';
      activeSection.appendChild(skillCount);
      const skillsWrap = document.createElement('div');
      skillsWrap.className = 'glossary-skill-grid';
      activeSection.appendChild(skillsWrap);
      const skillEmpty = document.createElement('p');
      skillEmpty.className = 'glossary-empty';
      skillEmpty.textContent = kidMode
        ? 'No skills found. Try another word or element.'
        : 'No active skills match your filters.';
      skillEmpty.hidden = true;
      activeSection.appendChild(skillEmpty);

      const skillEntriesMap = new Map();
      Object.entries(normalizedSkillDetails).forEach(([key, info]) => {
        skillEntriesMap.set(key, {
          key,
          displayName: info.name || key,
          element: info.element || 'Unknown',
          power: typeof info.power === 'number' ? info.power : null,
          cooldown: typeof info.ct === 'number' ? info.ct : null,
          description: info.description || ''
        });
      });
      Object.entries(skillsDictionary || {}).forEach(([rawKey, info = {}]) => {
        const normalizedKey = rawKey.toLowerCase();
        const existing = skillEntriesMap.get(normalizedKey);
        const baseName = info.name || niceName(rawKey);
        const fallbackPower = typeof info.power === 'number'
          ? info.power
          : (() => {
              const match = (info.damage || '').match(/(\d+)/);
              return match ? Number(match[1]) : null;
            })();
        const description = info.description || existing?.description || '';
        const element = (existing && existing.element && existing.element !== 'Unknown')
          ? existing.element
          : (info.element || info.type || 'Unknown');
        const cooldown = existing?.cooldown != null ? existing.cooldown : null;
        const merged = {
          key: normalizedKey,
          displayName: baseName,
          element,
          power: existing?.power != null ? existing.power : fallbackPower,
          cooldown,
          description
        };
        skillEntriesMap.set(normalizedKey, { ...existing, ...merged });
      });

      const skillEntries = Array.from(skillEntriesMap.values())
        .filter(entry => entry && entry.displayName)
        .sort((a, b) => a.displayName.localeCompare(b.displayName, undefined, { sensitivity: 'base' }));
      skillEntries.forEach(entry => {
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.className = 'glossary-skill';
        btn.dataset.skill = entry.key;
        const slug = slugifyForPalworld(entry.displayName);
        if (slug) {
          btn.id = `move-${slug}`;
        }
        const metaBits = [];
        if (typeof entry.power === 'number' && !Number.isNaN(entry.power)) {
          metaBits.push(`Power ${entry.power}`);
        }
        if (typeof entry.cooldown === 'number' && !Number.isNaN(entry.cooldown)) {
          metaBits.push(`CT ${entry.cooldown}s`);
        }
        const metaText = metaBits.join(' • ');
        btn.innerHTML = `
          <span class="glossary-skill__header">
            <span class="glossary-skill__name">${escapeHTML(entry.displayName)}</span>
            <span class="glossary-skill__element">${escapeHTML(entry.element || 'Unknown')}</span>
          </span>
          ${metaText ? `<span class="glossary-skill__meta">${escapeHTML(metaText)}</span>` : ''}
          <span class="glossary-skill__description">${escapeHTML(entry.description || 'No description available.')}</span>
        `;
        const searchableChunks = [
          entry.displayName,
          entry.element,
          entry.description,
          metaText
        ].filter(Boolean);
        btn.dataset.search = searchableChunks.join(' ').toLowerCase();
        skillsWrap.appendChild(btn);
      });

      const totalSkills = skillEntries.length;
      function filterSkills() {
        const term = skillSearch.value.trim().toLowerCase();
        let visible = 0;
        skillsWrap.querySelectorAll('.glossary-skill').forEach(btn => {
          const matches = !term || (btn.dataset.search || '').includes(term);
          btn.style.display = matches ? '' : 'none';
          btn.tabIndex = matches ? 0 : -1;
          if (matches) visible += 1;
        });
        skillCount.textContent = totalSkills
          ? (visible === totalSkills
            ? `${totalSkills} active skills listed.`
            : `Showing ${visible} of ${totalSkills} active skills.`)
          : 'No active skills available.';
        skillEmpty.hidden = visible !== 0;
      }
      filterSkills();
      skillSearch.addEventListener('input', filterSkills);

      if (!container.dataset.listenerBound) {
        container.addEventListener('click', (e) => {
          const passiveBtn = e.target.closest('.chip.passive');
          if (passiveBtn) {
            e.preventDefault();
            const trait = passiveBtn.dataset.trait;
            showTraitDetail(trait);
            return;
          }
          const workPalCard = e.target.closest('.work-pal-card');
          if (workPalCard && workPalCard.dataset.palId) {
            e.preventDefault();
            showPalDetail(workPalCard.dataset.palId);
            return;
          }
          const partnerPalBtn = e.target.closest('.partner-skill-card__pal');
          if (partnerPalBtn) {
            e.preventDefault();
            const palId = partnerPalBtn.dataset.palId;
            if (palId) {
              showPalDetail(palId);
            }
            return;
          }
          const moveBtn = e.target.closest('.glossary-skill');
          if (moveBtn) {
            e.preventDefault();
            const key = moveBtn.dataset.skill;
            showSkillDetail(key);
          }
        });
        container.dataset.listenerBound = 'true';
      }
    }

    // Map page builder.  Creates toggles for different layers and
    // instructions to open the external interactive map.  We do not
    // re‑host community map tiles; instead we encourage opening
    // palworld.gg with the appropriate filters.  A simple overlay is
    // available via environment highlights but hidden by default.
    function buildMapPage() {
      const layers = document.getElementById('mapLayers');
      if (!layers) return;
      layers.innerHTML = '';
      const categories = [
        { name: 'Pals', desc: 'See spawn locations on the external map', url: 'https://palworld.gg/map' },
        { name: 'Alpha Pals', desc: 'Locate strong alpha variants', url: 'https://palworld.gg/map' },
        { name: 'Boss Arenas', desc: 'Find boss arenas and fast travel points', url: 'https://palworld.gg/map' },
        { name: 'Dungeons', desc: 'Open map to see dungeon entrances', url: 'https://palworld.gg/map' },
        { name: 'Effigies', desc: 'Locate Lifmunk Effigies for free levels', url: 'https://palworld.gg/map' },
        { name: 'Skill Fruit Trees', desc: 'Find Skill Fruit trees to learn moves', url: 'https://palworld.gg/map' },
        { name: 'Fast Travel', desc: 'Discover fast travel statues', url: 'https://palworld.gg/map' }
      ];
      categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = 'collect-btn';
        btn.style.margin = '4px';
        btn.textContent = cat.name;
        btn.addEventListener('click', () => {
          window.open(cat.url, '_blank');
        });
        layers.appendChild(btn);
      });
    }
    function buildProgressPage() {
      const guideText = document.getElementById('guideProgressText');
      if (guideText) {
        guideText.textContent = kidMode
          ? 'Check off story steps and boss wins to power up this bar!'
          : 'Check off route steps, boss clears, and story & optional quests to track your run.';
      }
      const bossQuestBadge = document.getElementById('bossQuestBadge');
      if (bossQuestBadge) {
        bossQuestBadge.textContent = 'Bosses: 0/0 • Questions: 0/0';
      }
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = kidMode
          ? 'Catch pals to fill your squad meter.'
          : 'Mark pals as caught to track your crew.';
      }
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = kidMode
          ? 'Unlock new gadgets to light up this meter.'
          : 'Unlock tech to power up your workshop.';
      }
      const stageTitle = document.getElementById('progressStageTitle');
      if (stageTitle) {
        stageTitle.textContent = kidMode
          ? 'Loading your adaptive stage…'
          : 'Loading your adaptive stage…';
      }
      const stageSubtitle = document.getElementById('progressStageSubtitle');
      if (stageSubtitle) {
        stageSubtitle.textContent = kidMode
          ? 'We’re lining up the next big milestone for your adventure.'
          : 'We’ll summarise the upcoming milestone once the guide data loads.';
      }
      const stageLabel = document.getElementById('progressStageLabel');
      if (stageLabel) {
        stageLabel.textContent = kidMode ? 'Big steps complete' : 'Required completion';
      }
      const queueSubtitle = document.getElementById('progressQueueSubtitle');
      if (queueSubtitle) {
        queueSubtitle.textContent = kidMode
          ? 'Pin adventures from the planner to keep them right here.'
          : 'Pin your active adaptive guides in the planner to keep them here.';
      }
      const stageResume = document.getElementById('progressStageResume');
      if (stageResume) {
        stageResume.textContent = kidMode ? 'Resume next step' : 'Resume next step';
        stageResume.disabled = true;
        if (!stageResume.dataset.bound) {
          stageResume.dataset.bound = 'true';
          stageResume.addEventListener('click', () => {
            const stepId = stageResume.dataset.stepId;
            switchPage('route');
            if (stepId) {
              queueRouteFocus(stepId);
            }
            playSound(clickSound);
          });
        }
      }
      const stagePlanner = document.getElementById('progressStagePlanner');
      if (stagePlanner && !stagePlanner.dataset.bound) {
        stagePlanner.dataset.bound = 'true';
        stagePlanner.addEventListener('click', () => {
          switchPage('route');
          playSound(clickSound);
        });
      }
      const queueManage = document.getElementById('progressQueueManage');
      if (queueManage) {
        if (!queueManage.dataset.bound) {
          queueManage.dataset.bound = 'true';
          queueManage.addEventListener('click', () => {
            switchPage('route');
            playSound(clickSound);
          });
        }
        queueManage.textContent = kidMode ? 'Manage queue' : 'Manage queue';
      }
      const routeLead = document.getElementById('progressRouteLead');
      if (routeLead) {
        routeLead.textContent = kidMode
          ? 'See boss wins, story quests, and upcoming big steps without leaving this dashboard.'
          : 'Review boss victories, story & optional quest progress, and upcoming priorities directly from the adaptive dashboard.';
      }
      document.querySelectorAll('[data-route-action="toggle-optional"]').forEach(btn => {
        btn.textContent = routeOptionalToggleLabel(routeHideOptional);
        btn.setAttribute('aria-pressed', routeHideOptional ? 'true' : 'false');
      });
      document.querySelectorAll('[data-route-action="jump-next"]').forEach(btn => {
        btn.disabled = true;
        btn.textContent = kidMode ? 'Loading next objective…' : 'Loading next objective…';
        btn.dataset.stepId = '';
      });
      const resetGuideBtn = document.getElementById('resetRouteProgress');
      if (resetGuideBtn) {
        resetGuideBtn.onclick = () => {
          if (confirm('Reset all guide progress?')) {
            localStorage.removeItem(ROUTE_STORAGE_KEY);
            routeState = {};
            renderRouteGuide();
            updateProgressUI();
          }
        };
      }
    }
    // Update progress bars
    function updateProgressUI() {
      const palsFallback = kidMode
        ? 'Catch pals to fill your squad meter.'
        : 'Mark pals as caught to track your crew.';
      const techFallback = kidMode
        ? 'Unlock new gadgets to light up this meter.'
        : 'Unlock tech to power up your workshop.';
      const guideFallback = kidMode
        ? 'Check off story steps to power up this bar!'
        : 'Check off route steps to track your run.';

      const totalPals = Object.keys(PALS).length;
      const caughtCount = Object.keys(caught).filter(k => caught[k]).length;
      const palsPct = totalPals ? Math.round((caughtCount / totalPals) * 100) : 0;
      const palsBar = document.getElementById('palsProgress');
      if (palsBar) palsBar.style.width = palsPct + '%';
      const palsMeter = document.getElementById('palsProgressMeter');
      if (palsMeter) palsMeter.setAttribute('aria-valuenow', palsPct);
      const palsText = document.getElementById('palsProgressText');
      if (palsText) {
        palsText.textContent = totalPals
          ? `${caughtCount} / ${totalPals} pals recruited`
          : palsFallback;
      }
      const homePalsBar = document.getElementById('homePalsProgressBar');
      if (homePalsBar) homePalsBar.style.width = palsPct + '%';
      const homePalsMeter = document.getElementById('homePalsProgressMeter');
      if (homePalsMeter) homePalsMeter.setAttribute('aria-valuenow', palsPct);
      const homePalsText = document.getElementById('homePalsProgressText');
      if (homePalsText) {
        if (totalPals) {
          homePalsText.textContent = kidMode
            ? `${caughtCount} pals recruited so far`
            : `${caughtCount} / ${totalPals} pals recruited`;
        } else {
          homePalsText.textContent = palsFallback;
        }
      }

      const homePalsNext = document.getElementById('homePalsNext');
      if (homePalsNext) {
        const nextPal = findNextPalTarget();
        if (nextPal) {
          const typeLabel = Array.isArray(nextPal.types) && nextPal.types.length
            ? nextPal.types.join(kidMode ? ' & ' : ' / ')
            : (kidMode ? 'Mystery type' : 'Type unknown');
          homePalsNext.textContent = kidMode
            ? `Next recruit: ${nextPal.name}`
            : `Next recruit: ${nextPal.name} — ${typeLabel}`;
          homePalsNext.dataset.palId = nextPal.id || '';
        } else {
          homePalsNext.textContent = caughtCount && totalPals
            ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete! Open the pal list to revisit favourites.')
            : (kidMode ? 'Pal list loading…' : 'Pal data loading…');
          homePalsNext.dataset.palId = '';
        }
        homePalsNext.disabled = false;
      }

      let totalRecipes = 0;
      (Array.isArray(TECH) ? TECH : []).forEach(lvl => {
        if (lvl && Array.isArray(lvl.items)) {
          totalRecipes += lvl.items.length;
        }
      });
      const unlockedCount = Object.keys(unlocked).filter(k => unlocked[k]).length;
      const techPct = totalRecipes ? Math.round((unlockedCount / totalRecipes) * 100) : 0;
      const techBar = document.getElementById('techProgress');
      if (techBar) techBar.style.width = techPct + '%';
      const techMeter = document.getElementById('techProgressMeter');
      if (techMeter) techMeter.setAttribute('aria-valuenow', techPct);
      const techText = document.getElementById('techProgressText');
      if (techText) {
        techText.textContent = totalRecipes
          ? `${unlockedCount} / ${totalRecipes} inventions unlocked`
          : techFallback;
      }
      const homeTechBar = document.getElementById('homeTechProgressBar');
      if (homeTechBar) homeTechBar.style.width = techPct + '%';
      const homeTechMeter = document.getElementById('homeTechProgressMeter');
      if (homeTechMeter) homeTechMeter.setAttribute('aria-valuenow', techPct);
      const homeTechText = document.getElementById('homeTechProgressText');
      if (homeTechText) {
        if (totalRecipes) {
          homeTechText.textContent = kidMode
            ? `${unlockedCount} inventions unlocked`
            : `${unlockedCount} / ${totalRecipes} inventions unlocked`;
        } else {
          homeTechText.textContent = techFallback;
        }
      }

      const nextTech = findNextTechUnlock();
      const homeTechNext = document.getElementById('homeTechNext');
      if (homeTechNext) {
        if (nextTech && nextTech.item) {
          const levelLabel = nextTech.level && nextTech.level.level != null
            ? `Lv ${nextTech.level.level}`
            : (kidMode ? '' : 'Lv ?');
          homeTechNext.textContent = kidMode
            ? `Next unlock: ${nextTech.item.name}${levelLabel ? ` (${levelLabel})` : ''}`
            : `Next unlock: ${levelLabel || 'Level ?'} — ${nextTech.item.name}`;
          homeTechNext.dataset.techKey = nextTech.techKey || '';
        } else {
          homeTechNext.textContent = kidMode
            ? 'Workshop complete! Explore favourites.'
            : 'Workshop complete! Review unlocked blueprints anytime.';
          homeTechNext.dataset.techKey = '';
        }
        homeTechNext.disabled = false;
      }

      const guideSummary = calculateGuideProgressSummary();
      const nextRequired = findNextRouteStep();
      const nextAny = nextRequired || findNextRouteStep({ includeOptional: true });
      const stageSnapshot = determineGuideStageSnapshot();
      const guideBar = document.getElementById('guideProgress');
      if (guideBar) guideBar.style.width = guideSummary.percent + '%';
      const guideMeter = document.getElementById('guideProgressMeter');
      if (guideMeter) guideMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const guideText = document.getElementById('guideProgressText');
      const coreRouteStats = guideSummary.routes?.core || { total: 0, complete: 0 };
      if (guideText) {
        if (guideSummary.requiredTotal) {
          const stepLine = `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} guide steps complete`;
          const routeLine = coreRouteStats.total
            ? ` • ${coreRouteStats.complete}/${coreRouteStats.total} core routes cleared`
            : '';
          guideText.textContent = stepLine + routeLine;
        } else {
          guideText.textContent = guideFallback;
        }
      }
      const homeRouteBar = document.getElementById('homeRouteProgressBar');
      if (homeRouteBar) homeRouteBar.style.width = guideSummary.percent + '%';
      const homeRouteMeter = document.getElementById('homeRouteProgressMeter');
      if (homeRouteMeter) homeRouteMeter.setAttribute('aria-valuenow', guideSummary.percent);
      const homeRouteText = document.getElementById('homeRouteProgressText');
      if (homeRouteText) {
        if (guideSummary.requiredTotal) {
          const routeLine = coreRouteStats.total
            ? kidMode
              ? ` • ${coreRouteStats.complete}/${coreRouteStats.total} adventures`
              : ` • ${coreRouteStats.complete}/${coreRouteStats.total} core routes`
            : '';
          homeRouteText.textContent = kidMode
            ? `${guideSummary.requiredComplete} of ${guideSummary.requiredTotal} big steps done${routeLine}`
            : `${guideSummary.requiredComplete} / ${guideSummary.requiredTotal} required steps complete${routeLine}`;
        } else {
          homeRouteText.textContent = guideFallback;
        }
      }
      const homeRouteNext = document.getElementById('homeRouteNextStep');
      if (homeRouteNext) {
        if (nextAny && nextAny.step) {
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          const stepCopy = kidMode
            ? (nextAny.step.textKid || nextAny.step.text || '')
            : (nextAny.step.text || nextAny.step.textKid || '');
          const prefix = nextAny.step.optional && !nextRequired
            ? (kidMode ? 'Bonus step' : 'Optional step')
            : (kidMode ? 'Next step' : 'Next required step');
          const chapterHtml = chapterTitle ? ` — <strong>${escapeHTML(chapterTitle)}</strong>` : '';
          homeRouteNext.innerHTML = `${escapeHTML(prefix)}${chapterHtml}<br>${escapeHTML(stepCopy)}`;
          homeRouteNext.dataset.stepId = nextAny.step.id || '';
          homeRouteNext.disabled = false;
        } else {
          homeRouteNext.textContent = kidMode
            ? 'Guide complete! Revisit bonus adventures anytime.'
            : 'Guide complete! Revisit optional chores or rerun boss fights.';
          homeRouteNext.dataset.stepId = '';
          homeRouteNext.disabled = true;
        }
      }
      const guideDataReady = !!(routeGuideData && Array.isArray(routeGuideData.chapters) && routeGuideData.chapters.length);
      const stageIndex = stageSnapshot && Number.isInteger(stageSnapshot.stageIndex)
        ? stageSnapshot.stageIndex + 1
        : null;
      const stageTitleTextKid = stageSnapshot
        ? (stageSnapshot.stageTitleKid || stageSnapshot.stageTitleGrown || 'Adaptive stage')
        : 'Adaptive stage';
      const stageTitleTextGrown = stageSnapshot
        ? (stageSnapshot.stageTitleGrown || stageSnapshot.stageTitleKid || 'Adaptive stage')
        : 'Adaptive stage';
      const stageTitleText = kidMode ? stageTitleTextKid : stageTitleTextGrown;
      const stageHeadline = guideDataReady
        ? (stageIndex ? `Stage ${stageIndex}: ${stageTitleText}` : stageTitleText)
        : (kidMode ? 'Loading adaptive stage…' : 'Loading adaptive stage…');
      const heroHeadline = document.getElementById('homeAdaptiveHeadline');
      if (heroHeadline) {
        heroHeadline.textContent = stageHeadline;
      }
      const nextStepCopy = nextAny && nextAny.step
        ? (kidMode ? (nextAny.step.textKid || nextAny.step.text || '') : (nextAny.step.text || nextAny.step.textKid || ''))
        : '';
      const remainingRequired = guideSummary.requiredTotal
        ? Math.max(0, guideSummary.requiredTotal - guideSummary.requiredComplete)
        : null;
      const remainingText = remainingRequired != null
        ? remainingRequired === 0
          ? (kidMode ? 'All big steps complete' : 'All required steps complete')
          : `${remainingRequired} ${kidMode ? (remainingRequired === 1 ? 'big step left' : 'big steps left') : (remainingRequired === 1 ? 'required step remaining' : 'required steps remaining')}`
        : '';
      const heroSubhead = document.getElementById('homeAdaptiveSubhead');
      if (heroSubhead) {
        if (guideDataReady) {
          const parts = [];
          if (remainingText) parts.push(remainingText);
          if (nextStepCopy) parts.push(`${kidMode ? 'Next' : 'Next'}: ${nextStepCopy}`);
          heroSubhead.textContent = parts.length
            ? parts.join(' • ')
            : (kidMode
              ? 'Palmate is lining up the perfect adventures for tonight.'
              : 'Palmate is analysing your adaptive route and next milestones.');
        } else {
          heroSubhead.textContent = kidMode
            ? 'Palmate is lining up the perfect adventures for tonight.'
            : 'Palmate is analysing your adaptive route and next milestones.';
        }
      }
      const focusTitle = document.getElementById('homeHeroFocusTitle');
      if (focusTitle) {
        if (guideDataReady && nextAny && nextAny.chapter) {
          const chapterTitle = routeChapterTitle(nextAny.chapter);
          focusTitle.textContent = chapterTitle || stageHeadline;
        } else {
          focusTitle.textContent = guideDataReady ? (kidMode ? 'All caught up!' : 'All caught up!') : (kidMode ? 'Adaptive plan loading…' : 'Adaptive plan loading…');
        }
      }
      const focusCopy = document.getElementById('homeHeroFocusCopy');
      if (focusCopy) {
        if (guideDataReady) {
          focusCopy.textContent = nextStepCopy
            ? nextStepCopy
            : (kidMode
              ? 'Queue a new adventure from the planner to keep the journey rolling.'
              : 'Queue a new adaptive guide from the planner to keep momentum.');
        } else {
          focusCopy.textContent = kidMode
            ? 'We’ll show the next big step once the guide finishes loading.'
            : 'We’ll surface the next required step as soon as the adaptive guide finishes loading.';
        }
      }
      const focusMeter = document.getElementById('homeHeroFocusMeter');
      if (focusMeter) {
        focusMeter.setAttribute('aria-valuenow', guideSummary.percent);
      }
      const focusFill = document.getElementById('homeHeroFocusFill');
      if (focusFill) {
        focusFill.style.width = guideSummary.percent + '%';
      }
      const homeHeroResume = document.getElementById('homeHeroResume');
      if (homeHeroResume) {
        if (guideDataReady && nextAny && nextAny.step) {
          homeHeroResume.dataset.stepId = nextAny.step.id || '';
          homeHeroResume.disabled = false;
          homeHeroResume.textContent = kidMode ? 'Resume next step' : 'Resume next step';
        } else {
          homeHeroResume.dataset.stepId = '';
          homeHeroResume.disabled = true;
          homeHeroResume.textContent = guideDataReady ? (kidMode ? 'All caught up!' : 'All caught up!') : (kidMode ? 'Loading…' : 'Loading…');
        }
      }
      const progressStageTitleEl = document.getElementById('progressStageTitle');
      if (progressStageTitleEl) {
        progressStageTitleEl.textContent = stageHeadline;
      }
      const progressStageSubtitle = document.getElementById('progressStageSubtitle');
      if (progressStageSubtitle) {
        if (guideDataReady && nextStepCopy) {
          progressStageSubtitle.textContent = kidMode
            ? `Next up: ${nextStepCopy}`
            : `Next objective: ${nextStepCopy}`;
        } else {
          progressStageSubtitle.textContent = guideDataReady
            ? (kidMode
              ? 'All big steps complete! Queue optional adventures from the planner.'
              : 'All required steps complete—queue optional support routes whenever you like.')
            : (kidMode
              ? 'We’re warming up your adaptive stage. Hang tight!'
              : 'Adaptive stage insights will appear once the guide loads.');
        }
      }
      const progressStageMeter = document.getElementById('progressStageMeter');
      if (progressStageMeter) {
        progressStageMeter.setAttribute('aria-valuenow', guideSummary.percent);
      }
      const progressStageFill = document.getElementById('progressStageFill');
      if (progressStageFill) {
        progressStageFill.style.width = guideSummary.percent + '%';
      }
      const progressStageResume = document.getElementById('progressStageResume');
      if (progressStageResume) {
        if (guideDataReady && nextAny && nextAny.step) {
          progressStageResume.dataset.stepId = nextAny.step.id || '';
          progressStageResume.disabled = false;
          progressStageResume.textContent = kidMode ? 'Resume next step' : 'Resume next step';
        } else {
          progressStageResume.dataset.stepId = '';
          progressStageResume.disabled = true;
          progressStageResume.textContent = guideDataReady ? (kidMode ? 'All caught up!' : 'All caught up!') : (kidMode ? 'Loading…' : 'Loading…');
        }
      }
      const renderAdaptiveQueue = (containerId, { limit } = {}) => {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';
        if (!routeGuideData || !routeGuideData.routeLookup) {
          const item = document.createElement('li');
          item.className = 'adaptive-queue__item';
          const meta = document.createElement('div');
          meta.className = 'adaptive-queue__meta';
          const title = document.createElement('p');
          title.className = 'adaptive-queue__title';
          title.textContent = kidMode ? 'Queue loading…' : 'Queue loading…';
          const stats = document.createElement('p');
          stats.className = 'adaptive-queue__stats';
          stats.textContent = kidMode
            ? 'Hang tight while we load your guides.'
            : 'Adaptive guides are still loading.';
          meta.appendChild(title);
          meta.appendChild(stats);
          item.appendChild(meta);
          container.appendChild(item);
          return;
        }
        const queueRoutes = Array.from(activeRouteIds)
          .map(id => routeGuideData.routeLookup[id])
          .filter(Boolean);
        if (!queueRoutes.length) {
          const item = document.createElement('li');
          item.className = 'adaptive-queue__item';
          const meta = document.createElement('div');
          meta.className = 'adaptive-queue__meta';
          const title = document.createElement('p');
          title.className = 'adaptive-queue__title';
          title.textContent = kidMode ? 'No guides pinned yet' : 'No guides pinned yet';
          const stats = document.createElement('p');
          stats.className = 'adaptive-queue__stats';
          stats.textContent = kidMode
            ? 'Pick an adventure in the planner to keep it here.'
            : 'Select an adaptive guide in the planner to track it here.';
          meta.appendChild(title);
          meta.appendChild(stats);
          item.appendChild(meta);
          container.appendChild(item);
          return;
        }
        const slice = limit ? queueRoutes.slice(0, limit) : queueRoutes;
        slice.forEach(route => {
          const li = document.createElement('li');
          li.className = 'adaptive-queue__item';
          const meta = document.createElement('div');
          meta.className = 'adaptive-queue__meta';
          const title = document.createElement('p');
          title.className = 'adaptive-queue__title';
          title.textContent = route.title || routeChapterTitle(route.chapter) || 'Guide';
          const stats = document.createElement('p');
          stats.className = 'adaptive-queue__stats';
          const progress = chapterProgress(route.chapter);
          const requiredCount = progress.requiredCount;
          const requiredChecked = progress.requiredChecked;
          const progressLabel = requiredCount
            ? `${requiredChecked}/${requiredCount} ${kidMode ? 'big steps' : 'required steps'}`
            : (kidMode ? 'No required steps' : 'No required steps');
          const roleLabel = route.progression_role === 'core'
            ? (kidMode ? 'Core adventure' : 'Core route')
            : route.progression_role === 'support'
              ? (kidMode ? 'Support prep' : 'Support route')
              : (kidMode ? 'Optional fun' : 'Optional route');
          stats.textContent = `${progressLabel} • ${roleLabel}`;
          meta.appendChild(title);
          meta.appendChild(stats);
          li.appendChild(meta);
          const nextRouteStep = findNextStepForChapter(route.chapter) || findNextStepForChapter(route.chapter, { includeOptional: true });
          const cta = document.createElement('button');
          cta.type = 'button';
          cta.className = 'adaptive-queue__cta';
          const icon = document.createElement('i');
          icon.className = 'fa-solid fa-arrow-up-right-from-square';
          icon.setAttribute('aria-hidden', 'true');
          const span = document.createElement('span');
          if (nextRouteStep) {
            span.textContent = kidMode ? 'Resume' : 'Resume';
            cta.dataset.stepId = nextRouteStep.id || '';
            cta.addEventListener('click', () => {
              switchPage('route');
              queueRouteFocus(nextRouteStep.id);
              playSound(clickSound);
            });
          } else {
            span.textContent = kidMode ? 'Review' : 'Review';
            cta.dataset.stepId = '';
            cta.addEventListener('click', () => {
              switchPage('route');
              playSound(clickSound);
            });
          }
          cta.appendChild(icon);
          cta.appendChild(span);
          li.appendChild(cta);
          container.appendChild(li);
        });
      };
      renderAdaptiveQueue('homeActiveQueue', { limit: 3 });
      renderAdaptiveQueue('progressActiveQueue');
      const bossQuestBadgeLive = document.getElementById('bossQuestBadge');
      if (bossQuestBadgeLive) {
        const bossesLine = guideSummary.bossesTotal
          ? `${guideSummary.bossesComplete}/${guideSummary.bossesTotal}`
          : '0/0';
        const questsLine = guideSummary.questsTotal
          ? `${guideSummary.questsComplete}/${guideSummary.questsTotal}`
          : '0/0';
        bossQuestBadgeLive.textContent = `Bosses: ${bossesLine} • Questions: ${questsLine}`;
      }

      const spotlightBtn = document.getElementById('homePalSpotlight');
      if (spotlightBtn) {
        const primaryPal = findNextPalTarget();
        const spotlightPal = primaryPal || findRandomPalCandidate();
        if (spotlightPal) {
          const typeLabel = Array.isArray(spotlightPal.types) && spotlightPal.types.length
            ? spotlightPal.types.join(' • ')
            : '';
          const metaText = primaryPal
            ? (kidMode ? 'Next pal to recruit' : 'Next pal to recruit')
            : (caughtCount === totalPals && totalPals
              ? (kidMode ? 'Squad complete! Tap to browse pals.' : 'Squad complete — browse pals anytime.')
              : (kidMode ? 'Suggested pal to train next' : 'Suggested pal to train next'));
          const typesHtml = typeLabel
            ? `<span class="home-spotlight-card__types">${escapeHTML(typeLabel)}</span>`
            : '';
          spotlightBtn.innerHTML = `
            <img alt="">
            <div class="home-spotlight-card__text">
              <span class="home-spotlight-card__title">${escapeHTML(spotlightPal.name || 'Pal')}</span>
              <span class="home-spotlight-card__meta">${escapeHTML(metaText)}</span>
              ${typesHtml}
            </div>
          `;
          const spotlightImg = spotlightBtn.querySelector('img');
          applyPalArtwork(spotlightImg, spotlightPal, { alt: `${spotlightPal.name || 'Pal'} portrait` });
          spotlightBtn.dataset.palId = spotlightPal.id || '';
          spotlightBtn.disabled = false;
        } else {
          spotlightBtn.innerHTML = '<div class="home-spotlight-card__text"><span class="home-spotlight-card__title">Pal data loading…</span><span class="home-spotlight-card__meta">Keep playing while we fetch pals.</span></div>';
          spotlightBtn.dataset.palId = '';
          spotlightBtn.disabled = true;
        }
      }
      updateRouteOverviewUI(guideSummary);
      requestBaseBreedingRefresh();
    }

    // Display detailed information about an item using a Palworld-inspired card.
    function openItemDetail(itemKey) {
      const item = ITEMS[itemKey] || {};
      const detail = ITEM_DETAILS[itemKey] || {};
      if (!Object.keys(item).length && !Object.keys(detail).length) return;
      const human = detail.name || humaniseItemKey(itemKey);
      const slug = PALWORLD_ITEM_SLUG_OVERRIDES[itemKey] || slugifyForPalworld(human);
      const itemUrl = slug ? `${PALWORLD_BASE_URL}/item/${slug}` : `${PALWORLD_BASE_URL}/items`;
      const fallbackUrl = `${PALWORLD_BASE_URL}/items?search=${encodeURIComponent(human)}`;
      const drops = (DROPS_MAP[itemKey] || []).slice();
      const collectedStatus = !!collected[itemKey];
      const recipes = [];
      const ranchProducers = Array.isArray(detail.ranchProducers)
        ? detail.ranchProducers
        : (Array.isArray(item.ranchProducers) ? item.ranchProducers : []);
      const categoryLabel = detail.type || item.category || 'Item';
      TECH.forEach(level => {
        level.items.forEach(it => {
          if (it.materials && it.materials[itemKey]) {
            recipes.push({ name: it.name, qty: it.materials[itemKey], level: level.level });
          }
        });
      });
      modalBody.innerHTML = '';
      const card = document.createElement('article');
      card.className = 'item-detail-card';

      let dropSection = null;
      let guidesRendered = false;
      const renderGuideChips = (data) => {
        if (guidesRendered || !data) return;
        const entries = Array.isArray(data?.resourceGuides?.[itemKey]) ? data.resourceGuides[itemKey] : [];
        if (!entries.length) return;
        const guideSection = document.createElement('section');
        guideSection.className = 'item-detail-section item-detail-guides';
        const guideHeading = document.createElement('h4');
        guideHeading.textContent = kidMode ? 'Guides to start' : 'Guide shortcuts';
        guideSection.appendChild(guideHeading);
        const chipsWrap = document.createElement('div');
        chipsWrap.className = 'item-guide-chip-list';
        entries.forEach(entry => {
          if (!entry || !entry.id) return;
          const chip = document.createElement('button');
          chip.type = 'button';
          chip.className = 'chip item-guide-chip';
          chip.dataset.routeId = entry.id;
          const body = document.createElement('span');
          body.className = 'chip__body';
          const label = document.createElement('span');
          label.className = 'chip__label';
          label.textContent = entry.title || niceName(entry.id);
          body.appendChild(label);
          const metaParts = [];
          if (entry.levelLabel) metaParts.push(entry.levelLabel);
          if (entry.timeLabel) metaParts.push(entry.timeLabel);
          if (metaParts.length) {
            const meta = document.createElement('span');
            meta.className = 'chip__meta';
            meta.textContent = metaParts.join(' • ');
            body.appendChild(meta);
          }
          chip.appendChild(body);
          const tooltipParts = [];
          if (entry.summary) tooltipParts.push(entry.summary);
          if (Array.isArray(entry.shortageNotes) && entry.shortageNotes.length) {
            tooltipParts.push(entry.shortageNotes[0]);
          }
          if (tooltipParts.length) {
            chip.title = tooltipParts.join(' • ');
          }
          chip.addEventListener('click', () => {
            openRoutePreviewById(entry.id);
          });
          chipsWrap.appendChild(chip);
        });
        if (!chipsWrap.children.length) return;
        const count = chipsWrap.children.length;
        guideHeading.textContent = kidMode
          ? (count === 1 ? 'Guide to start' : 'Guides to start')
          : (count === 1 ? 'Guide shortcut' : 'Guide shortcuts');
        guideSection.appendChild(chipsWrap);
        if (dropSection && dropSection.parentNode === card) {
          card.insertBefore(guideSection, dropSection);
        } else {
          card.appendChild(guideSection);
        }
        guidesRendered = true;
      };

      const header = document.createElement('div');
      header.className = 'item-detail-header';
      const headingWrap = document.createElement('div');
      headingWrap.className = 'item-detail-heading';
      const art = document.createElement('div');
      art.className = 'item-detail-image';
      const renderPlaceholder = () => {
        if (!art.querySelector('.item-detail-placeholder')) {
          const placeholder = document.createElement('div');
          placeholder.className = 'item-detail-placeholder';
          placeholder.innerHTML = '<i class="fa-solid fa-box"></i>';
          art.appendChild(placeholder);
        }
      };
      if (detail.image) {
        const img = document.createElement('img');
        img.src = detail.image;
        img.alt = human;
        img.loading = 'lazy';
        img.decoding = 'async';
        img.referrerPolicy = 'no-referrer';
        img.onerror = () => {
          img.remove();
          renderPlaceholder();
        };
        art.appendChild(img);
      }
      if (!art.hasChildNodes()) {
        renderPlaceholder();
      }
      const meta = document.createElement('div');
      meta.className = 'item-detail-meta';
      const titleEl = document.createElement('h3');
      titleEl.textContent = human;
      const typeEl = document.createElement('span');
      const typeLabel = categoryLabel;
      typeEl.className = 'type-tag';
      typeEl.textContent = typeLabel;
      meta.appendChild(titleEl);
      meta.appendChild(typeEl);
      headingWrap.appendChild(art);
      headingWrap.appendChild(meta);
      header.appendChild(headingWrap);
      const collectBtn = document.createElement('button');
      collectBtn.className = `detail-collect-btn${collectedStatus ? ' collected' : ''}`;
      collectBtn.textContent = collectedStatus ? 'Collected' : 'Mark as collected';
      collectBtn.addEventListener('click', () => {
        collected[itemKey] = !collected[itemKey];
        localStorage.setItem('collected', JSON.stringify(collected));
        const state = !!collected[itemKey];
        collectBtn.classList.toggle('collected', state);
        collectBtn.textContent = state ? 'Collected' : 'Mark as collected';
        updateItemCollectionButtons(itemKey);
        requestBaseBreedingRefresh({ refreshBreedingAnalysis: true });
        updateProgressUI();
        playSound(clickSound);
      });
      header.appendChild(collectBtn);
      card.appendChild(header);

      const descriptionLines = Array.isArray(detail.description) && detail.description.length
        ? detail.description
        : [`${human} belongs to the ${categoryLabel} family.`];
      const descWrapper = document.createElement('div');
      descWrapper.className = 'item-detail-description';
      const maxParagraphs = kidMode ? Math.min(2, descriptionLines.length) : descriptionLines.length;
      for (let idx = 0; idx < maxParagraphs; idx += 1) {
        const p = document.createElement('p');
        p.textContent = descriptionLines[idx];
        descWrapper.appendChild(p);
      }
      card.appendChild(descWrapper);

      const statsEntries = Object.entries(detail.stats || {});
      if (categoryLabel && !statsEntries.some(entry => entry[0].toLowerCase() === 'category')) {
        statsEntries.push(['Category', categoryLabel]);
      }
      if (statsEntries.length) {
        const statGrid = document.createElement('div');
        statGrid.className = 'item-detail-stats';
        statsEntries.forEach(([label, value]) => {
          const pill = document.createElement('div');
          pill.className = 'stat-pill';
          const labelSpan = document.createElement('span');
          labelSpan.className = 'label';
          labelSpan.textContent = label;
          const valueSpan = document.createElement('span');
          valueSpan.className = 'value';
          valueSpan.textContent = value;
          pill.appendChild(labelSpan);
          pill.appendChild(valueSpan);
          statGrid.appendChild(pill);
        });
        card.appendChild(statGrid);
      }

      const summarySection = document.createElement('section');
      summarySection.className = 'item-detail-section item-detail-summary';
      const summaryHeading = document.createElement('h4');
      summaryHeading.textContent = kidMode ? 'Quick Take' : 'Tracker Notes';
      summarySection.appendChild(summaryHeading);
      if (kidMode) {
        const dropPreview = drops.length ? drops.slice(0, 4).join(', ') + (drops.length > 4 ? '…' : '') : 'Not sure yet';
        const ranchPreview = ranchProducers.length
          ? ranchProducers.slice(0, 4).join(', ') + (ranchProducers.length > 4 ? '…' : '')
          : 'Not recorded yet';
        const summaryLines = [
          `Status: ${collectedStatus ? 'We have this item!' : 'Let’s go find this!'}`,
          `Item type: ${typeLabel}`,
          `Find it from: ${dropPreview}`,
          `Ranch pals: ${ranchPreview}`
        ];
        if (recipes.length) {
          summaryLines.push(`Used for: ${recipes.length} tech unlock${recipes.length === 1 ? '' : 's'}.`);
        }
        summaryLines.forEach(line => {
          const p = document.createElement('p');
          p.textContent = line;
          summarySection.appendChild(p);
        });
      } else {
        const summaryList = document.createElement('ul');
        const lines = [
          `Tracking status: ${collectedStatus ? 'Collected' : 'Not collected yet'}`,
          `Category: ${categoryLabel}`,
          drops.length ? `Drops recorded: ${drops.length}` : 'Drops recorded: none yet',
          ranchProducers.length
            ? `Ranch producers: ${ranchProducers.join(', ')}`
            : 'Ranch producers: none recorded yet',
          recipes.length ? `Tech unlocks: ${recipes.length} recipe${recipes.length === 1 ? '' : 's'} listed below.` : 'Tech unlocks: none recorded yet.'
        ];
        if (detail.fromPalworld === false) {
          lines.push('Data source: Palmate placeholder entry until Palworld.gg publishes more info.');
        } else {
          lines.push('Data source: Palworld.gg item compendium.');
        }
        lines.forEach(text => {
          const li = document.createElement('li');
          li.textContent = text;
          summaryList.appendChild(li);
        });
        summarySection.appendChild(summaryList);
      }
      card.appendChild(summarySection);

      if (routeGuideData && routeGuideData.resourceGuides) {
        renderGuideChips(routeGuideData);
      } else {
        ensureRouteGuide().then(renderGuideChips).catch(() => {});
      }

      dropSection = document.createElement('section');
      dropSection.className = 'item-detail-section';
      const dropHeading = document.createElement('h4');
      dropHeading.textContent = 'Dropped by';
      dropSection.appendChild(dropHeading);
      if (drops.length) {
        const dropList = document.createElement('div');
        dropList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, drops.length) : drops.length;
        drops.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          dropList.appendChild(chip);
        });
        if (drops.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${drops.length - limit} more`;
          dropList.appendChild(more);
        }
        dropSection.appendChild(dropList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to drop this item yet.';
        dropSection.appendChild(none);
      }
      card.appendChild(dropSection);

      const ranchSection = document.createElement('section');
      ranchSection.className = 'item-detail-section';
      const ranchHeading = document.createElement('h4');
      ranchHeading.textContent = 'Ranch producers';
      ranchSection.appendChild(ranchHeading);
      if (ranchProducers.length) {
        const ranchList = document.createElement('div');
        ranchList.className = 'chip-list';
        const limit = kidMode ? Math.min(6, ranchProducers.length) : ranchProducers.length;
        ranchProducers.slice(0, limit).forEach((name, index) => {
          const chip = document.createElement('span');
          chip.className = 'chip';
          if (index === 0) chip.classList.add('highlight');
          chip.textContent = name;
          ranchList.appendChild(chip);
        });
        if (ranchProducers.length > limit) {
          const more = document.createElement('span');
          more.className = 'chip';
          more.textContent = `+${ranchProducers.length - limit} more`;
          ranchList.appendChild(more);
        }
        ranchSection.appendChild(ranchList);
      } else {
        const none = document.createElement('p');
        none.textContent = 'No pals are confirmed to produce this item at the ranch yet.';
        ranchSection.appendChild(none);
      }
      card.appendChild(ranchSection);

      if (Array.isArray(detail.recipe) && detail.recipe.length) {
        const recipeSection = document.createElement('section');
        recipeSection.className = 'item-detail-section';
        const recipeHeading = document.createElement('h4');
        recipeHeading.textContent = 'Crafting recipe';
        recipeSection.appendChild(recipeHeading);
        const ingredientGrid = document.createElement('div');
        ingredientGrid.className = 'ingredient-grid';
        detail.recipe.forEach(entry => {
          const ingredientCard = document.createElement('div');
          ingredientCard.className = 'ingredient-card';
          if (entry.icon) {
            const img = document.createElement('img');
            img.src = entry.icon;
            img.alt = entry.name;
            img.loading = 'lazy';
            ingredientCard.appendChild(img);
          }
          const textWrap = document.createElement('div');
          textWrap.className = 'ingredient-text';
          const nameEl = document.createElement('div');
          nameEl.className = 'name';
          nameEl.textContent = entry.name;
          textWrap.appendChild(nameEl);
          if (entry.quantity) {
            const qty = document.createElement('div');
            qty.textContent = `x${entry.quantity}`;
            textWrap.appendChild(qty);
          }
          ingredientCard.appendChild(textWrap);
          ingredientGrid.appendChild(ingredientCard);
        });
        recipeSection.appendChild(ingredientGrid);
        card.appendChild(recipeSection);
      }

      if (recipes.length) {
        const techSection = document.createElement('section');
        techSection.className = 'item-detail-section';
        const techHeading = document.createElement('h4');
        techHeading.textContent = 'Used in tech';
        techSection.appendChild(techHeading);
        const techList = document.createElement('ul');
        const maxEntries = kidMode ? Math.min(5, recipes.length) : recipes.length;
        recipes.slice(0, maxEntries).forEach(recipe => {
          const li = document.createElement('li');
          li.textContent = `Level ${recipe.level}: ${recipe.name} (x${recipe.qty})`;
          techList.appendChild(li);
        });
        if (recipes.length > maxEntries) {
          const li = document.createElement('li');
          li.textContent = `+${recipes.length - maxEntries} more unlock${recipes.length - maxEntries === 1 ? '' : 's'} in higher tiers.`;
          techList.appendChild(li);
        }
        techSection.appendChild(techList);
        card.appendChild(techSection);
      }

      const footer = document.createElement('div');
      footer.className = 'item-detail-footer';
      const link = document.createElement('a');
      link.href = slug ? itemUrl : fallbackUrl;
      link.target = '_blank';
      link.rel = 'noopener';
      link.textContent = detail.fromPalworld === false ? 'Search on Palworld.gg' : 'View on Palworld.gg';
      footer.appendChild(link);
      const note = document.createElement('p');
      note.className = 'item-detail-note';
      note.textContent = detail.fromPalworld === false
        ? 'Palworld.gg has not published a full entry for this item yet. Details shown use Palmate data.'
        : 'Stats, art, and rarities mirror the Palworld.gg item database.';
      footer.appendChild(note);
      card.appendChild(footer);

      modalBody.appendChild(card);
      openModal();
    }

    // Show details about an active skill.  Looks up the skill in the
    // dictionary; if it’s missing we display a generic placeholder.
    function showSkillDetail(key) {
      const normalisedKey = key.toLowerCase().replace(/[\s-]+/g, '_');
      const info = skillsDictionary[normalisedKey] || skillsDictionary[key] || { name: key.replace(/_/g,' '), damage: 'Unknown', type: 'Unknown', description: 'This skill\'s effects are a mystery! Try it out in battle.' };
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${info.name}</h3><p><strong>Damage:</strong> ${info.damage}</p><p><strong>Type:</strong> ${info.type}</p><p>${info.description}</p>`;
      modalBody.appendChild(div);
      openModal();
    }

    // Show details about a passive trait.  Retrieves the description
    // from the trait dictionary.  Unknown traits yield a default
    // explanation encouraging exploration.
    function showTraitDetail(name) {
      const desc = traitsDictionary[name] || 'This trait has mysterious effects that aren\'t fully documented. See how it behaves in-game!';
      modalBody.innerHTML = '';
      const div = document.createElement('div');
      div.innerHTML = `<h3>${name}</h3><p>${desc}</p>`;
      modalBody.appendChild(div);
      openModal();
    }
  </script>
</body>
</html>
