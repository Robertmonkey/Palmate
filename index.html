    .glossary-skill__fruit {
      font-size: 0.75rem;
      color: rgba(224, 225, 221, 0.6);
      margin-bottom: 6px;
      display: block;
    }
    .trait-detail-list,
    .skill-detail-list {
      margin: 0 0 1rem;
      display: grid;
      grid-template-columns: max-content 1fr;
      gap: 0.25rem 0.75rem;
    }
    .trait-detail-list dt,
    .skill-detail-list dt {
      font-weight: 600;
    }
    .trait-detail-list dd,
    .skill-detail-list dd {
      margin: 0 0 0.25rem;
    }
    const defaultTraitsDictionaryRaw = {

    function normalizeTraitDictionary(map) {
      const normalized = {};
      Object.entries(map || {}).forEach(([name, value]) => {
        if (!name) return;
        if (value && typeof value === 'object' && !Array.isArray(value)) {
          const entry = { ...value };
          if (!entry.name) {
            entry.name = name;
          }
          if (typeof entry.description !== 'string' || !entry.description.trim()) {
            entry.description = entry.effect || 'No description available.';
          }
          normalized[name] = entry;
        } else {
          normalized[name] = {
            name,
            description: typeof value === 'string'
              ? value
              : 'No description available.'
          };
        }
      });
      return normalized;
    }

    const defaultTraitsDictionary = normalizeTraitDictionary(defaultTraitsDictionaryRaw);
            const name = (info.name || key).replace(/_/g, ' ');
            const element = info.element || info.type || 'Unknown';
            const power = typeof info.power === 'number' ? info.power : null;
            const cooldown = info.ct != null ? info.ct : (info.cooldown != null ? info.cooldown : null);
            const description = info.description || 'No description available.';
            const skillFruit = info.skillFruit || info.fruit || null;
            const entry = {
              name,
              element,
              type: element || 'Unknown',
              description,
              damage: power != null ? `Power ${power}` : (info.damage || 'Unknown')
            if (power != null) entry.power = power;
            if (cooldown != null) {
              entry.ct = cooldown;
              entry.cooldown = cooldown;
            }
            if (skillFruit) entry.skillFruit = skillFruit;
            normalizedSkills[normalizedKey] = entry;
          traitsDictionary = normalizeTraitDictionary({ ...defaultTraitsDictionaryRaw, ...PASSIVE_DETAILS });
        } else {
          traitsDictionary = { ...defaultTraitsDictionary };
      const traitEntries = Object.entries(traitsDictionary || {}).map(([name, info = {}]) => {
        const detail = info && typeof info === 'object' && !Array.isArray(info)
          ? { ...info }
          : { description: typeof info === 'string' ? info : '' };
        if (!detail.description) {
          detail.description = detail.effect || '';
        }
        return {
          name,
          info: detail,
          description: detail.description || ''
        };
      }).sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
          const description = entry && entry.info && entry.info.description
            ? entry.info.description
            : entry && entry.description
              ? entry.description
              : '';
          if (description) {
            traitDescription.textContent = description;
      const passiveEntries = Object.entries(traitsDictionary || {})
        .map(([name, info = {}]) => ({
          name,
          info: info && typeof info === 'object' ? info : { description: typeof info === 'string' ? info : '' }
        }))
        .sort((a, b) => a.name.localeCompare(b.name, undefined, { sensitivity: 'base' }));
      passiveEntries.forEach(({ name, info }) => {
        const description = info.description || info.effect || '';
        btn.dataset.trait = name;
        const slug = slugifyForPalworld(name);
        btn.title = description || name;
        btn.textContent = name;
        const searchTokens = [name, description];
        if (info.stats) {
          Object.entries(info.stats).forEach(([label, value]) => {
            if (label && value) searchTokens.push(`${label} ${value}`);
          });
        }
        if (Array.isArray(info.naturalOn) && info.naturalOn.length) {
          searchTokens.push(info.naturalOn.join(' '));
        }
        btn.dataset.search = searchTokens.filter(Boolean).join(' ').toLowerCase();
          description,
          fruit: info.skillFruit || existing?.fruit || null
          ${entry.fruit ? `<span class="glossary-skill__fruit">${escapeHTML(entry.fruit)}</span>` : ''}
          metaText,
          entry.fruit
      const fallback = {
        name: key.replace(/_/g, ' '),
        damage: 'Unknown',
        type: 'Unknown',
        description: 'This skill\'s effects are a mystery! Try it out in battle.'
      };
      const info = skillsDictionary[normalisedKey] || skillsDictionary[key] || fallback;
      const name = info.name || fallback.name;
      const description = info.description || fallback.description;
      const element = info.element || info.type || 'Unknown';
      const power = typeof info.power === 'number' ? info.power : (() => {
        const match = (info.damage || '').match(/(\d+)/);
        return match ? Number(match[1]) : null;
      })();
      const cooldown = info.ct != null ? info.ct : (info.cooldown != null ? info.cooldown : null);
      const fruit = info.skillFruit || null;
      const meta = [];
      meta.push(`<dt>Element</dt><dd>${escapeHTML(element)}</dd>`);
      if (power != null && !Number.isNaN(power)) {
        meta.push(`<dt>Power</dt><dd>${escapeHTML(String(power))}</dd>`);
      } else if (info.damage) {
        meta.push(`<dt>Power</dt><dd>${escapeHTML(String(info.damage))}</dd>`);
      }
      if (cooldown != null && !Number.isNaN(cooldown)) {
        meta.push(`<dt>Cooldown</dt><dd>${escapeHTML(String(cooldown))}s</dd>`);
      }
      if (fruit) {
        meta.push(`<dt>Skill Fruit</dt><dd>${escapeHTML(fruit)}</dd>`);
      }
      const body = [`<h3>${escapeHTML(name)}</h3>`, `<p>${escapeHTML(description)}</p>`];
      if (meta.length) {
        body.splice(1, 0, `<dl class="skill-detail-list">${meta.join('')}</dl>`);
      }
      div.innerHTML = body.join('');
      const raw = traitsDictionary ? traitsDictionary[name] : null;
      const detail = raw && typeof raw === 'object' && !Array.isArray(raw)
        ? raw
        : { description: typeof raw === 'string' ? raw : '' };
      const fallbackDesc = 'This trait has mysterious effects that aren\'t fully documented. See how it behaves in-game!';
      const description = detail.description || detail.effect || fallbackDesc;
      const parts = [`<h3>${escapeHTML(name)}</h3>`, `<p>${escapeHTML(description)}</p>`];
      const detailRows = [];
      if (detail.rank != null) {
        detailRows.push(`<dt>Rank</dt><dd>${escapeHTML(String(detail.rank))}</dd>`);
      }
      if (detail.effect && detail.effect !== description) {
        detailRows.push(`<dt>Effect</dt><dd>${escapeHTML(detail.effect)}</dd>`);
      }
      if (detail.stats && typeof detail.stats === 'object') {
        Object.entries(detail.stats).forEach(([label, value]) => {
          if (!label || !value) return;
          detailRows.push(`<dt>${escapeHTML(label)}</dt><dd>${escapeHTML(String(value))}</dd>`);
        });
      }
      if (Array.isArray(detail.naturalOn) && detail.naturalOn.length) {
        detailRows.push(`<dt>Natural on</dt><dd>${escapeHTML(detail.naturalOn.join(', '))}</dd>`);
      }
      if (detail.notes) {
        detailRows.push(`<dt>Notes</dt><dd>${escapeHTML(detail.notes)}</dd>`);
      }
      if (detailRows.length) {
        parts.push(`<dl class="trait-detail-list">${detailRows.join('')}</dl>`);
      }
      div.innerHTML = parts.join('');
